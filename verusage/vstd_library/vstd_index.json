{
  "metadata": {
    "vstd_path": "verus/source/vstd",
    "version": "0.1.0",
    "statistics": {
      "total_files": 68,
      "total_functions": 883,
      "total_open_specs": 302,
      "functions_by_type": {
        "broadcast_proof": 338,
        "proof": 252,
        "closed_spec": 76,
        "exec": 24,
        "broadcast_axiom": 61,
        "uninterp_spec": 83,
        "axiom": 49
      }
    }
  },
  "index": {
    "functions": {
      "lemma_div_is_div_recursive": {
        "name": "lemma_div_is_div_recursive",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_is_div_recursive(x: int, d: int)\n    requires\n        0 < d,\n    ensures\n        div_recursive(x, d) == #[trigger] (x / d),",
        "ensures": [
          "div_recursive(x, d) == #[trigger] (x / d)"
        ],
        "requires": [
          "0 < d"
        ],
        "body": "{\n    reveal(div_recursive);\n    reveal(div_pos);\n    lemma_div_induction_auto(d, x, |u: int| div_recursive(u, d) == u / d);\n}",
        "doc_comment": "Proof that, for the case of `x / d`, division using `/` is\nequivalent to a recursive definition of division.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 51,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "div_recursive",
          "lemma_div_induction_auto"
        ]
      },
      "lemma_div_by_self": {
        "name": "vstd::arithmetic::div_mod::lemma_div_by_self",
        "type": "proof",
        "signature": "pub proof fn lemma_div_by_self(d: int)\n    requires\n        d != 0,\n    ensures\n        d / d == 1,",
        "ensures": [
          "d / d == 1"
        ],
        "requires": [
          "d != 0"
        ],
        "body": "{\n    DivINL::lemma_div_by_self(d);\n}",
        "doc_comment": "Proof that the quotient of an integer divided by itself is 1,\nspecifically that `d / d == 1`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 64,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [],
        "callees": [
          "lemma_div_by_self"
        ]
      },
      "lemma_div_of0": {
        "name": "vstd::arithmetic::div_mod::lemma_div_of0",
        "type": "proof",
        "signature": "pub proof fn lemma_div_of0(d: int)\n    requires\n        d != 0,\n    ensures\n        0 as int / d == 0,",
        "ensures": [
          "0 as int / d == 0"
        ],
        "requires": [
          "d != 0"
        ],
        "body": "{\n    DivINL::lemma_div_of0(d);\n}",
        "doc_comment": "Proof that 0 divided by a nonzero integer is 0, specifically `0 / d == 0`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 75,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [],
        "callees": [
          "lemma_div_of0"
        ]
      },
      "lemma_div_basics": {
        "name": "vstd::arithmetic::div_mod::lemma_div_basics",
        "type": "proof",
        "signature": "pub proof fn lemma_div_basics(x: int)\n    ensures\n        x != 0 as int ==> 0 as int / x == 0,\n        x / 1 == x,\n        x != 0 ==> x / x == 1,",
        "ensures": [
          "x != 0 as int ==> 0 as int / x == 0",
          "x / 1 == x",
          "x != 0 ==> x / x == 1"
        ],
        "requires": [],
        "body": "{\n    if (x != 0) {\n        lemma_div_by_self(x);\n        lemma_div_of0(x);\n    }\n}",
        "doc_comment": "Proof establishing basic properties of division using `x`: 0\ndivided by `x` is 0; `x` divided by 1 is itself; and `x` divided\nby itself is 1.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 85,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [],
        "callees": [
          "lemma_div_of0",
          "lemma_div_by_self"
        ]
      },
      "lemma_div_basics_1": {
        "name": "lemma_div_basics_1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_basics_1(x: int)\n    ensures\n        x != 0 as int ==> #[trigger] (0int / x) == 0,",
        "ensures": [
          "x != 0 as int ==> #[trigger] (0int / x) == 0"
        ],
        "requires": [],
        "body": "{\n    lemma_div_basics(x);\n}",
        "doc_comment": "Proof for basic property that 0 divided by `x` is 0.",
        "triggers": [
          "(0int / x"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 100,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_basics"
        ]
      },
      "lemma_div_basics_2": {
        "name": "lemma_div_basics_2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_basics_2(x: int)\n    ensures\n        #[trigger] (x / 1) == x,",
        "ensures": [
          "#[trigger] (x / 1) == x"
        ],
        "requires": [],
        "body": "{\n    lemma_div_basics(x);\n}",
        "doc_comment": "Proof for basic property that `x` divided by 1 is `x`.",
        "triggers": [
          "(x / 1"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 108,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_basics"
        ]
      },
      "lemma_div_basics_3": {
        "name": "lemma_div_basics_3",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_basics_3(x: int)\n    ensures\n        x != 0 ==> #[trigger] (x / x) == 1,",
        "ensures": [
          "x != 0 ==> #[trigger] (x / x) == 1"
        ],
        "requires": [],
        "body": "{\n    lemma_div_basics(x);\n}",
        "doc_comment": "Proof for basic property that `x` divided by `x` is 1.",
        "triggers": [
          "(x / x"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 116,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_basics"
        ]
      },
      "lemma_div_basics_4": {
        "name": "lemma_div_basics_4",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_basics_4(x: int, y: int)\n    ensures\n        x >= 0 && y > 0 ==> #[trigger] (x / y) >= 0,",
        "ensures": [
          "x >= 0 && y > 0 ==> #[trigger] (x / y) >= 0"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof that dividing any non-negative integer by a positive integer is non-zero.",
        "triggers": [
          "(x / y"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 124,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_div_basics_5": {
        "name": "lemma_div_basics_5",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_basics_5(x: int, y: int)\n    ensures\n        x >= 0 && y > 0 ==> #[trigger] (x / y) <= x,",
        "ensures": [
          "x >= 0 && y > 0 ==> #[trigger] (x / y) <= x"
        ],
        "requires": [],
        "body": "{\n    assert forall|x: int, y: int| x >= 0 && y > 0 implies 0 <= #[trigger] (x / y) <= x by {\n        lemma_div_pos_is_pos(x, y);\n        lemma_div_is_ordered_by_denominator(x, 1, y);\n    };\n}",
        "doc_comment": "Proof that the quotient produced by dividing any non-negative integer `x`\nby a positive integer `y` is at most `x`.",
        "triggers": [
          "(x / y"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 131,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_is_ordered_by_denominator",
          "lemma_div_pos_is_pos"
        ]
      },
      "lemma_small_div_converse": {
        "name": "lemma_small_div_converse",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_small_div_converse(x: int, d: int)\n    ensures\n        0 <= x && 0 < d && #[trigger] (x / d) == 0 ==> x < d,",
        "ensures": [
          "0 <= x && 0 < d && #[trigger] (x / d) == 0 ==> x < d"
        ],
        "requires": [],
        "body": "{\n    assert forall|x: int, d: int| 0 <= x && 0 < d && #[trigger] (x / d) == 0 implies x < d by {\n        lemma_div_induction_auto(d, x, |u: int| 0 <= u && 0 < d && u / d == 0 ==> u < d);\n    }\n}",
        "doc_comment": "Proof that if a dividend is a whole number, the divisor is a\nnatural number, and their quotient is 0, then the dividend is\nsmaller than the divisor.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 151,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_div_non_zero": {
        "name": "lemma_div_non_zero",
        "type": "proof",
        "signature": "pub proof fn lemma_div_non_zero(x: int, d: int)\n    requires\n        x >= d > 0,\n    ensures\n        #[trigger] (x / d) > 0,",
        "ensures": [
          "#[trigger] (x / d) > 0"
        ],
        "requires": [
          "x >= d > 0"
        ],
        "body": "{\n    broadcast use lemma_div_pos_is_pos;\n\n    if x / d == 0 {\n        broadcast use lemma_small_div_converse;\n\n    }\n}",
        "doc_comment": "Proof that division of a positive integer by a positive integer\nless than or equal to it is nonzero. Specifically,\ngiven that `x >= d`, we can conclude that `x / d > 0`.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 163,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_div_is_ordered_by_denominator": {
        "name": "lemma_div_is_ordered_by_denominator",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_is_ordered_by_denominator(x: int, y: int, z: int)\n    requires\n        0 <= x,\n        1 <= y <= z,\n    ensures\n        #[trigger] (x / y) >= #[trigger] (x / z),\n    decreases x,",
        "ensures": [
          "#[trigger] (x / y) >= #[trigger] (x / z)"
        ],
        "requires": [
          "0 <= x",
          "1 <= y <= z"
        ],
        "body": "{\n    reveal(div_recursive);\n    reveal(div_pos);\n    broadcast use lemma_div_is_div_recursive;\n\n    assert(forall|u: int, d: int|\n        #![trigger div_recursive(u, d)]\n        #![trigger div1(u, d)]\n        d > 0 ==> div_recursive(u, d) == div1(u, d));\n    if (x < z) {\n        lemma_div_is_ordered(0, x, y);\n    } else {\n        lemma_div_is_ordered(x - z, x - y, y);\n        lemma_div_is_ordered_by_denominator(x - z, y, z);\n    }\n}",
        "doc_comment": "Proof that given two fractions with the same numerator, the order\nof the fractions is determined by the denominators. However, if\nthe numerator is 0, the fractions are equal regardless of the\ndenominators' values. Specifically, given that `1 <= y <= z`, we\nknow `x / y >= x / z`.",
        "triggers": [
          "(x / y",
          "(x / z"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 180,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "div_recursive",
          "lemma_div_is_ordered_by_denominator",
          "div1",
          "lemma_div_is_ordered"
        ]
      },
      "lemma_div_is_strictly_smaller": {
        "name": "lemma_div_is_strictly_smaller",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_is_strictly_smaller(x: int, d: int)\n    requires\n        0 < x,\n        1 < d,\n    ensures\n        #[trigger] (x / d) < x,\n    decreases x,",
        "ensures": [
          "#[trigger] (x / d) < x"
        ],
        "requires": [
          "0 < x",
          "1 < d"
        ],
        "body": "{\n    lemma_div_induction_auto(d, x, |u: int| 0 < u ==> u / d < u);\n}",
        "doc_comment": "Proof that a number gets strictly smaller when divided by a number\ngreater than one. Specifically, `x / d < x`.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 209,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_dividing_sums": {
        "name": "lemma_dividing_sums",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_dividing_sums(a: int, b: int, d: int, r: int)\n    requires\n        0 < d,\n        r == a % d + b % d - (a + b) % d,\n    ensures\n        #![trigger (d * ((a + b) / d) - r), (d * (a / d) + d * (b / d))]\n        d * ((a + b) / d) - r == d * (a / d) + d * (b / d),",
        "ensures": [
          "#![trigger (d * ((a + b) / d) - r), (d * (a / d) + d * (b / d))]\n        d * ((a + b) / d) - r == d * (a / d) + d * (b / d)"
        ],
        "requires": [
          "0 < d",
          "r == a % d + b % d - (a + b) % d"
        ],
        "body": "{\n    ModINL::lemma_fundamental_div_mod(a + b, d);\n    ModINL::lemma_fundamental_div_mod(a, d);\n    ModINL::lemma_fundamental_div_mod(b, d);\n}",
        "doc_comment": "Proof that, given `r == a % d + b % d - (a + b) % d`, `r` can also\nbe expressed as `d * ((a + b) / d) - d * (a / d) - d * (b / d)`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 222,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_div_pos_is_pos": {
        "name": "lemma_div_pos_is_pos",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_pos_is_pos(x: int, d: int)\n    requires\n        0 <= x,\n        0 < d,\n    ensures\n        0 <= #[trigger] (x / d),",
        "ensures": [
          "0 <= #[trigger] (x / d)"
        ],
        "requires": [
          "0 <= x",
          "0 < d"
        ],
        "body": "{\n    lemma_div_auto(d);\n    assert(div_auto(d));\n    let f = |u: int| 0 <= u ==> u / d >= 0;\n    assert forall|i: int| #[trigger] is_le(0, i) && f(i) implies f(i + d) by {\n        assert(i / d >= 0);\n    };\n    lemma_div_induction_auto(d, x, |u: int| 0 <= u ==> u / d >= 0);\n}",
        "doc_comment": "Proof that dividing a whole number by a natural number will result\nin a quotient that is greater than or equal to 0. Specifically,\n`x / d >= 0`.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 237,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "f",
          "lemma_div_induction_auto",
          "is_le",
          "lemma_div_auto",
          "div_auto"
        ]
      },
      "lemma_div_plus_one": {
        "name": "lemma_div_plus_one",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_plus_one(x: int, d: int)\n    requires\n        0 < d,\n    ensures\n        #![trigger (1 + x / d), ((d + x) / d)]\n        1 + x / d == (d + x) / d,",
        "ensures": [
          "#![trigger (1 + x / d), ((d + x) / d)]\n        1 + x / d == (d + x) / d"
        ],
        "requires": [
          "0 < d"
        ],
        "body": "{\n    lemma_div_auto(d);\n}",
        "doc_comment": "Proof that dividing a number then adding 1 gives the same result\nas adding the divisor and then doing the division. Specifically,\n`1 + (x / d)` is equal to `(d + x) / d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 256,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_auto"
        ]
      },
      "lemma_div_minus_one": {
        "name": "lemma_div_minus_one",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_minus_one(x: int, d: int)\n    requires\n        0 < d,\n    ensures\n        #![trigger (-1 + x / d), ((-d + x) / d)]\n        -1 + x / d == (-d + x) / d,",
        "ensures": [
          "#![trigger (-1 + x / d), ((-d + x) / d)]\n        -1 + x / d == (-d + x) / d"
        ],
        "requires": [
          "0 < d"
        ],
        "body": "{\n    lemma_div_auto(d);\n}",
        "doc_comment": "Proof that dividing a number then subtracting 1 gives the same result\nas subtracting the divisor and then doing the division. Specifically,\n`-1 + (x / d)` is equal to `(-d + x) / d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 269,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_auto"
        ]
      },
      "lemma_basic_div_specific_divisor": {
        "name": "lemma_basic_div_specific_divisor",
        "type": "proof",
        "signature": "pub proof fn lemma_basic_div_specific_divisor(d: int)\n    requires\n        0 < d,\n    ensures\n        forall|x: int| 0 <= x < d ==> #[trigger] (x / d) == 0,",
        "ensures": [
          "forall|x: int| 0 <= x < d ==> #[trigger] (x / d) == 0"
        ],
        "requires": [
          "0 < d"
        ],
        "body": "{\n    lemma_div_auto(d);\n}",
        "doc_comment": "Proof that dividing any non-negative integer less than `d` by `d`\nproduces a quotient of 0.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 282,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "lemma_div_auto"
        ]
      },
      "lemma_basic_div": {
        "name": "lemma_basic_div",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_basic_div(x: int, d: int)\n    requires\n        0 <= x < d,\n    ensures\n        #[trigger] (x / d) == 0,",
        "ensures": [
          "#[trigger] (x / d) == 0"
        ],
        "requires": [
          "0 <= x < d"
        ],
        "body": "{\n    lemma_basic_div_specific_divisor(d);\n}",
        "doc_comment": "Proof that dividing any non-negative integer by a larger integer\nproduces a quotient of 0.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 293,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_basic_div_specific_divisor"
        ]
      },
      "lemma_div_is_ordered": {
        "name": "lemma_div_is_ordered",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_is_ordered(x: int, y: int, z: int)\n    requires\n        x <= y,\n        0 < z,\n    ensures\n        #[trigger] (x / z) <= #[trigger] (y / z),",
        "ensures": [
          "#[trigger] (x / z) <= #[trigger] (y / z)"
        ],
        "requires": [
          "x <= y",
          "0 < z"
        ],
        "body": "{\n    lemma_div_auto(z);\n    let f = |xy: int| xy <= 0 ==> (xy + y) / z <= y / z;\n    assert forall|i: int| #[trigger] is_le(i + 1, z) && f(i) implies f(i - z) by {\n        if (i - z <= 0) {\n            assert(f(i));\n            assert(i <= 0 ==> (i + y) / z <= y / z);\n            if (i > 0) {\n                assert(z > 0);\n                assert(i <= z);\n                assert(((i + y) - z) / z <= y / z);\n            } else {\n                assert((i + y) / z <= y / z);\n            }\n            assert((i - z + y) / z <= y / z);\n        }\n    };\n    lemma_div_induction_auto(z, x - y, |xy: int| xy <= 0 ==> (xy + y) / z <= y / z);\n}",
        "doc_comment": "Proof that numerical order is preserved when dividing two seperate\nintegers by a common positive divisor. Specifically, given that\n`z > 0` and `x <= y`, we know `x / z <= y / z`.",
        "triggers": [
          "(x / z",
          "(y / z"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 304,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "f",
          "is_le",
          "lemma_div_auto",
          "lemma_div_induction_auto"
        ]
      },
      "lemma_div_decreases": {
        "name": "lemma_div_decreases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_decreases(x: int, d: int)\n    requires\n        0 < x,\n        1 < d,\n    ensures\n        #[trigger] (x / d) < x,",
        "ensures": [
          "#[trigger] (x / d) < x"
        ],
        "requires": [
          "0 < x",
          "1 < d"
        ],
        "body": "{\n    lemma_div_induction_auto(d, x, |u: int| 0 < u ==> u / d < u);\n}",
        "doc_comment": "Proof that dividing an integer by 2 or more results in a quotient\nthat is smaller than the original dividend. Specifically, `x / d < x`.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 333,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_div_nonincreasing": {
        "name": "lemma_div_nonincreasing",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_nonincreasing(x: int, d: int)\n    requires\n        0 <= x,\n        0 < d,\n    ensures\n        #[trigger] (x / d) <= x,",
        "ensures": [
          "#[trigger] (x / d) <= x"
        ],
        "requires": [
          "0 <= x",
          "0 < d"
        ],
        "body": "{\n    lemma_div_induction_auto(d, x, |u: int| 0 <= u ==> u / d <= u);\n}",
        "doc_comment": "Proof that dividing an integer by 1 or more results in a quotient\nthat is less than or equal to the original dividend. Specifically,\n`x / d <= x`.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 345,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_small_mod": {
        "name": "vstd::arithmetic::div_mod::lemma_small_mod",
        "type": "proof",
        "signature": "pub proof fn lemma_small_mod(x: nat, m: nat)\n    requires\n        x < m,\n        0 < m,\n    ensures\n        x % m == x,",
        "ensures": [
          "x % m == x"
        ],
        "requires": [
          "x < m",
          "0 < m"
        ],
        "body": "{\n    ModINL::lemma_small_mod(x, m);\n}",
        "doc_comment": "Proof that a natural number x divided by a larger natural number\ngives a remainder equal to x. Specifically, because `x < m`, we\nknow `x % m == x`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 358,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [],
        "callees": [
          "lemma_small_mod"
        ]
      },
      "lemma_breakdown": {
        "name": "lemma_breakdown",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_breakdown(x: int, y: int, z: int)\n    requires\n        0 <= x,\n        0 < y,\n        0 < z,\n    ensures\n        #![trigger y * z, x % (y * z), y * ((x / y) % z) + x % y]\n        0 < y * z,\n        (x % (y * z)) == y * ((x / y) % z) + x % y,",
        "ensures": [
          "#![trigger y * z, x % (y * z), y * ((x / y) % z) + x % y]\n        0 < y * z",
          "(x % (y * z)) == y * ((x / y) % z) + x % y"
        ],
        "requires": [
          "0 <= x",
          "0 < y",
          "0 < z"
        ],
        "body": "{\n    broadcast use lemma_mul_strictly_positive;\n\n    lemma_div_pos_is_pos(x, y);\n    calc! {\n        (<)\n        (y * (x / y)) % (y * z) + (x % y) % (y * z); (<=) {\n            lemma_part_bound1(x, y, z);\n        }\n        y * (z - 1) + (x % y) % (y * z); (<) {\n            lemma_part_bound2(x, y, z);\n        }\n        y * (z - 1) + y; (==) {\n            broadcast use group_mul_basics;\n\n        }\n        y * (z - 1) + y * 1; (==) {\n            broadcast use group_mul_is_distributive;\n\n        }\n        y * (z - 1 + 1); (==) {}\n        y * z;\n    }\n    calc! {\n        (==)\n        x % (y * z); {\n            ModINL::lemma_fundamental_div_mod(x, y);\n        }\n        (y * (x / y) + x % y) % (y * z); {\n            broadcast use group_mod_properties;\n\n            assert(0 <= x % y);\n            lemma_mul_nonnegative(y, x / y);\n            assert((y * (x / y)) % (y * z) + (x % y) % (y * z) < y * z);\n            lemma_mod_adds(y * (x / y), x % y, y * z);\n        }\n        (y * (x / y)) % (y * z) + (x % y) % (y * z); {\n            broadcast use {group_mod_properties, lemma_mul_is_commutative};\n\n            lemma_mul_increases(z, y);\n            // comparison op can't be chained in calc!\n            // assert forall is also not avaialable in calc!\n            assert((x % y) < y && y <= (y * z));\n            lemma_small_mod((x % y) as nat, (y * z) as nat);\n            assert((x % y) % (y * z) == x % y);\n        }\n        (y * (x / y)) % (y * z) + x % y; {\n            lemma_truncate_middle(x / y, y, z);\n        }\n        y * ((x / y) % z) + x % y;\n    }\n}",
        "doc_comment": "The remainder of a nonnegative integer `x` divided by the product of two positive integers\n`y` and `z` is equivalent to dividing `x` by `y`, dividing the quotient by `z`, multiplying\nthe remainder by `y`, and then adding the product to the remainder of `x` divided by `y`.\nIn mathematical terms, `(x % (y * z)) == y * ((x / y) % z) + x % y`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 371,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_part_bound2",
          "lemma_mod_adds",
          "lemma_mul_increases",
          "lemma_part_bound1",
          "lemma_fundamental_div_mod",
          "lemma_div_pos_is_pos",
          "lemma_truncate_middle",
          "lemma_small_mod",
          "lemma_mul_nonnegative"
        ]
      },
      "lemma_remainder_upper": {
        "name": "lemma_remainder_upper",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_remainder_upper(x: int, d: int)\n    requires\n        0 <= x,\n        0 < d,\n    ensures\n        #![trigger (x - d), (x / d * d)]\n        x - d < x / d * d,",
        "ensures": [
          "#![trigger (x - d), (x / d * d)]\n        x - d < x / d * d"
        ],
        "requires": [
          "0 <= x",
          "0 < d"
        ],
        "body": "{\n    broadcast use group_mul_properties_internal;\n\n    lemma_div_induction_auto(d, x, |u: int| 0 <= u ==> u - d < u / d * d);\n}",
        "doc_comment": "Proof that the difference between a nonnegative integer `x` and a\npositive integer `d` must be strictly less than the quotient of\n`x` divided by `d` and then multiplied by `d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 437,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_remainder_lower": {
        "name": "lemma_remainder_lower",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_remainder_lower(x: int, d: int)\n    requires\n        0 <= x,\n        0 < d,\n    ensures\n        x >= #[trigger] (x / d * d),",
        "ensures": [
          "x >= #[trigger] (x / d * d)"
        ],
        "requires": [
          "0 <= x",
          "0 < d"
        ],
        "body": "{\n    broadcast use group_mul_properties_internal;\n\n    lemma_div_induction_auto(d, x, |u: int| 0 <= u ==> u >= u / d * d);\n}",
        "doc_comment": "Proof that the division of a nonnegative integer `x` by a positive\ninteger `d` multiplied by `d` is less than or equal to the value\nof `x`.",
        "triggers": [
          "(x / d * d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 453,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_remainder": {
        "name": "lemma_remainder",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_remainder(x: int, d: int)\n    requires\n        0 <= x,\n        0 < d,\n    ensures\n        0 <= #[trigger] (x - (x / d * d)) < d,",
        "ensures": [
          "0 <= #[trigger] (x - (x / d * d)) < d"
        ],
        "requires": [
          "0 <= x",
          "0 < d"
        ],
        "body": "{\n    broadcast use group_mul_properties_internal;\n\n    lemma_div_induction_auto(d, x, |u: int| 0 <= u - u / d * d < d);\n}",
        "doc_comment": "Proof that the difference between a nonnegative integer `x` and\nthe division of `x` by a positive integer `d` multiplied by `d` is\nlower bounded (inclusively) by 0 and upper bounded (exclusively)\nby `d`.",
        "triggers": [
          "(x - (x / d * d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 468,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_fundamental_div_mod": {
        "name": "vstd::arithmetic::div_mod::lemma_fundamental_div_mod",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_fundamental_div_mod(x: int, d: int)\n    requires\n        d != 0,\n    ensures\n        x == #[trigger] (d * (x / d) + (x % d)),",
        "ensures": [
          "x == #[trigger] (d * (x / d) + (x % d))"
        ],
        "requires": [
          "d != 0"
        ],
        "body": "{\n    assert(x == d * (x / d) + (x % d)) by {\n        ModINL::lemma_fundamental_div_mod(x, d);\n    }\n}",
        "doc_comment": "Proof of the fundamental theorem of division and modulo, namely\nthat `x` can be expressed as `d` times the quotient `x / d` plus\nthe remainder `x % d`.",
        "triggers": [
          "(d * (x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 484,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_div_denominator": {
        "name": "lemma_div_denominator",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_denominator(x: int, c: int, d: int)\n    requires\n        0 <= x,\n        0 < c,\n        0 < d,\n    ensures\n        c * d != 0,\n        #[trigger] ((x / c) / d) == x / (c * d),",
        "ensures": [
          "c * d != 0",
          "#[trigger] ((x / c) / d) == x / (c * d)"
        ],
        "requires": [
          "0 <= x",
          "0 < c",
          "0 < d"
        ],
        "body": null,
        "doc_comment": "Proof that dividing `x` by `c * d` is equivalent to first dividing\n`x` by `c` and then dividing the result by `d`.",
        "triggers": [
          "((x / c"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 498,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mul_hoist_inequality": {
        "name": "lemma_mul_hoist_inequality",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_hoist_inequality(x: int, y: int, z: int)\n    requires\n        0 <= x,\n        0 < z,\n    ensures\n        #![trigger (x * (y / z)), ((x * y) / z)]\n        x * (y / z) <= (x * y) / z,",
        "ensures": [
          "#![trigger (x * (y / z)), ((x * y) / z)]\n        x * (y / z) <= (x * y) / z"
        ],
        "requires": [
          "0 <= x",
          "0 < z"
        ],
        "body": "{\n    calc! {\n        (==)\n        (x * y) / z; (==) {\n            lemma_fundamental_div_mod(y, z);\n        }\n        (x * (z * (y / z) + y % z)) / z; (==) {\n            broadcast use group_mul_is_distributive;\n\n        }\n        (x * (z * (y / z)) + x * (y % z)) / z;\n    }\n    assert((x * (z * (y / z)) + x * (y % z)) / z >= x * (y / z)) by {\n        broadcast use {group_mod_properties, lemma_mul_is_associative, lemma_mul_is_commutative};\n\n        lemma_mul_nonnegative(x, y % z);\n        lemma_div_is_ordered(x * (z * (y / z)), x * (z * (y / z)) + x * (y % z), z);\n        lemma_div_multiples_vanish(x * (y / z), z);\n    };\n}",
        "doc_comment": "Proof that multiplying an integer by a fraction is equivalent to\nmultiplying the fraction's numerator by the integer. Specifically,\n`x * (y / z) == (x * y) / z`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 596,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_multiples_vanish",
          "lemma_mul_nonnegative",
          "lemma_div_is_ordered",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_indistinguishable_quotients": {
        "name": "lemma_indistinguishable_quotients",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_indistinguishable_quotients(a: int, b: int, d: int)\n    requires\n        0 < d,\n        0 <= a - a % d <= b < a + d - a % d,\n    ensures\n        #![trigger (a / d), (b / d)]\n        a / d == b / d,",
        "ensures": [
          "#![trigger (a / d), (b / d)]\n        a / d == b / d"
        ],
        "requires": [
          "0 < d",
          "0 <= a - a % d <= b < a + d - a % d"
        ],
        "body": "{\n    lemma_div_induction_auto(\n        d,\n        a - b,\n        |ab: int|\n            {\n                let u = ab + b;\n                0 <= u - u % d <= b < u + d - u % d ==> u / d == b / d\n            },\n    );\n}",
        "doc_comment": "Proof that for a positive integer `d`, if `a - a % d` is less than\nor equal to `b` and `b` is less than `a + d - a % d`, then the\nquotient of `a` divided by `d` is equivalent to the quotient of\n`b` divided by `d`.\n\nIn other words, if `a` and `b` occur between the same two\nmultiples of `d`, then their quotient with `d` is equivalent.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 627,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_truncate_middle": {
        "name": "lemma_truncate_middle",
        "type": "proof",
        "signature": "pub proof fn lemma_truncate_middle(x: int, b: int, c: int)\n    requires\n        0 <= x,\n        0 < b,\n        0 < c,\n    ensures\n        #![trigger (b * (x % c))]\n        0 < b * c,\n        (b * x) % (b * c) == b * (x % c),",
        "ensures": [
          "#![trigger (b * (x % c))]\n        0 < b * c",
          "(b * x) % (b * c) == b * (x % c)"
        ],
        "requires": [
          "0 <= x",
          "0 < b",
          "0 < c"
        ],
        "body": "{\n    broadcast use {lemma_mul_strictly_positive, lemma_mul_nonnegative};\n\n    calc! {\n        (==)\n        b * x; {\n            ModINL::lemma_fundamental_div_mod(b * x, b * c);\n        }\n        (b * c) * ((b * x) / (b * c)) + (b * x) % (b * c); {\n            lemma_div_denominator(b * x, b, c);\n        }\n        (b * c) * (((b * x) / b) / c) + (b * x) % (b * c); {\n            broadcast use lemma_mul_is_commutative;\n\n            lemma_div_by_multiple(x, b);\n        }\n        (b * c) * (x / c) + (b * x) % (b * c);\n    }\n    assert(b * x == (b * c) * (x / c) + b * (x % c)) by {\n        ModINL::lemma_fundamental_div_mod(x, c);\n        broadcast use {group_mul_is_distributive, lemma_mul_is_associative};\n\n    };\n}",
        "doc_comment": "Proof that common factors from the dividend and divisor of a\nmodulus operation can be factored out. Specifically,\n`(b * x) % (b * c) == b * (x % c)`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 653,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_denominator",
          "lemma_div_by_multiple",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_div_multiples_vanish_quotient": {
        "name": "lemma_div_multiples_vanish_quotient",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_multiples_vanish_quotient(x: int, a: int, d: int)\n    requires\n        0 < x,\n        0 <= a,\n        0 < d,\n    ensures\n        #![trigger a / d, x * a, x * d]\n        0 < x * d,\n        a / d == (x * a) / (x * d),",
        "ensures": [
          "#![trigger a / d, x * a, x * d]\n        0 < x * d",
          "a / d == (x * a) / (x * d)"
        ],
        "requires": [
          "0 < x",
          "0 <= a",
          "0 < d"
        ],
        "body": "{\n    lemma_mul_strictly_positive(x, d);\n    calc! {\n        (==)\n        (x * a) / (x * d); {\n            lemma_mul_nonnegative(x, a);\n            lemma_div_denominator(x * a, x, d);\n        }\n        ((x * a) / x) / d; {\n            lemma_div_multiples_vanish(a, x);\n        }\n        a / d;\n    }\n}",
        "doc_comment": "Proof that multiplying the numerator and denominator by an integer\ndoes not change the quotient. Specifically,\n`a / d == (x * a) / (x * d)`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 690,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_denominator",
          "lemma_div_multiples_vanish",
          "lemma_mul_nonnegative",
          "lemma_mul_strictly_positive"
        ]
      },
      "lemma_round_down": {
        "name": "lemma_round_down",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_round_down(a: int, r: int, d: int)\n    requires\n        0 < d,\n        a % d == 0,\n        0 <= r < d,\n    ensures\n        #![trigger (d * ((a + r) / d))]\n        a == d * ((a + r) / d),",
        "ensures": [
          "#![trigger (d * ((a + r) / d))]\n        a == d * ((a + r) / d)"
        ],
        "requires": [
          "0 < d",
          "a % d == 0",
          "0 <= r < d"
        ],
        "body": "{\n    broadcast use group_mul_properties_internal;\n\n    lemma_div_induction_auto(d, a, |u: int| u % d == 0 ==> u == d * ((u + r) / d));\n}",
        "doc_comment": "Proof that, since `a % d == 0` and `0 <= r < d`, we can conclude\n`a == d * (a + r) / d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 717,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_induction_auto"
        ]
      },
      "lemma_div_multiples_vanish_fancy": {
        "name": "lemma_div_multiples_vanish_fancy",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_multiples_vanish_fancy(x: int, b: int, d: int)\n    requires\n        0 < d,\n        0 <= b < d,\n    ensures\n        #![trigger (d * x + b) / d]\n        (d * x + b) / d == x,",
        "ensures": [
          "#![trigger (d * x + b) / d]\n        (d * x + b) / d == x"
        ],
        "requires": [
          "0 < d",
          "0 <= b < d"
        ],
        "body": "{\n    let f = |u: int| (d * u + b) / d == u;\n    assert(f(0)) by {\n        lemma_div_auto(d);\n    }\n    assert forall|i: int| i >= 0 && #[trigger] f(i) implies #[trigger] f(add1(i, 1)) by {\n        assert(d * (i + 1) + b == d * i + b + d) by {\n            assert(d * (i + 1) == d * i + d) by {\n                lemma_mul_is_distributive_add(d, i, 1);\n                lemma_mul_basics(d);\n            }\n        }\n        super::internals::div_internals::lemma_div_basics(d);\n    }\n    assert forall|i: int| i <= 0 && #[trigger] f(i) implies #[trigger] f(sub1(i, 1)) by {\n        assert(d * (i - 1) + b == d * i + b - d) by {\n            assert(d * (i - 1) == d * i - d) by {\n                lemma_mul_is_distributive_sub(d, i, 1);\n                lemma_mul_basics(d);\n            }\n        }\n        super::internals::div_internals::lemma_div_basics(d);\n    }\n    broadcast use group_mul_properties_internal;\n\n    lemma_mul_induction(f);\n    assert(f(x));\n}",
        "doc_comment": "Proof that, since `0 <= b < d`, we have `(d * x + b) / d == x`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 733,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "f",
          "lemma_mul_is_distributive_sub",
          "add1",
          "lemma_mul_induction",
          "lemma_mul_basics",
          "lemma_div_basics",
          "lemma_mul_is_distributive_add",
          "lemma_div_auto",
          "sub1"
        ]
      },
      "lemma_div_multiples_vanish": {
        "name": "lemma_div_multiples_vanish",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_multiples_vanish(x: int, d: int)\n    requires\n        0 < d,\n    ensures\n        #![trigger (d * x) / d]\n        (d * x) / d == x,",
        "ensures": [
          "#![trigger (d * x) / d]\n        (d * x) / d == x"
        ],
        "requires": [
          "0 < d"
        ],
        "body": "{\n    lemma_div_multiples_vanish_fancy(x, 0, d);\n}",
        "doc_comment": "Proof that multiplying an integer by a common numerator and\ndenominator results in the original integer. Specifically,\n`(d * x) / d == x`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 770,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_multiples_vanish_fancy"
        ]
      },
      "lemma_div_by_multiple": {
        "name": "lemma_div_by_multiple",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_by_multiple(b: int, d: int)\n    requires\n        0 <= b,\n        0 < d,\n    ensures\n        #![trigger ((b * d) / d)]\n        (b * d) / d == b,",
        "ensures": [
          "#![trigger ((b * d) / d)]\n        (b * d) / d == b"
        ],
        "requires": [
          "0 <= b",
          "0 < d"
        ],
        "body": "{\n    lemma_div_multiples_vanish(b, d);\n    broadcast use group_mul_properties_internal;\n\n}",
        "doc_comment": "Proof that multiplying a whole number by a common numerator and\ndenominator results in the original integer. Specifically,\n`(b * d) / d == b`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 783,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_multiples_vanish"
        ]
      },
      "lemma_div_by_multiple_is_strongly_ordered": {
        "name": "lemma_div_by_multiple_is_strongly_ordered",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_div_by_multiple_is_strongly_ordered(x: int, y: int, m: int, z: int)\n    requires\n        x < y,\n        y == m * z,\n        0 < z,\n    ensures\n        #![trigger x / z, m * z, y / z]\n        x / z < y / z,",
        "ensures": [
          "#![trigger x / z, m * z, y / z]\n        x / z < y / z"
        ],
        "requires": [
          "x < y",
          "y == m * z",
          "0 < z"
        ],
        "body": "{\n    lemma_mod_multiples_basic(m, z);\n    lemma_div_induction_auto(\n        z,\n        y - x,\n        |yx: int|\n            {\n                let u = yx + x;\n                x < u && u % z == 0 ==> x / z < u / z\n            },\n    );\n}",
        "doc_comment": "Proof that a dividend that is a positive multiple of a divisor\nwill always yield a greater quotient than a smaller dividend.\nSpecifically, `x / z < y / z` because `y == m * z` and `x < y`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 799,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_multiples_basic",
          "lemma_div_induction_auto"
        ]
      },
      "lemma_multiply_divide_le": {
        "name": "lemma_multiply_divide_le",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_multiply_divide_le(a: int, b: int, c: int)\n    requires\n        0 < b,\n        a <= b * c,\n    ensures\n        #![trigger a / b, b * c]\n        a / b <= c,",
        "ensures": [
          "#![trigger a / b, b * c]\n        a / b <= c"
        ],
        "requires": [
          "0 < b",
          "a <= b * c"
        ],
        "body": "{\n    lemma_mod_multiples_basic(c, b);\n    let f = |i: int| 0 <= i && (i + a) % b == 0 ==> a / b <= (i + a) / b;\n    lemma_div_induction_auto(b, b * c - a, f);\n    lemma_div_multiples_vanish(c, b);\n}",
        "doc_comment": "Proof that if an integer is less than or equal to the product of\ntwo other integers, then the quotient with one of them will be\nless than or equal to the other of them. Specifically, because\n`a <= b * c`, we know `a / b <= c`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 823,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_multiples_basic",
          "lemma_div_multiples_vanish",
          "lemma_div_induction_auto"
        ]
      },
      "lemma_multiply_divide_lt": {
        "name": "lemma_multiply_divide_lt",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_multiply_divide_lt(a: int, b: int, c: int)\n    requires\n        0 < b,\n        a < b * c,\n    ensures\n        #![trigger a / b, b * c]\n        a / b < c,",
        "ensures": [
          "#![trigger a / b, b * c]\n        a / b < c"
        ],
        "requires": [
          "0 < b",
          "a < b * c"
        ],
        "body": "{\n    assert(((b * c - a) + a) % b == 0 ==> a / b < ((b * c - a) + a) / b) by {\n        let f = |i: int| 0 < i && (i + a) % b == 0 ==> a / b < (i + a) / b;\n        lemma_div_induction_auto(b, b * c - a, f);\n    }\n    assert(b * c == c * b) by {\n        lemma_mul_is_commutative(b, c);\n    }\n    assert((b * c) % b == 0) by {\n        lemma_mod_multiples_basic(c, b);\n    }\n    assert((b * c) / b == c) by {\n        lemma_div_multiples_vanish(c, b);\n    }\n}",
        "doc_comment": "Proof that if an integer is less than the product of two other\nintegers, then the quotient with one of them will be less than the\nother. Specifically, because `a < b * c`, we know `a / b < c`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 841,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_multiples_basic",
          "lemma_mul_is_commutative",
          "lemma_div_multiples_vanish",
          "lemma_div_induction_auto"
        ]
      },
      "lemma_hoist_over_denominator": {
        "name": "lemma_hoist_over_denominator",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_hoist_over_denominator(x: int, j: int, d: nat)\n    requires\n        0 < d,\n    ensures\n        #![trigger x / d as int + j]\n        x / d as int + j == (x + j * d) / d as int,",
        "ensures": [
          "#![trigger x / d as int + j]\n        x / d as int + j == (x + j * d) / d as int"
        ],
        "requires": [
          "0 < d"
        ],
        "body": "{\n    let dd = d as int;\n    let q = x / dd;\n    let r = x % dd;\n    assert(x == dd * q + r) by {\n        lemma_fundamental_div_mod(x, dd);\n    }\n    assert(j * dd == dd * j) by {\n        lemma_mul_is_commutative(j, dd);\n    }\n    assert(x + j * dd == dd * (q + j) + r) by {\n        lemma_mul_is_distributive_add(dd, q, j);\n    }\n    assert((x + j * dd) / dd == q + j) by {\n        lemma_fundamental_div_mod_converse(x + j * d, dd, q + j, r);\n    }\n}",
        "doc_comment": "Proof that adding an integer to a fraction is equivalent to adding\nthat integer times the denominator to the numerator. Specifically,\n`x / d + j == (x + j * d) / d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 867,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_is_commutative",
          "lemma_mul_is_distributive_add",
          "lemma_fundamental_div_mod_converse",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_part_bound1": {
        "name": "lemma_part_bound1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_part_bound1(a: int, b: int, c: int)\n    requires\n        0 <= a,\n        0 < b,\n        0 < c,\n    ensures\n        #![trigger (b * (a / b) % (b * c))]\n        0 < b * c,\n        (b * (a / b) % (b * c)) <= b * (c - 1),",
        "ensures": [
          "#![trigger (b * (a / b) % (b * c))]\n        0 < b * c",
          "(b * (a / b) % (b * c)) <= b * (c - 1)"
        ],
        "requires": [
          "0 <= a",
          "0 < b",
          "0 < c"
        ],
        "body": "{\n    lemma_mul_strictly_positive(b, a / b);\n    lemma_mul_strictly_positive(b, c);\n    lemma_mul_strictly_positive(b, c - 1);\n    calc! {\n        (==)\n        b * (a / b) % (b * c); {\n            ModINL::lemma_fundamental_div_mod(b * (a / b), b * c);\n        }\n        b * (a / b) - (b * c) * ((b * (a / b)) / (b * c)); {\n            broadcast use lemma_mul_is_associative;\n\n        }\n        b * (a / b) - b * (c * ((b * (a / b)) / (b * c))); {\n            broadcast use group_mul_is_distributive;\n\n        }\n        b * ((a / b) - (c * ((b * (a / b)) / (b * c))));\n    }\n    assert(b * (a / b) % (b * c) <= b * (c - 1)) by {\n        broadcast use {lemma_mul_is_commutative, lemma_mul_inequality};\n\n    };\n}",
        "doc_comment": "Proof that, for nonnegative integer `a` and positive integers `b` and `c`,\nthe remainder of `b * (a / b)` divided by `b * c` is less than or equal to `b * (c - 1)`.\nThis accounts for the rounding down that occurs in integer division.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 894,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_strictly_positive",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_mod_is_mod_recursive": {
        "name": "lemma_mod_is_mod_recursive",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_is_mod_recursive(x: int, m: int)\n    requires\n        m > 0,\n    ensures\n        mod_recursive(x, m) == #[trigger] (x % m),\n    decreases\n            (if x < 0",
        "ensures": [
          "mod_recursive(x, m) == #[trigger] (x % m)"
        ],
        "requires": [
          "m > 0"
        ],
        "body": "{\n                -x + m\n            }",
        "doc_comment": "Proof that computing the modulus using `%` is equivalent to\ncomputing it with a recursive definition of modulus. Specifically,\n`x % m` is equivalent in that way.",
        "triggers": [
          "(x % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 935,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": []
      },
      "lemma_mod_self_0": {
        "name": "lemma_mod_self_0",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_self_0(m: int)\n    requires\n        m > 0,\n    ensures\n        #[trigger] (m % m) == 0,",
        "ensures": [
          "#[trigger] (m % m) == 0"
        ],
        "requires": [
          "m > 0"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that any integer divided by itself produces a remainder of 0.",
        "triggers": [
          "(m % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 996,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_twice": {
        "name": "lemma_mod_twice",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_twice(x: int, m: int)\n    requires\n        m > 0,\n    ensures\n        #[trigger] ((x % m) % m) == x % m,",
        "ensures": [
          "#[trigger] ((x % m) % m) == x % m"
        ],
        "requires": [
          "m > 0"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that performing `(x % m) % m` gives the same result as simply perfoming `x % m`.",
        "triggers": [
          "((x % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1006,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_division_less_than_divisor": {
        "name": "lemma_mod_division_less_than_divisor",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_division_less_than_divisor(x: int, m: int)\n    requires\n        m > 0,\n    ensures\n        0 <= #[trigger] (x % m) < m,",
        "ensures": [
          "0 <= #[trigger] (x % m) < m"
        ],
        "requires": [
          "m > 0"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that the remainder of any division will be less than the divisor's value.",
        "triggers": [
          "(x % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1021,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_decreases": {
        "name": "lemma_mod_decreases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_decreases(x: nat, m: nat)\n    requires\n        0 < m,\n    ensures\n        #[trigger] (x % m) <= x,",
        "ensures": [
          "#[trigger] (x % m) <= x"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m as int);\n}",
        "doc_comment": "Proof that when natural number `x` is divided by natural number\n`m`, the remainder will be less than or equal to `x`.",
        "triggers": [
          "(x % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1036,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_is_zero": {
        "name": "lemma_mod_is_zero",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_is_zero(x: nat, m: nat)\n    requires\n        x > 0 && m > 0,\n        #[trigger] (x % m) == 0,\n    ensures\n        x >= m,",
        "ensures": [
          "x >= m"
        ],
        "requires": [
          "x > 0 && m > 0",
          "#[trigger] (x % m) == 0"
        ],
        "body": "{\n    if (x < m) {\n        lemma_small_mod(x, m);\n    }\n}",
        "doc_comment": "Proof that if `x % m` is zero and `x` is positive, then `x >= m`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1047,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_small_mod"
        ]
      },
      "lemma_mod_multiples_basic": {
        "name": "lemma_mod_multiples_basic",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_multiples_basic(x: int, m: int)\n    requires\n        m > 0,\n    ensures\n        #[trigger] ((x * m) % m) == 0,",
        "ensures": [
          "#[trigger] ((x * m) % m) == 0"
        ],
        "requires": [
          "m > 0"
        ],
        "body": "{\n    lemma_mod_auto(m);\n    broadcast use group_mul_properties_internal;\n\n    let f = |u: int| (u * m) % m == 0;\n    lemma_mul_induction(f);\n    assert(f(x));\n}",
        "doc_comment": "Proof that multiplying by a number then dividing by that same\nnumber produces a remainder of 0. Specifically, `(x * m) % m == 0`.",
        "triggers": [
          "((x * m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1060,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto",
          "f",
          "lemma_mul_induction"
        ]
      },
      "lemma_mod_add_multiples_vanish": {
        "name": "lemma_mod_add_multiples_vanish",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_add_multiples_vanish(b: int, m: int)\n    requires\n        0 < m,\n    ensures\n        (m + b) % m == #[trigger] (b % m),",
        "ensures": [
          "(m + b) % m == #[trigger] (b % m)"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that adding the divisor to the dividend doesn't change the\nremainder. Specifically, `(m + b) % m == b % m`.",
        "triggers": [
          "(b % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1077,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_sub_multiples_vanish": {
        "name": "lemma_mod_sub_multiples_vanish",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_sub_multiples_vanish(b: int, m: int)\n    requires\n        0 < m,\n    ensures\n        (-m + b) % m == #[trigger] (b % m),",
        "ensures": [
          "(-m + b) % m == #[trigger] (b % m)"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that subtracting the divisor from the dividend doesn't\nchange the remainder. Specifically, `(-m + b) % m == b % m`.",
        "triggers": [
          "(b % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1088,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_multiples_vanish": {
        "name": "lemma_mod_multiples_vanish",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_multiples_vanish(a: int, b: int, m: int)\n    requires\n        0 < m,\n    ensures\n        #[trigger] ((m * a + b) % m) == b % m,\n    decreases\n            (if a > 0",
        "ensures": [
          "#[trigger] ((m * a + b) % m) == b % m"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n                a\n            }",
        "doc_comment": "Proof that adding any multiple of the divisor to the dividend will produce the\nsame remainder. In other words, `(m * a + b) % m == b % m`.",
        "triggers": [
          "((m * a + b"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1099,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": []
      },
      "lemma_mod_subtraction": {
        "name": "lemma_mod_subtraction",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_subtraction(x: nat, s: nat, d: nat)\n    requires\n        0 < d,\n        0 <= s <= x % d,\n    ensures\n        #![trigger ((x - s) % d as int)]\n        x % d - s % d == (x - s) % d as int,",
        "ensures": [
          "#![trigger ((x - s) % d as int)]\n        x % d - s % d == (x - s) % d as int"
        ],
        "requires": [
          "0 < d",
          "0 <= s <= x % d"
        ],
        "body": "{\n    lemma_mod_auto(d as int);\n}",
        "doc_comment": "Proof that modulo distributes over subtraction if the subtracted value is\nless than or equal to the modulo of the number it's being subtracted from.\nSpecifically, because `0 <= s <= x % d`, we can conclude that\n`x % d - s % d == (x - s) % d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1122,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_add_mod_noop": {
        "name": "lemma_add_mod_noop",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_add_mod_noop(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        #![trigger (x + y) % m]\n        ((x % m) + (y % m)) % m == (x + y) % m,",
        "ensures": [
          "#![trigger (x + y) % m]\n        ((x % m) + (y % m)) % m == (x + y) % m"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that modulo distributes over addition, provided you do an\nextra modulo after adding the remainders. Specifically,\n`((x % m) + (y % m)) % m == (x + y) % m`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1137,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_add_mod_noop_right": {
        "name": "lemma_add_mod_noop_right",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_add_mod_noop_right(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        #![trigger (x + y) % m]\n        (x + (y % m)) % m == (x + y) % m,",
        "ensures": [
          "#![trigger (x + y) % m]\n        (x + (y % m)) % m == (x + y) % m"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that describes an expanded and succinct version of modulus\noperator in relation to addition. Specifically,\n`(x + (y % m)) % m == (x + y) % m`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1150,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_sub_mod_noop": {
        "name": "lemma_sub_mod_noop",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_sub_mod_noop(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        #![trigger (x - y) % m]\n        ((x % m) - (y % m)) % m == (x - y) % m,",
        "ensures": [
          "#![trigger (x - y) % m]\n        ((x % m) - (y % m)) % m == (x - y) % m"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that modulo distributes over subtraction provided you do an\nextra modulo operation after subtracting the remainders.\nSpecifically, `((x % m) - (y % m)) % m == (x - y) % m`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1163,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_sub_mod_noop_right": {
        "name": "lemma_sub_mod_noop_right",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_sub_mod_noop_right(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        #![trigger ((x - y) % m)]\n        (x - (y % m)) % m == (x - y) % m,",
        "ensures": [
          "#![trigger ((x - y) % m)]\n        (x - (y % m)) % m == (x - y) % m"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that describes an expanded and succinct version of modulus\noperator in relation to subtraction. Specifically,\n`(x - (y % m)) % m == (x - y) % m`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1176,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_adds": {
        "name": "lemma_mod_adds",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_adds(a: int, b: int, d: int)\n    requires\n        0 < d,\n    ensures\n        #![trigger ((a + b) % d)]\n        a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d),\n        (a % d + b % d) < d ==> a % d + b % d == (a + b) % d,",
        "ensures": [
          "#![trigger ((a + b) % d)]\n        a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)",
          "(a % d + b % d) < d ==> a % d + b % d == (a + b) % d"
        ],
        "requires": [
          "0 < d"
        ],
        "body": "{\n    broadcast use group_mul_properties_internal;\n\n    lemma_div_auto(d);\n}",
        "doc_comment": "Proof of two properties of the sum of two remainders with the same dividend:\n1) `a % d + b % d == (a + b) % d + d * ((a % d + b % d) / d)`.\n2) `(a % d + b % d) < d ==> a % d + b % d == (a + b) % d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1189,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_div_auto"
        ]
      },
      "lemma_mod_neg_neg": {
        "name": "lemma_mod_neg_neg",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_neg_neg(x: int, d: int)\n    requires\n        0 < d,\n    ensures\n        x % d == (x * (1 - d)) % d,",
        "ensures": [
          "x % d == (x * (1 - d)) % d"
        ],
        "requires": [
          "0 < d"
        ],
        "body": "{\n    broadcast use group_mul_properties_internal;\n\n    assert((x - x * d) % d == x % d) by {\n        let f = |i: int| (x - i * d) % d == x % d;\n        assert(f(0) && (forall|i: int| i >= 0 && #[trigger] f(i) ==> #[trigger] f(add1(i, 1))) && (\n        forall|i: int| i <= 0 && #[trigger] f(i) ==> #[trigger] f(sub1(i, 1)))) by {\n            lemma_mod_auto(d);\n        };\n        lemma_mul_induction(f);\n        assert(f(x));\n    }\n\n}",
        "doc_comment": "Proof that the remainder when dividing integer `x` by positive\ninteger `d` is equivalent to the remainder of `x * (1 - d)` by\n`d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1205,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [],
        "callees": [
          "f",
          "lemma_mul_induction",
          "add1",
          "lemma_mod_auto",
          "sub1"
        ]
      },
      "lemma_fundamental_div_mod_converse_mod": {
        "name": "lemma_fundamental_div_mod_converse_mod",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_fundamental_div_mod_converse_mod(x: int, d: int, q: int, r: int)\n    requires\n        d != 0,\n        0 <= r < d,\n        x == #[trigger] (q * d + r),\n    ensures\n        r == #[trigger] (x % d),",
        "ensures": [
          "r == #[trigger] (x % d)"
        ],
        "requires": [
          "d != 0",
          "0 <= r < d",
          "x == #[trigger] (q * d + r)"
        ],
        "body": "{\n    lemma_fundamental_div_mod_converse_helper_1(q, d, r);\n    assert(q == (q * d + r) / d);\n    lemma_fundamental_div_mod_converse_helper_2(q, d, r);\n}",
        "doc_comment": "Proof of the converse of the fundamental property of division and modulo.\nSpecifically, if we know `0 <= r < d` and `x == q * d + r`, then we\nknow that `r` is the remainder `x % d`.",
        "triggers": [
          "(x % d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1301,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_fundamental_div_mod_converse_helper_2",
          "lemma_fundamental_div_mod_converse_helper_1"
        ]
      },
      "lemma_fundamental_div_mod_converse_div": {
        "name": "lemma_fundamental_div_mod_converse_div",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_fundamental_div_mod_converse_div(x: int, d: int, q: int, r: int)\n    requires\n        d != 0,\n        0 <= r < d,\n        x == #[trigger] (q * d + r),\n    ensures\n        q == #[trigger] (x / d),",
        "ensures": [
          "q == #[trigger] (x / d)"
        ],
        "requires": [
          "d != 0",
          "0 <= r < d",
          "x == #[trigger] (q * d + r)"
        ],
        "body": "{\n    lemma_fundamental_div_mod_converse_helper_1(q, d, r);\n    assert(q == (q * d + r) / d);\n    lemma_fundamental_div_mod_converse_helper_2(q, d, r);\n}",
        "doc_comment": "Proof of the converse of the fundamental property of division and modulo.\nSpecifically, if we know `0 <= r < d` and `x == q * d + r`, then we\nknow that `q` is the quotient `x / d`.",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1317,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_fundamental_div_mod_converse_helper_2",
          "lemma_fundamental_div_mod_converse_helper_1"
        ]
      },
      "lemma_fundamental_div_mod_converse": {
        "name": "lemma_fundamental_div_mod_converse",
        "type": "proof",
        "signature": "pub proof fn lemma_fundamental_div_mod_converse(x: int, d: int, q: int, r: int)\n    requires\n        d != 0,\n        0 <= r < d,\n        x == q * d + r,\n    ensures\n        r == x % d,\n        q == x / d,",
        "ensures": [
          "r == x % d",
          "q == x / d"
        ],
        "requires": [
          "d != 0",
          "0 <= r < d",
          "x == q * d + r"
        ],
        "body": "{\n    lemma_fundamental_div_mod_converse_mod(x, d, q, r);\n    lemma_fundamental_div_mod_converse_div(x, d, q, r);\n}",
        "doc_comment": "Proof of the converse of the fundamental property of division and modulo.\nSpecifically, if we know `0 <= r < d` and `x == q * d + r`, then we\nknow that `q` is the quotient `x / d` and `r` is the remainder `x % d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1333,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [],
        "callees": [
          "lemma_fundamental_div_mod_converse_div",
          "lemma_fundamental_div_mod_converse_mod"
        ]
      },
      "lemma_mod_pos_bound": {
        "name": "lemma_mod_pos_bound",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_pos_bound(x: int, m: int)\n    requires\n        0 <= x,\n        0 < m,\n    ensures\n        0 <= #[trigger] (x % m) < m,",
        "ensures": [
          "0 <= #[trigger] (x % m) < m"
        ],
        "requires": [
          "0 <= x",
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that the remainder, when natural number `x` is divided by\npositive integer `m`, is less than `m`.",
        "triggers": [
          "(x % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1354,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_bound": {
        "name": "lemma_mod_bound",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_bound(x: int, m: int)\n    requires\n        0 < m,\n    ensures\n        0 <= #[trigger] (x % m) < m,",
        "ensures": [
          "0 <= #[trigger] (x % m) < m"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    ModINL::lemma_mod_range(x, m);\n}",
        "doc_comment": "Proof that when integer `x` is divided by positive integer `m`,\nthe remainder is nonegative and less than `m`.",
        "triggers": [
          "(x % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1366,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_range"
        ]
      },
      "lemma_mul_mod_noop_left": {
        "name": "lemma_mul_mod_noop_left",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_mod_noop_left(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        (x % m) * y % m == #[trigger] (x * y % m),",
        "ensures": [
          "(x % m) * y % m == #[trigger] (x * y % m)"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n    lemma_mul_induction_auto(y, |u: int| (x % m) * u % m == x * u % m);\n}",
        "doc_comment": "Proof that the remainder when `x * y` is divided by `m` is\nequivalent to the remainder when `(x % m) * y` is divided by `m`.",
        "triggers": [
          "(x * y % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1377,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto",
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_mod_noop_right": {
        "name": "lemma_mul_mod_noop_right",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_mod_noop_right(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        x * (y % m) % m == #[trigger] ((x * y) % m),",
        "ensures": [
          "x * (y % m) % m == #[trigger] ((x * y) % m)"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n    lemma_mul_induction_auto(x, |u: int| u * (y % m) % m == (u * y) % m);\n}",
        "doc_comment": "Proof that the remainder when `x * y` is divided by `m` is\nequivalent to the remainder when `x * (y % m)` is divided by `m`.",
        "triggers": [
          "((x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1389,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto",
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_mod_noop_general": {
        "name": "lemma_mul_mod_noop_general",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_mod_noop_general(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        ((x % m) * y) % m == (x * y) % m,\n        (x * (y % m)) % m == (x * y) % m,\n        ((x % m) * (y % m)) % m == #[trigger] ((x * y) % m),",
        "ensures": [
          "((x % m) * y) % m == (x * y) % m",
          "(x * (y % m)) % m == (x * y) % m",
          "((x % m) * (y % m)) % m == #[trigger] ((x * y) % m)"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mul_mod_noop_left(x, y, m);\n    lemma_mul_mod_noop_right(x, y, m);\n    lemma_mul_mod_noop_right(x % m, y, m);\n}",
        "doc_comment": "Proof of various properties about modulo equivalence with respect\nto multiplication, specifically various expressions that `(x * y)\n% m` is equivalent to.",
        "triggers": [
          "((x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1401,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_mod_noop_right",
          "lemma_mul_mod_noop_left"
        ]
      },
      "lemma_mul_mod_noop": {
        "name": "lemma_mul_mod_noop",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_mod_noop(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        (x % m) * (y % m) % m == #[trigger] ((x * y) % m),",
        "ensures": [
          "(x % m) * (y % m) % m == #[trigger] ((x * y) % m)"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mul_mod_noop_general(x, y, m);\n}",
        "doc_comment": "Proof that modulo distributes over multiplication, provided you do\nan extra modulo operation after multiplying the remainders. Specifically,\n`(x % m) * (y % m) % m == (x * y) % m`.",
        "triggers": [
          "((x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1417,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_mod_noop_general"
        ]
      },
      "lemma_mod_equivalence": {
        "name": "lemma_mod_equivalence",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_equivalence(x: int, y: int, m: int)\n    requires\n        0 < m,\n    ensures\n        #![trigger (x - y) % m]\n        x % m == y % m <==> (x - y) % m == 0,",
        "ensures": [
          "#![trigger (x - y) % m]\n        x % m == y % m <==> (x - y) % m == 0"
        ],
        "requires": [
          "0 < m"
        ],
        "body": "{\n    lemma_mod_auto(m);\n}",
        "doc_comment": "Proof that `x` and `y` are congruent modulo `m` if and only if `x\n- y` is congruent to 0 modulo `m`. In other words, `x % m == y % m\n<==> (x - y) % m == 0`.\n\nNote: The Dafny standard library uses the triggers `x % m, y % m`\nfor the broadcasted forall quantifier. But this can lead to a trigger loop,\nso we don't do that here.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1429,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_auto"
        ]
      },
      "lemma_mod_mul_equivalent": {
        "name": "lemma_mod_mul_equivalent",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_mul_equivalent(x: int, y: int, z: int, m: int)\n    requires\n        m > 0,\n        is_mod_equivalent(x, y, m),\n    ensures\n        #[trigger] is_mod_equivalent(x * z, y * z, m),",
        "ensures": [
          "#[trigger] is_mod_equivalent(x * z, y * z, m)"
        ],
        "requires": [
          "m > 0",
          "is_mod_equivalent(x, y, m)"
        ],
        "body": "{\n    lemma_mul_mod_noop_left(x, z, m);\n    lemma_mul_mod_noop_left(y, z, m);\n    lemma_mod_equivalence(x, y, m);\n    lemma_mod_equivalence(x * z, y * z, m);\n}",
        "doc_comment": "Proof that if `is_mod_equivalent` holds for `x`, `y`, and `m`,\nthen it holds for `x * z`, `y * z`, and `m`.",
        "triggers": [
          "is_mod_equivalent(x * z"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1455,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_mod_noop_left",
          "lemma_mod_equivalence"
        ]
      },
      "lemma_mod_ordering": {
        "name": "lemma_mod_ordering",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_ordering(x: int, k: int, d: int)\n    requires\n        1 < d,\n        0 < k,\n    ensures\n        0 < d * k,\n        x % d <= #[trigger] (x % (d * k)),",
        "ensures": [
          "0 < d * k",
          "x % d <= #[trigger] (x % (d * k))"
        ],
        "requires": [
          "1 < d",
          "0 < k"
        ],
        "body": "{\n    lemma_mul_strictly_increases(d, k);\n    calc! {\n        (==)\n        x % d + d * (x / d); {\n            lemma_fundamental_div_mod(x, d);\n        }\n        x; {\n            lemma_fundamental_div_mod(x, d * k);\n        }\n        x % (d * k) + (d * k) * (x / (d * k)); {\n            broadcast use lemma_mul_is_associative;\n\n        }\n        x % (d * k) + d * (k * (x / (d * k)));\n    }\n    calc! {\n        (==)\n        x % d; {\n            broadcast use group_mod_properties;\n\n        }\n        (x % d) % d; {\n            lemma_mod_multiples_vanish(x / d - k * (x / (d * k)), x % d, d);\n        }\n        (x % d + d * (x / d - k * (x / (d * k)))) % d; {\n            broadcast use lemma_mul_is_distributive_sub;\n\n        }\n        (x % d + d * (x / d) - d * (k * (x / (d * k)))) % d; {}\n        (x % (d * k)) % d;\n    }\n    assert((x % (d * k)) % d <= x % (d * k)) by {\n        broadcast use group_mod_properties;\n\n        lemma_mod_decreases((x % (d * k)) as nat, d as nat);\n    };\n}",
        "doc_comment": "Proof that multiplying the divisor by a positive number can't\ndecrease the remainder. Specifically, because `k > 0`, we have\n`x % d <= x % (d * k)`.",
        "triggers": [
          "(x % (d * k"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1470,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_strictly_increases",
          "lemma_mod_multiples_vanish",
          "lemma_fundamental_div_mod",
          "lemma_mod_decreases"
        ]
      },
      "lemma_mod_mod": {
        "name": "lemma_mod_mod",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_mod(x: int, a: int, b: int)\n    requires\n        0 < a,\n        0 < b,\n    ensures\n        #![trigger (x % (a * b)) % a, x % a]\n        0 < a * b,\n        (x % (a * b)) % a == x % a,",
        "ensures": [
          "#![trigger (x % (a * b)) % a, x % a]\n        0 < a * b",
          "(x % (a * b)) % a == x % a"
        ],
        "requires": [
          "0 < a",
          "0 < b"
        ],
        "body": "{\n    broadcast use lemma_mul_strictly_positive;\n\n    calc! {\n        (==)\n        x; {\n            lemma_fundamental_div_mod(x, a * b);\n        }\n        (a * b) * (x / (a * b)) + x % (a * b); {\n            broadcast use lemma_mul_is_associative;\n\n        }\n        a * (b * (x / (a * b))) + x % (a * b); {\n            lemma_fundamental_div_mod(x % (a * b), a);\n        }\n        a * (b * (x / (a * b))) + a * (x % (a * b) / a) + (x % (a * b)) % a; {\n            broadcast use group_mul_is_distributive;\n\n        }\n        a * (b * (x / (a * b)) + x % (a * b) / a) + (x % (a * b)) % a;\n    }\n    broadcast use {group_mod_properties, lemma_mul_is_commutative};\n\n    lemma_fundamental_div_mod_converse(\n        x,\n        a,\n        b * (x / (a * b)) + x % (a * b) / a,\n        (x % (a * b)) % a,\n    );\n}",
        "doc_comment": "Proof that the remainder when `x` is divided by `a * b`, taken\nmodulo `a`, is equivalent to `x` modulo `a`. That is,\n`(x % (a * b)) % a == x % a`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1519,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_fundamental_div_mod_converse",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_part_bound2": {
        "name": "lemma_part_bound2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_part_bound2(x: int, y: int, z: int)\n    requires\n        0 <= x,\n        0 < y,\n        0 < z,\n    ensures\n        y * z > 0,\n        #[trigger] (x % y) % #[trigger] (y * z) < y,",
        "ensures": [
          "y * z > 0",
          "#[trigger] (x % y) % #[trigger] (y * z) < y"
        ],
        "requires": [
          "0 <= x",
          "0 < y",
          "0 < z"
        ],
        "body": "{\n    broadcast use {\n        lemma_mul_strictly_positive,\n        group_mod_properties,\n        lemma_mul_is_commutative,\n        lemma_mul_increases,\n    };\n\n    assert(x % y < y);\n    assert(y <= y * z);\n    assert(0 <= x % y < y * z);\n    lemma_small_mod((x % y) as nat, (y * z) as nat);\n    assert((x % y) % (y * z) == x % y);\n}",
        "doc_comment": "Proof that `(x % y) % (y * z) < y`.",
        "triggers": [
          "(x % y",
          "(y * z"
        ],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1561,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_small_mod"
        ]
      },
      "lemma_mod_breakdown": {
        "name": "lemma_mod_breakdown",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mod_breakdown(x: int, y: int, z: int)\n    requires\n        0 <= x,\n        0 < y,\n        0 < z,\n    ensures\n        #![trigger x % (y * z)]\n        y * z > 0,\n        x % (y * z) == y * ((x / y) % z) + x % y,",
        "ensures": [
          "#![trigger x % (y * z)]\n        y * z > 0",
          "x % (y * z) == y * ((x / y) % z) + x % y"
        ],
        "requires": [
          "0 <= x",
          "0 < y",
          "0 < z"
        ],
        "body": "{\n    broadcast use lemma_mul_strictly_positive;\n\n    lemma_div_pos_is_pos(x, y);\n    assert(0 <= x / y);\n    assert((y * (x / y)) % (y * z) + (x % y) % (y * z) < y * z) by {\n        lemma_part_bound1(x, y, z);\n        lemma_part_bound2(x, y, z);\n        broadcast use {group_mul_basics, group_mul_is_distributive};\n\n    };\n    calc! {\n        (==)\n        x % (y * z); {\n            lemma_fundamental_div_mod(x, y);\n        }\n        (y * (x / y) + x % y) % (y * z); {\n            broadcast use group_mod_properties;\n\n            assert(0 <= x % y);\n            lemma_mul_nonnegative(y, x / y);\n            assert((y * (x / y)) % (y * z) + (x % y) % (y * z) < y * z);\n            lemma_mod_adds(y * (x / y), x % y, y * z);\n        }\n        (y * (x / y)) % (y * z) + (x % y) % (y * z); {\n            broadcast use {group_mod_properties, lemma_mul_is_commutative};\n\n            lemma_mul_increases(z, y);\n            assert(x % y < y && y <= y * z);\n            lemma_small_mod((x % y) as nat, (y * z) as nat);\n            assert((x % y) % (y * z) == x % y);\n        }\n        (y * (x / y)) % (y * z) + x % y; {\n            lemma_truncate_middle(x / y, y, z);\n        }\n        y * ((x / y) % z) + x % y;\n    }\n}",
        "doc_comment": "Proof of the validity of an expanded form of the modulus operation.\nSpecifically, `x % (y * z) == y * ((x / y) % z) + x % y`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1585,
        "module": "vstd::arithmetic::div_mod",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_part_bound2",
          "lemma_mod_adds",
          "lemma_mul_increases",
          "lemma_part_bound1",
          "lemma_fundamental_div_mod",
          "lemma_div_pos_is_pos",
          "lemma_truncate_middle",
          "lemma_small_mod",
          "lemma_mul_nonnegative"
        ]
      },
      "vstd::arithmetic::internals::div_internals::lemma_div_basics": {
        "name": "vstd::arithmetic::internals::div_internals::lemma_div_basics",
        "type": "proof",
        "signature": "pub proof fn lemma_div_basics(n: int)\n    requires\n        n > 0,\n    ensures\n        (n / n) == 1 && -((-n) / n) == 1,\n        forall|x: int| 0 <= x < n <==> #[trigger] (x / n) == 0,\n        forall|x: int| #[trigger] ((x + n) / n) == x / n + 1,\n        forall|x: int| #[trigger] ((x - n) / n) == x / n - 1,",
        "ensures": [
          "(n / n) == 1 && -((-n) / n) == 1",
          "forall|x: int| 0 <= x < n <==> #[trigger] (x / n) == 0",
          "forall|x: int| #[trigger] ((x + n) / n) == x / n + 1",
          "forall|x: int| #[trigger] ((x - n) / n) == x / n - 1"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    lemma_mod_auto(n);\n    lemma_mod_basics(n);\n    div_internals_nonlinear::lemma_small_div();\n    div_internals_nonlinear::lemma_div_by_self(n);\n    assert forall|x: int| #[trigger] (x / n) == 0 implies 0 <= x < n by {\n        mod_internals_nonlinear::lemma_fundamental_div_mod(x, n);\n    }\n}",
        "doc_comment": "Proof of basic properties of integer division when the divisor is\nthe given positive integer `n`",
        "triggers": [
          "(x / n",
          "((x + n",
          "((x - n"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 73,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "lemma_fundamental_div_mod",
          "lemma_mod_auto",
          "lemma_mod_basics",
          "lemma_div_by_self",
          "lemma_small_div"
        ]
      },
      "lemma_div_auto": {
        "name": "lemma_div_auto",
        "type": "proof",
        "signature": "pub proof fn lemma_div_auto(n: int)\n    requires\n        n > 0,\n    ensures\n        div_auto(n),",
        "ensures": [
          "div_auto(n)"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    lemma_mod_auto(n);\n    lemma_div_basics(n);\n    assert forall|x: int| 0 <= x < n <==> #[trigger] (x / n) == 0 by {\n        lemma_div_basics(n);\n    }\n    assert((0 + n) / n == 1);\n    assert((0 - n) / n == -1);\n    lemma_div_auto_plus(n);\n    lemma_div_auto_minus(n);\n}",
        "doc_comment": "Proof of `div_auto(n)`, which expresses many useful properties of\ndivision when the denominator is the given positive integer `n`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 230,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": [],
        "callees": [
          "lemma_mod_auto",
          "lemma_div_auto_plus",
          "lemma_div_auto_minus",
          "lemma_div_basics"
        ]
      },
      "lemma_div_induction_auto": {
        "name": "lemma_div_induction_auto",
        "type": "proof",
        "signature": "pub proof fn lemma_div_induction_auto(n: int, x: int, f: spec_fn(int) -> bool)\n    requires\n        n > 0,\n        div_auto(n) ==>",
        "ensures": [],
        "requires": [
          "n > 0",
          "div_auto(n) ==>"
        ],
        "body": "{\n            &&& (forall|i: int| #[trigger] is_le(0, i) && i < n ==> f(i))\n            &&& (forall|i: int| #[trigger] is_le(0, i) && f(i) ==> f(i + n))\n            &&& (forall|i: int| #[trigger] is_le(i + 1, n) && f(i) ==> f(i - n))\n        }",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nthe given arbitrary input `x`.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `is_le(0, i) &&\ni < n`.\n\n`x`: The desired case established by this lemma. Its postcondition\nthus includes `f(x)`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i`, `is_le(0, i) && f(i) ==> f(i +\nn)`. `is_le(0, i)` is just `0 <= i`, but written in a functional\nstyle so that it can be used where functional triggers are\nrequired.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i`, `is_le(i + 1, n) && f(i) ==> f(i\n- n)`. `is_le(i + 1, n)` is just `i + 1 <= n`, but written in a\nfunctional style so that it can be used where functional triggers\nare required.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 249,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": [],
        "callees": [
          "f",
          "is_le"
        ]
      },
      "lemma_div_induction_auto_forall": {
        "name": "lemma_div_induction_auto_forall",
        "type": "proof",
        "signature": "pub proof fn lemma_div_induction_auto_forall(n: int, f: spec_fn(int) -> bool)\n    requires\n        n > 0,\n        div_auto(n) ==>",
        "ensures": [],
        "requires": [
          "n > 0",
          "div_auto(n) ==>"
        ],
        "body": "{\n            &&& (forall|i: int| #[trigger] is_le(0, i) && i < n ==> f(i))\n            &&& (forall|i: int| #[trigger] is_le(0, i) && f(i) ==> f(i + n))\n            &&& (forall|i: int| #[trigger] is_le(i + 1, n) && f(i) ==> f(i - n))\n        }",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nall integer values.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `is_le(0, i) &&\ni < n`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i`, `is_le(0, i) && f(i) ==> f(i +\nn)`. `is_le(0, i)` is just `0 <= i`, but written in a functional\nstyle so that it can be used where functional triggers are\nrequired.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i`, `is_le(i + 1, n) && f(i) ==> f(i\n- n)`. `is_le(i + 1, n)` is just `i + 1 <= n`, but written in a\nfunctional style so that it can be used where functional triggers\nare required.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 302,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": [
          "forall"
        ],
        "callees": [
          "f",
          "is_le"
        ]
      },
      "vstd::arithmetic::internals::div_internals_nonlinear::lemma_div_of0": {
        "name": "vstd::arithmetic::internals::div_internals_nonlinear::lemma_div_of0",
        "type": "proof",
        "signature": "pub proof fn lemma_div_of0(d: int)\n    requires\n        d != 0 as int,\n    ensures\n        0 as int / d == 0 as int,",
        "ensures": [
          "0 as int / d == 0 as int"
        ],
        "requires": [
          "d != 0 as int"
        ],
        "body": "{\n}",
        "doc_comment": "Proof that 0 divided by any given integer `d` is 0",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals_nonlinear.rs",
        "line_number": 18,
        "module": "vstd::arithmetic::internals::div_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "vstd::arithmetic::internals::div_internals_nonlinear::lemma_div_by_self": {
        "name": "vstd::arithmetic::internals::div_internals_nonlinear::lemma_div_by_self",
        "type": "proof",
        "signature": "pub proof fn lemma_div_by_self(d: int)\n    requires\n        d != 0,\n    ensures\n        d / d == 1,",
        "ensures": [
          "d / d == 1"
        ],
        "requires": [
          "d != 0"
        ],
        "body": "{\n}",
        "doc_comment": "Proof that any given integer `d` divided by itself is 1",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals_nonlinear.rs",
        "line_number": 28,
        "module": "vstd::arithmetic::internals::div_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "lemma_small_div": {
        "name": "lemma_small_div",
        "type": "proof",
        "signature": "pub proof fn lemma_small_div()\n    ensures\n        forall|x: int, d: int| 0 <= x < d && d > 0 ==> #[trigger] (x / d) == 0,",
        "ensures": [
          "forall|x: int, d: int| 0 <= x < d && d > 0 ==> #[trigger] (x / d) == 0"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof that dividing a non-negative integer by a larger integer results in a quotient of 0",
        "triggers": [
          "(x / d"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals_nonlinear.rs",
        "line_number": 37,
        "module": "vstd::arithmetic::internals::div_internals_nonlinear",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "lemma_induction_helper": {
        "name": "lemma_induction_helper",
        "type": "proof",
        "signature": "pub proof fn lemma_induction_helper(n: int, f: spec_fn(int) -> bool, x: int)\n    requires\n        n > 0,\n        forall|i: int| 0 <= i < n ==> #[trigger] f(i),\n        forall|i: int| i >= 0 && #[trigger] f(i) ==> #[trigger] f(add1(i, n)),\n        forall|i: int| i < n && #[trigger] f(i) ==> #[trigger] f(sub1(i, n)),\n    ensures\n        f(x),",
        "ensures": [
          "f(x)"
        ],
        "requires": [
          "n > 0",
          "forall|i: int| 0 <= i < n ==> #[trigger] f(i)",
          "forall|i: int| i >= 0 && #[trigger] f(i) ==> #[trigger] f(add1(i, n))",
          "forall|i: int| i < n && #[trigger] f(i) ==> #[trigger] f(sub1(i, n))"
        ],
        "body": "{\n    if (x >= 0) {\n        lemma_induction_helper_pos(n, f, x);\n    } else {\n        lemma_induction_helper_neg(n, f, x);\n    }\n}",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nthe given arbitrary input `x`.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `0 <= i < n`.\n\n`x`: The desired case established by this lemma. Its postcondition\nis thus simply `f(x)`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i >= 0`, `f(i) ==> f(add1(i, n))`.\n`add1(i, n)` is just `i + n`, but written in a functional style\nso that it can be used where functional triggers are required.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i < n`, `f(i) ==> f(sub1(i, n))`.\n`sub1(i, n)` is just `i - n`, but written in a functional style\nso that it can be used where functional triggers are required.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/general_internals.rs",
        "line_number": 74,
        "module": "vstd::arithmetic::internals::general_internals",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "lemma_induction_helper_neg",
          "lemma_induction_helper_pos"
        ]
      },
      "lemma_mod_induction_forall": {
        "name": "lemma_mod_induction_forall",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_induction_forall(n: int, f: spec_fn(int) -> bool)\n    requires\n        n > 0,\n        forall|i: int| 0 <= i < n ==> #[trigger] f(i),\n        forall|i: int| i >= 0 && #[trigger] f(i) ==> #[trigger] f(add1(i, n)),\n        forall|i: int| i < n && #[trigger] f(i) ==> #[trigger] f(sub1(i, n)),\n    ensures\n        forall|i| #[trigger] f(i),",
        "ensures": [
          "forall|i| #[trigger] f(i)"
        ],
        "requires": [
          "n > 0",
          "forall|i: int| 0 <= i < n ==> #[trigger] f(i)",
          "forall|i: int| i >= 0 && #[trigger] f(i) ==> #[trigger] f(add1(i, n))",
          "forall|i: int| i < n && #[trigger] f(i) ==> #[trigger] f(sub1(i, n))"
        ],
        "body": "{\n    assert forall|i: int| #[trigger] f(i) by {\n        lemma_induction_helper(n, f, i);\n    };\n}",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nall possible inputs.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `0 <= i < n`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i >= 0`, `f(i) ==> f(add1(i, n))`.\n`add1(i, n)` is just `i + n`, but written in a functional style\nso that it can be used where functional triggers are required.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i < n`, `f(i) ==> f(sub1(i, n))`.\n`sub1(i, n)` is just `i - n`, but written in a functional style\nso that it can be used where functional triggers are required.",
        "triggers": [
          "f(i"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 56,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "f",
          "lemma_induction_helper"
        ]
      },
      "lemma_mod_induction_forall2": {
        "name": "lemma_mod_induction_forall2",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_induction_forall2(n: int, f: spec_fn(int, int) -> bool)\n    requires\n        n > 0,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] f(i, j),\n        forall|i: int, j: int| i >= 0 && #[trigger] f(i, j) ==> #[trigger] f(add1(i, n), j),\n        forall|i: int, j: int| j >= 0 && #[trigger] f(i, j) ==> #[trigger] f(i, add1(j, n)),\n        forall|i: int, j: int| i < n && #[trigger] f(i, j) ==> #[trigger] f(sub1(i, n), j),\n        forall|i: int, j: int| j < n && #[trigger] f(i, j) ==> #[trigger] f(i, sub1(j, n)),\n    ensures\n        forall|i: int, j: int| #[trigger] f(i, j),",
        "ensures": [
          "forall|i: int, j: int| #[trigger] f(i, j)"
        ],
        "requires": [
          "n > 0",
          "forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] f(i, j)",
          "forall|i: int, j: int| i >= 0 && #[trigger] f(i, j) ==> #[trigger] f(add1(i, n), j)",
          "forall|i: int, j: int| j >= 0 && #[trigger] f(i, j) ==> #[trigger] f(i, add1(j, n))",
          "forall|i: int, j: int| i < n && #[trigger] f(i, j) ==> #[trigger] f(sub1(i, n), j)",
          "forall|i: int, j: int| j < n && #[trigger] f(i, j) ==> #[trigger] f(i, sub1(j, n))"
        ],
        "body": "{\n    assert forall|x: int, y: int| #[trigger] f(x, y) by {\n        assert forall|i: int| 0 <= i < n implies #[trigger] f(i, y) by {\n            let fj = |j| f(i, j);\n            lemma_mod_induction_forall(n, fj);\n            assert(fj(y));\n        };\n        let fi = |i| f(i, y);\n        lemma_mod_induction_forall(n, fi);\n        assert(fi(x));\n    };\n}",
        "doc_comment": "This utility function helps prove a mathematical property of a\npair of integers by induction. The caller supplies a predicate\nover a pair of integers, proves the predicate holds in certain\nbase cases, and proves correctness of inductive steps both upward\nand downward from the base cases. This lemma invokes induction to\nestablish that the predicate holds for all possible inputs.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i, j)` for every pair of values `i, j` satisfying\n`0 <= i < n` and `0 <= j < n`.\n\nTo prove inductive steps from the base cases, the caller must\nestablish that:\n\n1) For any `i >= 0`, `f(i, j) ==> f(add1(i, n), j)`. `add1(i, n)`\nis just `i + n`, but written in a functional style so that it can\nbe used where functional triggers are required.\n\n2) For any `j >= 0`, `f(i, j) ==> f(i, add1(j, n))`\n\n3) For any `i < n`, `f(i) ==> f(sub1(i, n))`. `sub1(i, n)` is just\n`i - n`, but written in a functional style so that it can be used\nwhere functional triggers are required.\n\n4) For any `j < n`, `f(j) ==> f(i, sub1(j, n))`.",
        "triggers": [
          "f(i"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 91,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "f",
          "lemma_mod_induction_forall",
          "fi",
          "fj"
        ]
      },
      "lemma_div_add_denominator": {
        "name": "lemma_div_add_denominator",
        "type": "proof",
        "signature": "pub proof fn lemma_div_add_denominator(n: int, x: int)\n    requires\n        n > 0,\n    ensures\n        (x + n) / n == x / n + 1,",
        "ensures": [
          "(x + n) / n == x / n + 1"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    lemma_fundamental_div_mod(x, n);\n    lemma_fundamental_div_mod(x + n, n);\n    let zp = (x + n) / n - x / n - 1;\n    assert(0 == n * zp + ((x + n) % n) - (x % n)) by {\n        broadcast use group_mul_properties_internal;\n\n    };\n    if (zp > 0) {\n        lemma_mul_inequality(1, zp, n);\n    }\n    if (zp < 0) {\n        lemma_mul_inequality(zp, -1, n);\n    }\n}",
        "doc_comment": "Proof that when dividing, adding the denominator to the numerator\nincreases the result by 1. Specifically, for the given `n` and `x`,\n`(x + n) / n == x / n + 1`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 141,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [],
        "callees": [
          "lemma_mul_inequality",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_div_sub_denominator": {
        "name": "lemma_div_sub_denominator",
        "type": "proof",
        "signature": "pub proof fn lemma_div_sub_denominator(n: int, x: int)\n    requires\n        n > 0,\n    ensures\n        (x - n) / n == x / n - 1,",
        "ensures": [
          "(x - n) / n == x / n - 1"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    lemma_fundamental_div_mod(x, n);\n    lemma_fundamental_div_mod(x - n, n);\n    let zm = (x - n) / n - x / n + 1;\n    assert(0 == n * zm + ((x - n) % n) - (x % n)) by {\n        broadcast use group_mul_properties_internal;\n\n    }\n    if (zm > 0) {\n        lemma_mul_inequality(1, zm, n);\n    }\n    if (zm < 0) {\n        lemma_mul_inequality(zm, -1, n);\n    }\n}",
        "doc_comment": "Proof that when dividing, subtracting the denominator from the numerator\ndecreases the result by 1. Specifically, for the given `n` and `x`,\n`(x - n) / n == x / n - 1`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 166,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [],
        "callees": [
          "lemma_mul_inequality",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_mod_add_denominator": {
        "name": "lemma_mod_add_denominator",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_add_denominator(n: int, x: int)\n    requires\n        n > 0,\n    ensures\n        (x + n) % n == x % n,",
        "ensures": [
          "(x + n) % n == x % n"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    lemma_fundamental_div_mod(x, n);\n    lemma_fundamental_div_mod(x + n, n);\n    let zp = (x + n) / n - x / n - 1;\n    assert(n * zp == n * ((x + n) / n - x / n) - n) by {\n        assert(n * (((x + n) / n - x / n) - 1) == n * ((x + n) / n - x / n) - n) by {\n            broadcast use group_mul_is_commutative_and_distributive;\n\n        };\n    };\n    assert(0 == n * zp + ((x + n) % n) - (x % n)) by {\n        broadcast use group_mul_properties_internal;\n\n    }\n    if (zp > 0) {\n        lemma_mul_inequality(1, zp, n);\n    } else if (zp < 0) {\n        lemma_mul_inequality(zp, -1, n);\n    } else {\n        broadcast use group_mul_properties_internal;\n\n    }\n}",
        "doc_comment": "Proof that when dividing, adding the denominator to the numerator\ndoesn't change the remainder. Specifically, for the given `n` and\n`x`, `(x + n) % n == x % n`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 190,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [],
        "callees": [
          "lemma_mul_inequality",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_mod_sub_denominator": {
        "name": "lemma_mod_sub_denominator",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_sub_denominator(n: int, x: int)\n    requires\n        n > 0,\n    ensures\n        (x - n) % n == x % n,",
        "ensures": [
          "(x - n) % n == x % n"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    lemma_fundamental_div_mod(x, n);\n    lemma_fundamental_div_mod(x - n, n);\n    let zm = (x - n) / n - x / n + 1;\n    broadcast use group_mul_is_distributive;  // OBSERVE\n\n    assert(0 == n * zm + ((x - n) % n) - (x % n)) by {\n        broadcast use group_mul_properties_internal;\n\n    }\n    if (zm > 0) {\n        lemma_mul_inequality(1, zm, n);\n    }\n    if (zm < 0) {\n        lemma_mul_inequality(zm, -1, n);\n    }\n}",
        "doc_comment": "Proof that when dividing, subtracting the denominator from the\nnumerator doesn't change the remainder. Specifically, for the\ngiven `n` and `x`, `(x - n) % n == x % n`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 223,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [],
        "callees": [
          "lemma_mul_inequality",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_mod_below_denominator": {
        "name": "lemma_mod_below_denominator",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_below_denominator(n: int, x: int)\n    requires\n        n > 0,\n    ensures\n        0 <= x < n <==> x % n == x,",
        "ensures": [
          "0 <= x < n <==> x % n == x"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    assert forall|x: int| 0 <= x < n <==> #[trigger] (x % n) == x by {\n        if (0 <= x < n) {\n            lemma_small_mod(x as nat, n as nat);\n        }\n        lemma_mod_range(x, n);\n    }\n}",
        "doc_comment": "Proof that for the given `n` and `x`, `x % n == x` if and only if\n`0 <= x < n`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 249,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [],
        "callees": [
          "lemma_small_mod",
          "lemma_mod_range"
        ]
      },
      "lemma_mod_basics": {
        "name": "lemma_mod_basics",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_basics(n: int)\n    requires\n        n > 0,\n    ensures\n        forall|x: int| #[trigger] ((x + n) % n) == x % n,\n        forall|x: int| #[trigger] ((x - n) % n) == x % n,\n        forall|x: int| #[trigger] ((x + n) / n) == x / n + 1,\n        forall|x: int| #[trigger] ((x - n) / n) == x / n - 1,\n        forall|x: int| 0 <= x < n <==> #[trigger] (x % n) == x,",
        "ensures": [
          "forall|x: int| #[trigger] ((x + n) % n) == x % n",
          "forall|x: int| #[trigger] ((x - n) % n) == x % n",
          "forall|x: int| #[trigger] ((x + n) / n) == x / n + 1",
          "forall|x: int| #[trigger] ((x - n) / n) == x / n - 1",
          "forall|x: int| 0 <= x < n <==> #[trigger] (x % n) == x"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    assert forall|x: int| #[trigger] ((x + n) % n) == x % n by {\n        lemma_mod_add_denominator(n, x);\n    };\n    assert forall|x: int| #[trigger] ((x - n) % n) == x % n by {\n        lemma_mod_sub_denominator(n, x);\n        assert((x - n) % n == x % n);\n    };\n    assert forall|x: int| #[trigger] ((x + n) / n) == x / n + 1 by {\n        lemma_div_add_denominator(n, x);\n    };\n    assert forall|x: int| #[trigger] ((x - n) / n) == x / n - 1 by {\n        lemma_div_sub_denominator(n, x);\n    };\n    assert forall|x: int| 0 <= x < n <==> #[trigger] (x % n) == x by {\n        lemma_mod_below_denominator(n, x);\n    };\n}",
        "doc_comment": "Proof of basic properties of the division given the divisor `n`:\n\n1) Adding the denominator to the numerator increases the quotient\nby 1 and doesn't change the remainder.\n\n2) Subtracting the denominator from the numerator decreases the\nquotient by 1 and doesn't change the remainder.\n\n3) The numerator is the same as the result if and only if the\nnumerator is in the half-open range `[0, n)`.",
        "triggers": [
          "((x + n",
          "((x - n",
          "((x + n",
          "((x - n",
          "(x % n"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 265,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "lemma_mod_sub_denominator",
          "lemma_mod_add_denominator",
          "lemma_div_add_denominator",
          "lemma_mod_below_denominator",
          "lemma_div_sub_denominator"
        ]
      },
      "lemma_quotient_and_remainder": {
        "name": "lemma_quotient_and_remainder",
        "type": "proof",
        "signature": "pub proof fn lemma_quotient_and_remainder(x: int, q: int, r: int, n: int)\n    requires\n        n > 0,\n        0 <= r < n,\n        x == q * n + r,\n    ensures\n        q == x / n,\n        r == x % n,\n    decreases\n            (if q > 0",
        "ensures": [
          "q == x / n",
          "r == x % n"
        ],
        "requires": [
          "n > 0",
          "0 <= r < n",
          "x == q * n + r"
        ],
        "body": "{\n                q\n            }",
        "doc_comment": "Proof that if `x == q * r + n` and `0 <= r < n`, then `q == x / n`\nand `r == x % n`. Essentially, this is the converse of the\nfundamental theorem of division and modulo.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 303,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [
          "decreases"
        ],
        "callees": []
      },
      "lemma_mod_auto": {
        "name": "lemma_mod_auto",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_auto(n: int)\n    requires\n        n > 0,\n    ensures\n        mod_auto(n),",
        "ensures": [
          "mod_auto(n)"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    lemma_mod_basics(n);\n    broadcast use group_mul_properties_internal;\n\n    assert forall|x: int, y: int|\n        {\n            let z = (x % n) + (y % n);\n            ((0 <= z < n && #[trigger] ((x + y) % n) == z) || (n <= z < n + n && ((x + y) % n) == z\n                - n))\n        } by {\n        let xq = x / n;\n        let xr = x % n;\n        lemma_fundamental_div_mod(x, n);\n        assert(x == xq * n + xr);\n        let yq = y / n;\n        let yr = y % n;\n        lemma_fundamental_div_mod(y, n);\n        assert(y == yq * n + yr);\n        if xr + yr < n {\n            lemma_quotient_and_remainder(x + y, xq + yq, xr + yr, n);\n        } else {\n            lemma_quotient_and_remainder(x + y, xq + yq + 1, xr + yr - n, n);\n        }\n    }\n    assert forall|x: int, y: int|\n        {\n            let z = (x % n) - (y % n);\n            ((0 <= z < n && #[trigger] ((x - y) % n) == z) || (-n <= z < 0 && ((x - y) % n) == z\n                + n))\n        } by {\n        let xq = x / n;\n        let xr = x % n;\n        lemma_fundamental_div_mod(x, n);\n        assert(x == n * (x / n) + (x % n));\n        let yq = y / n;\n        let yr = y % n;\n        lemma_fundamental_div_mod(y, n);\n        assert(y == yq * n + yr);\n        if xr - yr >= 0 {\n            lemma_quotient_and_remainder(x - y, xq - yq, xr - yr, n);\n        } else {  // xr - yr < 0\n            lemma_quotient_and_remainder(x - y, xq - yq - 1, xr - yr + n, n);\n        }\n    }\n}",
        "doc_comment": "Proof of `mod_auto(n)`, which states various useful properties\nabout the modulo operator when the divisor is the positive number\n`n`",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 385,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [],
        "callees": [
          "lemma_mod_basics",
          "lemma_quotient_and_remainder",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_mod_induction_auto": {
        "name": "lemma_mod_induction_auto",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_induction_auto(n: int, x: int, f: spec_fn(int) -> bool)\n    requires\n        n > 0,\n        mod_auto(n) ==>",
        "ensures": [],
        "requires": [
          "n > 0",
          "mod_auto(n) ==>"
        ],
        "body": "{\n            &&& (forall|i: int| #[trigger] is_le(0, i) && i < n ==> f(i))\n            &&& (forall|i: int| #[trigger] is_le(0, i) && f(i) ==> f(i + n))\n            &&& (forall|i: int| #[trigger] is_le(i + 1, n) && f(i) ==> f(i - n))\n        }",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nthe given arbitrary input `x`.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `is_le(0, i) &&\ni < n`.\n\n`x`: The desired case established by this lemma. Its postcondition\nthus includes `f(x)`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i`, `is_le(0, i) && f(i) ==> f(i +\nn)`. `is_le(0, i)` is just `0 <= i`, but written in a functional\nstyle so that it can be used where functional triggers are\nrequired.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i`, `is_le(i + 1, n) && f(i) ==> f(i\n- n)`. `is_le(i + 1, n)` is just `i + 1 <= n`, but written in a\nfunctional style so that it can be used where functional triggers\nare required.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 439,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [],
        "callees": [
          "f",
          "is_le"
        ]
      },
      "lemma_mod_induction_auto_forall": {
        "name": "lemma_mod_induction_auto_forall",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_induction_auto_forall(n: int, f: spec_fn(int) -> bool)\n    requires\n        n > 0,\n        mod_auto(n) ==>",
        "ensures": [],
        "requires": [
          "n > 0",
          "mod_auto(n) ==>"
        ],
        "body": "{\n            &&& (forall|i: int| #[trigger] is_le(0, i) && i < n ==> f(i))\n            &&& (forall|i: int| #[trigger] is_le(0, i) && f(i) ==> f(i + n))\n            &&& (forall|i: int| #[trigger] is_le(i + 1, n) && f(i) ==> f(i - n))\n        }",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in certain base cases, and proves correctness of\ninductive steps both upward and downward from the base cases. This\nlemma invokes induction to establish that the predicate holds for\nall integer values.\n\n`f`: The integer predicate\n\n`n`: Upper bound on the base cases. Specifically, the caller\nestablishes `f(i)` for every value `i` satisfying `is_le(0, i) &&\ni < n`.\n\nTo prove inductive steps upward from the base cases, the caller\nmust establish that, for any `i`, `is_le(0, i) && f(i) ==> f(i +\nn)`. `is_le(0, i)` is just `0 <= i`, but written in a functional\nstyle so that it can be used where functional triggers are\nrequired.\n\nTo prove inductive steps downward from the base cases, the caller\nmust establish that, for any `i`, `is_le(i + 1, n) && f(i) ==> f(i\n- n)`. `is_le(i + 1, n)` is just `i + 1 <= n`, but written in a\nfunctional style so that it can be used where functional triggers\nare required.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 489,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [
          "forall"
        ],
        "callees": [
          "f",
          "is_le"
        ]
      },
      "vstd::arithmetic::internals::mod_internals_nonlinear::lemma_fundamental_div_mod": {
        "name": "vstd::arithmetic::internals::mod_internals_nonlinear::lemma_fundamental_div_mod",
        "type": "proof",
        "signature": "pub proof fn lemma_fundamental_div_mod(x: int, d: int)\n    requires\n        d != 0,\n    ensures\n        x == d * (x / d) + (x % d),",
        "ensures": [
          "x == d * (x / d) + (x % d)"
        ],
        "requires": [
          "d != 0"
        ],
        "body": "{\n}",
        "doc_comment": "Proof of the fundamental theorem of division and modulo: That for\nany positive divisor `d` and any integer `x`, `x` is equal to `d`\ntimes `x / d` plus `x % d`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals_nonlinear.rs",
        "line_number": 35,
        "module": "vstd::arithmetic::internals::mod_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "vstd::arithmetic::internals::mod_internals_nonlinear::lemma_small_mod": {
        "name": "vstd::arithmetic::internals::mod_internals_nonlinear::lemma_small_mod",
        "type": "proof",
        "signature": "pub proof fn lemma_small_mod(x: nat, m: nat)\n    requires\n        x < m,\n        0 < m,\n    ensures\n        #[trigger] modulus(x as int, m as int) == x as int,",
        "ensures": [
          "#[trigger] modulus(x as int, m as int) == x as int"
        ],
        "requires": [
          "x < m",
          "0 < m"
        ],
        "body": "{\n}",
        "doc_comment": "Proof that a natural number `x` divided by a larger natural number\n`m` gives a remainder equal to `x`",
        "triggers": [
          "modulus(x as int"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals_nonlinear.rs",
        "line_number": 54,
        "module": "vstd::arithmetic::internals::mod_internals_nonlinear",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mod_range": {
        "name": "lemma_mod_range",
        "type": "proof",
        "signature": "pub proof fn lemma_mod_range(x: int, m: int)\n    requires\n        m > 0,\n    ensures\n        0 <= #[trigger] modulus(x, m) < m,",
        "ensures": [
          "0 <= #[trigger] modulus(x, m) < m"
        ],
        "requires": [
          "m > 0"
        ],
        "body": "{\n}",
        "doc_comment": "Proof of Euclid's division lemma, i.e., that any integer `x`\nmodulo any positive integer `m` is in the half-open range `[0, m)`.",
        "triggers": [
          "modulus(x"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals_nonlinear.rs",
        "line_number": 66,
        "module": "vstd::arithmetic::internals::mod_internals_nonlinear",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mul_induction": {
        "name": "lemma_mul_induction",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_induction(f: spec_fn(int) -> bool)\n    requires\n        f(0),\n        forall|i: int| i >= 0 && #[trigger] f(i) ==> #[trigger] f(add1(i, 1)),\n        forall|i: int| i <= 0 && #[trigger] f(i) ==> #[trigger] f(sub1(i, 1)),\n    ensures\n        forall|i: int| #[trigger] f(i),",
        "ensures": [
          "forall|i: int| #[trigger] f(i)"
        ],
        "requires": [
          "f(0)",
          "forall|i: int| i >= 0 && #[trigger] f(i) ==> #[trigger] f(add1(i, 1))",
          "forall|i: int| i <= 0 && #[trigger] f(i) ==> #[trigger] f(sub1(i, 1))"
        ],
        "body": "{\n    assert forall|i: int| #[trigger] f(i) by { lemma_induction_helper(1, f, i) };\n}",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate, proves the\npredicate holds in the base case of 0, and proves correctness of\ninductive steps both upward and downward from the base case. This\nlemma invokes induction to establish that the predicate holds for\nall integers.\n\nTo prove inductive steps upward from the base case, the caller\nmust establish that, for any `i >= 0`, `f(i) ==> f(add1(i, 1))`.\n`add1(i, 1)` is just `i + 1`, but written in a functional style\nso that it can be used where functional triggers are required.\n\nTo prove inductive steps downward from the base case, the caller\nmust establish that, for any `i <= 0`, `f(i) ==> f(sub1(i, 1))`.\n`sub1(i, 1)` is just `i - 1`, but written in a functional style\nso that it can be used where functional triggers are required.",
        "triggers": [
          "f(i"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 49,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "f",
          "lemma_induction_helper"
        ]
      },
      "lemma_mul_commutes": {
        "name": "lemma_mul_commutes",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_commutes(x: int, y: int)\n    ensures\n        #[trigger] (x * y) == y * x,",
        "ensures": [
          "#[trigger] (x * y) == y * x"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof that multiplication is always commutative",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 76,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mul_distributes_plus": {
        "name": "lemma_mul_distributes_plus",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_distributes_plus(x: int, y: int, z: int)\n    ensures\n        #[trigger] ((x + y) * z) == (x * z + y * z),",
        "ensures": [
          "#[trigger] ((x + y) * z) == (x * z + y * z)"
        ],
        "requires": [],
        "body": "{\n    lemma_mul_successor();\n    assert forall|x: int, y: int, z: int| #[trigger] ((x + y) * z) == (x * z + y * z) by {\n        let f1 = |i: int| ((x + i) * z) == (x * z + i * z);\n        assert(f1(0));\n        assert forall|i: int| i >= 0 && #[trigger] f1(i) implies #[trigger] f1(add1(i, 1)) by {\n            assert((x + (i + 1)) * z == ((x + i) + 1) * z == (x + i) * z + z);\n        };\n        assert forall|i: int| i <= 0 && #[trigger] f1(i) implies #[trigger] f1(sub1(i, 1)) by {\n            assert((x + (i - 1)) * z == ((x + i) - 1) * z == (x + i) * z - z);\n        };\n        lemma_mul_induction(f1);\n        assert(f1(y));\n    }\n}",
        "doc_comment": "Proof that multiplication distributes over addition and over\nsubtraction",
        "triggers": [
          "((x + y"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 102,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction",
          "add1",
          "lemma_mul_successor",
          "f1",
          "sub1"
        ]
      },
      "lemma_mul_distributes_minus": {
        "name": "lemma_mul_distributes_minus",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_distributes_minus(x: int, y: int, z: int)\n    ensures\n        #[trigger] ((x - y) * z) == (x * z - y * z),",
        "ensures": [
          "#[trigger] ((x - y) * z) == (x * z - y * z)"
        ],
        "requires": [],
        "body": "{\n    lemma_mul_successor();\n    assert forall|x: int, y: int, z: int| #[trigger] ((x - y) * z) == (x * z - y * z) by {\n        let f2 = |i: int| ((x - i) * z) == (x * z - i * z);\n        assert(f2(0));\n        assert forall|i: int| i >= 0 && #[trigger] f2(i) implies #[trigger] f2(add1(i, 1)) by {\n            assert((x - (i + 1)) * z == ((x - i) - 1) * z == (x - i) * z - z);\n        };\n        assert forall|i: int| i <= 0 && #[trigger] f2(i) implies #[trigger] f2(sub1(i, 1)) by {\n            assert((x - (i - 1)) * z == ((x - i) + 1) * z == (x - i) * z + z);\n        };\n        lemma_mul_induction(f2);\n        assert(f2(y));\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "((x - y"
        ],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 124,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction",
          "add1",
          "lemma_mul_successor",
          "f2",
          "sub1"
        ]
      },
      "lemma_mul_induction_auto": {
        "name": "lemma_mul_induction_auto",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_induction_auto(x: int, f: spec_fn(int) -> bool)\n    requires\n        mul_auto() ==>",
        "ensures": [],
        "requires": [
          "mul_auto() ==>"
        ],
        "body": "{\n            &&& f(0)\n            &&& (forall|i| #[trigger] is_le(0, i) && f(i) ==> f(i + 1))\n            &&& (forall|i| #[trigger] is_le(i, 0) && f(i) ==> f(i - 1))\n        }",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate `f`, proves\nthe predicate holds in the base case of 0, and proves correctness\nof inductive steps both upward and downward from the base case.\nThis lemma invokes induction to establish that the predicate holds\nfor the given integer `x`.\n\nTo prove inductive steps upward from the base case, the caller\nmust establish that, for any `i`, `is_le(0, i)` implies `f(i) ==>\nf(i + 1)`.\n\nTo prove inductive steps downward from the base case, the caller\nmust establish that, for any `i`, `is_le(i, 0)` implies `f(i) ==>\nf(i - 1)`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 168,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": [],
        "callees": [
          "f",
          "is_le"
        ]
      },
      "lemma_mul_induction_auto_forall": {
        "name": "lemma_mul_induction_auto_forall",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_induction_auto_forall(f: spec_fn(int) -> bool)\n    requires\n        mul_auto() ==>",
        "ensures": [],
        "requires": [
          "mul_auto() ==>"
        ],
        "body": "{\n            &&& f(0)\n            &&& (forall|i| #[trigger] is_le(0, i) && f(i) ==> f(i + 1))\n            &&& (forall|i| #[trigger] is_le(i, 0) && f(i) ==> f(i - 1))\n        }",
        "doc_comment": "This utility function helps prove a mathematical property by\ninduction. The caller supplies an integer predicate `f`, proves\nthe predicate holds in the base case of 0, and proves correctness\nof inductive steps both upward and downward from the base case.\nThis lemma invokes induction to establish that the predicate holds\nfor all integers.\n\nTo prove inductive steps upward from the base case, the caller\nmust establish that, for any `i`, `is_le(0, i)` implies `f(i) ==>\nf(i + 1)`.\n\nTo prove inductive steps downward from the base case, the caller\nmust establish that, for any `i`, `is_le(i, 0)` implies `f(i) ==>\nf(i - 1)`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 200,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": [
          "forall"
        ],
        "callees": [
          "f",
          "is_le"
        ]
      },
      "lemma_mul_strictly_positive": {
        "name": "vstd::arithmetic::internals::mul_internals_nonlinear::lemma_mul_strictly_positive",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_strictly_positive(x: int, y: int)\n    ensures\n        (0 < x && 0 < y) ==> (0 < x * y),",
        "ensures": [
          "(0 < x && 0 < y) ==> (0 < x * y)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof that multiplying two positive integers `x` and `y` will result in a positive integer",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals_nonlinear.rs",
        "line_number": 23,
        "module": "vstd::arithmetic::internals::mul_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "lemma_mul_nonzero": {
        "name": "vstd::arithmetic::internals::mul_internals_nonlinear::lemma_mul_nonzero",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_nonzero(x: int, y: int)\n    ensures\n        x * y != 0 <==> x != 0 && y != 0,",
        "ensures": [
          "x * y != 0 <==> x != 0 && y != 0"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof that `x` and `y` are both nonzero if and only if `x * y` is nonzero",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals_nonlinear.rs",
        "line_number": 31,
        "module": "vstd::arithmetic::internals::mul_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "lemma_mul_is_associative": {
        "name": "vstd::arithmetic::internals::mul_internals_nonlinear::lemma_mul_is_associative",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_is_associative(x: int, y: int, z: int)\n    ensures\n        x * (y * z) == (x * y) * z,",
        "ensures": [
          "x * (y * z) == (x * y) * z"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof that multiplication is associative in this specific case,\ni.e., that `x * y * z` is the same no matter which of the two\nmultiplications is done first",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals_nonlinear.rs",
        "line_number": 39,
        "module": "vstd::arithmetic::internals::mul_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "lemma_mul_is_distributive_add": {
        "name": "vstd::arithmetic::internals::mul_internals_nonlinear::lemma_mul_is_distributive_add",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_is_distributive_add(x: int, y: int, z: int)\n    ensures\n        x * (y + z) == x * y + x * z,",
        "ensures": [
          "x * (y + z) == x * y + x * z"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof that multiplication distributes over addition in this\nspecific case, i.e., that `x * (y + z)` equals `x * y` plus `x * z`",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals_nonlinear.rs",
        "line_number": 49,
        "module": "vstd::arithmetic::internals::mul_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "lemma_mul_ordering": {
        "name": "vstd::arithmetic::internals::mul_internals_nonlinear::lemma_mul_ordering",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_ordering(x: int, y: int)\n    requires\n        x != 0,\n        y != 0,\n        0 <= x * y,\n    ensures\n        x * y >= x && x * y >= y,",
        "ensures": [
          "x * y >= x && x * y >= y"
        ],
        "requires": [
          "x != 0",
          "y != 0",
          "0 <= x * y"
        ],
        "body": "{\n}",
        "doc_comment": "Proof that the if the product of two nonzero integers `x` and `y`\nis nonnegative, then it's greater than or equal to each of `x` and\n`y`",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals_nonlinear.rs",
        "line_number": 58,
        "module": "vstd::arithmetic::internals::mul_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "lemma_mul_strict_inequality": {
        "name": "vstd::arithmetic::internals::mul_internals_nonlinear::lemma_mul_strict_inequality",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_strict_inequality(x: int, y: int, z: int)\n    requires\n        x < y,\n        z > 0,\n    ensures\n        x * z < y * z,",
        "ensures": [
          "x * z < y * z"
        ],
        "requires": [
          "x < y",
          "z > 0"
        ],
        "body": "{\n}",
        "doc_comment": "Proof that multiplying by a positive integer preserves inequality\nin this specific case, i.e., that since `x < y` and `z > 0` we can\nconclude that `x * z < y * z`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals_nonlinear.rs",
        "line_number": 72,
        "module": "vstd::arithmetic::internals::mul_internals_nonlinear",
        "keywords": [],
        "callees": []
      },
      "lemma_log0": {
        "name": "lemma_log0",
        "type": "proof",
        "signature": "pub proof fn lemma_log0(base: int, pow: int)\n    requires\n        base > 1,\n        0 <= pow < base,\n    ensures\n        log(base, pow) == 0,",
        "ensures": [
          "log(base, pow) == 0"
        ],
        "requires": [
          "base > 1",
          "0 <= pow < base"
        ],
        "body": "{\n    reveal(log);\n}",
        "doc_comment": "Proof that since `pow` is less than `base`, its logarithm in that base is 0.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/logarithm.rs",
        "line_number": 53,
        "module": "vstd::arithmetic::logarithm",
        "keywords": [],
        "callees": []
      },
      "lemma_log_s": {
        "name": "lemma_log_s",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_log_s(base: int, pow: int)\n    requires\n        base > 1,\n        pow >= base,\n    ensures\n        #![trigger log(base, div1(pow, base))]\n        pow / base >= 0,\n        log(base, pow) == 1 + log(base, pow / base),",
        "ensures": [
          "#![trigger log(base, div1(pow, base))]\n        pow / base >= 0",
          "log(base, pow) == 1 + log(base, pow / base)"
        ],
        "requires": [
          "base > 1",
          "pow >= base"
        ],
        "body": "{\n    broadcast use {lemma_div_pos_is_pos, lemma_div_decreases};\n\n    reveal(log);\n}",
        "doc_comment": "Proof that since `pow` is greater than or equal to `base`, its\nlogarithm in that base is 1 more than the logarithm of `pow /\nbase`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/logarithm.rs",
        "line_number": 64,
        "module": "vstd::arithmetic::logarithm",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_log_nonnegative": {
        "name": "lemma_log_nonnegative",
        "type": "proof",
        "signature": "pub proof fn lemma_log_nonnegative(base: int, pow: int)\n    requires\n        base > 1,\n        0 <= pow,\n    ensures\n        log(base, pow) >= 0,\n    decreases pow,",
        "ensures": [
          "log(base, pow) >= 0"
        ],
        "requires": [
          "base > 1",
          "0 <= pow"
        ],
        "body": "{\n    reveal(log);\n    if !(pow < base || pow / base >= pow || pow / base < 0) {\n        lemma_log_nonnegative(base, pow / base);\n    }\n}",
        "doc_comment": "Proof that the integer logarithm is always nonnegative. Specifically,\n`log(base, pow) >= 0`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/logarithm.rs",
        "line_number": 81,
        "module": "vstd::arithmetic::logarithm",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "lemma_log_nonnegative"
        ]
      },
      "lemma_log_is_ordered": {
        "name": "lemma_log_is_ordered",
        "type": "proof",
        "signature": "pub proof fn lemma_log_is_ordered(base: int, pow1: int, pow2: int)\n    requires\n        base > 1,\n        0 <= pow1 <= pow2,\n    ensures\n        log(base, pow1) <= log(base, pow2),\n    decreases pow1,",
        "ensures": [
          "log(base, pow1) <= log(base, pow2)"
        ],
        "requires": [
          "base > 1",
          "0 <= pow1 <= pow2"
        ],
        "body": "{\n    reveal(log);\n    if pow2 < base {\n        assert(log(base, pow1) == 0 == log(base, pow2));\n    } else if pow1 < base {\n        assert(log(base, pow1) == 0);\n        lemma_log_nonnegative(base, pow2);\n    } else {\n        broadcast use {lemma_div_pos_is_pos, lemma_div_is_ordered, lemma_div_decreases};\n\n        lemma_log_is_ordered(base, pow1 / base, pow2 / base);\n    }\n}",
        "doc_comment": "Proof that since `pow1` is less than or equal to `pow2`, the\ninteger logarithm of `pow1` in base `base` is less than or equal\nto that of `pow2`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/logarithm.rs",
        "line_number": 97,
        "module": "vstd::arithmetic::logarithm",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "log",
          "lemma_log_nonnegative",
          "lemma_log_is_ordered"
        ]
      },
      "lemma_log_pow": {
        "name": "lemma_log_pow",
        "type": "proof",
        "signature": "pub proof fn lemma_log_pow(base: int, n: nat)\n    requires\n        base > 1,\n    ensures\n        log(base, pow(base, n)) == n,\n    decreases n,",
        "ensures": [
          "log(base, pow(base, n)) == n"
        ],
        "requires": [
          "base > 1"
        ],
        "body": "{\n    if n == 0 {\n        reveal(pow);\n        reveal(log);\n    } else {\n        let n_minus_1: nat = (n - 1) as nat;\n        lemma_pow_positive(base, n);\n        calc! {\n            (==)\n            log(base, pow(base, n)); (==) {\n                reveal(pow);\n            }\n            log(base, base * pow(base, n_minus_1)); (==) {\n                lemma_pow_positive(base, n_minus_1);\n                lemma_mul_increases(pow(base, n_minus_1), base);\n                lemma_mul_is_commutative(pow(base, n_minus_1), base);\n                lemma_log_s(base, base * pow(base, n_minus_1));\n            }\n            1 + log(base, (base * pow(base, n_minus_1)) / base); (==) {\n                lemma_div_multiples_vanish(pow(base, n_minus_1), base);\n            }\n            1 + log(base, pow(base, n_minus_1)); (==) {\n                lemma_log_pow(base, n_minus_1);\n            }\n            1 + (n - 1);\n        }\n    }\n}",
        "doc_comment": "Proof that the integer logarithm of `pow(base, n)` in base `base` is `n`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/logarithm.rs",
        "line_number": 121,
        "module": "vstd::arithmetic::logarithm",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "lemma_log_s",
          "lemma_mul_is_commutative",
          "log",
          "lemma_mul_increases",
          "pow",
          "lemma_div_multiples_vanish",
          "lemma_pow_positive",
          "lemma_log_pow"
        ]
      },
      "lemma_mul_is_mul_recursive": {
        "name": "lemma_mul_is_mul_recursive",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_is_mul_recursive(x: int, y: int)\n    ensures\n        #[trigger] (x * y) == mul_recursive(x, y),",
        "ensures": [
          "#[trigger] (x * y) == mul_recursive(x, y)"
        ],
        "requires": [],
        "body": "{\n    if (x >= 0) {\n        lemma_mul_is_mul_pos(x, y);\n        assert(x * y == mul_pos(x, y));\n        assert((x * y) == mul_recursive(x, y));\n    } else {\n        lemma_mul_is_mul_pos(-x, y);\n        assert(x * y == -1 * (-x * y)) by { lemma_mul_is_associative(-1, -x, y) };  // OBSERVE\n        assert((x * y) == mul_recursive(x, y));\n    }\n}",
        "doc_comment": "Proof that multiplication using `*` is equivalent to\nmultiplication using a recursive definition. Specifically,\n`x * y` is equivalent in that way.",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 20,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_is_associative",
          "mul_recursive",
          "lemma_mul_is_mul_pos",
          "mul_pos"
        ]
      },
      "lemma_mul_is_mul_pos": {
        "name": "lemma_mul_is_mul_pos",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_is_mul_pos(x: int, y: int)\n    requires\n        x >= 0,\n    ensures\n        x * y == mul_pos(x, y),",
        "ensures": [
          "x * y == mul_pos(x, y)"
        ],
        "requires": [
          "x >= 0"
        ],
        "body": "{\n    reveal(mul_pos);\n    lemma_mul_induction_auto(x, |u: int| u >= 0 ==> u * y == mul_pos(u, y));\n}",
        "doc_comment": "Proof that multiplying two positive integers with `*` results in\nthe same product as would be achieved by recursive addition.\nSpecifically, `x * y == mul_pos(x, y)`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 38,
        "module": "vstd::arithmetic::mul",
        "keywords": [],
        "callees": [
          "lemma_mul_induction_auto",
          "mul_pos"
        ]
      },
      "lemma_mul_basics": {
        "name": "lemma_mul_basics",
        "type": "proof",
        "signature": "pub proof fn lemma_mul_basics(x: int)\n    ensures\n        0 * x == 0,\n        x * 0 == 0,\n        x * 1 == x,\n        1 * x == x,",
        "ensures": [
          "0 * x == 0",
          "x * 0 == 0",
          "x * 1 == x",
          "1 * x == x"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 51,
        "module": "vstd::arithmetic::mul",
        "keywords": [],
        "callees": []
      },
      "lemma_mul_basics_1": {
        "name": "lemma_mul_basics_1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_basics_1(x: int)\n    ensures\n        #[trigger] (0 * x) == 0,",
        "ensures": [
          "#[trigger] (0 * x) == 0"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
        "triggers": [
          "(0 * x"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 60,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mul_basics_2": {
        "name": "lemma_mul_basics_2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_basics_2(x: int)\n    ensures\n        #[trigger] (x * 0) == 0,",
        "ensures": [
          "#[trigger] (x * 0) == 0"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
        "triggers": [
          "(x * 0"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 68,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mul_basics_3": {
        "name": "lemma_mul_basics_3",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_basics_3(x: int)\n    ensures\n        #[trigger] (x * 1) == x,",
        "ensures": [
          "#[trigger] (x * 1) == x"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
        "triggers": [
          "(x * 1"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 76,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mul_basics_4": {
        "name": "lemma_mul_basics_4",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_basics_4(x: int)\n    ensures\n        #[trigger] (1 * x) == x,",
        "ensures": [
          "#[trigger] (1 * x) == x"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof of basic properties of multiplication by `x`, specifically\nwhat happens when multiplying by 0 or 1.",
        "triggers": [
          "(1 * x"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 84,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "vstd::arithmetic::mul::lemma_mul_nonzero": {
        "name": "vstd::arithmetic::mul::lemma_mul_nonzero",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_nonzero(x: int, y: int)\n    ensures\n        #[trigger] (x * y) != 0 <==> x != 0 && y != 0,",
        "ensures": [
          "#[trigger] (x * y) != 0 <==> x != 0 && y != 0"
        ],
        "requires": [],
        "body": "{\n    MulINL::lemma_mul_nonzero(x, y);\n}",
        "doc_comment": "Proof that `x * y` is nonzero if and only if both `x` and `y` are nonzero.",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 99,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_nonzero"
        ]
      },
      "lemma_mul_by_zero_is_zero": {
        "name": "lemma_mul_by_zero_is_zero",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_by_zero_is_zero(x: int)\n    ensures\n        #![trigger x * 0]\n        #![trigger 0 * x]\n        x * 0 == 0 && 0 * x == 0,",
        "ensures": [
          "#![trigger x * 0]\n        #![trigger 0 * x]\n        x * 0 == 0 && 0 * x == 0"
        ],
        "requires": [],
        "body": "{\n    assert forall|x: int| #![trigger x * 0] #![trigger 0 * x] x * 0 == 0 && 0 * x == 0 by {\n        lemma_mul_basics(x);\n    }\n}",
        "doc_comment": "Proof that any integer multiplied by 0 results in a product of 0.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 107,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_basics"
        ]
      },
      "vstd::arithmetic::mul::lemma_mul_is_associative": {
        "name": "vstd::arithmetic::mul::lemma_mul_is_associative",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_is_associative(x: int, y: int, z: int)\n    ensures\n        #![trigger x * (y * z)]\n        #![trigger (x * y) * z]\n        x * (y * z) == (x * y) * z,",
        "ensures": [
          "#![trigger x * (y * z)]\n        #![trigger (x * y) * z]\n        x * (y * z) == (x * y) * z"
        ],
        "requires": [],
        "body": "{\n    MulINL::lemma_mul_is_associative(x, y, z);\n}",
        "doc_comment": "Proof that multiplication is associative, specifically that\n`x * (y * z) == (x * y) * z`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 119,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_is_associative"
        ]
      },
      "lemma_mul_is_commutative": {
        "name": "lemma_mul_is_commutative",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_is_commutative(x: int, y: int)\n    ensures\n        #[trigger] (x * y) == y * x,",
        "ensures": [
          "#[trigger] (x * y) == y * x"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Proof that multiplication is commutative, specifically that\n`x * y == y * x`.",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 130,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "vstd::arithmetic::mul::lemma_mul_ordering": {
        "name": "vstd::arithmetic::mul::lemma_mul_ordering",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_ordering(x: int, y: int)\n    requires\n        x != 0,\n        y != 0,\n        0 <= x * y,\n    ensures\n        #[trigger] (x * y) >= x && x * y >= y,",
        "ensures": [
          "#[trigger] (x * y) >= x && x * y >= y"
        ],
        "requires": [
          "x != 0",
          "y != 0",
          "0 <= x * y"
        ],
        "body": "{\n    MulINL::lemma_mul_ordering(x, y);\n}",
        "doc_comment": "Proof that, since the product of the two integers `x` and `y` is\nnonnegative, that product is greater than or equal to each of `x`\nand `y`",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 138,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_ordering"
        ]
      },
      "lemma_mul_inequality": {
        "name": "lemma_mul_inequality",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_inequality(x: int, y: int, z: int)\n    requires\n        x <= y,\n        z >= 0,\n    ensures\n        #[trigger] (x * z) <= #[trigger] (y * z),",
        "ensures": [
          "#[trigger] (x * z) <= #[trigger] (y * z)"
        ],
        "requires": [
          "x <= y",
          "z >= 0"
        ],
        "body": "{\n    lemma_mul_induction_auto(z, |u: int| u >= 0 ==> x * u <= y * u);\n}",
        "doc_comment": "Proof that, since `x <= y` and `z >= 0`, `x * z <= y * z`.",
        "triggers": [
          "(x * z",
          "(y * z"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 161,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "vstd::arithmetic::mul::lemma_mul_strict_inequality": {
        "name": "vstd::arithmetic::mul::lemma_mul_strict_inequality",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_strict_inequality(x: int, y: int, z: int)\n    requires\n        x < y,\n        z > 0,\n    ensures\n        #[trigger] (x * z) < #[trigger] (y * z),",
        "ensures": [
          "#[trigger] (x * z) < #[trigger] (y * z)"
        ],
        "requires": [
          "x < y",
          "z > 0"
        ],
        "body": "{\n    MulINL::lemma_mul_strict_inequality(x, y, z);\n}",
        "doc_comment": "Proof that since `x < y` and `z > 0`, `x * z < y * z`.",
        "triggers": [
          "(x * z",
          "(y * z"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 172,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_strict_inequality"
        ]
      },
      "lemma_mul_upper_bound": {
        "name": "lemma_mul_upper_bound",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_upper_bound(x: int, xbound: int, y: int, ybound: int)\n    requires\n        x <= xbound,\n        y <= ybound,\n        0 <= x,\n        0 <= y,\n    ensures\n        #[trigger] (x * y) <= #[trigger] (xbound * ybound),",
        "ensures": [
          "#[trigger] (x * y) <= #[trigger] (xbound * ybound)"
        ],
        "requires": [
          "x <= xbound",
          "y <= ybound",
          "0 <= x",
          "0 <= y"
        ],
        "body": "{\n    lemma_mul_inequality(x, xbound, y);\n    lemma_mul_inequality(y, ybound, xbound);\n}",
        "doc_comment": "Proof that since `x` is bounded above by `xbound` and `y` is\nbounded above by `ybound`, the product of `x` and `y` is bounded\nabove by the product of the bounds.",
        "triggers": [
          "(x * y",
          "(xbound * ybound"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 183,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_inequality"
        ]
      },
      "lemma_mul_strict_upper_bound": {
        "name": "lemma_mul_strict_upper_bound",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_strict_upper_bound(x: int, xbound: int, y: int, ybound: int)\n    requires\n        x < xbound,\n        y < ybound,\n        0 < x,\n        0 < y,\n    ensures\n        #[trigger] (x * y) <= #[trigger] ((xbound - 1) * (ybound - 1)),",
        "ensures": [
          "#[trigger] (x * y) <= #[trigger] ((xbound - 1) * (ybound - 1))"
        ],
        "requires": [
          "x < xbound",
          "y < ybound",
          "0 < x",
          "0 < y"
        ],
        "body": "{\n    lemma_mul_inequality(x, xbound - 1, y);\n    lemma_mul_inequality(y, ybound - 1, xbound - 1);\n}",
        "doc_comment": "Proof that when `x` has an exclusive upper bound `xbound` and `y`\nhas an exclusive upper bound `ybound`, that the product of `x` and\n`y` is bounded above by the product of the predecessors of their\nupper bounds. In other words, `x * y <= (xbound - 1) * (ybound - 1)`.",
        "triggers": [
          "(x * y",
          "((xbound - 1"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 199,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_inequality"
        ]
      },
      "lemma_mul_left_inequality": {
        "name": "lemma_mul_left_inequality",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_left_inequality(x: int, y: int, z: int)\n    requires\n        0 < x,\n    ensures\n        y <= z ==> #[trigger] (x * y) <= #[trigger] (x * z),\n        y < z ==> x * y < x * z,",
        "ensures": [
          "y <= z ==> #[trigger] (x * y) <= #[trigger] (x * z)",
          "y < z ==> x * y < x * z"
        ],
        "requires": [
          "0 < x"
        ],
        "body": "{\n    lemma_mul_induction_auto(x, |u: int| u > 0 ==> y <= z ==> u * y <= u * z);\n    lemma_mul_induction_auto(x, |u: int| u > 0 ==> y < z ==> u * y < u * z);\n}",
        "doc_comment": "Proof that multiplying the positive integer `x` by respectively\n`y` and `z` maintains the order of `y` and `z`. Specifically, `y\n<= z ==> x * y <= x * z` and `y < z ==> x * y < x * z`.",
        "triggers": [
          "(x * y",
          "(x * z"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 216,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_equality_converse": {
        "name": "lemma_mul_equality_converse",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_equality_converse(m: int, x: int, y: int)\n    requires\n        m != 0,\n        #[trigger] (m * x) == #[trigger] (m * y),\n    ensures\n        x == y,",
        "ensures": [
          "x == y"
        ],
        "requires": [
          "m != 0",
          "#[trigger] (m * x) == #[trigger] (m * y)"
        ],
        "body": "{\n    lemma_mul_induction_auto(m, |u| x > y && 0 < u ==> x * u > y * u);\n    lemma_mul_induction_auto(m, |u: int| x < y && 0 < u ==> x * u < y * u);\n    lemma_mul_induction_auto(m, |u: int| x > y && 0 > u ==> x * u < y * u);\n    lemma_mul_induction_auto(m, |u: int| x < y && 0 > u ==> x * u > y * u);\n}",
        "doc_comment": "Proof that if `x` and `y` have equal results when multiplied by\nnonzero `m`, then they're equal.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 230,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_inequality_converse": {
        "name": "lemma_mul_inequality_converse",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_inequality_converse(x: int, y: int, z: int)\n    requires\n        #[trigger] (x * z) <= #[trigger] (y * z),\n        z > 0,\n    ensures\n        x <= y,",
        "ensures": [
          "x <= y"
        ],
        "requires": [
          "#[trigger] (x * z) <= #[trigger] (y * z)",
          "z > 0"
        ],
        "body": "{\n    lemma_mul_induction_auto(z, |u: int| x * u <= y * u && u > 0 ==> x <= y);\n}",
        "doc_comment": "Proof that since `x * z <= y * z` and `z > 0`, that `x <= y`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 245,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_strict_inequality_converse": {
        "name": "lemma_mul_strict_inequality_converse",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_strict_inequality_converse(x: int, y: int, z: int)\n    requires\n        #[trigger] (x * z) < #[trigger] (y * z),\n        z >= 0,\n    ensures\n        x < y,",
        "ensures": [
          "x < y"
        ],
        "requires": [
          "#[trigger] (x * z) < #[trigger] (y * z)",
          "z >= 0"
        ],
        "body": "{\n    lemma_mul_induction_auto(z, |u: int| x * u < y * u && u >= 0 ==> x < y);\n}",
        "doc_comment": "Proof that since `x * z < y * z` and `z >= 0`, we know `x < y`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 256,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "vstd::arithmetic::mul::lemma_mul_is_distributive_add": {
        "name": "vstd::arithmetic::mul::lemma_mul_is_distributive_add",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_is_distributive_add(x: int, y: int, z: int)\n    ensures\n        #[trigger] (x * (y + z)) == x * y + x * z,",
        "ensures": [
          "#[trigger] (x * (y + z)) == x * y + x * z"
        ],
        "requires": [],
        "body": "{\n    MulINL::lemma_mul_is_distributive_add(x, y, z);\n}",
        "doc_comment": "Proof that multiplication distributes over addition, specifically that\n`x * (y + z) == x * y + x * z`.",
        "triggers": [
          "(x * (y + z"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 267,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_is_distributive_add"
        ]
      },
      "lemma_mul_is_distributive_add_other_way": {
        "name": "lemma_mul_is_distributive_add_other_way",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_is_distributive_add_other_way(x: int, y: int, z: int)\n    ensures\n        #[trigger] ((y + z) * x) == y * x + z * x,",
        "ensures": [
          "#[trigger] ((y + z) * x) == y * x + z * x"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_mul_properties_internal;\n\n}",
        "doc_comment": "Proof that multiplication distributes over addition, specifically that\n`(y + z) * x == y * x + z * x`.",
        "triggers": [
          "((y + z"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 276,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mul_is_distributive_sub": {
        "name": "lemma_mul_is_distributive_sub",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_is_distributive_sub(x: int, y: int, z: int)\n    ensures\n        #[trigger] (x * (y - z)) == x * y - x * z,",
        "ensures": [
          "#[trigger] (x * (y - z)) == x * y - x * z"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_mul_properties_internal;\n\n}",
        "doc_comment": "Proof that multiplication distributes over subtraction, specifically that\n`x * (y - z) == x * y - x * z`.",
        "triggers": [
          "(x * (y - z"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 286,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_mul_is_distributive_sub_other_way": {
        "name": "lemma_mul_is_distributive_sub_other_way",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_is_distributive_sub_other_way(x: int, y: int, z: int)\n    ensures\n        #[trigger] ((y - z) * x) == y * x - z * x,",
        "ensures": [
          "#[trigger] ((y - z) * x) == y * x - z * x"
        ],
        "requires": [],
        "body": "{\n    lemma_mul_is_distributive_sub(x, y, z);\n    lemma_mul_is_commutative(x, y - z);\n    lemma_mul_is_commutative(x, y);\n    lemma_mul_is_commutative(x, z);\n}",
        "doc_comment": "Proof that multiplication distributes over subtraction when the\nsubtraction happens in the multiplicand (i.e., in the left-hand\nargument to `*`). Specifically, `(y - z) * x == y * x - z * x`.",
        "triggers": [
          "((y - z"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 296,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_is_commutative",
          "lemma_mul_is_distributive_sub"
        ]
      },
      "vstd::arithmetic::mul::lemma_mul_strictly_positive": {
        "name": "vstd::arithmetic::mul::lemma_mul_strictly_positive",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_strictly_positive(x: int, y: int)\n    ensures\n        (0 < x && 0 < y) ==> (0 < #[trigger] (x * y)),",
        "ensures": [
          "(0 < x && 0 < y) ==> (0 < #[trigger] (x * y))"
        ],
        "requires": [],
        "body": "{\n    MulINL::lemma_mul_strictly_positive(x, y);\n}",
        "doc_comment": "Proof that if `x` and `y` are both positive, then their product is\nalso positive.",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 355,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_strictly_positive"
        ]
      },
      "lemma_mul_strictly_increases": {
        "name": "lemma_mul_strictly_increases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_strictly_increases(x: int, y: int)\n    requires\n        1 < x,\n        0 < y,\n    ensures\n        y < #[trigger] (x * y),",
        "ensures": [
          "y < #[trigger] (x * y)"
        ],
        "requires": [
          "1 < x",
          "0 < y"
        ],
        "body": "{\n    lemma_mul_induction_auto(x, |u: int| 1 < u ==> y < u * y);\n}",
        "doc_comment": "Proof that since `x > 1` and `y > 0`, `y < x * y`.",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 363,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_increases": {
        "name": "lemma_mul_increases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_increases(x: int, y: int)\n    requires\n        0 < x,\n        0 < y,\n    ensures\n        y <= #[trigger] (x * y),",
        "ensures": [
          "y <= #[trigger] (x * y)"
        ],
        "requires": [
          "0 < x",
          "0 < y"
        ],
        "body": "{\n    lemma_mul_induction_auto(x, |u: int| 0 < u ==> y <= u * y);\n}",
        "doc_comment": "Proof that since `x` and `y` are both positive, their product is\ngreater than or equal to `y`.",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 374,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_nonnegative": {
        "name": "lemma_mul_nonnegative",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_nonnegative(x: int, y: int)\n    requires\n        0 <= x,\n        0 <= y,\n    ensures\n        0 <= #[trigger] (x * y),",
        "ensures": [
          "0 <= #[trigger] (x * y)"
        ],
        "requires": [
          "0 <= x",
          "0 <= y"
        ],
        "body": "{\n    lemma_mul_induction_auto(x, |u: int| 0 <= u ==> 0 <= u * y);\n}",
        "doc_comment": "Proof that since `x` and `y` are non-negative, their product is\nnon-negative.",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 386,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_unary_negation": {
        "name": "lemma_mul_unary_negation",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_unary_negation(x: int, y: int)\n    ensures\n        #![trigger (-x) * y]\n        #![trigger x * (-y)]\n        (-x) * y == -(x * y) == x * (-y),",
        "ensures": [
          "#![trigger (-x) * y]\n        #![trigger x * (-y)]\n        (-x) * y == -(x * y) == x * (-y)"
        ],
        "requires": [],
        "body": "{\n    lemma_mul_induction_auto(x, |u: int| (-u) * y == -(u * y) == u * (-y));\n}",
        "doc_comment": "Proof that negating `x` or `y` before multiplying them together\nproduces the negation of the product of `x` and `y`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 398,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "lemma_mul_cancels_negatives": {
        "name": "lemma_mul_cancels_negatives",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_mul_cancels_negatives(x: int, y: int)\n    ensures\n        #[trigger] (x * y) == (-x) * (-y),",
        "ensures": [
          "#[trigger] (x * y) == (-x) * (-y)"
        ],
        "requires": [],
        "body": "{\n    lemma_mul_induction_auto(x, |u: int| (-u) * y == -(u * y) == u * (-y));\n}",
        "doc_comment": "Proof that multiplying `-x` and `-y` produces the same product as\nmultiplying `x` and `y`.",
        "triggers": [
          "(x * y"
        ],
        "file_path": "verus/source/vstd/arithmetic/mul.rs",
        "line_number": 409,
        "module": "vstd::arithmetic::mul",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto"
        ]
      },
      "spec_new": {
        "name": "spec_new",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_new(v: $uty) -> $cty",
        "ensures": [],
        "requires": [],
        "body": "{\n                    $cty{ i: Ghost(v as nat), v: Some(v) }\n                }",
        "doc_comment": "Creates a new `$cty` instance from a `$uty` value.\nEnsures the internal representation matches the provided value.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 107,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "host",
          "ome"
        ]
      },
      "new": {
        "name": "vstd::arithmetic::overflow::new",
        "type": "exec",
        "signature": "pub exec fn new(v: $uty) -> (result: Self)\n                    ensures\n                        result@ == v,",
        "ensures": [
          "result@ == v"
        ],
        "requires": [],
        "body": "{\n                    Self{ i: Ghost(v as nat), v: Some(v) }\n                }",
        "doc_comment": "Creates a new `$cty` instance from a `$uty` value.\nEnsures the internal representation matches the provided value.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 114,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "host",
          "ome"
        ]
      },
      "new_overflowed": {
        "name": "new_overflowed",
        "type": "exec",
        "signature": "pub exec fn new_overflowed(Ghost(i): Ghost<int>) -> (result: Self)\n                    requires\n                        i > $uty::MAX,\n                    ensures\n                        result@ == i,",
        "ensures": [
          "result@ == i"
        ],
        "requires": [
          "i > $uty::MAX"
        ],
        "body": "{\n                    Self{ i: Ghost(i as nat), v: None }\n                }",
        "doc_comment": "Creates a new `$cty` instance with an overflowed value.\nRequires the provided value to be greater than `$uty::MAX`.\nEnsures the internal representation matches the provided value.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 124,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "host"
        ]
      },
      "is_overflowed": {
        "name": "is_overflowed",
        "type": "exec",
        "signature": "pub exec fn is_overflowed(&self) -> (result: bool)\n                    ensures\n                        result == self.spec_is_overflowed()",
        "ensures": [
          "result == self.spec_is_overflowed()"
        ],
        "requires": [],
        "body": "{\n                    proof { use_type_invariant(self) }\n                    self.v.is_none()\n                }",
        "doc_comment": "Checks if the `$cty` instance is overflowed.\nReturns true if the value is greater than `$uty::MAX`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 143,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "use_type_invariant"
        ]
      },
      "unwrap": {
        "name": "unwrap",
        "type": "exec",
        "signature": "pub exec fn unwrap(&self) -> (result: $uty)\n                    requires\n                        !self.is_overflowed(),\n                    ensures\n                        result == self@,",
        "ensures": [
          "result == self@"
        ],
        "requires": [
          "!self.is_overflowed()"
        ],
        "body": "{\n                    proof { use_type_invariant(self) }\n                    self.v.unwrap()\n                }",
        "doc_comment": "Unwraps the `$cty` instance to get the `$uty` value.\nRequires the instance to not be overflowed.\nEnsures the returned value matches the internal representation.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 154,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "use_type_invariant"
        ]
      },
      "to_option": {
        "name": "to_option",
        "type": "exec",
        "signature": "pub exec fn to_option(&self) -> (result: Option<$uty>)\n                    ensures\n                        match result",
        "ensures": [
          "match result"
        ],
        "requires": [],
        "body": "{\n                            Some(v) => self@ == v && v <= $uty::MAX,\n                            None => self@ > $uty::MAX,\n                        }",
        "doc_comment": "Converts the `$cty` instance to an `Option<$uty>`.\nEnsures the returned option matches the internal representation.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 167,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "ome"
        ]
      },
      "add_value": {
        "name": "add_value",
        "type": "exec",
        "signature": "pub exec fn add_value(&self, v2: $uty) -> (result: Self)\n                    ensures\n                        result@ == self@ + v2,",
        "ensures": [
          "result@ == self@ + v2"
        ],
        "requires": [],
        "body": "{\n                    proof {\n                        use_type_invariant(&self);\n                    }\n                    let i: Ghost<nat> = Ghost((&self@ + v2) as nat);\n                    match self.v {\n                        Some(v1) => Self{ i, v: v1.checked_add(v2) },\n                        None => Self{ i, v: None },\n                    }\n                }",
        "doc_comment": "Adds a `$uty` value to the `$cty` instance.\nEnsures the resulting value matches the sum of\nthe internal representation and the provided\nvalue.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 180,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "host",
          "ome",
          "checked_add",
          "use_type_invariant"
        ]
      },
      "add_checked": {
        "name": "add_checked",
        "type": "exec",
        "signature": "pub exec fn add_checked(&self, v2: &$cty) -> (result: Self)\n                    ensures\n                        result@ == self@ + v2@,",
        "ensures": [
          "result@ == self@ + v2@"
        ],
        "requires": [],
        "body": "{\n                    proof {\n                        use_type_invariant(self);\n                        use_type_invariant(v2);\n                    }\n                    match v2.v {\n                        Some(n) => self.add_value(n),\n                        None => {\n                            let i: Ghost<nat> = Ghost((self@ + v2@) as nat);\n                            Self{ i, v: None }\n                        }\n                    }\n                }",
        "doc_comment": "Adds another `$cty` instance to the current\ninstance. Ensures the resulting value matches\nthe sum of the internal representations of\nboth instances.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 199,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "host",
          "add_value",
          "ome",
          "use_type_invariant"
        ]
      },
      "mul_value": {
        "name": "mul_value",
        "type": "exec",
        "signature": "pub exec fn mul_value(&self, v2: $uty) -> (result: Self)\n                    ensures\n                        result@ == self@ as int * v2 as int,",
        "ensures": [
          "result@ == self@ as int * v2 as int"
        ],
        "requires": [],
        "body": "{\n                    proof {\n                        use_type_invariant(self);\n                    }\n                    let i: Ghost<nat> = Ghost((self@ * v2) as nat);\n                    match self.v {\n                        Some(n1) => Self{ i, v: n1.checked_mul(v2) },\n                        None => {\n                            if v2 == 0 {\n                                assert(i@ == 0) by {\n                                    lemma_mul_by_zero_is_zero(self@ as int);\n                                }\n                                Self{ i, v: Some(0) }\n                            }\n                            else {\n                                assert(self@ * v2 >= self@ * 1 == self@) by {\n                                    lemma_mul_inequality(1, v2 as int, self@ as int);\n                                    lemma_mul_is_commutative(self@ as int, v2 as int);\n                                }\n                                Self{ i, v: None }\n                            }\n                        },\n                    }\n                }",
        "doc_comment": "Multiplies the `$cty` instance by a `$uty`\nvalue. Ensures the resulting value matches the\nproduct of the internal representation and the\nprovided value.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 221,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "use_type_invariant",
          "lemma_mul_is_commutative",
          "lemma_mul_by_zero_is_zero",
          "ome",
          "lemma_mul_inequality",
          "host",
          "checked_mul"
        ]
      },
      "mul_checked": {
        "name": "mul_checked",
        "type": "exec",
        "signature": "pub exec fn mul_checked(&self, v2: &Self) -> (result: Self)\n                    ensures\n                        result@ == self@ as int * v2@ as int,",
        "ensures": [
          "result@ == self@ as int * v2@ as int"
        ],
        "requires": [],
        "body": "{\n                    proof {\n                        use_type_invariant(self);\n                        use_type_invariant(v2);\n                    }\n                    let i: Ghost<nat> = Ghost((self@ * v2@) as nat);\n                    match v2.v {\n                        Some(n) => self.mul_value(n),\n                        None => {\n                            match self.v {\n                                Some(n1) => {\n                                    if n1 == 0 {\n                                        assert(i@ == 0) by {\n                                            lemma_mul_by_zero_is_zero(v2@ as int);\n                                        }\n                                        Self{ i, v: Some(0) }\n                                    }\n                                    else {\n                                        assert(self@ * v2@ >= 1 * v2@ == v2@) by {\n                                            lemma_mul_inequality(1, self@ as int, v2@ as int);\n                                        }\n                                        Self{ i, v: None }\n                                    }\n                                },\n                                None => {\n                                    assert(self@ * v2@ > $uty::MAX) by {\n                                        lemma_mul_inequality(1, self@ as int, v2@ as int);\n                                    }\n                                    Self{ i, v: None }\n                                },\n                            }\n                        }\n                    }\n                }",
        "doc_comment": "Multiplies the `$cty` instance by another `$cty` instance.\nEnsures the resulting value matches the product of the internal\nrepresentations of both instances.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 254,
        "module": "vstd::arithmetic::overflow",
        "keywords": [],
        "callees": [
          "use_type_invariant",
          "mul_value",
          "lemma_mul_by_zero_is_zero",
          "ome",
          "lemma_mul_inequality",
          "host"
        ]
      },
      "lemma_pow0": {
        "name": "lemma_pow0",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow0(b: int)\n    ensures\n        #[trigger] pow(b, 0) == 1,",
        "ensures": [
          "#[trigger] pow(b, 0) == 1"
        ],
        "requires": [],
        "body": "{\n    reveal(pow);\n}",
        "doc_comment": "Proof that the given integer `b` to the power of 0 is 1.",
        "triggers": [
          "pow(b"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 51,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_pow1": {
        "name": "lemma_pow1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow1(b: int)\n    ensures\n        #[trigger] pow(b, 1) == b,",
        "ensures": [
          "#[trigger] pow(b, 1) == b"
        ],
        "requires": [],
        "body": "{\n    calc! {\n        (==)\n        pow(b, 1); {\n            reveal(pow);\n        }\n        b * pow(b, 0); {\n            lemma_pow0(b);\n        }\n        b * 1; {\n            broadcast use group_mul_basics;\n\n        }\n        b;\n    }\n}",
        "doc_comment": "Proof that the given integer `b` to the power of 1 is `b`.",
        "triggers": [
          "pow(b"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 59,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "pow",
          "lemma_pow0"
        ]
      },
      "lemma0_pow": {
        "name": "lemma0_pow",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma0_pow(e: nat)\n    requires\n        e > 0,\n    ensures\n        #[trigger] pow(0, e) == 0,\n    decreases e,",
        "ensures": [
          "#[trigger] pow(0, e) == 0"
        ],
        "requires": [
          "e > 0"
        ],
        "body": "{\n    reveal(pow);\n    broadcast use group_mul_basics;\n\n    if e != 1 {\n        lemma0_pow((e - 1) as nat);\n    }\n}",
        "doc_comment": "Proof that 0 to the power of the given positive integer `e` is 0.",
        "triggers": [
          "pow(0"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 80,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "lemma0_pow"
        ]
      },
      "lemma1_pow": {
        "name": "lemma1_pow",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma1_pow(e: nat)\n    ensures\n        #[trigger] pow(1, e) == 1,\n    decreases e,",
        "ensures": [
          "#[trigger] pow(1, e) == 1"
        ],
        "requires": [],
        "body": "{\n    reveal(pow);\n    broadcast use group_mul_basics;\n\n    if e != 0 {\n        lemma1_pow((e - 1) as nat);\n    }\n}",
        "doc_comment": "Proof that 1 to the power of the given natural number `e` is 1.",
        "triggers": [
          "pow(1"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 96,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "lemma1_pow"
        ]
      },
      "lemma_square_is_pow2": {
        "name": "lemma_square_is_pow2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_square_is_pow2(x: int)\n    ensures\n        #[trigger] pow(x, 2) == x * x,",
        "ensures": [
          "#[trigger] pow(x, 2) == x * x"
        ],
        "requires": [],
        "body": "{\n    reveal_with_fuel(pow, 3);\n}",
        "doc_comment": "Proof that taking the given number `x` to the power of 2 produces `x * x`.",
        "triggers": [
          "pow(x"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 110,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "reveal_with_fuel"
        ]
      },
      "lemma_pow_positive": {
        "name": "lemma_pow_positive",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_positive(b: int, e: nat)\n    requires\n        b > 0,\n    ensures\n        0 < #[trigger] pow(b, e),",
        "ensures": [
          "0 < #[trigger] pow(b, e)"
        ],
        "requires": [
          "b > 0"
        ],
        "body": "{\n    // dafny does not need to reveal\n    reveal(pow);\n    broadcast use {lemma_mul_increases, lemma_pow0};\n\n    lemma_mul_induction_auto(e as int, |u: int| 0 <= u ==> 0 < pow(b, u as nat));\n}",
        "doc_comment": "Proof that taking the given positive integer `b` to the power of\nthe given natural number `n` produces a positive result.",
        "triggers": [
          "pow(b"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 118,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_induction_auto",
          "pow"
        ]
      },
      "lemma_pow_adds": {
        "name": "lemma_pow_adds",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_adds(b: int, e1: nat, e2: nat)\n    ensures\n        #[trigger] pow(b, e1 + e2) == pow(b, e1) * pow(b, e2),\n    decreases e1,",
        "ensures": [
          "#[trigger] pow(b, e1 + e2) == pow(b, e1) * pow(b, e2)"
        ],
        "requires": [],
        "body": "{\n    if e1 == 0 {\n        calc! {\n            (==)\n            pow(b, e1) * pow(b, e2); {\n                lemma_pow0(b);\n            }\n            1 * pow(b, e2); {\n                broadcast use group_mul_basics;\n\n            }\n            pow(b, 0 + e2);\n        }\n    } else {\n        calc! {\n            (==)\n            pow(b, e1) * pow(b, e2); {\n                reveal(pow);\n            }\n            (b * pow(b, (e1 - 1) as nat)) * pow(b, e2); {\n                broadcast use lemma_mul_is_associative;\n\n            }\n            b * (pow(b, (e1 - 1) as nat) * pow(b, e2)); {\n                lemma_pow_adds(b, (e1 - 1) as nat, e2);\n            }\n            b * pow(b, (e1 - 1 + e2) as nat); {\n                reveal(pow);\n            }\n            pow(b, e1 + e2);\n        }\n    }\n}",
        "doc_comment": "Proof that taking an integer `b` to the power of the sum of two\nnatural numbers `e1` and `e2` is equivalent to multiplying `b` to\nthe power of `e1` by `b` to the power of `e2`.",
        "triggers": [
          "pow(b"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 133,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "pow",
          "lemma_pow_adds",
          "lemma_pow0"
        ]
      },
      "lemma_pow_sub_add_cancel": {
        "name": "lemma_pow_sub_add_cancel",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_sub_add_cancel(b: int, e1: nat, e2: nat)\n    requires\n        e1 >= e2,\n    ensures\n        #[trigger] pow(b, (e1 - e2) as nat) * pow(b, e2) == pow(b, e1),\n    decreases e1,",
        "ensures": [
          "#[trigger] pow(b, (e1 - e2) as nat) * pow(b, e2) == pow(b, e1)"
        ],
        "requires": [
          "e1 >= e2"
        ],
        "body": "{\n    lemma_pow_adds(b, (e1 - e2) as nat, e2);\n}",
        "doc_comment": "Proof that if `e1 >= e2`, then `b` to the power of `e1` is equal\nto the product of `b` to the power of `e1 - e2` and `b` to the\npower of `e2`.",
        "triggers": [
          "pow(b"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 174,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "lemma_pow_adds"
        ]
      },
      "lemma_pow_subtracts": {
        "name": "lemma_pow_subtracts",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_subtracts(b: int, e1: nat, e2: nat)\n    requires\n        b > 0,\n        e1 <= e2,\n    ensures\n        pow(b, e1) > 0,\n        #[trigger] pow(b, (e2 - e1) as nat) == pow(b, e2) / pow(b, e1) > 0,",
        "ensures": [
          "pow(b, e1) > 0",
          "#[trigger] pow(b, (e2 - e1) as nat) == pow(b, e2) / pow(b, e1) > 0"
        ],
        "requires": [
          "b > 0",
          "e1 <= e2"
        ],
        "body": "{\n    broadcast use lemma_pow_positive;\n\n    calc! {\n        (==)\n        pow(b, e2) / pow(b, e1); {\n            lemma_pow_sub_add_cancel(b, e2, e1);\n        }\n        pow(b, (e2 - e1) as nat) * pow(b, e1) / pow(b, e1); {\n            lemma_div_by_multiple(pow(b, (e2 - e1) as nat), pow(b, e1));\n        }\n        pow(b, (e2 - e1) as nat);\n    }\n}",
        "doc_comment": "Proof that, as long as `e1 <= e2`, taking a positive integer `b`\nto the power of `e2 - e1` is equivalent to dividing `b` to the\npower of `e2` by `b` to the power of `e1`.",
        "triggers": [
          "pow(b"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 187,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "pow",
          "lemma_pow_sub_add_cancel",
          "lemma_div_by_multiple"
        ]
      },
      "lemma_pow_multiplies": {
        "name": "lemma_pow_multiplies",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_multiplies(a: int, b: nat, c: nat)\n    ensures\n        0 <= b * c,\n        #[trigger] pow(pow(a, b), c) == pow(a, b * c),\n    decreases c,",
        "ensures": [
          "0 <= b * c",
          "#[trigger] pow(pow(a, b), c) == pow(a, b * c)"
        ],
        "requires": [],
        "body": "{\n    lemma_mul_nonnegative(b as int, c as int);\n    if c == 0 {\n        broadcast use group_mul_basics;\n\n        calc! {\n            (==)\n            pow(a, (b * c) as nat); {\n                lemma_pow0(a);\n            }\n            1; {\n                lemma_pow0(pow(a, b));\n            }\n            pow(pow(a, b), c);\n        }\n    } else {\n        calc! {\n            (==)\n            b * c - b; {\n                broadcast use group_mul_basics;\n\n            }\n            b * c - b * 1; {\n                broadcast use group_mul_is_distributive;\n\n            }\n            b * (c - 1);\n        }\n        lemma_mul_nonnegative(b as int, c - 1);\n        assert(0 <= b * c - b);\n        calc! {\n            (==)\n            pow(a, b * c); {}\n            pow(a, (b + b * c - b) as nat); {\n                lemma_pow_adds(a, b, (b * c - b) as nat);\n            }\n            pow(a, b) * pow(a, (b * c - b) as nat); {}\n            pow(a, b) * pow(a, (b * (c - 1)) as nat); {\n                lemma_pow_multiplies(a, b, (c - 1) as nat);\n            }\n            pow(a, b) * pow(pow(a, b), (c - 1) as nat); {\n                reveal(pow);\n            }\n            pow(pow(a, b), c);\n        }\n    }\n}",
        "doc_comment": "Proof that `a` to the power of `b * c` is equal to the result of\ntaking `a` to the power of `b`, then taking that to the power of\n`c`.",
        "triggers": [
          "pow(pow(a"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 212,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "lemma_pow0",
          "lemma_pow_adds",
          "lemma_pow_multiplies",
          "pow",
          "lemma_mul_nonnegative"
        ]
      },
      "lemma_pow_distributes": {
        "name": "lemma_pow_distributes",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_distributes(a: int, b: int, e: nat)\n    ensures\n        #[trigger] pow(a * b, e) == pow(a, e) * pow(b, e),\n    decreases e,",
        "ensures": [
          "#[trigger] pow(a * b, e) == pow(a, e) * pow(b, e)"
        ],
        "requires": [],
        "body": "{\n    reveal(pow);\n    broadcast use group_mul_basics;\n\n    if e >= 1 {\n        calc! {\n            (==)\n            pow(a * b, e); {\n                reveal(pow);\n            }\n            (a * b) * pow(a * b, (e - 1) as nat); {\n                lemma_pow_distributes(a, b, (e - 1) as nat);\n            }\n            (a * b) * (pow(a, (e - 1) as nat) * pow(b, (e - 1) as nat)); {\n                broadcast use {lemma_mul_is_associative, lemma_mul_is_commutative};\n\n                assert((a * b * pow(a, (e - 1) as nat)) * pow(b, (e - 1) as nat) == (a * pow(\n                    a,\n                    (e - 1) as nat,\n                ) * b) * pow(b, (e - 1) as nat));\n            }\n            (a * pow(a, (e - 1) as nat)) * (b * pow(b, (e - 1) as nat)); {\n                reveal(pow);\n            }\n            pow(a, e) * pow(b, e);\n        }\n    }\n}",
        "doc_comment": "Proof that `a * b` to the power of `e` is equal to the product of\n`a` to the power of `e` and `b` to the power of `e`.",
        "triggers": [
          "pow(a * b"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 268,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "pow",
          "lemma_pow_distributes"
        ]
      },
      "lemma_pow_strictly_increases": {
        "name": "lemma_pow_strictly_increases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_strictly_increases(b: nat, e1: nat, e2: nat)\n    requires\n        1 < b,\n        e1 < e2,\n    ensures\n        #[trigger] pow(b as int, e1) < #[trigger] pow(b as int, e2),",
        "ensures": [
          "#[trigger] pow(b as int, e1) < #[trigger] pow(b as int, e2)"
        ],
        "requires": [
          "1 < b",
          "e1 < e2"
        ],
        "body": "{\n    let f = |e: int| 0 < e ==> pow(b as int, e1) < pow(b as int, (e1 + e) as nat);\n    assert forall|i: int| (#[trigger] is_le(0, i) && f(i)) implies f(i + 1) by {\n        calc! {\n            (<=)\n            pow(b as int, (e1 + i) as nat); (<=) {\n                lemma_pow_positive(b as int, (e1 + i) as nat);\n                lemma_mul_left_inequality(pow(b as int, (e1 + i) as nat), 1, b as int);\n            }\n            pow(b as int, (e1 + i) as nat) * b; (<=) {\n                lemma_pow1(b as int);\n            }\n            pow(b as int, (e1 + i) as nat) * pow(b as int, 1); (<=) {\n                lemma_pow_adds(b as int, (e1 + i) as nat, 1nat);\n            }\n            pow(b as int, (e1 + i + 1) as nat);\n        }\n        assert(0 < i ==> pow(b as int, e1) < pow(b as int, (e1 + i) as nat));\n        if (i == 0) {\n            assert(pow(b as int, e1) < pow(b as int, (e1 + 1) as nat)) by {\n                reveal(pow);\n                assert(pow(b as int, e1) < b * pow(b as int, e1)) by {\n                    // cannot be replaced to lemma_pow_auto()\n                    assert(pow(b as int, e1) > 0) by {\n                        broadcast use lemma_pow_positive;\n\n                    }\n                    lemma_mul_strictly_increases(b as int, pow(b as int, e1));\n                };\n            };\n        }\n        assert(f(i + 1));\n    }\n    lemma_mul_induction_auto(e2 - e1, f);\n}",
        "doc_comment": "Proof that a number greater than 1 raised to a power strictly\nincreases as the power strictly increases. Specifically, given\nthat `b > 1` and `e1 < e2`, we can conclude that `pow(b, e1) <\npow(b, e2)`.",
        "triggers": [
          "pow(b as int",
          "pow(b as int"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 333,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "f",
          "lemma_mul_induction_auto",
          "lemma_pow1",
          "lemma_pow_adds",
          "lemma_pow_auto",
          "lemma_mul_strictly_increases",
          "is_le",
          "pow",
          "lemma_pow_positive",
          "lemma_mul_left_inequality"
        ]
      },
      "lemma_pow_increases": {
        "name": "lemma_pow_increases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_increases(b: nat, e1: nat, e2: nat)\n    requires\n        b > 0,\n        e1 <= e2,\n    ensures\n        #[trigger] pow(b as int, e1) <= #[trigger] pow(b as int, e2),",
        "ensures": [
          "#[trigger] pow(b as int, e1) <= #[trigger] pow(b as int, e2)"
        ],
        "requires": [
          "b > 0",
          "e1 <= e2"
        ],
        "body": "{\n    if e1 != e2 {\n        if b > 1 {\n            lemma_pow_strictly_increases(b, e1, e2);\n        } else {\n            lemma1_pow(e1);\n            lemma1_pow(e2);\n        }\n    }\n}",
        "doc_comment": "Proof that a positive number raised to a power increases as the\npower increases. Specifically, since `e1 <= e2`, we know `pow(b,\ne1) <= pow(b, e2)`.",
        "triggers": [
          "pow(b as int",
          "pow(b as int"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 379,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma1_pow",
          "lemma_pow_strictly_increases"
        ]
      },
      "lemma_pow_strictly_increases_converse": {
        "name": "lemma_pow_strictly_increases_converse",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_strictly_increases_converse(b: nat, e1: nat, e2: nat)\n    requires\n        b > 0,\n        #[trigger] pow(b as int, e1) < #[trigger] pow(b as int, e2),\n    ensures\n        e1 < e2,",
        "ensures": [
          "e1 < e2"
        ],
        "requires": [
          "b > 0",
          "#[trigger] pow(b as int, e1) < #[trigger] pow(b as int, e2)"
        ],
        "body": "{\n    if e1 >= e2 {\n        lemma_pow_increases(b, e2, e1);\n        assert(false);\n    }\n}",
        "doc_comment": "Proof that if an exponentiation result strictly increases when the\nexponent changes, then the change is an increase. Specifically, if\nwe know `pow(b, e1) < pow(b, e2)`, then we can conclude `e1 < e2`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 399,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_pow_increases"
        ]
      },
      "lemma_pow_increases_converse": {
        "name": "lemma_pow_increases_converse",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_increases_converse(b: nat, e1: nat, e2: nat)\n    requires\n        1 < b,\n        #[trigger] pow(b as int, e1) <= #[trigger] pow(b as int, e2),\n    ensures\n        e1 <= e2,",
        "ensures": [
          "e1 <= e2"
        ],
        "requires": [
          "1 < b",
          "#[trigger] pow(b as int, e1) <= #[trigger] pow(b as int, e2)"
        ],
        "body": "{\n    if e1 > e2 {\n        lemma_pow_strictly_increases(b, e2, e1);\n        assert(false);\n    }\n}",
        "doc_comment": "Proof that if the exponentiation of a number greater than 1\ndoesn't decrease when the exponent changes, then the change isn't\na decrease. Specifically, given that `b > 1` and `pow(b, e1) <=\npow(b, e2)`, we can conclude that `e1 <= e2`.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 415,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_pow_strictly_increases"
        ]
      },
      "lemma_pull_out_pows": {
        "name": "lemma_pull_out_pows",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pull_out_pows(b: nat, x: nat, y: nat, z: nat)\n    requires\n        b > 0,\n    ensures\n        0 <= x * y,\n        0 <= y * z,\n        #[trigger] pow(pow(b as int, x * y), z) == pow(pow(b as int, x), y * z),",
        "ensures": [
          "0 <= x * y",
          "0 <= y * z",
          "#[trigger] pow(pow(b as int, x * y), z) == pow(pow(b as int, x), y * z)"
        ],
        "requires": [
          "b > 0"
        ],
        "body": "{\n    lemma_mul_nonnegative(x as int, y as int);\n    lemma_mul_nonnegative(y as int, z as int);\n    lemma_pow_positive(b as int, x);\n    calc! {\n        (==)\n        pow(pow(b as int, x * y), z); {\n            lemma_pow_multiplies(b as int, x, y);\n        }\n        pow(pow(pow(b as int, x), y), z); {\n            lemma_pow_multiplies(pow(b as int, x), y, z);\n        }\n        pow(pow(b as int, x), y * z);\n    }\n}",
        "doc_comment": "Proof that `(b^(xy))^z = (b^x)^(yz)`, given that `x * y` and `y *\nz` are nonnegative and `b` is positive.",
        "triggers": [
          "pow(pow(b as int"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 432,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_pow_multiplies",
          "pow",
          "lemma_mul_nonnegative",
          "lemma_pow_positive"
        ]
      },
      "lemma_pow_division_inequality": {
        "name": "lemma_pow_division_inequality",
        "type": "proof",
        "signature": "pub proof fn lemma_pow_division_inequality(x: nat, b: nat, e1: nat, e2: nat)\n    requires\n        b > 0,\n        e2 <= e1,\n        x < pow(b as int, e1),\n    ensures\n        pow(b as int, e2) > 0,\n        // also somewhat annoying that division operator needs explicit type casting\n        // because the divisor and dividend need to have the same type\n        #[trigger] (x as int / pow(b as int, e2)) < #[trigger] pow(b as int, (e1 - e2) as nat),",
        "ensures": [
          "pow(b as int, e2) > 0",
          "// also somewhat annoying that division operator needs explicit type casting\n        // because the divisor and dividend need to have the same type\n        #[trigger] (x as int / pow(b as int, e2)) < #[trigger] pow(b as int, (e1 - e2) as nat)"
        ],
        "requires": [
          "b > 0",
          "e2 <= e1",
          "x < pow(b as int, e1)"
        ],
        "body": "{\n    broadcast use lemma_pow_positive;\n\n    assert(x as int / pow(b as int, e2) >= pow(b as int, (e1 - e2) as nat) ==> false) by {\n        if x as int / pow(b as int, e2) >= pow(b as int, (e1 - e2) as nat) {\n            lemma_mul_inequality(\n                pow(b as int, (e1 - e2) as nat),\n                x as int / pow(b as int, e2),\n                pow(b as int, e2),\n            );\n            lemma_fundamental_div_mod(x as int, pow(b as int, e2));\n            broadcast use {lemma_mul_is_commutative, group_mod_properties};\n\n            lemma_pow_adds(b as int, (e1 - e2) as nat, e2);\n        }\n    };\n}",
        "doc_comment": "Proof that if `e2 <= e1` and `x < pow(b, e1)`, then dividing `x`\nby `pow(b, e2)` produces a result less than `pow(b, e1 - e2)`.",
        "triggers": [
          "(x as int / pow(b as int",
          "pow(b as int"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 457,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mul_inequality",
          "pow",
          "lemma_pow_adds",
          "lemma_fundamental_div_mod"
        ]
      },
      "lemma_pow_mod": {
        "name": "lemma_pow_mod",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_mod(b: nat, e: nat)\n    requires\n        b > 0,\n        e > 0,\n    ensures\n        #[trigger] pow(b as int, e) % b as int == 0,",
        "ensures": [
          "#[trigger] pow(b as int, e) % b as int == 0"
        ],
        "requires": [
          "b > 0",
          "e > 0"
        ],
        "body": "{\n    reveal(pow);\n    assert(pow(b as int, e) % b as int == (b * pow(b as int, (e - 1) as nat)) % b as int);\n    assert((b * pow(b as int, (e - 1) as nat)) % b as int == (pow(b as int, (e - 1) as nat) * b)\n        % b as int) by {\n        broadcast use lemma_mul_is_commutative;\n\n    };\n    assert((pow(b as int, (e - 1) as nat) * b) % b as int == 0) by {\n        broadcast use lemma_pow_positive;\n\n        lemma_mod_multiples_basic(pow(b as int, (e - 1) as nat), b as int);\n    };\n    // TODO\n    // TO BE DiSCUSSED, suprisingly, the calculational proof saying the same thing does not work\n    // calc! {\n    // (==)\n    // pow(b as int, e) % b as int; {}\n    // (b * pow(b as int, (e - 1) as nat)) % b as int;\n    // { broadcast use lemma_mul_is_associative; }\n    // (pow(b as int, (e - 1) as nat) * b) % b as int;\n    // {\n    //     lemma_pow_positive_auto();\n    //     lemma_mod_multiples_basic(pow(b as int, (e - 1) as nat) , b as int);\n    // }\n    // 0;\n    // }\n}",
        "doc_comment": "Proof that `pow(b, e)` modulo `b` is 0.",
        "triggers": [
          "pow(b as int"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 487,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_mod_multiples_basic",
          "pow",
          "lemma_pow_positive_auto"
        ]
      },
      "lemma_pow_mod_noop": {
        "name": "lemma_pow_mod_noop",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow_mod_noop(b: int, e: nat, m: int)\n    requires\n        m > 0,\n    ensures\n        #[trigger] pow(b % m, e) % m == pow(b, e) % m,\n    decreases e,",
        "ensures": [
          "#[trigger] pow(b % m, e) % m == pow(b, e) % m"
        ],
        "requires": [
          "m > 0"
        ],
        "body": "{\n    reveal(pow);\n    broadcast use group_mod_properties;\n\n    if e > 0 {\n        calc! {\n            (==)\n            pow(b % m, e) % m; {}\n            ((b % m) * pow(b % m, (e - 1) as nat)) % m; {\n                lemma_mul_mod_noop_general(b, pow(b % m, (e - 1) as nat), m);\n            }\n            ((b % m) * (pow(b % m, (e - 1) as nat) % m) % m) % m; {\n                lemma_pow_mod_noop(b, (e - 1) as nat, m);\n            }\n            ((b % m) * (pow(b, (e - 1) as nat) % m) % m) % m; {\n                lemma_mul_mod_noop_general(b, pow(b, (e - 1) as nat), m);\n            }\n            (b * (pow(b, (e - 1) as nat)) % m) % m; {}\n            (b * (pow(b, (e - 1) as nat))) % m; {}\n            pow(b, e) % m;\n        }\n    }\n}",
        "doc_comment": "Proof that exponentiation then modulo produces the same result as\ndoing the modulo first, then doing the exponentiation, then doing\nthe modulo again. Specifically, `((b % m)^e) % m == b^e % m`.",
        "triggers": [
          "pow(b % m"
        ],
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 523,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "pow",
          "lemma_pow_mod_noop",
          "lemma_mul_mod_noop_general"
        ]
      },
      "lemma_pow2_pos": {
        "name": "lemma_pow2_pos",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow2_pos(e: nat)\n    ensures\n        #[trigger] pow2(e) > 0,",
        "ensures": [
          "#[trigger] pow2(e) > 0"
        ],
        "requires": [],
        "body": "{\n    reveal(pow2);\n    lemma_pow_positive(2, e);\n}",
        "doc_comment": "Proof that 2 to the power of any natural number (specifically,\n`e`) is positive.",
        "triggers": [
          "pow2(e"
        ],
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 43,
        "module": "vstd::arithmetic::power2",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_pow_positive"
        ]
      },
      "lemma_pow2": {
        "name": "lemma_pow2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow2(e: nat)\n    ensures\n        #[trigger] pow2(e) == pow(2, e) as int,\n    decreases e,",
        "ensures": [
          "#[trigger] pow2(e) == pow(2, e) as int"
        ],
        "requires": [],
        "body": "{\n    reveal(pow);\n    reveal(pow2);\n    if e != 0 {\n        lemma_pow2((e - 1) as nat);\n    }\n}",
        "doc_comment": "Proof that `pow2(e)` is equivalent to `pow(2, e)`.",
        "triggers": [
          "pow2(e"
        ],
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 53,
        "module": "vstd::arithmetic::power2",
        "keywords": [
          "decreases",
          "trigger"
        ],
        "callees": [
          "lemma_pow2"
        ]
      },
      "lemma_pow2_unfold": {
        "name": "lemma_pow2_unfold",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow2_unfold(e: nat)\n    requires\n        e > 0,\n    ensures\n        #[trigger] pow2(e) == 2 * pow2((e - 1) as nat),",
        "ensures": [
          "#[trigger] pow2(e) == 2 * pow2((e - 1) as nat)"
        ],
        "requires": [
          "e > 0"
        ],
        "body": "{\n    reveal(pow);\n    lemma_pow2(e);\n    lemma_pow2((e - 1) as nat);\n}",
        "doc_comment": "Proof relating 2^e to 2^(e-1).",
        "triggers": [
          "pow2(e"
        ],
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 66,
        "module": "vstd::arithmetic::power2",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_pow2"
        ]
      },
      "lemma_pow2_adds": {
        "name": "lemma_pow2_adds",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow2_adds(e1: nat, e2: nat)\n    ensures\n        #[trigger] pow2(e1 + e2) == pow2(e1) * pow2(e2),",
        "ensures": [
          "#[trigger] pow2(e1 + e2) == pow2(e1) * pow2(e2)"
        ],
        "requires": [],
        "body": "{\n    lemma_pow2(e1);\n    lemma_pow2(e2);\n    lemma_pow2(e1 + e2);\n    lemma_pow_adds(2, e1, e2);\n}",
        "doc_comment": "Proof that `2^(e1 + e2)` is equivalent to `2^e1 * 2^e2`.",
        "triggers": [
          "pow2(e1 + e2"
        ],
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 78,
        "module": "vstd::arithmetic::power2",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_pow_adds",
          "lemma_pow2"
        ]
      },
      "lemma_pow2_subtracts": {
        "name": "lemma_pow2_subtracts",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow2_subtracts(e1: nat, e2: nat)\n    requires\n        e1 <= e2,\n    ensures\n        #[trigger] pow2((e2 - e1) as nat) == pow2(e2) / pow2(e1) > 0,",
        "ensures": [
          "#[trigger] pow2((e2 - e1) as nat) == pow2(e2) / pow2(e1) > 0"
        ],
        "requires": [
          "e1 <= e2"
        ],
        "body": "{\n    lemma_pow2(e1);\n    lemma_pow2(e2);\n    lemma_pow2((e2 - e1) as nat);\n    lemma_pow_subtracts(2, e1, e2);\n}",
        "doc_comment": "Proof that, as long as `e1 <= e2`, `2^(e2 - e1)` is equivalent to `2^e2 / 2^e1`.",
        "triggers": [
          "pow2((e2 - e1"
        ],
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 89,
        "module": "vstd::arithmetic::power2",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_pow2",
          "lemma_pow_subtracts"
        ]
      },
      "lemma_pow2_strictly_increases": {
        "name": "lemma_pow2_strictly_increases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_pow2_strictly_increases(e1: nat, e2: nat)\n    requires\n        e1 < e2,\n    ensures\n        #[trigger] pow2(e1) < #[trigger] pow2(e2),",
        "ensures": [
          "#[trigger] pow2(e1) < #[trigger] pow2(e2)"
        ],
        "requires": [
          "e1 < e2"
        ],
        "body": "{\n    lemma_pow2(e1);\n    lemma_pow2(e2);\n    lemma_pow_strictly_increases(2, e1, e2);\n}",
        "doc_comment": "Proof that if `e1 < e2` then `2^e1 < 2^e2`.",
        "triggers": [
          "pow2(e1",
          "pow2(e2"
        ],
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 102,
        "module": "vstd::arithmetic::power2",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_pow_strictly_increases",
          "lemma_pow2"
        ]
      },
      "lemma2_to64": {
        "name": "lemma2_to64",
        "type": "proof",
        "signature": "pub proof fn lemma2_to64()\n    ensures\n        pow2(0) == 0x1,\n        pow2(1) == 0x2,\n        pow2(2) == 0x4,\n        pow2(3) == 0x8,\n        pow2(4) == 0x10,\n        pow2(5) == 0x20,\n        pow2(6) == 0x40,\n        pow2(7) == 0x80,\n        pow2(8) == 0x100,\n        pow2(9) == 0x200,\n        pow2(10) == 0x400,\n        pow2(11) == 0x800,\n        pow2(12) == 0x1000,\n        pow2(13) == 0x2000,\n        pow2(14) == 0x4000,\n        pow2(15) == 0x8000,\n        pow2(16) == 0x10000,\n        pow2(17) == 0x20000,\n        pow2(18) == 0x40000,\n        pow2(19) == 0x80000,\n        pow2(20) == 0x100000,\n        pow2(21) == 0x200000,\n        pow2(22) == 0x400000,\n        pow2(23) == 0x800000,\n        pow2(24) == 0x1000000,\n        pow2(25) == 0x2000000,\n        pow2(26) == 0x4000000,\n        pow2(27) == 0x8000000,\n        pow2(28) == 0x10000000,\n        pow2(29) == 0x20000000,\n        pow2(30) == 0x40000000,\n        pow2(31) == 0x80000000,\n        pow2(32) == 0x100000000,\n        pow2(64) == 0x10000000000000000,",
        "ensures": [
          "pow2(0) == 0x1",
          "pow2(1) == 0x2",
          "pow2(2) == 0x4",
          "pow2(3) == 0x8",
          "pow2(4) == 0x10",
          "pow2(5) == 0x20",
          "pow2(6) == 0x40",
          "pow2(7) == 0x80",
          "pow2(8) == 0x100",
          "pow2(9) == 0x200",
          "pow2(10) == 0x400",
          "pow2(11) == 0x800",
          "pow2(12) == 0x1000",
          "pow2(13) == 0x2000",
          "pow2(14) == 0x4000",
          "pow2(15) == 0x8000",
          "pow2(16) == 0x10000",
          "pow2(17) == 0x20000",
          "pow2(18) == 0x40000",
          "pow2(19) == 0x80000",
          "pow2(20) == 0x100000",
          "pow2(21) == 0x200000",
          "pow2(22) == 0x400000",
          "pow2(23) == 0x800000",
          "pow2(24) == 0x1000000",
          "pow2(25) == 0x2000000",
          "pow2(26) == 0x4000000",
          "pow2(27) == 0x8000000",
          "pow2(28) == 0x10000000",
          "pow2(29) == 0x20000000",
          "pow2(30) == 0x40000000",
          "pow2(31) == 0x80000000",
          "pow2(32) == 0x100000000",
          "pow2(64) == 0x10000000000000000"
        ],
        "requires": [],
        "body": "{\n    reveal(pow2);\n    reveal(pow);\n    #[verusfmt::skip]\n    assert(\n        pow2(0) == 0x1 &&\n        pow2(1) == 0x2 &&\n        pow2(2) == 0x4 &&\n        pow2(3) == 0x8 &&\n        pow2(4) == 0x10 &&\n        pow2(5) == 0x20 &&\n        pow2(6) == 0x40 &&\n        pow2(7) == 0x80 &&\n        pow2(8) == 0x100 &&\n        pow2(9) == 0x200 &&\n        pow2(10) == 0x400 &&\n        pow2(11) == 0x800 &&\n        pow2(12) == 0x1000 &&\n        pow2(13) == 0x2000 &&\n        pow2(14) == 0x4000 &&\n        pow2(15) == 0x8000 &&\n        pow2(16) == 0x10000 &&\n        pow2(17) == 0x20000 &&\n        pow2(18) == 0x40000 &&\n        pow2(19) == 0x80000 &&\n        pow2(20) == 0x100000 &&\n        pow2(21) == 0x200000 &&\n        pow2(22) == 0x400000 &&\n        pow2(23) == 0x800000 &&\n        pow2(24) == 0x1000000 &&\n        pow2(25) == 0x2000000 &&\n        pow2(26) == 0x4000000 &&\n        pow2(27) == 0x8000000 &&\n        pow2(28) == 0x10000000 &&\n        pow2(29) == 0x20000000 &&\n        pow2(30) == 0x40000000 &&\n        pow2(31) == 0x80000000 &&\n        pow2(32) == 0x100000000 &&\n        pow2(64) == 0x10000000000000000\n    ) by(compute_only);\n}",
        "doc_comment": "Proof establishing the concrete values for all powers of 2 from 0 to 32 and also 2^64.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 114,
        "module": "vstd::arithmetic::power2",
        "keywords": [],
        "callees": [
          "pow2"
        ]
      },
      "lemma2_to64_rest": {
        "name": "lemma2_to64_rest",
        "type": "proof",
        "signature": "pub proof fn lemma2_to64_rest()\n    ensures\n        pow2(33) == 0x200000000,\n        pow2(34) == 0x400000000,\n        pow2(35) == 0x800000000,\n        pow2(36) == 0x1000000000,\n        pow2(37) == 0x2000000000,\n        pow2(38) == 0x4000000000,\n        pow2(39) == 0x8000000000,\n        pow2(40) == 0x10000000000,\n        pow2(41) == 0x20000000000,\n        pow2(42) == 0x40000000000,\n        pow2(43) == 0x80000000000,\n        pow2(44) == 0x100000000000,\n        pow2(45) == 0x200000000000,\n        pow2(46) == 0x400000000000,\n        pow2(47) == 0x800000000000,\n        pow2(48) == 0x1000000000000,\n        pow2(49) == 0x2000000000000,\n        pow2(50) == 0x4000000000000,\n        pow2(51) == 0x8000000000000,\n        pow2(52) == 0x10000000000000,\n        pow2(53) == 0x20000000000000,\n        pow2(54) == 0x40000000000000,\n        pow2(55) == 0x80000000000000,\n        pow2(56) == 0x100000000000000,\n        pow2(57) == 0x200000000000000,\n        pow2(58) == 0x400000000000000,\n        pow2(59) == 0x800000000000000,\n        pow2(60) == 0x1000000000000000,\n        pow2(61) == 0x2000000000000000,\n        pow2(62) == 0x4000000000000000,\n        pow2(63) == 0x8000000000000000,\n        pow2(64) == 0x10000000000000000,",
        "ensures": [
          "pow2(33) == 0x200000000",
          "pow2(34) == 0x400000000",
          "pow2(35) == 0x800000000",
          "pow2(36) == 0x1000000000",
          "pow2(37) == 0x2000000000",
          "pow2(38) == 0x4000000000",
          "pow2(39) == 0x8000000000",
          "pow2(40) == 0x10000000000",
          "pow2(41) == 0x20000000000",
          "pow2(42) == 0x40000000000",
          "pow2(43) == 0x80000000000",
          "pow2(44) == 0x100000000000",
          "pow2(45) == 0x200000000000",
          "pow2(46) == 0x400000000000",
          "pow2(47) == 0x800000000000",
          "pow2(48) == 0x1000000000000",
          "pow2(49) == 0x2000000000000",
          "pow2(50) == 0x4000000000000",
          "pow2(51) == 0x8000000000000",
          "pow2(52) == 0x10000000000000",
          "pow2(53) == 0x20000000000000",
          "pow2(54) == 0x40000000000000",
          "pow2(55) == 0x80000000000000",
          "pow2(56) == 0x100000000000000",
          "pow2(57) == 0x200000000000000",
          "pow2(58) == 0x400000000000000",
          "pow2(59) == 0x800000000000000",
          "pow2(60) == 0x1000000000000000",
          "pow2(61) == 0x2000000000000000",
          "pow2(62) == 0x4000000000000000",
          "pow2(63) == 0x8000000000000000",
          "pow2(64) == 0x10000000000000000"
        ],
        "requires": [],
        "body": "{\n    reveal(pow2);\n    reveal(pow);\n    #[verusfmt::skip]\n    assert(\n        pow2(33) == 0x200000000 &&\n        pow2(34) == 0x400000000 &&\n        pow2(35) == 0x800000000 &&\n        pow2(36) == 0x1000000000 &&\n        pow2(37) == 0x2000000000 &&\n        pow2(38) == 0x4000000000 &&\n        pow2(39) == 0x8000000000 &&\n        pow2(40) == 0x10000000000 &&\n        pow2(41) == 0x20000000000 &&\n        pow2(42) == 0x40000000000 &&\n        pow2(43) == 0x80000000000 &&\n        pow2(44) == 0x100000000000 &&\n        pow2(45) == 0x200000000000 &&\n        pow2(46) == 0x400000000000 &&\n        pow2(47) == 0x800000000000 &&\n        pow2(48) == 0x1000000000000 &&\n        pow2(49) == 0x2000000000000 &&\n        pow2(50) == 0x4000000000000 &&\n        pow2(51) == 0x8000000000000 &&\n        pow2(52) == 0x10000000000000 &&\n        pow2(53) == 0x20000000000000 &&\n        pow2(54) == 0x40000000000000 &&\n        pow2(55) == 0x80000000000000 &&\n        pow2(56) == 0x100000000000000 &&\n        pow2(57) == 0x200000000000000 &&\n        pow2(58) == 0x400000000000000 &&\n        pow2(59) == 0x800000000000000 &&\n        pow2(60) == 0x1000000000000000 &&\n        pow2(61) == 0x2000000000000000 &&\n        pow2(62) == 0x4000000000000000 &&\n        pow2(63) == 0x8000000000000000 &&\n        pow2(64) == 0x10000000000000000\n    ) by(compute_only);\n}",
        "doc_comment": "Proof establishing the concrete values for all powers of 2 from 33 to 64.\nThis lemma is separated from `lemma2_to64()` to avoid a stack overflow issue\nwhile executing ./tools/docs.sh.",
        "triggers": [],
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 193,
        "module": "vstd::arithmetic::power2",
        "keywords": [],
        "callees": [
          "pow2"
        ]
      },
      "lemma_array_index": {
        "name": "lemma_array_index",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_array_index<T, const N: usize>(a: [T",
        "ensures": [
          "#![trigger array_index(a, i)]\n        a[i] == array_view(a)[i]"
        ],
        "requires": [
          "0 <= i < N"
        ],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 49,
        "module": "vstd::array",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "array_index_get": {
        "name": "array_index_get",
        "type": "exec",
        "signature": "pub exec fn array_index_get<T, const N: usize>(ar: &[T",
        "ensures": [
          "*out == ar@.index(i as int)"
        ],
        "requires": [
          "0 <= i < N"
        ],
        "body": "{\n    &ar[i]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 69,
        "module": "vstd::array",
        "keywords": [],
        "callees": []
      },
      "array_len_matches_n": {
        "name": "array_len_matches_n",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn array_len_matches_n<T, const N: usize>(ar: &[T",
        "ensures": [
          "(#[trigger] ar@.len()) == N",
          "(#[trigger] spec_array_as_slice(ar))@ == ar@",
          "ar@ == out@"
        ],
        "requires": [],
        "body": "{\n    ar\n}",
        "doc_comment": null,
        "triggers": [
          "ar@.len(",
          "spec_array_as_slice(ar"
        ],
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 80,
        "module": "vstd::array",
        "keywords": [
          "len",
          "trigger"
        ],
        "callees": []
      },
      "spec_array_as_slice": {
        "name": "spec_array_as_slice",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_array_as_slice<T, const N: usize>(ar: &[T",
        "ensures": [
          "(#[trigger] spec_array_as_slice(ar))@ == ar@",
          "ar@ == out@"
        ],
        "requires": [],
        "body": "{\n    ar\n}",
        "doc_comment": null,
        "triggers": [
          "spec_array_as_slice(ar"
        ],
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 85,
        "module": "vstd::array",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "axiom_spec_array_as_slice": {
        "name": "axiom_spec_array_as_slice",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_spec_array_as_slice<T, const N: usize>(ar: &[T",
        "ensures": [
          "(#[trigger] spec_array_as_slice(ar))@ == ar@",
          "ar@ == out@"
        ],
        "requires": [],
        "body": "{\n    ar\n}",
        "doc_comment": null,
        "triggers": [
          "spec_array_as_slice(ar"
        ],
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 87,
        "module": "vstd::array",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "spec_array_fill_for_copy_type": {
        "name": "spec_array_fill_for_copy_type",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_array_fill_for_copy_type<T: Copy, const N: usize>(t: T) -> (res: [T",
        "ensures": [
          "#![trigger spec_array_fill_for_copy_type::<T, N>(t)]\n        // intentionally triggering on `spec_array_fill_for_copy_type` only\n        forall|i: int|\n            0 <= i < N ==> spec_array_fill_for_copy_type::<T, N>(t).view()[i] == t",
          "res == spec_array_fill_for_copy_type::<T, N>(t)"
        ],
        "requires": [],
        "body": "{\n    [t;N]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 109,
        "module": "vstd::array",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "axiom_spec_array_fill_for_copy_type": {
        "name": "axiom_spec_array_fill_for_copy_type",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_spec_array_fill_for_copy_type<T: Copy, const N: usize>(t: T)\n    ensures\n        #![trigger spec_array_fill_for_copy_type::<T, N>(t)]\n        // intentionally triggering on `spec_array_fill_for_copy_type` only\n        forall|i: int|\n            0 <= i < N ==> spec_array_fill_for_copy_type::<T, N>(t).view()[i] == t,",
        "ensures": [
          "#![trigger spec_array_fill_for_copy_type::<T, N>(t)]\n        // intentionally triggering on `spec_array_fill_for_copy_type` only\n        forall|i: int|\n            0 <= i < N ==> spec_array_fill_for_copy_type::<T, N>(t).view()[i] == t",
          "res == spec_array_fill_for_copy_type::<T, N>(t)"
        ],
        "requires": [],
        "body": "{\n    [t;N]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 111,
        "module": "vstd::array",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "axiom_array_ext_equal": {
        "name": "axiom_array_ext_equal",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_array_ext_equal<T, const N: usize>(a1: [T",
        "ensures": [
          "#[trigger] (a1 =~= a2) <==> (forall|i: int| 0 <= i < N ==> a1[i] == a2[i])"
        ],
        "requires": [],
        "body": "{\n    array_len_matches_n,\n    lemma_array_index,\n    axiom_spec_array_as_slice,\n    axiom_spec_array_fill_for_copy_type,\n    axiom_array_ext_equal,\n}",
        "doc_comment": null,
        "triggers": [
          "(a1 =~= a2"
        ],
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 132,
        "module": "vstd::array",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "view": {
        "name": "vstd::atomic::view",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn view(self) -> $p_data_ident",
        "ensures": [],
        "requires": [],
        "body": "{\n                self.view().patomic == patomic.id()\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 114,
        "module": "vstd::atomic",
        "keywords": [],
        "callees": [
          "id",
          "view"
        ]
      },
      "vstd::atomic::view": {
        "name": "vstd::atomic::view",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn view(self) -> $p_data_ident <T>",
        "ensures": [],
        "requires": [],
        "body": "{\n                self.view().patomic == patomic.id()\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 164,
        "module": "vstd::atomic",
        "keywords": [],
        "callees": [
          "id",
          "view"
        ]
      },
      "id": {
        "name": "vstd::atomic::id",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn id(&self) -> int",
        "ensures": [
          "equal(res.1@.view(), $p_data_ident"
        ],
        "requires": [],
        "body": "{ patomic: res.0.id(), value: i }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 194,
        "module": "vstd::atomic",
        "keywords": [],
        "callees": [
          "id"
        ]
      },
      "lemma_low_bits_mask_unfold": {
        "name": "lemma_low_bits_mask_unfold",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_low_bits_mask_unfold(n: nat)\n    requires\n        n > 0,\n    ensures\n        #[trigger] low_bits_mask(n) == 2 * low_bits_mask((n - 1) as nat) + 1,",
        "ensures": [
          "#[trigger] low_bits_mask(n) == 2 * low_bits_mask((n - 1) as nat) + 1"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    calc! {\n        (==)\n        low_bits_mask(n); {}\n        (pow2(n) - 1) as nat; {\n            lemma_pow2_unfold(n);\n        }\n        (2 * pow2((n - 1) as nat) - 1) as nat; {}\n        (2 * (pow2((n - 1) as nat) - 1) + 1) as nat; {\n            lemma_pow2_pos((n - 1) as nat);\n        }\n        (2 * low_bits_mask((n - 1) as nat) + 1) as nat;\n    }\n}",
        "doc_comment": "Proof relating the n-bit mask to a function of the (n-1)-bit mask.",
        "triggers": [
          "low_bits_mask(n"
        ],
        "file_path": "verus/source/vstd/bits.rs",
        "line_number": 238,
        "module": "vstd::bits",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "pow2",
          "low_bits_mask",
          "lemma_pow2_unfold",
          "lemma_pow2_pos"
        ]
      },
      "lemma_low_bits_mask_is_odd": {
        "name": "lemma_low_bits_mask_is_odd",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_low_bits_mask_is_odd(n: nat)\n    requires\n        n > 0,\n    ensures\n        #[trigger] (low_bits_mask(n) % 2) == 1,",
        "ensures": [
          "#[trigger] (low_bits_mask(n) % 2) == 1"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    calc! {\n        (==)\n        low_bits_mask(n) % 2; {\n            lemma_low_bits_mask_unfold(n);\n        }\n        (2 * low_bits_mask((n - 1) as nat) + 1) % 2; {\n            lemma_mod_multiples_vanish(low_bits_mask((n - 1) as nat) as int, 1, 2);\n        }\n        1nat % 2;\n    }\n}",
        "doc_comment": "Proof that low_bits_mask(n) is odd.",
        "triggers": [
          "(low_bits_mask(n"
        ],
        "file_path": "verus/source/vstd/bits.rs",
        "line_number": 259,
        "module": "vstd::bits",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_low_bits_mask_unfold",
          "low_bits_mask",
          "lemma_mod_multiples_vanish"
        ]
      },
      "lemma_low_bits_mask_div2": {
        "name": "lemma_low_bits_mask_div2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_low_bits_mask_div2(n: nat)\n    requires\n        n > 0,\n    ensures\n        #[trigger] (low_bits_mask(n) / 2) == low_bits_mask((n - 1) as nat),",
        "ensures": [
          "#[trigger] (low_bits_mask(n) / 2) == low_bits_mask((n - 1) as nat)"
        ],
        "requires": [
          "n > 0"
        ],
        "body": "{\n    lemma_low_bits_mask_unfold(n);\n}",
        "doc_comment": "Proof that dividing the low n bit mask by 2 gives the low n-1 bit mask.",
        "triggers": [
          "(low_bits_mask(n"
        ],
        "file_path": "verus/source/vstd/bits.rs",
        "line_number": 278,
        "module": "vstd::bits",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "lemma_low_bits_mask_unfold"
        ]
      },
      "lemma_low_bits_mask_values": {
        "name": "lemma_low_bits_mask_values",
        "type": "proof",
        "signature": "pub proof fn lemma_low_bits_mask_values()\n    ensures\n        low_bits_mask(0) == 0x0,\n        low_bits_mask(1) == 0x1,\n        low_bits_mask(2) == 0x3,\n        low_bits_mask(3) == 0x7,\n        low_bits_mask(4) == 0xf,\n        low_bits_mask(5) == 0x1f,\n        low_bits_mask(6) == 0x3f,\n        low_bits_mask(7) == 0x7f,\n        low_bits_mask(8) == 0xff,\n        low_bits_mask(9) == 0x1ff,\n        low_bits_mask(10) == 0x3ff,\n        low_bits_mask(11) == 0x7ff,\n        low_bits_mask(12) == 0xfff,\n        low_bits_mask(13) == 0x1fff,\n        low_bits_mask(14) == 0x3fff,\n        low_bits_mask(15) == 0x7fff,\n        low_bits_mask(16) == 0xffff,\n        low_bits_mask(17) == 0x1ffff,\n        low_bits_mask(18) == 0x3ffff,\n        low_bits_mask(19) == 0x7ffff,\n        low_bits_mask(20) == 0xfffff,\n        low_bits_mask(21) == 0x1fffff,\n        low_bits_mask(22) == 0x3fffff,\n        low_bits_mask(23) == 0x7fffff,\n        low_bits_mask(24) == 0xffffff,\n        low_bits_mask(25) == 0x1ffffff,\n        low_bits_mask(26) == 0x3ffffff,\n        low_bits_mask(27) == 0x7ffffff,\n        low_bits_mask(28) == 0xfffffff,\n        low_bits_mask(29) == 0x1fffffff,\n        low_bits_mask(30) == 0x3fffffff,\n        low_bits_mask(31) == 0x7fffffff,\n        low_bits_mask(32) == 0xffffffff,\n        low_bits_mask(64) == 0xffffffffffffffff,",
        "ensures": [
          "low_bits_mask(0) == 0x0",
          "low_bits_mask(1) == 0x1",
          "low_bits_mask(2) == 0x3",
          "low_bits_mask(3) == 0x7",
          "low_bits_mask(4) == 0xf",
          "low_bits_mask(5) == 0x1f",
          "low_bits_mask(6) == 0x3f",
          "low_bits_mask(7) == 0x7f",
          "low_bits_mask(8) == 0xff",
          "low_bits_mask(9) == 0x1ff",
          "low_bits_mask(10) == 0x3ff",
          "low_bits_mask(11) == 0x7ff",
          "low_bits_mask(12) == 0xfff",
          "low_bits_mask(13) == 0x1fff",
          "low_bits_mask(14) == 0x3fff",
          "low_bits_mask(15) == 0x7fff",
          "low_bits_mask(16) == 0xffff",
          "low_bits_mask(17) == 0x1ffff",
          "low_bits_mask(18) == 0x3ffff",
          "low_bits_mask(19) == 0x7ffff",
          "low_bits_mask(20) == 0xfffff",
          "low_bits_mask(21) == 0x1fffff",
          "low_bits_mask(22) == 0x3fffff",
          "low_bits_mask(23) == 0x7fffff",
          "low_bits_mask(24) == 0xffffff",
          "low_bits_mask(25) == 0x1ffffff",
          "low_bits_mask(26) == 0x3ffffff",
          "low_bits_mask(27) == 0x7ffffff",
          "low_bits_mask(28) == 0xfffffff",
          "low_bits_mask(29) == 0x1fffffff",
          "low_bits_mask(30) == 0x3fffffff",
          "low_bits_mask(31) == 0x7fffffff",
          "low_bits_mask(32) == 0xffffffff",
          "low_bits_mask(64) == 0xffffffffffffffff"
        ],
        "requires": [],
        "body": "{\n    reveal(pow2);\n    #[verusfmt::skip]\n    assert(\n        low_bits_mask(0) == 0x0 &&\n        low_bits_mask(1) == 0x1 &&\n        low_bits_mask(2) == 0x3 &&\n        low_bits_mask(3) == 0x7 &&\n        low_bits_mask(4) == 0xf &&\n        low_bits_mask(5) == 0x1f &&\n        low_bits_mask(6) == 0x3f &&\n        low_bits_mask(7) == 0x7f &&\n        low_bits_mask(8) == 0xff &&\n        low_bits_mask(9) == 0x1ff &&\n        low_bits_mask(10) == 0x3ff &&\n        low_bits_mask(11) == 0x7ff &&\n        low_bits_mask(12) == 0xfff &&\n        low_bits_mask(13) == 0x1fff &&\n        low_bits_mask(14) == 0x3fff &&\n        low_bits_mask(15) == 0x7fff &&\n        low_bits_mask(16) == 0xffff &&\n        low_bits_mask(17) == 0x1ffff &&\n        low_bits_mask(18) == 0x3ffff &&\n        low_bits_mask(19) == 0x7ffff &&\n        low_bits_mask(20) == 0xfffff &&\n        low_bits_mask(21) == 0x1fffff &&\n        low_bits_mask(22) == 0x3fffff &&\n        low_bits_mask(23) == 0x7fffff &&\n        low_bits_mask(24) == 0xffffff &&\n        low_bits_mask(25) == 0x1ffffff &&\n        low_bits_mask(26) == 0x3ffffff &&\n        low_bits_mask(27) == 0x7ffffff &&\n        low_bits_mask(28) == 0xfffffff &&\n        low_bits_mask(29) == 0x1fffffff &&\n        low_bits_mask(30) == 0x3fffffff &&\n        low_bits_mask(31) == 0x7fffffff &&\n        low_bits_mask(32) == 0xffffffff &&\n        low_bits_mask(64) == 0xffffffffffffffff\n    ) by (compute_only);\n}",
        "doc_comment": "Proof establishing the concrete values of all masks of bit sizes from 0 to\n32, and 64.",
        "triggers": [],
        "file_path": "verus/source/vstd/bits.rs",
        "line_number": 288,
        "module": "vstd::bits",
        "keywords": [],
        "callees": [
          "low_bits_mask"
        ]
      },
      "spec_u16_to_le_bytes": {
        "name": "spec_u16_to_le_bytes",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_u16_to_le_bytes(x: u16) -> Seq<u8>",
        "ensures": [],
        "requires": [],
        "body": "{\n    #[verusfmt::skip]\n    seq![\n        (x & 0xff) as u8,\n        ((x >> 8) & 0xff) as u8\n    ]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 14,
        "module": "vstd::bytes",
        "keywords": [
          "Seq"
        ],
        "callees": []
      },
      "spec_u16_from_le_bytes": {
        "name": "spec_u16_from_le_bytes",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_u16_from_le_bytes(s: Seq<u8>) -> u16\n    recommends\n        s.len() == 2,",
        "ensures": [],
        "requires": [],
        "body": "{\n    (s[0] as u16) | (s[1] as u16) << 8\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 22,
        "module": "vstd::bytes",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": []
      },
      "lemma_auto_spec_u16_to_from_le_bytes": {
        "name": "lemma_auto_spec_u16_to_from_le_bytes",
        "type": "proof",
        "signature": "pub proof fn lemma_auto_spec_u16_to_from_le_bytes()\n    ensures\n        forall|x: u16|",
        "ensures": [
          "forall|x: u16|"
        ],
        "requires": [],
        "body": "{\n                &&& #[trigger] spec_u16_to_le_bytes(x).len() == 2\n                &&& spec_u16_from_le_bytes(spec_u16_to_le_bytes(x)) == x\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 29,
        "module": "vstd::bytes",
        "keywords": [
          "forall"
        ],
        "callees": [
          "spec_u16_to_le_bytes",
          "len",
          "spec_u16_from_le_bytes"
        ]
      },
      "u16_from_le_bytes": {
        "name": "u16_from_le_bytes",
        "type": "exec",
        "signature": "pub exec fn u16_from_le_bytes(s: &[u8]) -> (x: u16)\n    requires\n        s@.len() == 2,\n    ensures\n        x == spec_u16_from_le_bytes(s@),",
        "ensures": [
          "x == spec_u16_from_le_bytes(s@)"
        ],
        "requires": [
          "s@.len() == 2"
        ],
        "body": "{\n    use core::convert::TryInto;\n    u16::from_le_bytes(s.try_into().unwrap())\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 76,
        "module": "vstd::bytes",
        "keywords": [
          "len"
        ],
        "callees": [
          "from_le_bytes",
          "try_into"
        ]
      },
      "u16_to_le_bytes": {
        "name": "u16_to_le_bytes",
        "type": "exec",
        "signature": "pub exec fn u16_to_le_bytes(x: u16) -> (s: alloc::vec::Vec<u8>)\n    ensures\n        s@ == spec_u16_to_le_bytes(x),\n        s@.len() == 2,",
        "ensures": [
          "s@ == spec_u16_to_le_bytes(x)",
          "s@.len() == 2"
        ],
        "requires": [],
        "body": "{\n    x.to_le_bytes().to_vec()\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 87,
        "module": "vstd::bytes",
        "keywords": [
          "Vec",
          "len"
        ],
        "callees": [
          "to_le_bytes",
          "to_vec"
        ]
      },
      "spec_u32_to_le_bytes": {
        "name": "spec_u32_to_le_bytes",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_u32_to_le_bytes(x: u32) -> Seq<u8>",
        "ensures": [],
        "requires": [],
        "body": "{\n    #[verusfmt::skip]\n    seq![\n        (x & 0xff) as u8,\n        ((x >> 8) & 0xff) as u8,\n        ((x >> 16) & 0xff) as u8,\n        ((x >> 24) & 0xff) as u8,\n    ]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 99,
        "module": "vstd::bytes",
        "keywords": [
          "Seq"
        ],
        "callees": []
      },
      "spec_u32_from_le_bytes": {
        "name": "spec_u32_from_le_bytes",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_u32_from_le_bytes(s: Seq<u8>) -> u32\n    recommends\n        s.len() == 4,",
        "ensures": [],
        "requires": [],
        "body": "{\n    (s[0] as u32) | (s[1] as u32) << 8 | (s[2] as u32) << 16 | (s[3] as u32) << 24\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 108,
        "module": "vstd::bytes",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": []
      },
      "lemma_auto_spec_u32_to_from_le_bytes": {
        "name": "lemma_auto_spec_u32_to_from_le_bytes",
        "type": "proof",
        "signature": "pub proof fn lemma_auto_spec_u32_to_from_le_bytes()\n    ensures\n        forall|x: u32|",
        "ensures": [
          "forall|x: u32|"
        ],
        "requires": [],
        "body": "{\n                &&& #[trigger] spec_u32_to_le_bytes(x).len() == 4\n                &&& spec_u32_from_le_bytes(spec_u32_to_le_bytes(x)) == x\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 115,
        "module": "vstd::bytes",
        "keywords": [
          "forall"
        ],
        "callees": [
          "len",
          "spec_u32_from_le_bytes",
          "spec_u32_to_le_bytes"
        ]
      },
      "u32_from_le_bytes": {
        "name": "u32_from_le_bytes",
        "type": "exec",
        "signature": "pub exec fn u32_from_le_bytes(s: &[u8]) -> (x: u32)\n    requires\n        s@.len() == 4,\n    ensures\n        x == spec_u32_from_le_bytes(s@),",
        "ensures": [
          "x == spec_u32_from_le_bytes(s@)"
        ],
        "requires": [
          "s@.len() == 4"
        ],
        "body": "{\n    use core::convert::TryInto;\n    u32::from_le_bytes(s.try_into().unwrap())\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 171,
        "module": "vstd::bytes",
        "keywords": [
          "len"
        ],
        "callees": [
          "from_le_bytes",
          "try_into"
        ]
      },
      "u32_to_le_bytes": {
        "name": "u32_to_le_bytes",
        "type": "exec",
        "signature": "pub exec fn u32_to_le_bytes(x: u32) -> (s: alloc::vec::Vec<u8>)\n    ensures\n        s@ == spec_u32_to_le_bytes(x),\n        s@.len() == 4,",
        "ensures": [
          "s@ == spec_u32_to_le_bytes(x)",
          "s@.len() == 4"
        ],
        "requires": [],
        "body": "{\n    x.to_le_bytes().to_vec()\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 182,
        "module": "vstd::bytes",
        "keywords": [
          "Vec",
          "len"
        ],
        "callees": [
          "to_le_bytes",
          "to_vec"
        ]
      },
      "spec_u64_to_le_bytes": {
        "name": "spec_u64_to_le_bytes",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_u64_to_le_bytes(x: u64) -> Seq<u8>",
        "ensures": [],
        "requires": [],
        "body": "{\n    #[verusfmt::skip]\n    seq![\n        (x & 0xff) as u8,\n        ((x >> 8) & 0xff) as u8,\n        ((x >> 16) & 0xff) as u8,\n        ((x >> 24) & 0xff) as u8,\n        ((x >> 32) & 0xff) as u8,\n        ((x >> 40) & 0xff) as u8,\n        ((x >> 48) & 0xff) as u8,\n        ((x >> 56) & 0xff) as u8,\n    ]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 194,
        "module": "vstd::bytes",
        "keywords": [
          "Seq"
        ],
        "callees": []
      },
      "spec_u64_from_le_bytes": {
        "name": "spec_u64_from_le_bytes",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_u64_from_le_bytes(s: Seq<u8>) -> u64\n    recommends\n        s.len() == 8,",
        "ensures": [],
        "requires": [],
        "body": "{\n    #[verusfmt::skip]\n    (s[0] as u64) |\n    (s[1] as u64) << 8 |\n    (s[2] as u64) << 16 |\n    (s[3] as u64) << 24 |\n    (s[4] as u64) << 32 |\n    (s[5] as u64) << 40 |\n    (s[6] as u64) << 48 |\n    (s[7] as u64) << 56\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 228,
        "module": "vstd::bytes",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": []
      },
      "lemma_auto_spec_u64_to_from_le_bytes": {
        "name": "lemma_auto_spec_u64_to_from_le_bytes",
        "type": "proof",
        "signature": "pub proof fn lemma_auto_spec_u64_to_from_le_bytes()\n    ensures\n        forall|x: u64|\n            #![trigger spec_u64_to_le_bytes(x)]",
        "ensures": [
          "forall|x: u64|\n            #![trigger spec_u64_to_le_bytes(x)]"
        ],
        "requires": [],
        "body": "{\n                &&& spec_u64_to_le_bytes(x).len() == 8\n                &&& spec_u64_from_le_bytes(spec_u64_to_le_bytes(x)) == x\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 243,
        "module": "vstd::bytes",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "len",
          "spec_u64_to_le_bytes",
          "spec_u64_from_le_bytes"
        ]
      },
      "spec_u64_to_le_bytes_to_open": {
        "name": "spec_u64_to_le_bytes_to_open",
        "type": "proof",
        "signature": "pub proof fn spec_u64_to_le_bytes_to_open(x: u64)\n    ensures\n        spec_u64_to_le_bytes(x) == spec_u64_to_le_bytes_open(x),",
        "ensures": [
          "spec_u64_to_le_bytes(x) == spec_u64_to_le_bytes_open(x)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 322,
        "module": "vstd::bytes",
        "keywords": [],
        "callees": []
      },
      "u64_from_le_bytes": {
        "name": "u64_from_le_bytes",
        "type": "exec",
        "signature": "pub exec fn u64_from_le_bytes(s: &[u8]) -> (x: u64)\n    requires\n        s@.len() == 8,\n    ensures\n        x == spec_u64_from_le_bytes(s@),",
        "ensures": [
          "x == spec_u64_from_le_bytes(s@)"
        ],
        "requires": [
          "s@.len() == 8"
        ],
        "body": "{\n    use core::convert::TryInto;\n    u64::from_le_bytes(s.try_into().unwrap())\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 328,
        "module": "vstd::bytes",
        "keywords": [
          "len"
        ],
        "callees": [
          "from_le_bytes",
          "try_into"
        ]
      },
      "u64_to_le_bytes": {
        "name": "u64_to_le_bytes",
        "type": "exec",
        "signature": "pub exec fn u64_to_le_bytes(x: u64) -> (s: alloc::vec::Vec<u8>)\n    ensures\n        s@ == spec_u64_to_le_bytes(x),\n        s@.len() == 8,",
        "ensures": [
          "s@ == spec_u64_to_le_bytes(x)",
          "s@.len() == 8"
        ],
        "requires": [],
        "body": "{\n    x.to_le_bytes().to_vec()\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 339,
        "module": "vstd::bytes",
        "keywords": [
          "Vec",
          "len"
        ],
        "callees": [
          "to_le_bytes",
          "to_vec"
        ]
      },
      "spec_u128_to_le_bytes": {
        "name": "spec_u128_to_le_bytes",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_u128_to_le_bytes(x: u128) -> Seq<u8>",
        "ensures": [],
        "requires": [],
        "body": "{\n    #[verusfmt::skip]\n    seq![\n        (x & 0xff) as u8,\n        ((x >> 8) & 0xff) as u8,\n        ((x >> 16) & 0xff) as u8,\n        ((x >> 24) & 0xff) as u8,\n        ((x >> 32) & 0xff) as u8,\n        ((x >> 40) & 0xff) as u8,\n        ((x >> 48) & 0xff) as u8,\n        ((x >> 56) & 0xff) as u8,\n        ((x >> 64) & 0xff) as u8,\n        ((x >> 72) & 0xff) as u8,\n        ((x >> 80) & 0xff) as u8,\n        ((x >> 88) & 0xff) as u8,\n        ((x >> 96) & 0xff) as u8,\n        ((x >> 104) & 0xff) as u8,\n        ((x >> 112) & 0xff) as u8,\n        ((x >> 120) & 0xff) as u8,\n    ]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 351,
        "module": "vstd::bytes",
        "keywords": [
          "Seq"
        ],
        "callees": []
      },
      "spec_u128_from_le_bytes": {
        "name": "spec_u128_from_le_bytes",
        "type": "closed_spec",
        "signature": "pub closed spec fn spec_u128_from_le_bytes(s: Seq<u8>) -> u128\n    recommends\n        s.len() == 16,",
        "ensures": [],
        "requires": [],
        "body": "{\n    #[verusfmt::skip]\n    (s[0] as u128) |\n    (s[1] as u128) << 8 |\n    (s[2] as u128) << 16 |\n    (s[3] as u128) << 24 |\n    (s[4] as u128) << 32 |\n    (s[5] as u128) << 40 |\n    (s[6] as u128) << 48 |\n    (s[7] as u128) << 56 |\n    (s[8] as u128) << 64 |\n    (s[9] as u128) << 72 |\n    (s[10] as u128) << 80 |\n    (s[11] as u128) << 88 |\n    (s[12] as u128) << 96 |\n    (s[13] as u128) << 104 |\n    (s[14] as u128) << 112 |\n    (s[15] as u128) << 120\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 372,
        "module": "vstd::bytes",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": []
      },
      "lemma_auto_spec_u128_to_from_le_bytes": {
        "name": "lemma_auto_spec_u128_to_from_le_bytes",
        "type": "proof",
        "signature": "pub proof fn lemma_auto_spec_u128_to_from_le_bytes()\n    ensures\n        forall|x: u128|",
        "ensures": [
          "forall|x: u128|"
        ],
        "requires": [],
        "body": "{\n                &&& #[trigger] spec_u128_to_le_bytes(x).len() == 16\n                &&& spec_u128_from_le_bytes(spec_u128_to_le_bytes(x)) == x\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 395,
        "module": "vstd::bytes",
        "keywords": [
          "forall"
        ],
        "callees": [
          "len",
          "spec_u128_to_le_bytes",
          "spec_u128_from_le_bytes"
        ]
      },
      "u128_from_le_bytes": {
        "name": "u128_from_le_bytes",
        "type": "exec",
        "signature": "pub exec fn u128_from_le_bytes(s: &[u8]) -> (x: u128)\n    requires\n        s@.len() == 16,\n    ensures\n        x == spec_u128_from_le_bytes(s@),",
        "ensures": [
          "x == spec_u128_from_le_bytes(s@)"
        ],
        "requires": [
          "s@.len() == 16"
        ],
        "body": "{\n    use core::convert::TryInto;\n    u128::from_le_bytes(s.try_into().unwrap())\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 515,
        "module": "vstd::bytes",
        "keywords": [
          "len"
        ],
        "callees": [
          "from_le_bytes",
          "try_into"
        ]
      },
      "u128_to_le_bytes": {
        "name": "u128_to_le_bytes",
        "type": "exec",
        "signature": "pub exec fn u128_to_le_bytes(x: u128) -> (s: alloc::vec::Vec<u8>)\n    ensures\n        s@ == spec_u128_to_le_bytes(x),\n        s@.len() == 16,",
        "ensures": [
          "s@ == spec_u128_to_le_bytes(x)",
          "s@.len() == 16"
        ],
        "requires": [],
        "body": "{\n    x.to_le_bytes().to_vec()\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 526,
        "module": "vstd::bytes",
        "keywords": [
          "Vec",
          "len"
        ],
        "callees": [
          "to_le_bytes",
          "to_vec"
        ]
      },
      "vstd::cell::id": {
        "name": "vstd::cell::id",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn id(&self) -> CellId",
        "ensures": [
          "pt.1@@ === pcell_points![ pt.0.id() => MemContents::Uninit ]"
        ],
        "requires": [],
        "body": "{\n        let p = PCell { ucell: UnsafeCell::new(MaybeUninit::uninit()) };\n        (p, Tracked::assume_new())\n    }",
        "doc_comment": "A unique ID for the cell.",
        "triggers": [],
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 195,
        "module": "vstd::cell",
        "keywords": [],
        "callees": [
          "uninit",
          "new",
          "assume_new"
        ]
      },
      "mem_contents": {
        "name": "vstd::cell::mem_contents",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn mem_contents(&self) -> MemContents<V>",
        "ensures": [],
        "requires": [],
        "body": "{\n        PointsToData { pcell: self.id(), value: option_from_mem_contents(self.mem_contents()) }\n    }",
        "doc_comment": "The contents of the cell, either unitialized or initialized to some `V`.",
        "triggers": [],
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 156,
        "module": "vstd::cell",
        "keywords": [],
        "callees": [
          "option_from_mem_contents",
          "id",
          "mem_contents"
        ]
      },
      "inv": {
        "name": "inv",
        "type": "closed_spec",
        "signature": "pub closed spec fn inv(&self, val: T) -> bool",
        "ensures": [],
        "requires": [],
        "body": "{\n        &&& self.possible_values@.contains(val)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 361,
        "module": "vstd::cell",
        "keywords": [],
        "callees": [
          "contains"
        ]
      },
      "all_spec_ensures": {
        "name": "all_spec_ensures",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn all_spec_ensures(r: Range<int>, p: spec_fn(int) -> bool)\n    ensures\n        #[trigger] r.all_spec(p) ==> (forall|i| r.start <= i < r.end ==> #[trigger] p(i)),\n    decreases r.end - r.start,",
        "ensures": [
          "#[trigger] r.all_spec(p) ==> (forall|i| r.start <= i < r.end ==> #[trigger] p(i))"
        ],
        "requires": [],
        "body": "{\n    if r.start >= r.end {\n    } else {\n        all_spec_ensures(r.start + 1..r.end, p);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "r.all_spec(p",
          "p(i"
        ],
        "file_path": "verus/source/vstd/compute.rs",
        "line_number": 27,
        "module": "vstd::compute",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "all_spec_ensures"
        ]
      },
      "axiom_proof_fn_requires": {
        "name": "axiom_proof_fn_requires",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_proof_fn_requires<\n    F,\n    ArgModes,\n    OutMode,\n    Args: core::marker::Tuple,\n    Output,\n>(f: FnProof<F, ArgModes, OutMode, Args, Output>, args: Args) where\n    F: ProofFnOnce,\n    F: ProofFnReqEnsAssoc,\n    <F as ProofFnReqEnsAssoc>::ReqEns: ProofFnReqEnsDef<Args, Output>,\n\n    ensures\n        #[trigger] f.requires(args) <==> <F as ProofFnReqEnsAssoc>::ReqEns::req(args),",
        "ensures": [
          "#[trigger] f.",
          "#[trigger] f."
        ],
        "requires": [
          "forall|args: Args| #[trigger] R::req(args) ==> f."
        ],
        "body": "{\n    axiom_proof_fn_requires,\n    axiom_proof_fn_ensures,\n}",
        "doc_comment": null,
        "triggers": [
          "f.",
          "f."
        ],
        "file_path": "verus/source/vstd/function.rs",
        "line_number": 77,
        "module": "vstd::function",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "axiom_proof_fn_ensures": {
        "name": "axiom_proof_fn_ensures",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_proof_fn_ensures<\n    F,\n    ArgModes,\n    OutMode,\n    Args: core::marker::Tuple,\n    Output,\n>(f: FnProof<F, ArgModes, OutMode, Args, Output>, args: Args, output: Output) where\n    F: ProofFnOnce,\n    F: ProofFnReqEnsAssoc,\n    <F as ProofFnReqEnsAssoc>::ReqEns: ProofFnReqEnsDef<Args, Output>,\n\n    ensures\n        #[trigger] f.ensures(args, output) <==> <F as ProofFnReqEnsAssoc>::ReqEns::ens(\n            args,\n            output,\n        ),",
        "ensures": [
          "#[trigger] f."
        ],
        "requires": [
          "forall|args: Args| #[trigger] R::req(args) ==> f."
        ],
        "body": "{\n    axiom_proof_fn_requires,\n    axiom_proof_fn_ensures,\n}",
        "doc_comment": null,
        "triggers": [
          "f."
        ],
        "file_path": "verus/source/vstd/function.rs",
        "line_number": 93,
        "module": "vstd::function",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "proof_fn_as_req_ens": {
        "name": "proof_fn_as_req_ens",
        "type": "axiom",
        "signature": "pub axiom fn proof_fn_as_req_ens<\n    R: ProofFnReqEnsDef<Args, Output>,\n    const USAGE: u8,\n    ReqEns,\n    const COPY: u8,\n    const SEND: u8,\n    const SYNC: u8,\n    ArgModes,\n    OutMode,\n    Args: core::marker::Tuple,\n    Output,\n>(\n    tracked f: FnProof<FOpts<USAGE, ReqEns, COPY, SEND, SYNC>, ArgModes, OutMode, Args, Output>,\n) -> tracked FnProof<FOpts<USAGE, RqEn<R>, COPY, SEND, SYNC>, ArgModes, OutMode, Args, Output>\n    requires\n        forall|args: Args| #[trigger] R::req(args) ==> f.requires(args),\n        forall|args: Args, output: Output|\n            f.ensures(args, output) ==> #[trigger] R::ens(args, output),",
        "ensures": [],
        "requires": [
          "forall|args: Args| #[trigger] R::req(args) ==> f."
        ],
        "body": "{\n    axiom_proof_fn_requires,\n    axiom_proof_fn_ensures,\n}",
        "doc_comment": "Retype a proof_fn, introducing `ReqEns<R>`",
        "triggers": [],
        "file_path": "verus/source/vstd/function.rs",
        "line_number": 112,
        "module": "vstd::function",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "spec_len": {
        "name": "vstd::hash_map::spec_len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_len(&self) -> usize",
        "ensures": [
          "result == self@.len()"
        ],
        "requires": [],
        "body": "{\n        self.m.len()\n    }",
        "doc_comment": "Returns the number of elements in the map.",
        "triggers": [],
        "file_path": "verus/source/vstd/hash_map.rs",
        "line_number": 87,
        "module": "vstd::hash_map",
        "keywords": [
          "len"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_hash_map_with_view_spec_len": {
        "name": "axiom_hash_map_with_view_spec_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_hash_map_with_view_spec_len<Key, Value>(\n    m: &HashMapWithView<Key, Value>,\n) where Key: View + Eq + Hash\n    ensures\n        #[trigger] m.spec_len() == m@.len(),",
        "ensures": [
          "#[trigger] m.spec_len() == m@.len()"
        ],
        "requires": [],
        "body": "{\n    m: HashMap<String, Value>,\n}",
        "doc_comment": null,
        "triggers": [
          "m.spec_len("
        ],
        "file_path": "verus/source/vstd/hash_map.rs",
        "line_number": 168,
        "module": "vstd::hash_map",
        "keywords": [
          "Map",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "vstd::hash_map::spec_len": {
        "name": "vstd::hash_map::spec_len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_len(&self) -> usize",
        "ensures": [
          "result == self@.len()"
        ],
        "requires": [],
        "body": "{\n        self.m.len()\n    }",
        "doc_comment": "Returns the number of elements in the map.",
        "triggers": [],
        "file_path": "verus/source/vstd/hash_map.rs",
        "line_number": 240,
        "module": "vstd::hash_map",
        "keywords": [
          "len"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_string_hash_map_spec_len": {
        "name": "axiom_string_hash_map_spec_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_string_hash_map_spec_len<Value>(m: &StringHashMap<Value>)\n    ensures\n        #[trigger] m.spec_len() == m@.len(),",
        "ensures": [
          "#[trigger] m.spec_len() == m@.len()"
        ],
        "requires": [],
        "body": "{\n    axiom_hash_map_with_view_spec_len,\n    axiom_string_hash_map_spec_len,\n}",
        "doc_comment": null,
        "triggers": [
          "m.spec_len("
        ],
        "file_path": "verus/source/vstd/hash_map.rs",
        "line_number": 321,
        "module": "vstd::hash_map",
        "keywords": [
          "Map",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "vstd::hash_set::spec_len": {
        "name": "vstd::hash_set::spec_len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_len(&self) -> usize",
        "ensures": [
          "result == self@.len()"
        ],
        "requires": [],
        "body": "{\n        self.m.len()\n    }",
        "doc_comment": "Returns the number of elements in the set.",
        "triggers": [],
        "file_path": "verus/source/vstd/hash_set.rs",
        "line_number": 231,
        "module": "vstd::hash_set",
        "keywords": [
          "len"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_hash_set_with_view_spec_len": {
        "name": "axiom_hash_set_with_view_spec_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_hash_set_with_view_spec_len<Key>(m: &HashSetWithView<Key>) where\n    Key: View + Eq + Hash,\n\n    ensures\n        #[trigger] m.spec_len() == m@.len(),",
        "ensures": [
          "#[trigger] m.spec_len() == m@.len()"
        ],
        "requires": [],
        "body": "{\n    m: HashSet<String>,\n}",
        "doc_comment": null,
        "triggers": [
          "m.spec_len("
        ],
        "file_path": "verus/source/vstd/hash_set.rs",
        "line_number": 160,
        "module": "vstd::hash_set",
        "keywords": [
          "Set",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_string_hash_set_spec_len": {
        "name": "axiom_string_hash_set_spec_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_string_hash_set_spec_len(m: &StringHashSet)\n    ensures\n        #[trigger] m.spec_len() == m@.len(),",
        "ensures": [
          "#[trigger] m.spec_len() == m@.len()"
        ],
        "requires": [],
        "body": "{\n    axiom_hash_set_with_view_spec_len,\n    axiom_string_hash_set_spec_len,\n}",
        "doc_comment": null,
        "triggers": [
          "m.spec_len("
        ],
        "file_path": "verus/source/vstd/hash_set.rs",
        "line_number": 303,
        "module": "vstd::hash_set",
        "keywords": [
          "Set",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "constant": {
        "name": "constant",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn constant(&self) -> K",
        "ensures": [],
        "requires": [],
        "body": "{\n                Pred::inv(self.constant(), v)\n            }",
        "doc_comment": "`.",
        "triggers": [],
        "file_path": "verus/source/vstd/invariant.rs",
        "line_number": 180,
        "module": "vstd::invariant",
        "keywords": [],
        "callees": [
          "constant",
          "inv"
        ]
      },
      "namespace": {
        "name": "namespace",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn namespace(&self) -> int",
        "ensures": [],
        "requires": [],
        "body": "{\n                Pred::inv(self.constant(), v)\n            }",
        "doc_comment": "Namespace the invariant was declared in.",
        "triggers": [],
        "file_path": "verus/source/vstd/invariant.rs",
        "line_number": 182,
        "module": "vstd::invariant",
        "keywords": [],
        "callees": [
          "constant",
          "inv"
        ]
      },
      "vstd::invariant::new": {
        "name": "vstd::invariant::new",
        "type": "axiom",
        "signature": "pub axiom fn new(k: K, tracked v: V, ns: int) -> (tracked i: $invariant<K, V, Pred>)\n                requires\n                    Pred::inv(k, v),\n                ensures\n                    i.constant() == k,\n                    i.namespace() == ns",
        "ensures": [
          "i.constant() == k",
          "i.namespace() == ns",
          "self.inv(v)",
          "opens_invariants [ self.namespace() ]"
        ],
        "requires": [
          "Pred::inv(k, v)"
        ],
        "body": "{\n//        let f = !r;\n//        f();\n//    }",
        "doc_comment": "` with constant `k`. initial stored (tracked) value `v`,\nand in the namespace `ns`.",
        "triggers": [],
        "file_path": "verus/source/vstd/invariant.rs",
        "line_number": 200,
        "module": "vstd::invariant",
        "keywords": [
          "invariant"
        ],
        "callees": [
          "f"
        ]
      },
      "into_inner": {
        "name": "into_inner",
        "type": "axiom",
        "signature": "pub axiom fn into_inner(#[verifier::proof] self) -> (tracked v: V)\n                ensures self.inv(v),\n                opens_invariants [ self.namespace() ]",
        "ensures": [
          "self.inv(v)",
          "opens_invariants [ self.namespace() ]"
        ],
        "requires": [],
        "body": "{\n//        let f = !r;\n//        f();\n//    }",
        "doc_comment": "`, returning the tracked value contained within.",
        "triggers": [],
        "file_path": "verus/source/vstd/invariant.rs",
        "line_number": 212,
        "module": "vstd::invariant",
        "keywords": [
          "invariant"
        ],
        "callees": [
          "f"
        ]
      },
      "spend_open_invariant_credit_in_proof": {
        "name": "spend_open_invariant_credit_in_proof",
        "type": "proof",
        "signature": "pub proof fn spend_open_invariant_credit_in_proof(tracked credit: OpenInvariantCredit)",
        "ensures": [],
        "requires": [],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/invariant.rs",
        "line_number": 279,
        "module": "vstd::invariant",
        "keywords": [
          "invariant"
        ],
        "callees": []
      },
      "lemma_obeys_cmp_spec": {
        "name": "lemma_obeys_cmp_spec",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_obeys_cmp_spec()\n                ensures\n                    #[trigger] obeys_cmp_spec::<$n>(),",
        "ensures": [
          "#[trigger] obeys_cmp_spec::<$n>()"
        ],
        "requires": [],
        "body": "{\n                broadcast use group_laws_eq;\n                reveal(obeys_eq_spec_properties);\n                reveal(obeys_partial_cmp_spec_properties);\n                reveal(obeys_cmp_partial_ord);\n                reveal(obeys_cmp_ord);\n                assert(obeys_eq_spec::<$n>());\n            }",
        "doc_comment": null,
        "triggers": [
          "obeys_cmp_spec::<$n>("
        ],
        "file_path": "verus/source/vstd/laws_cmp.rs",
        "line_number": 58,
        "module": "vstd::laws_cmp",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_option_obeys_cmp_spec": {
        "name": "lemma_option_obeys_cmp_spec",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_option_obeys_cmp_spec<T: Ord>()\n    requires\n        obeys_cmp_spec::<T>(),\n    ensures\n        #[trigger] obeys_cmp_spec::<Option<T>>(),",
        "ensures": [
          "#[trigger] obeys_cmp_spec::<Option<T>>()"
        ],
        "requires": [
          "obeys_cmp_spec::<T>()"
        ],
        "body": "{\n    broadcast use lemma_option_obeys_eq_spec;\n\n    assert(obeys_eq_spec::<Option<T>>());\n\n    assert(obeys_cmp_partial_ord::<Option<T>>() && obeys_cmp_ord::<Option<T>>()) by {\n        reveal(obeys_cmp_partial_ord);\n        reveal(obeys_cmp_ord);\n    }\n\n    assert(obeys_partial_cmp_spec_properties::<Option<T>>()) by {\n        reveal(obeys_cmp_partial_ord);\n        reveal(obeys_partial_cmp_spec_properties);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_cmp_spec::<Option<T>>("
        ],
        "file_path": "verus/source/vstd/laws_cmp.rs",
        "line_number": 98,
        "module": "vstd::laws_cmp",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "axiom_structural_obeys_concrete_eq": {
        "name": "axiom_structural_obeys_concrete_eq",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_structural_obeys_concrete_eq<T: PartialEq + Structural>()\n    requires\n        T::obeys_eq_spec(),\n        forall|x: T, y: T| x.eq_spec(&y) <==> x == y,\n    ensures\n        #[trigger] obeys_concrete_eq::<T>(),",
        "ensures": [
          "#[trigger] obeys_concrete_eq::<T>()"
        ],
        "requires": [
          "T::obeys_eq_spec()",
          "forall|x: T, y: T| x.eq_spec(&y) <==> x == y"
        ],
        "body": "{\n    reveal(obeys_concrete_eq);\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_concrete_eq::<T>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 38,
        "module": "vstd::laws_eq",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "lemma_obeys_eq_spec": {
        "name": "lemma_obeys_eq_spec",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_obeys_eq_spec()\n                ensures\n                    #[trigger] obeys_eq_spec::<$n>(),",
        "ensures": [
          "#[trigger] obeys_eq_spec::<$n>()"
        ],
        "requires": [],
        "body": "{\n                reveal(obeys_eq_spec_properties);\n            }",
        "doc_comment": null,
        "triggers": [
          "obeys_eq_spec::<$n>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 54,
        "module": "vstd::laws_eq",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_obeys_concrete_eq": {
        "name": "lemma_obeys_concrete_eq",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_obeys_concrete_eq()\n                ensures\n                    #[trigger] obeys_concrete_eq::<$n>(),",
        "ensures": [
          "#[trigger] obeys_concrete_eq::<$n>()"
        ],
        "requires": [],
        "body": "{\n                reveal(obeys_concrete_eq);\n            }",
        "doc_comment": null,
        "triggers": [
          "obeys_concrete_eq::<$n>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 61,
        "module": "vstd::laws_eq",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_obeys_view_eq": {
        "name": "lemma_obeys_view_eq",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_obeys_view_eq()\n                ensures\n                    #[trigger] obeys_view_eq::<$n>(),",
        "ensures": [
          "#[trigger] obeys_view_eq::<$n>()"
        ],
        "requires": [],
        "body": "{\n                reveal(obeys_view_eq);\n            }",
        "doc_comment": null,
        "triggers": [
          "obeys_view_eq::<$n>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 68,
        "module": "vstd::laws_eq",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_obeys_deep_eq": {
        "name": "lemma_obeys_deep_eq",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_obeys_deep_eq()\n                ensures\n                    #[trigger] obeys_deep_eq::<$n>(),",
        "ensures": [
          "#[trigger] obeys_deep_eq::<$n>()"
        ],
        "requires": [],
        "body": "{\n                reveal(obeys_deep_eq);\n            }",
        "doc_comment": null,
        "triggers": [
          "obeys_deep_eq::<$n>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 75,
        "module": "vstd::laws_eq",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_option_obeys_eq_spec": {
        "name": "lemma_option_obeys_eq_spec",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_option_obeys_eq_spec<T: PartialEq>()\n    requires\n        obeys_eq_spec::<T>(),\n    ensures\n        #[trigger] obeys_eq_spec::<Option<T>>(),",
        "ensures": [
          "#[trigger] obeys_eq_spec::<Option<T>>()"
        ],
        "requires": [
          "obeys_eq_spec::<T>()"
        ],
        "body": "{\n    reveal(obeys_eq_spec_properties);\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_eq_spec::<Option<T>>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 119,
        "module": "vstd::laws_eq",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_option_obeys_concrete_eq": {
        "name": "lemma_option_obeys_concrete_eq",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_option_obeys_concrete_eq<T: PartialEq>()\n    requires\n        obeys_concrete_eq::<T>(),\n    ensures\n        #[trigger] obeys_concrete_eq::<Option<T>>(),",
        "ensures": [
          "#[trigger] obeys_concrete_eq::<Option<T>>()"
        ],
        "requires": [
          "obeys_concrete_eq::<T>()"
        ],
        "body": "{\n    reveal(obeys_concrete_eq);\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_concrete_eq::<Option<T>>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 128,
        "module": "vstd::laws_eq",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_option_obeys_view_eq": {
        "name": "lemma_option_obeys_view_eq",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_option_obeys_view_eq<T: PartialEq + View>()\n    requires\n        obeys_concrete_eq::<T>(),\n    ensures\n        #[trigger] obeys_view_eq::<Option<T>>(),",
        "ensures": [
          "#[trigger] obeys_view_eq::<Option<T>>()"
        ],
        "requires": [
          "obeys_concrete_eq::<T>()"
        ],
        "body": "{\n    reveal(obeys_concrete_eq);\n    reveal(obeys_view_eq);\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_view_eq::<Option<T>>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 137,
        "module": "vstd::laws_eq",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "lemma_option_obeys_deep_eq": {
        "name": "lemma_option_obeys_deep_eq",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_option_obeys_deep_eq<T: PartialEq + DeepView>()\n    requires\n        obeys_deep_eq::<T>(),\n    ensures\n        #[trigger] obeys_deep_eq::<Option<T>>(),",
        "ensures": [
          "#[trigger] obeys_deep_eq::<Option<T>>()"
        ],
        "requires": [
          "obeys_deep_eq::<T>()"
        ],
        "body": "{\n    reveal(obeys_deep_eq);\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_deep_eq::<Option<T>>("
        ],
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 147,
        "module": "vstd::laws_eq",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "is_sized": {
        "name": "is_sized",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn is_sized<V: ?Sized>() -> bool",
        "ensures": [],
        "requires": [],
        "body": "{\n    size_of::<V>() as usize\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 24,
        "module": "vstd::layout",
        "keywords": [],
        "callees": []
      },
      "size_of": {
        "name": "size_of",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn size_of<V>() -> nat",
        "ensures": [],
        "requires": [],
        "body": "{\n    size_of::<V>() as usize\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 27,
        "module": "vstd::layout",
        "keywords": [],
        "callees": []
      },
      "align_of": {
        "name": "align_of",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn align_of<V>() -> nat",
        "ensures": [],
        "requires": [],
        "body": "{\n    size_of::<V>() as usize\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 29,
        "module": "vstd::layout",
        "keywords": [],
        "callees": []
      },
      "layout_for_type_is_valid": {
        "name": "layout_for_type_is_valid",
        "type": "exec",
        "signature": "pub exec fn layout_for_type_is_valid<V>()\n    ensures\n        valid_layout(size_of::<V>() as usize, align_of::<V>() as usize),\n        size_of::<V>() as usize as nat == size_of::<V>(),\n        align_of::<V>() as usize as nat == align_of::<V>(),\n        align_of::<V>() != 0,\n        size_of::<V>() % align_of::<V>() == 0,\n    opens_invariants none\n    no_unwind",
        "ensures": [
          "valid_layout(size_of::<V>() as usize, align_of::<V>() as usize)",
          "size_of::<V>() as usize as nat == size_of::<V>()",
          "align_of::<V>() as usize as nat == align_of::<V>()",
          "align_of::<V>() != 0",
          "size_of::<V>() % align_of::<V>() == 0",
          "opens_invariants none\n    no_unwind"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Lemma to learn that the (size, alignment) of a type is a valid \"layout\".\nSee [`valid_layout`] for the exact conditions.\n\nAlso exports that size is a multiple of alignment ([Reference](https://doc.rust-lang.org/reference/type-layout.html#r-layout.properties.size)).\n\nNote that, unusually for a lemma, this is an `exec`-mode function. (This is necessary to\nensure that the types are really compilable, as ghost code can reason about \"virtual\" types\nthat exceed these bounds.) Despite being `exec`-mode, it is a no-op.",
        "triggers": [],
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 76,
        "module": "vstd::layout",
        "keywords": [
          "invariant"
        ],
        "callees": []
      },
      "layout_of_primitives": {
        "name": "layout_of_primitives",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn layout_of_primitives()\n    ensures\n        #![trigger size_of::<bool>()]\n        #![trigger size_of::<char>()]\n        #![trigger size_of::<u8>()]\n        #![trigger size_of::<i8>()]\n        #![trigger size_of::<u16>()]\n        #![trigger size_of::<i16>()]\n        #![trigger size_of::<u32>()]\n        #![trigger size_of::<i32>()]\n        #![trigger size_of::<u64>()]\n        #![trigger size_of::<i64>()]\n        #![trigger size_of::<usize>()]\n        #![trigger size_of::<isize>()]\n        size_of::<bool>() == 1,\n        size_of::<char>() == 4,\n        size_of::<u8>() == size_of::<i8>() == 1,\n        size_of::<u16>() == size_of::<i16>() == 2,\n        size_of::<u32>() == size_of::<i32>() == 4,\n        size_of::<u64>() == size_of::<i64>() == 8,\n        size_of::<u128>() == size_of::<i128>() == 16,\n        size_of::<usize>() == size_of::<isize>(),\n        size_of::<usize>() * 8 == usize::BITS,",
        "ensures": [
          "#![trigger size_of::<bool>()]\n        #![trigger size_of::<char>()]\n        #![trigger size_of::<u8>()]\n        #![trigger size_of::<i8>()]\n        #![trigger size_of::<u16>()]\n        #![trigger size_of::<i16>()]\n        #![trigger size_of::<u32>()]\n        #![trigger size_of::<i32>()]\n        #![trigger size_of::<u64>()]\n        #![trigger size_of::<i64>()]\n        #![trigger size_of::<usize>()]\n        #![trigger size_of::<isize>()]\n        size_of::<bool>() == 1",
          "size_of::<char>() == 4",
          "size_of::<u8>() == size_of::<i8>() == 1",
          "size_of::<u16>() == size_of::<i16>() == 2",
          "size_of::<u32>() == size_of::<i32>() == 4",
          "size_of::<u64>() == size_of::<i64>() == 8",
          "size_of::<u128>() == size_of::<i128>() == 16",
          "size_of::<usize>() == size_of::<isize>()",
          "size_of::<usize>() * 8 == usize::BITS",
          "#![trigger size_of::<()>()]\n        #![trigger align_of::<()>()]\n        size_of::<()>() == 0",
          "align_of::<()>() == 1",
          "#![trigger size_of::<*mut T>()]\n        #![trigger size_of::<*const T>()]\n        #![trigger size_of::<&T>()]\n        #![trigger align_of::<*mut T>()]\n        #![trigger align_of::<*const T>()]\n        #![trigger align_of::<&T>()]\n        size_of::<*mut T>() == size_of::<*const T>() == size_of::<&T>()",
          "align_of::<*mut T>() == align_of::<*const T>() == align_of::<&T>()",
          "#![trigger size_of::<*mut T>()]\n        #![trigger align_of::<*mut T>()]\n        size_of::<*mut T>() == size_of::<usize>()",
          "align_of::<*mut T>() == align_of::<usize>()"
        ],
        "requires": [],
        "body": "{\n    layout_of_primitives,\n    layout_of_unit_tuple,\n    layout_of_references_and_pointers,\n    layout_of_references_and_pointers_for_sized_types,\n}",
        "doc_comment": "Size of primitives ([Reference](https://doc.rust-lang.org/reference/type-layout.html#r-layout.primitive)).\n\nNote that alignment may be platform specific; if you need to use alignment, use\n[Verus's global directive](https://verus-lang.github.io/verus/guide/reference-global.html).",
        "triggers": [],
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 98,
        "module": "vstd::layout",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "layout_of_unit_tuple": {
        "name": "layout_of_unit_tuple",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn layout_of_unit_tuple()\n    ensures\n        #![trigger size_of::<()>()]\n        #![trigger align_of::<()>()]\n        size_of::<()>() == 0,\n        align_of::<()>() == 1,",
        "ensures": [
          "#![trigger size_of::<()>()]\n        #![trigger align_of::<()>()]\n        size_of::<()>() == 0",
          "align_of::<()>() == 1",
          "#![trigger size_of::<*mut T>()]\n        #![trigger size_of::<*const T>()]\n        #![trigger size_of::<&T>()]\n        #![trigger align_of::<*mut T>()]\n        #![trigger align_of::<*const T>()]\n        #![trigger align_of::<&T>()]\n        size_of::<*mut T>() == size_of::<*const T>() == size_of::<&T>()",
          "align_of::<*mut T>() == align_of::<*const T>() == align_of::<&T>()",
          "#![trigger size_of::<*mut T>()]\n        #![trigger align_of::<*mut T>()]\n        size_of::<*mut T>() == size_of::<usize>()",
          "align_of::<*mut T>() == align_of::<usize>()"
        ],
        "requires": [],
        "body": "{\n    layout_of_primitives,\n    layout_of_unit_tuple,\n    layout_of_references_and_pointers,\n    layout_of_references_and_pointers_for_sized_types,\n}",
        "doc_comment": "Size and alignment of the unit tuple ([Reference](https://doc.rust-lang.org/reference/type-layout.html#r-layout.tuple.unit)).",
        "triggers": [],
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 127,
        "module": "vstd::layout",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "layout_of_references_and_pointers": {
        "name": "layout_of_references_and_pointers",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn layout_of_references_and_pointers<T: ?Sized>()\n    ensures\n        #![trigger size_of::<*mut T>()]\n        #![trigger size_of::<*const T>()]\n        #![trigger size_of::<&T>()]\n        #![trigger align_of::<*mut T>()]\n        #![trigger align_of::<*const T>()]\n        #![trigger align_of::<&T>()]\n        size_of::<*mut T>() == size_of::<*const T>() == size_of::<&T>(),\n        align_of::<*mut T>() == align_of::<*const T>() == align_of::<&T>(),",
        "ensures": [
          "#![trigger size_of::<*mut T>()]\n        #![trigger size_of::<*const T>()]\n        #![trigger size_of::<&T>()]\n        #![trigger align_of::<*mut T>()]\n        #![trigger align_of::<*const T>()]\n        #![trigger align_of::<&T>()]\n        size_of::<*mut T>() == size_of::<*const T>() == size_of::<&T>()",
          "align_of::<*mut T>() == align_of::<*const T>() == align_of::<&T>()",
          "#![trigger size_of::<*mut T>()]\n        #![trigger align_of::<*mut T>()]\n        size_of::<*mut T>() == size_of::<usize>()",
          "align_of::<*mut T>() == align_of::<usize>()"
        ],
        "requires": [],
        "body": "{\n    layout_of_primitives,\n    layout_of_unit_tuple,\n    layout_of_references_and_pointers,\n    layout_of_references_and_pointers_for_sized_types,\n}",
        "doc_comment": "Pointers and references have the same layout. Mutability of the pointer or reference does not change the layout ([Reference](https://doc.rust-lang.org/reference/type-layout.html#r-layout.pointer.intro)).",
        "triggers": [],
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 136,
        "module": "vstd::layout",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "layout_of_references_and_pointers_for_sized_types": {
        "name": "layout_of_references_and_pointers_for_sized_types",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn layout_of_references_and_pointers_for_sized_types<T: Sized>()\n    ensures\n        #![trigger size_of::<*mut T>()]\n        #![trigger align_of::<*mut T>()]\n        size_of::<*mut T>() == size_of::<usize>(),\n        align_of::<*mut T>() == align_of::<usize>(),",
        "ensures": [
          "#![trigger size_of::<*mut T>()]\n        #![trigger align_of::<*mut T>()]\n        size_of::<*mut T>() == size_of::<usize>()",
          "align_of::<*mut T>() == align_of::<usize>()"
        ],
        "requires": [],
        "body": "{\n    layout_of_primitives,\n    layout_of_unit_tuple,\n    layout_of_references_and_pointers,\n    layout_of_references_and_pointers_for_sized_types,\n}",
        "doc_comment": "Pointers to sized types have the same size and alignment as usize\n([Reference](https://doc.rust-lang.org/reference/type-layout.html#r-layout.pointer.intro)).",
        "triggers": [],
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 149,
        "module": "vstd::layout",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "empty": {
        "name": "vstd::map::empty",
        "type": "closed_spec",
        "signature": "pub closed spec fn empty() -> Map<K, V>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Map { mapping: |k| None }\n    }",
        "doc_comment": "An empty map.",
        "triggers": [],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 36,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "empty"
        ],
        "callees": []
      },
      "dom": {
        "name": "vstd::map::dom",
        "type": "closed_spec",
        "signature": "pub closed spec fn dom(self) -> Set<K>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set::new(|k| (self.mapping)(k) is Some)\n    }",
        "doc_comment": "The domain of the map as a set.",
        "triggers": [],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 52,
        "module": "vstd::map",
        "keywords": [
          "Set"
        ],
        "callees": [
          "new"
        ]
      },
      "index": {
        "name": "vstd::map::index",
        "type": "closed_spec",
        "signature": "pub closed spec fn index(self, key: K) -> V\n        recommends\n            self.dom().contains(key),",
        "ensures": [],
        "requires": [],
        "body": "{\n        (self.mapping)(key)->Some_0\n    }",
        "doc_comment": "Gets the value that the given key `key` maps to.\nFor keys not in the domain, the result is meaningless and arbitrary.",
        "triggers": [],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 57,
        "module": "vstd::map",
        "keywords": [
          "contains"
        ],
        "callees": []
      },
      "insert": {
        "name": "vstd::map::insert",
        "type": "closed_spec",
        "signature": "pub closed spec fn insert(self, key: K, value: V) -> Map<K, V>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Map {\n            mapping: |k|\n                if k == key {\n                    Some(value)\n                } else {\n                    (self.mapping)(k)\n                },\n        }\n    }",
        "doc_comment": "Inserts the given (key, value) pair into the map.\n\nIf the key is already present from the map, then its existing value is overwritten\nby the new value.",
        "triggers": [],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 75,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "insert"
        ],
        "callees": [
          "ome"
        ]
      },
      "remove": {
        "name": "vstd::map::remove",
        "type": "closed_spec",
        "signature": "pub closed spec fn remove(self, key: K) -> Map<K, V>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Map {\n            mapping: |k|\n                if k == key {\n                    None\n                } else {\n                    (self.mapping)(k)\n                },\n        }\n    }",
        "doc_comment": "Removes the given key and its associated value from the map.\n\nIf the key is already absent from the map, then the map is left unchanged.",
        "triggers": [],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 90,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "remove"
        ],
        "callees": []
      },
      "tracked_empty": {
        "name": "vstd::map::tracked_empty",
        "type": "axiom",
        "signature": "pub axiom fn tracked_empty() -> (tracked out_v: Self)\n        ensures\n            out_v == Map::<K, V>::empty(),",
        "ensures": [
          "out_v == Map::<K, V>::empty()",
          "*self == Map::insert(*old(self), key, value)",
          "*self == Map::remove(*old(self), key)",
          "v == old(self)[key]",
          "*v === self.index(key)",
          "forall|j| #[trigger] new_map.dom().contains(j) <==> key_map.dom().contains(j)",
          "forall|j|\n                key_map.dom().contains(j) ==> new_map.dom().contains(j) && #[trigger] new_map.index(\n                    j",
          ") == old_map.index(key_map.index(j))",
          "self == old(self).remove_keys(keys)",
          "out_map == old(self).restrict(keys)",
          "*self == old(self).union_prefer_right(right)",
          "#[trigger](",
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "old(self).dom().contains(key)",
          "self.dom().contains(key)",
          "forall|j|\n                #![auto]\n                key_map.dom().contains(j) ==> old_map.dom().contains(key_map.index(j))",
          "forall|j1, j2|\n                #![auto]\n                !equal(j1, j2) && key_map.dom().contains(j1) && key_map.dom().contains(j2)\n                    ==> !equal(key_map.index(j1), key_map.index(j2))",
          "keys.subset_of(old(self).dom())",
          "m.dom().contains(key)",
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "new_map.dom(",
          "new_map.index(",
          "(",
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 109,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "empty",
          "finite",
          "forall",
          "insert",
          "remove",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "tracked_insert": {
        "name": "vstd::map::tracked_insert",
        "type": "axiom",
        "signature": "pub axiom fn tracked_insert(tracked &mut self, key: K, tracked value: V)\n        ensures\n            *self == Map::insert(*old(self), key, value),",
        "ensures": [
          "*self == Map::insert(*old(self), key, value)",
          "*self == Map::remove(*old(self), key)",
          "v == old(self)[key]",
          "*v === self.index(key)",
          "forall|j| #[trigger] new_map.dom().contains(j) <==> key_map.dom().contains(j)",
          "forall|j|\n                key_map.dom().contains(j) ==> new_map.dom().contains(j) && #[trigger] new_map.index(\n                    j",
          ") == old_map.index(key_map.index(j))",
          "self == old(self).remove_keys(keys)",
          "out_map == old(self).restrict(keys)",
          "*self == old(self).union_prefer_right(right)",
          "#[trigger](",
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "old(self).dom().contains(key)",
          "self.dom().contains(key)",
          "forall|j|\n                #![auto]\n                key_map.dom().contains(j) ==> old_map.dom().contains(key_map.index(j))",
          "forall|j1, j2|\n                #![auto]\n                !equal(j1, j2) && key_map.dom().contains(j1) && key_map.dom().contains(j2)\n                    ==> !equal(key_map.index(j1), key_map.index(j2))",
          "keys.subset_of(old(self).dom())",
          "m.dom().contains(key)",
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "new_map.dom(",
          "new_map.index(",
          "(",
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 114,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "empty",
          "finite",
          "forall",
          "insert",
          "remove",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "tracked_remove": {
        "name": "vstd::map::tracked_remove",
        "type": "axiom",
        "signature": "pub axiom fn tracked_remove(tracked &mut self, key: K) -> (tracked v: V)\n        requires\n            old(self).dom().contains(key),\n        ensures\n            *self == Map::remove(*old(self), key),\n            v == old(self)[key],",
        "ensures": [
          "*self == Map::remove(*old(self), key)",
          "v == old(self)[key]",
          "*v === self.index(key)",
          "forall|j| #[trigger] new_map.dom().contains(j) <==> key_map.dom().contains(j)",
          "forall|j|\n                key_map.dom().contains(j) ==> new_map.dom().contains(j) && #[trigger] new_map.index(\n                    j",
          ") == old_map.index(key_map.index(j))",
          "self == old(self).remove_keys(keys)",
          "out_map == old(self).restrict(keys)",
          "*self == old(self).union_prefer_right(right)",
          "#[trigger](",
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "old(self).dom().contains(key)",
          "self.dom().contains(key)",
          "forall|j|\n                #![auto]\n                key_map.dom().contains(j) ==> old_map.dom().contains(key_map.index(j))",
          "forall|j1, j2|\n                #![auto]\n                !equal(j1, j2) && key_map.dom().contains(j1) && key_map.dom().contains(j2)\n                    ==> !equal(key_map.index(j1), key_map.index(j2))",
          "keys.subset_of(old(self).dom())",
          "m.dom().contains(key)",
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": "todo fill in documentation",
        "triggers": [
          "new_map.dom(",
          "new_map.index(",
          "(",
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 119,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "empty",
          "finite",
          "forall",
          "remove",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "tracked_borrow": {
        "name": "vstd::map::tracked_borrow",
        "type": "axiom",
        "signature": "pub axiom fn tracked_borrow(tracked &self, key: K) -> (tracked v: &V)\n        requires\n            self.dom().contains(key),\n        ensures\n            *v === self.index(key),",
        "ensures": [
          "*v === self.index(key)",
          "forall|j| #[trigger] new_map.dom().contains(j) <==> key_map.dom().contains(j)",
          "forall|j|\n                key_map.dom().contains(j) ==> new_map.dom().contains(j) && #[trigger] new_map.index(\n                    j",
          ") == old_map.index(key_map.index(j))",
          "self == old(self).remove_keys(keys)",
          "out_map == old(self).restrict(keys)",
          "*self == old(self).union_prefer_right(right)",
          "#[trigger](",
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "self.dom().contains(key)",
          "forall|j|\n                #![auto]\n                key_map.dom().contains(j) ==> old_map.dom().contains(key_map.index(j))",
          "forall|j1, j2|\n                #![auto]\n                !equal(j1, j2) && key_map.dom().contains(j1) && key_map.dom().contains(j2)\n                    ==> !equal(key_map.index(j1), key_map.index(j2))",
          "keys.subset_of(old(self).dom())",
          "m.dom().contains(key)",
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "new_map.dom(",
          "new_map.index(",
          "(",
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 128,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "empty",
          "finite",
          "forall",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "tracked_map_keys": {
        "name": "tracked_map_keys",
        "type": "axiom",
        "signature": "pub axiom fn tracked_map_keys<J>(\n        tracked old_map: Map<K, V>,\n        key_map: Map<J, K>,\n    ) -> (tracked new_map: Map<J, V>)\n        requires\n            forall|j|\n                #![auto]\n                key_map.dom().contains(j) ==> old_map.dom().contains(key_map.index(j)),\n            forall|j1, j2|\n                #![auto]\n                !equal(j1, j2) && key_map.dom().contains(j1) && key_map.dom().contains(j2)\n                    ==> !equal(key_map.index(j1), key_map.index(j2)),\n        ensures\n            forall|j| #[trigger] new_map.dom().contains(j) <==> key_map.dom().contains(j),\n            forall|j|\n                key_map.dom().contains(j) ==> new_map.dom().contains(j) && #[trigger] new_map.index(\n                    j,\n                ) == old_map.index(key_map.index(j)),",
        "ensures": [
          "forall|j| #[trigger] new_map.dom().contains(j) <==> key_map.dom().contains(j)",
          "forall|j|\n                key_map.dom().contains(j) ==> new_map.dom().contains(j) && #[trigger] new_map.index(\n                    j",
          ") == old_map.index(key_map.index(j))",
          "self == old(self).remove_keys(keys)",
          "out_map == old(self).restrict(keys)",
          "*self == old(self).union_prefer_right(right)",
          "#[trigger](",
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "forall|j|\n                #![auto]\n                key_map.dom().contains(j) ==> old_map.dom().contains(key_map.index(j))",
          "forall|j1, j2|\n                #![auto]\n                !equal(j1, j2) && key_map.dom().contains(j1) && key_map.dom().contains(j2)\n                    ==> !equal(key_map.index(j1), key_map.index(j2))",
          "keys.subset_of(old(self).dom())",
          "m.dom().contains(key)",
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "new_map.dom(",
          "new_map.index(",
          "(",
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 135,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "empty",
          "finite",
          "forall",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "tracked_remove_keys": {
        "name": "tracked_remove_keys",
        "type": "axiom",
        "signature": "pub axiom fn tracked_remove_keys(tracked &mut self, keys: Set<K>) -> (tracked out_map: Map<\n        K,\n        V,\n    >)\n        requires\n            keys.subset_of(old(self).dom()),\n        ensures\n            self == old(self).remove_keys(keys),\n            out_map == old(self).restrict(keys),",
        "ensures": [
          "self == old(self).remove_keys(keys)",
          "out_map == old(self).restrict(keys)",
          "*self == old(self).union_prefer_right(right)",
          "#[trigger](",
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "keys.subset_of(old(self).dom())",
          "m.dom().contains(key)",
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "(",
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 155,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "empty",
          "finite",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "tracked_union_prefer_right": {
        "name": "tracked_union_prefer_right",
        "type": "axiom",
        "signature": "pub axiom fn tracked_union_prefer_right(tracked &mut self, right: Self)\n        ensures\n            *self == old(self).union_prefer_right(right),",
        "ensures": [
          "*self == old(self).union_prefer_right(right)",
          "#[trigger](",
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "m.dom().contains(key)",
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "(",
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 166,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "empty",
          "finite",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "axiom_map_index_decreases": {
        "name": "axiom_map_index_decreases",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_map_index_decreases<K, V>(m: Map<K, V>, key: K)\n    requires\n        m.dom().contains(key),\n    ensures\n        #[trigger](decreases_to!(m => m[key]))",
        "ensures": [
          "#[trigger](",
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "m.dom().contains(key)",
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "(",
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 175,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "decreases",
          "empty",
          "finite",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "axiom_map_index_decreases_finite": {
        "name": "axiom_map_index_decreases_finite",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_map_index_decreases_finite<K, V>(m: Map<K, V>, key: K)\n    requires\n        m.dom().finite(),\n        m.dom().contains(key),\n    ensures\n        #[trigger] (decreases_to!(m => m[key])),",
        "ensures": [
          "#[trigger] (",
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "m.dom().finite()",
          "m.dom().contains(key)",
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "(",
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 181,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "decreases",
          "empty",
          "finite",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "axiom_map_index_decreases_infinite": {
        "name": "axiom_map_index_decreases_infinite",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_map_index_decreases_infinite<K, V>(m: Map<K, V>, key: K)\n    requires\n        m.dom().contains(key),\n    ensures\n        #[trigger] is_smaller_than_recursive_function_field(m[key], m),",
        "ensures": [
          "#[trigger] is_smaller_than_recursive_function_field(m[key], m)",
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [
          "m.dom().contains(key)"
        ],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": null,
        "triggers": [
          "is_smaller_than_recursive_function_field(m[key]",
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 192,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "contains",
          "decreases",
          "empty",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "axiom_map_empty": {
        "name": "axiom_map_empty",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_map_empty<K, V>()\n    ensures\n        #[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty(),",
        "ensures": [
          "#[trigger] Map::<K, V>::empty().dom() == Set::<K>::empty()"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(Set::new(|k: K| (|k| None::<V>)(k) is Some) == Set::<K>::empty());\n}",
        "doc_comment": "The domain of the empty map is the empty set",
        "triggers": [
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 198,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "Set",
          "empty",
          "trigger"
        ],
        "callees": [
          "new",
          "empty"
        ]
      },
      "axiom_map_insert_domain": {
        "name": "axiom_map_insert_domain",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_map_insert_domain<K, V>(m: Map<K, V>, key: K, value: V)\n    ensures\n        #[trigger] m.insert(key, value).dom() == m.dom().insert(key),",
        "ensures": [
          "#[trigger] m.insert(key, value).dom() == m.dom().insert(key)"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(m.insert(key, value).dom() =~= m.dom().insert(key));\n}",
        "doc_comment": "The domain of a map after inserting a key-value pair is equivalent to inserting the key into\nthe original map's domain set.",
        "triggers": [
          "m.insert(key"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 208,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "insert",
          "trigger"
        ],
        "callees": [
          "insert",
          "dom"
        ]
      },
      "axiom_map_insert_same": {
        "name": "axiom_map_insert_same",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_map_insert_same<K, V>(m: Map<K, V>, key: K, value: V)\n    ensures\n        #[trigger] m.insert(key, value)[key] == value,",
        "ensures": [
          "#[trigger] m.insert(key, value)[key] == value"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Inserting `value` at `key` in `m` results in a map that maps `key` to `value`",
        "triggers": [
          "m.insert(key"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 219,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "axiom_map_insert_different": {
        "name": "axiom_map_insert_different",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_map_insert_different<K, V>(m: Map<K, V>, key1: K, key2: K, value: V)\n    requires\n        key1 != key2,\n    ensures\n        #[trigger] m.insert(key2, value)[key1] == m[key1],",
        "ensures": [
          "#[trigger] m.insert(key2, value)[key1] == m[key1]"
        ],
        "requires": [
          "key1 != key2"
        ],
        "body": "{\n}",
        "doc_comment": "Inserting `value` at `key2` does not change the value mapped to by any other keys in `m`",
        "triggers": [
          "m.insert(key2"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 226,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "axiom_map_remove_domain": {
        "name": "axiom_map_remove_domain",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_map_remove_domain<K, V>(m: Map<K, V>, key: K)\n    ensures\n        #[trigger] m.remove(key).dom() == m.dom().remove(key),",
        "ensures": [
          "#[trigger] m.remove(key).dom() == m.dom().remove(key)"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(m.remove(key).dom() =~= m.dom().remove(key));\n}",
        "doc_comment": "The domain of a map after removing a key-value pair is equivalent to removing the key from\nthe original map's domain set.",
        "triggers": [
          "m.remove(key"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 235,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "remove",
          "trigger"
        ],
        "callees": [
          "dom",
          "remove"
        ]
      },
      "axiom_map_remove_different": {
        "name": "axiom_map_remove_different",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_map_remove_different<K, V>(m: Map<K, V>, key1: K, key2: K)\n    requires\n        key1 != key2,\n    ensures\n        #[trigger] m.remove(key2)[key1] == m[key1],",
        "ensures": [
          "#[trigger] m.remove(key2)[key1] == m[key1]"
        ],
        "requires": [
          "key1 != key2"
        ],
        "body": "{\n}",
        "doc_comment": "Removing a key-value pair from a map does not change the value mapped to by\nany other keys in the map.",
        "triggers": [
          "m.remove(key2"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 246,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "remove",
          "trigger"
        ],
        "callees": []
      },
      "axiom_map_ext_equal": {
        "name": "axiom_map_ext_equal",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_map_ext_equal<K, V>(m1: Map<K, V>, m2: Map<K, V>)\n    ensures\n        #[trigger] (m1 =~= m2) <==>",
        "ensures": [
          "#[trigger] (m1 =~= m2) <==>"
        ],
        "requires": [],
        "body": "{\n            &&& m1.dom() =~= m2.dom()\n            &&& forall|k: K| #![auto] m1.dom().contains(k) ==> m1[k] == m2[k]\n        }",
        "doc_comment": "Two maps are equivalent if their domains are equivalent and every key in their domains map to the same value.",
        "triggers": [
          "(m1 =~= m2"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 256,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "dom",
          "contains"
        ]
      },
      "axiom_map_ext_equal_deep": {
        "name": "axiom_map_ext_equal_deep",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_map_ext_equal_deep<K, V>(m1: Map<K, V>, m2: Map<K, V>)\n    ensures\n        #[trigger] (m1 =~~= m2) <==>",
        "ensures": [
          "#[trigger] (m1 =~~= m2) <==>"
        ],
        "requires": [],
        "body": "{\n            &&& m1.dom() =~~= m2.dom()\n            &&& forall|k: K| #![auto] m1.dom().contains(k) ==> m1[k] =~~= m2[k]\n        }",
        "doc_comment": null,
        "triggers": [
          "(m1 =~~= m2"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 286,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "dom",
          "contains"
        ]
      },
      "tracked_map_keys_in_place": {
        "name": "tracked_map_keys_in_place",
        "type": "proof",
        "signature": "pub proof fn tracked_map_keys_in_place(\n        #[verifier::proof]\n        &mut self,\n        key_map: Map<K, K>,\n    )\n        requires\n            forall|j|\n                #![auto]\n                key_map.dom().contains(j) ==> old(self).dom().contains(key_map.index(j)),\n            forall|j1, j2|\n                #![auto]\n                j1 != j2 && key_map.dom().contains(j1) && key_map.dom().contains(j2)\n                    ==> key_map.index(j1) != key_map.index(j2),\n        ensures\n            forall|j| #[trigger] self.dom().contains(j) == key_map.dom().contains(j),\n            forall|j|\n                key_map.dom().contains(j) ==> self.dom().contains(j) && #[trigger] self.index(j)\n                    == old(self).index(key_map.index(j)),",
        "ensures": [
          "forall|j| #[trigger] self.dom().contains(j) == key_map.dom().contains(j)",
          "forall|j|\n                key_map.dom().contains(j) ==> self.dom().contains(j) && #[trigger] self.index(j)\n                    == old(self).index(key_map.index(j))"
        ],
        "requires": [
          "forall|j|\n                #![auto]\n                key_map.dom().contains(j) ==> old(self).dom().contains(key_map.index(j))",
          "forall|j1, j2|\n                #![auto]\n                j1 != j2 && key_map.dom().contains(j1) && key_map.dom().contains(j2)\n                    ==> key_map.index(j1) != key_map.index(j2)"
        ],
        "body": "{\n        #[verifier::proof]\n        let mut tmp = Self::tracked_empty();\n        super::modes::tracked_swap(&mut tmp, self);\n        #[verifier::proof]\n        let mut tmp = Self::tracked_map_keys(tmp, key_map);\n        super::modes::tracked_swap(&mut tmp, self);\n    }",
        "doc_comment": null,
        "triggers": [
          "self.dom(",
          "self.index(j"
        ],
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 432,
        "module": "vstd::map",
        "keywords": [
          "Map",
          "contains",
          "forall",
          "trigger"
        ],
        "callees": [
          "tracked_swap",
          "tracked_empty",
          "tracked_map_keys"
        ]
      },
      "lemma_remove_key_len": {
        "name": "lemma_remove_key_len",
        "type": "proof",
        "signature": "pub proof fn lemma_remove_key_len(self, key: K)\n        requires\n            self.dom().contains(key),\n            self.dom().finite(),\n        ensures\n            self.dom().len() == 1 + self.remove(key).dom().len(),",
        "ensures": [
          "self.dom().len() == 1 + self.remove(key).dom().len()"
        ],
        "requires": [
          "self.dom().contains(key)",
          "self.dom().finite()"
        ],
        "body": "{\n    }",
        "doc_comment": "Removing a key from a map that previously contained that key decreases\nthe map's length by one",
        "triggers": [],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 200,
        "module": "vstd::map_lib",
        "keywords": [
          "contains",
          "finite",
          "len",
          "remove"
        ],
        "callees": []
      },
      "lemma_remove_equivalency": {
        "name": "lemma_remove_equivalency",
        "type": "proof",
        "signature": "pub proof fn lemma_remove_equivalency(self, key: K)\n        ensures\n            self.remove(key).dom() == self.dom().remove(key),",
        "ensures": [
          "self.remove(key).dom() == self.dom().remove(key)"
        ],
        "requires": [],
        "body": "{\n    }",
        "doc_comment": "The domain of a map after removing a key is equivalent to removing the key from\nthe domain of the original map.",
        "triggers": [],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 210,
        "module": "vstd::map_lib",
        "keywords": [
          "remove"
        ],
        "callees": []
      },
      "lemma_remove_keys_len": {
        "name": "lemma_remove_keys_len",
        "type": "proof",
        "signature": "pub proof fn lemma_remove_keys_len(self, keys: Set<K>)\n        requires\n            forall|k: K| #[trigger] keys.contains(k) ==> self.contains_key(k),\n            keys.finite(),\n            self.dom().finite(),\n        ensures\n            self.remove_keys(keys).dom().len() == self.dom().len() - keys.len(),\n        decreases keys.len(),",
        "ensures": [
          "self.remove_keys(keys).dom().len() == self.dom().len() - keys.len()"
        ],
        "requires": [
          "forall|k: K| #[trigger] keys.contains(k) ==> self.contains_key(k)",
          "keys.finite()",
          "self.dom().finite()"
        ],
        "body": "{\n        broadcast use group_set_properties;\n\n        if keys.len() > 0 {\n            let key = keys.choose();\n            let val = self[key];\n            self.remove(key).lemma_remove_keys_len(keys.remove(key));\n            assert(self.remove(key).remove_keys(keys.remove(key)) =~= self.remove_keys(keys));\n        } else {\n            assert(self.remove_keys(keys) =~= self);\n        }\n    }",
        "doc_comment": "Removing a set of n keys from a map that previously contained all n keys\nresults in a domain of size n less than the original domain.",
        "triggers": [],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 218,
        "module": "vstd::map_lib",
        "keywords": [
          "Set",
          "contains",
          "decreases",
          "finite",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "remove_keys",
          "lemma_remove_keys_len",
          "remove"
        ]
      },
      "lemma_invert_is_injective": {
        "name": "lemma_invert_is_injective",
        "type": "proof",
        "signature": "pub proof fn lemma_invert_is_injective(self)\n        ensures\n            self.invert().is_injective(),",
        "ensures": [
          "self.invert().is_injective()"
        ],
        "requires": [],
        "body": "{\n        assert forall|x: V, y: V|\n            x != y && self.invert().dom().contains(x) && self.invert().dom().contains(\n                y,\n            ) implies #[trigger] self.invert()[x] != #[trigger] self.invert()[y] by {\n            let i = choose|i: K| #[trigger] self.dom().contains(i) && self[i] == x;\n            assert(self.contains_pair(i, x));\n            let j = choose|j: K| self.contains_pair(j, x) && self.invert()[x] == j;\n            let k = choose|k: K| #[trigger] self.dom().contains(k) && self[k] == y;\n            assert(self.contains_pair(k, y));\n            let l = choose|l: K| self.contains_pair(l, y) && self.invert()[y] == l && l != j;\n        }\n    }",
        "doc_comment": "The function `invert` results in an injective map",
        "triggers": [],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 241,
        "module": "vstd::map_lib",
        "keywords": [],
        "callees": [
          "contains_pair",
          "dom",
          "invert",
          "contains"
        ]
      },
      "lemma_union_insert_left": {
        "name": "lemma_union_insert_left",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_union_insert_left<K, V>(m1: Map<K, V>, m2: Map<K, V>, k: K, v: V)\n    requires\n        !m2.contains_key(k),\n    ensures\n        #[trigger] m1.insert(k, v).union_prefer_right(m2) == m1.union_prefer_right(m2).insert(k, v),",
        "ensures": [
          "#[trigger] m1.insert(k, v).union_prefer_right(m2) == m1.union_prefer_right(m2).insert(k, v)"
        ],
        "requires": [
          "!m2.contains_key(k)"
        ],
        "body": "{\n    assert(m1.insert(k, v).union_prefer_right(m2) =~= m1.union_prefer_right(m2).insert(k, v));\n}",
        "doc_comment": null,
        "triggers": [
          "m1.insert(k"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 584,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "insert",
          "trigger"
        ],
        "callees": [
          "insert",
          "union_prefer_right"
        ]
      },
      "lemma_union_insert_right": {
        "name": "lemma_union_insert_right",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_union_insert_right<K, V>(m1: Map<K, V>, m2: Map<K, V>, k: K, v: V)\n    ensures\n        #[trigger] m1.union_prefer_right(m2.insert(k, v)) == m1.union_prefer_right(m2).insert(k, v),",
        "ensures": [
          "#[trigger] m1.union_prefer_right(m2.insert(k, v)) == m1.union_prefer_right(m2).insert(k, v)"
        ],
        "requires": [],
        "body": "{\n    assert(m1.union_prefer_right(m2.insert(k, v)) =~= m1.union_prefer_right(m2).insert(k, v));\n}",
        "doc_comment": null,
        "triggers": [
          "m1.union_prefer_right(m2.insert(k"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 592,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "insert",
          "trigger"
        ],
        "callees": [
          "insert",
          "union_prefer_right"
        ]
      },
      "lemma_union_remove_left": {
        "name": "lemma_union_remove_left",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_union_remove_left<K, V>(m1: Map<K, V>, m2: Map<K, V>, k: K)\n    requires\n        m1.contains_key(k),\n        !m2.contains_key(k),\n    ensures\n        #[trigger] m1.union_prefer_right(m2).remove(k) == m1.remove(k).union_prefer_right(m2),",
        "ensures": [
          "#[trigger] m1.union_prefer_right(m2).remove(k) == m1.remove(k).union_prefer_right(m2)"
        ],
        "requires": [
          "m1.contains_key(k)",
          "!m2.contains_key(k)"
        ],
        "body": "{\n    assert(m1.remove(k).union_prefer_right(m2) =~= m1.union_prefer_right(m2).remove(k));\n}",
        "doc_comment": null,
        "triggers": [
          "m1.union_prefer_right(m2"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 599,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "remove",
          "trigger"
        ],
        "callees": [
          "remove",
          "union_prefer_right"
        ]
      },
      "lemma_union_remove_right": {
        "name": "lemma_union_remove_right",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_union_remove_right<K, V>(m1: Map<K, V>, m2: Map<K, V>, k: K)\n    requires\n        !m1.contains_key(k),\n        m2.contains_key(k),\n    ensures\n        #[trigger] m1.union_prefer_right(m2).remove(k) == m1.union_prefer_right(m2.remove(k)),",
        "ensures": [
          "#[trigger] m1.union_prefer_right(m2).remove(k) == m1.union_prefer_right(m2.remove(k))"
        ],
        "requires": [
          "!m1.contains_key(k)",
          "m2.contains_key(k)"
        ],
        "body": "{\n    assert(m1.union_prefer_right(m2.remove(k)) =~= m1.union_prefer_right(m2).remove(k));\n}",
        "doc_comment": null,
        "triggers": [
          "m1.union_prefer_right(m2"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 609,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "remove",
          "trigger"
        ],
        "callees": [
          "remove",
          "union_prefer_right"
        ]
      },
      "lemma_union_dom": {
        "name": "lemma_union_dom",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_union_dom<K, V>(m1: Map<K, V>, m2: Map<K, V>)\n    ensures\n        #[trigger] m1.union_prefer_right(m2).dom() == m1.dom().union(m2.dom()),",
        "ensures": [
          "#[trigger] m1.union_prefer_right(m2).dom() == m1.dom().union(m2.dom())"
        ],
        "requires": [],
        "body": "{\n    assert(m1.dom().union(m2.dom()) =~= m1.union_prefer_right(m2).dom());\n}",
        "doc_comment": null,
        "triggers": [
          "m1.union_prefer_right(m2"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 619,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "trigger",
          "union"
        ],
        "callees": [
          "dom",
          "union_prefer_right",
          "union"
        ]
      },
      "lemma_disjoint_union_size": {
        "name": "lemma_disjoint_union_size",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_disjoint_union_size<K, V>(m1: Map<K, V>, m2: Map<K, V>)\n    requires\n        m1.dom().disjoint(m2.dom()),\n        m1.dom().finite(),\n        m2.dom().finite(),\n    ensures\n        #[trigger] m1.union_prefer_right(m2).dom().len() == m1.dom().len() + m2.dom().len(),",
        "ensures": [
          "#[trigger] m1.union_prefer_right(m2).dom().len() == m1.dom().len() + m2.dom().len()"
        ],
        "requires": [
          "m1.dom().disjoint(m2.dom())",
          "m1.dom().finite()",
          "m2.dom().finite()"
        ],
        "body": "{\n    let u = m1.union_prefer_right(m2);\n    assert(u.dom() =~= m1.dom() + m2.dom());  //proves u.dom() is finite\n    assert(u.remove_keys(m1.dom()).dom() =~= m2.dom());\n    assert(u.remove_keys(m1.dom()).dom().len() == u.dom().len() - m1.dom().len()) by {\n        u.lemma_remove_keys_len(m1.dom());\n    }\n}",
        "doc_comment": "The size of the union of two disjoint maps is equal to the sum of the sizes of the individual maps",
        "triggers": [
          "m1.union_prefer_right(m2"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 626,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "finite",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "remove_keys",
          "lemma_remove_keys_len",
          "dom",
          "union_prefer_right"
        ]
      },
      "lemma_submap_of_trans": {
        "name": "lemma_submap_of_trans",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_submap_of_trans<K, V>(m1: Map<K, V>, m2: Map<K, V>, m3: Map<K, V>)\n    requires\n        #[trigger] m1.submap_of(m2),\n        #[trigger] m2.submap_of(m3),\n    ensures\n        m1.submap_of(m3),",
        "ensures": [
          "m1.submap_of(m3)"
        ],
        "requires": [
          "#[trigger] m1.submap_of(m2)",
          "#[trigger] m2.submap_of(m3)"
        ],
        "body": "{\n    assert forall|k| m1.dom().contains(k) implies #[trigger] m3.dom().contains(k) && m1[k]\n        == m3[k] by {\n        assert(m2.dom().contains(k));\n    }\n}",
        "doc_comment": "submap_of (<=) is transitive.",
        "triggers": [],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 652,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "dom",
          "contains"
        ]
      },
      "lemma_map_new_domain": {
        "name": "lemma_map_new_domain",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_map_new_domain<K, V>(fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V)\n    ensures\n        #[trigger] Map::<K, V>::new(fk, fv).dom() == Set::<K>::new(|k: K| fk(k)),",
        "ensures": [
          "#[trigger] Map::<K, V>::new(fk, fv).dom() == Set::<K>::new(|k: K| fk(k))"
        ],
        "requires": [],
        "body": "{\n    assert(Set::new(fk) =~= Set::<K>::new(|k: K| fk(k)));\n}",
        "doc_comment": "The domain of a map constructed with `Map::new(fk, fv)` is equivalent to the set constructed with `Set::new(fk)`.",
        "triggers": [
          "Map::<K"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 668,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "Set",
          "trigger"
        ],
        "callees": [
          "fk",
          "new"
        ]
      },
      "lemma_map_new_values": {
        "name": "lemma_map_new_values",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_map_new_values<K, V>(fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V)\n    ensures\n        #[trigger] Map::<K, V>::new(fk, fv).values() == Set::<V>::new(\n            |v: V| (exists|k: K| #[trigger] fk(k) && #[trigger] fv(k) == v),\n        ),",
        "ensures": [
          "#[trigger] Map::<K, V>::new(fk, fv).values() == Set::<V>::new(\n            |v: V| (exists|k: K| #[trigger] fk(k) && #[trigger] fv(k) == v)",
          ")"
        ],
        "requires": [],
        "body": "{\n    let keys = Set::<K>::new(fk);\n    let values = Map::<K, V>::new(fk, fv).values();\n    let map = Map::<K, V>::new(fk, fv);\n    assert(map.dom() =~= keys);\n    assert(forall|k: K| #[trigger] fk(k) ==> keys.contains(k));\n    assert(values =~= Set::<V>::new(\n        |v: V| (exists|k: K| #[trigger] fk(k) && #[trigger] fv(k) == v),\n    ));\n}",
        "doc_comment": "The set of values of a map constructed with `Map::new(fk, fv)` is equivalent to\nthe set constructed with `Set::new(|v: V| (exists |k: K| fk(k) && fv(k) == v)`. In other words,\nthe set of all values fv(k) where fk(k) is true.",
        "triggers": [
          "Map::<K",
          "fk(k",
          "fv(k"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 677,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "Set",
          "exists",
          "trigger"
        ],
        "callees": [
          "values",
          "fk",
          "contains",
          "fv",
          "dom",
          "new"
        ]
      },
      "lemma_map_properties": {
        "name": "lemma_map_properties",
        "type": "proof",
        "signature": "pub proof fn lemma_map_properties<K, V>()\n    ensures\n        forall|fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V| #[trigger]\n            Map::<K, V>::new(fk, fv).dom() == Set::<K>::new(|k: K| fk(k)),  //from lemma_map_new_domain\n        forall|fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V| #[trigger]\n            Map::<K, V>::new(fk, fv).values() == Set::<V>::new(\n                |v: V| exists|k: K| #[trigger] fk(k) && #[trigger] fv(k) == v,\n            ),  //from lemma_map_new_values",
        "ensures": [
          "forall|fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V| #[trigger]\n            Map::<K, V>::new(fk, fv).dom() == Set::<K>::new(|k: K| fk(k)),  //from lemma_map_new_domain\n        forall|fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V| #[trigger]\n            Map::<K, V>::new(fk, fv).values() == Set::<V>::new(\n                |v: V| exists|k: K| #[trigger] fk(k) && #[trigger] fv(k) == v",
          "),  //from lemma_map_new_values"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_map_properties;\n\n}",
        "doc_comment": "Properties of maps from the Dafny prelude (which were axioms in Dafny, but proven here in Verus)",
        "triggers": [
          "Map::<K",
          "Map::<K",
          "fk(k",
          "fv(k"
        ],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 695,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "Set",
          "exists",
          "forall",
          "trigger"
        ],
        "callees": []
      },
      "lemma_values_finite": {
        "name": "lemma_values_finite",
        "type": "proof",
        "signature": "pub proof fn lemma_values_finite<K, V>(m: Map<K, V>)\n    requires\n        m.dom().finite(),\n    ensures\n        m.values().finite(),\n    decreases m.len(),",
        "ensures": [
          "m.values().finite()"
        ],
        "requires": [
          "m.dom().finite()"
        ],
        "body": "{\n    if m.len() > 0 {\n        let k = m.dom().choose();\n        let v = m[k];\n        let m1 = m.remove(k);\n        assert(m.contains_key(k));\n        assert(m.contains_value(v));\n        let mv = m.values();\n        let m1v = m1.values();\n        assert_sets_equal!(mv == m1v.insert(v), v0 => {\n            if m.contains_value(v0) {\n                if v0 != v {\n                    let k0 = choose|k0| #![auto] m.contains_key(k0) && m[k0] == v0;\n                    assert(k0 != k);\n                    assert(m1.contains_key(k0));\n                    assert(mv.contains(v0) ==> m1v.insert(v).contains(v0));\n                    assert(mv.contains(v0) <== m1v.insert(v).contains(v0));\n                }\n            }\n        });\n        assert(m1.len() < m.len());\n        lemma_values_finite(m1);\n        axiom_set_insert_finite(m1.values(), v);\n    } else {\n        assert(m.values() =~= Set::<V>::empty());\n    }\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 724,
        "module": "vstd::map_lib",
        "keywords": [
          "Map",
          "decreases",
          "finite",
          "len"
        ],
        "callees": [
          "values",
          "remove",
          "axiom_set_insert_finite",
          "contains_value",
          "contains",
          "len",
          "insert",
          "empty",
          "contains_key",
          "lemma_values_finite",
          "dom"
        ]
      },
      "tracked_swap": {
        "name": "tracked_swap",
        "type": "axiom",
        "signature": "pub axiom fn tracked_swap<V>(tracked a: &mut V, tracked b: &mut V)\n    ensures\n        a == old(b),\n        b == old(a),",
        "ensures": [
          "a == old(b)",
          "b == old(a)"
        ],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/modes.rs",
        "line_number": 6,
        "module": "vstd::modes",
        "keywords": [],
        "callees": []
      },
      "tracked_static_ref": {
        "name": "tracked_static_ref",
        "type": "axiom",
        "signature": "pub axiom fn tracked_static_ref<V>(tracked v: V) -> (tracked res: &'static V)\n    ensures\n        res == v,",
        "ensures": [
          "res == v"
        ],
        "requires": [],
        "body": null,
        "doc_comment": "Make any tracked object permanently shared and get a reference to it.\n\nTip: If you try to use this and run into problems relating to the introduction\nof a lifetime variable, you want to try [`Shared`](crate::shared::Shared) instead.",
        "triggers": [],
        "file_path": "verus/source/vstd/modes.rs",
        "line_number": 12,
        "module": "vstd::modes",
        "keywords": [],
        "callees": []
      },
      "count": {
        "name": "count",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn count(self, value: V) -> nat",
        "ensures": [],
        "requires": [],
        "body": "{\n        Self::from_map(Map::new(|k| m.contains(k), |v| 1))\n    }",
        "doc_comment": "Returns the _count_, or _multiplicity_ of a single value within the multiset.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 50,
        "module": "vstd::multiset",
        "keywords": [],
        "callees": [
          "from_map",
          "new",
          "contains"
        ]
      },
      "len": {
        "name": "vstd::multiset::len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn len(self) -> nat",
        "ensures": [],
        "requires": [],
        "body": "{\n        Self::from_map(Map::new(|k| m.contains(k), |v| 1))\n    }",
        "doc_comment": "The total size of the multiset, i.e., the sum of all multiplicities over all values.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 52,
        "module": "vstd::multiset",
        "keywords": [
          "len"
        ],
        "callees": [
          "from_map",
          "new",
          "contains"
        ]
      },
      "vstd::multiset::empty": {
        "name": "vstd::multiset::empty",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn empty() -> Self",
        "ensures": [],
        "requires": [],
        "body": "{\n        Self::from_map(Map::new(|k| m.contains(k), |v| 1))\n    }",
        "doc_comment": "An empty multiset.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 55,
        "module": "vstd::multiset",
        "keywords": [
          "empty"
        ],
        "callees": [
          "from_map",
          "new",
          "contains"
        ]
      },
      "from_map": {
        "name": "vstd::multiset::from_map",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn from_map(m: Map<V, nat>) -> Self",
        "ensures": [],
        "requires": [],
        "body": "{\n        Self::from_map(Map::new(|k| m.contains(k), |v| 1))\n    }",
        "doc_comment": "Creates a multiset whose elements are given by the domain of the map `m` and whose\nmultiplicities are given by the corresponding values of `m[element]`. The map `m`\nmust be finite, or else this multiset is arbitrary.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 58,
        "module": "vstd::multiset",
        "keywords": [
          "Map"
        ],
        "callees": [
          "from_map",
          "new",
          "contains"
        ]
      },
      "singleton": {
        "name": "singleton",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn singleton(v: V) -> Self",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.add(Self::singleton(v))\n    }",
        "doc_comment": "A singleton multiset, i.e., a multiset with a single element of multiplicity 1.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 67,
        "module": "vstd::multiset",
        "keywords": [],
        "callees": [
          "singleton"
        ]
      },
      "add": {
        "name": "add",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn add(self, m2: Self) -> Self",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.add(Self::singleton(v))\n    }",
        "doc_comment": "Takes the union of two multisets. For a given element, its multiplicity in\nthe resulting multiset is the sum of its multiplicities in the operands.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 70,
        "module": "vstd::multiset",
        "keywords": [],
        "callees": [
          "singleton"
        ]
      },
      "sub": {
        "name": "sub",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn sub(self, m2: Self) -> Self",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.add(Self::singleton(v))\n    }",
        "doc_comment": "Takes the difference of two multisets.\nThe multiplicities of `m2` are subtracted from those of `self`; if any element\noccurs more in `m2` then the resulting multiplicity bottoms out at 0.\n(See [`axiom_multiset_sub`] for the precise definition.)\n\nNote in particular that `self == self.sub(m).add(m)` only holds if\n`m` is included in `self`.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 74,
        "module": "vstd::multiset",
        "keywords": [],
        "callees": [
          "singleton"
        ]
      },
      "filter": {
        "name": "filter",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn filter(self, f: impl Fn(V) -> bool) -> Self",
        "ensures": [],
        "requires": [],
        "body": "{\n        choose|v: V| self.count(v) > 0\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 125,
        "module": "vstd::multiset",
        "keywords": [
          "filter"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_multiset_empty": {
        "name": "axiom_multiset_empty",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_empty<V>(v: V)\n    ensures\n        #[trigger] Multiset::empty().count(v) == 0,",
        "ensures": [
          "#[trigger] Multiset::empty().count(v) == 0",
          "#[trigger] m.len() == 0 <==> m =~= Multiset::empty()",
          "#[trigger] m.len() > 0 ==> exists|v: V| 0 < m.count(v)"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n    assert(m.len() == 0 <==> m =~= Multiset::empty());\n}",
        "doc_comment": "The empty multiset maps every element to multiplicity 0",
        "triggers": [
          "Multiset::empty(",
          "m.len(",
          "m.len("
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 183,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "empty",
          "exists",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "empty"
        ]
      },
      "lemma_multiset_empty_len": {
        "name": "lemma_multiset_empty_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_multiset_empty_len<V>(m: Multiset<V>)\n    ensures\n        #[trigger] m.len() == 0 <==> m =~= Multiset::empty(),\n        #[trigger] m.len() > 0 ==> exists|v: V| 0 < m.count(v),",
        "ensures": [
          "#[trigger] m.len() == 0 <==> m =~= Multiset::empty()",
          "#[trigger] m.len() > 0 ==> exists|v: V| 0 < m.count(v)"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n    assert(m.len() == 0 <==> m =~= Multiset::empty());\n}",
        "doc_comment": "A multiset is equivalent to the empty multiset if and only if it has length 0.\nIf the multiset has length greater than 0, then there exists some element in the\nmultiset that has a count greater than 0.",
        "triggers": [
          "m.len(",
          "m.len("
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 190,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "empty",
          "exists",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "empty"
        ]
      },
      "axiom_multiset_contained": {
        "name": "axiom_multiset_contained",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_contained<V>(m: Map<V, nat>, v: V)\n    requires\n        m.dom().finite(),\n        m.dom().contains(v),\n    ensures\n        #[trigger] Multiset::from_map(m).count(v) == m[v],",
        "ensures": [
          "#[trigger] Multiset::from_map(m).count(v) == m[v]",
          "#[trigger] Multiset::from_map(m).count(v) == 0",
          "(#[trigger] Multiset::singleton(v)).count(v) == 1",
          "v != w ==> #[trigger] Multiset::singleton(v).count(w) == 0",
          "#[trigger] m1.add(m2).count(v) == m1.count(v) + m2.count(v)",
          "#[trigger] m1.sub(m2).count(v) == if m1.count(v) >= m2.count(v)"
        ],
        "requires": [
          "m.dom().finite()",
          "m.dom().contains(v)",
          "m.dom().finite()",
          "!m.dom().contains(v)"
        ],
        "body": "{\n            m1.count(v) - m2.count(v)\n        }",
        "doc_comment": "A call to Multiset::new with input map `m` will return a multiset that maps\nvalue `v` to multiplicity `m[v]` if `v` is in the domain of `m`.",
        "triggers": [
          "Multiset::from_map(m",
          "Multiset::from_map(m",
          "Multiset::singleton(v",
          "Multiset::singleton(v",
          "m1.add(m2",
          "m1.sub(m2"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 204,
        "module": "vstd::multiset",
        "keywords": [
          "Map",
          "Multiset",
          "contains",
          "finite",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_multiset_new_not_contained": {
        "name": "axiom_multiset_new_not_contained",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_new_not_contained<V>(m: Map<V, nat>, v: V)\n    requires\n        m.dom().finite(),\n        !m.dom().contains(v),\n    ensures\n        #[trigger] Multiset::from_map(m).count(v) == 0,",
        "ensures": [
          "#[trigger] Multiset::from_map(m).count(v) == 0",
          "(#[trigger] Multiset::singleton(v)).count(v) == 1",
          "v != w ==> #[trigger] Multiset::singleton(v).count(w) == 0",
          "#[trigger] m1.add(m2).count(v) == m1.count(v) + m2.count(v)",
          "#[trigger] m1.sub(m2).count(v) == if m1.count(v) >= m2.count(v)"
        ],
        "requires": [
          "m.dom().finite()",
          "!m.dom().contains(v)"
        ],
        "body": "{\n            m1.count(v) - m2.count(v)\n        }",
        "doc_comment": "A call to Multiset::new with input map `m` will return a multiset that maps\nvalue `v` to multiplicity 0 if `v` is not in the domain of `m`.",
        "triggers": [
          "Multiset::from_map(m",
          "Multiset::singleton(v",
          "Multiset::singleton(v",
          "m1.add(m2",
          "m1.sub(m2"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 213,
        "module": "vstd::multiset",
        "keywords": [
          "Map",
          "Multiset",
          "contains",
          "finite",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_multiset_singleton": {
        "name": "axiom_multiset_singleton",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_singleton<V>(v: V)\n    ensures\n        (#[trigger] Multiset::singleton(v)).count(v) == 1,",
        "ensures": [
          "(#[trigger] Multiset::singleton(v)).count(v) == 1",
          "v != w ==> #[trigger] Multiset::singleton(v).count(w) == 0",
          "#[trigger] m1.add(m2).count(v) == m1.count(v) + m2.count(v)",
          "#[trigger] m1.sub(m2).count(v) == if m1.count(v) >= m2.count(v)"
        ],
        "requires": [],
        "body": "{\n            m1.count(v) - m2.count(v)\n        }",
        "doc_comment": "A call to Multiset::singleton with input value `v` will return a multiset that maps\nvalue `v` to multiplicity 1.",
        "triggers": [
          "Multiset::singleton(v",
          "Multiset::singleton(v",
          "m1.add(m2",
          "m1.sub(m2"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 225,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_multiset_singleton_different": {
        "name": "axiom_multiset_singleton_different",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_singleton_different<V>(v: V, w: V)\n    ensures\n        v != w ==> #[trigger] Multiset::singleton(v).count(w) == 0,",
        "ensures": [
          "v != w ==> #[trigger] Multiset::singleton(v).count(w) == 0",
          "#[trigger] m1.add(m2).count(v) == m1.count(v) + m2.count(v)",
          "#[trigger] m1.sub(m2).count(v) == if m1.count(v) >= m2.count(v)"
        ],
        "requires": [],
        "body": "{\n            m1.count(v) - m2.count(v)\n        }",
        "doc_comment": "A call to Multiset::singleton with input value `v` will return a multiset that maps\nany value other than `v` to 0",
        "triggers": [
          "Multiset::singleton(v",
          "m1.add(m2",
          "m1.sub(m2"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 231,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_multiset_add": {
        "name": "axiom_multiset_add",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_add<V>(m1: Multiset<V>, m2: Multiset<V>, v: V)\n    ensures\n        #[trigger] m1.add(m2).count(v) == m1.count(v) + m2.count(v),",
        "ensures": [
          "#[trigger] m1.add(m2).count(v) == m1.count(v) + m2.count(v)",
          "#[trigger] m1.sub(m2).count(v) == if m1.count(v) >= m2.count(v)"
        ],
        "requires": [],
        "body": "{\n            m1.count(v) - m2.count(v)\n        }",
        "doc_comment": "The count of value `v` in the multiset `m1.add(m2)` is equal to the sum of the\ncounts of `v` in `m1` and `m2` individually.",
        "triggers": [
          "m1.add(m2",
          "m1.sub(m2"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 240,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_multiset_sub": {
        "name": "axiom_multiset_sub",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_sub<V>(m1: Multiset<V>, m2: Multiset<V>, v: V)\n    ensures\n        #[trigger] m1.sub(m2).count(v) == if m1.count(v) >= m2.count(v)",
        "ensures": [
          "#[trigger] m1.sub(m2).count(v) == if m1.count(v) >= m2.count(v)"
        ],
        "requires": [],
        "body": "{\n            m1.count(v) - m2.count(v)\n        }",
        "doc_comment": "The count of value `v` in the multiset `m1.sub(m2)` is equal to the difference between the\ncount of `v` in `m1` and `m2` individually. However, the difference is cut off at 0 and\ncannot be negative.",
        "triggers": [
          "m1.sub(m2"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 248,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_multiset_ext_equal": {
        "name": "axiom_multiset_ext_equal",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_ext_equal<V>(m1: Multiset<V>, m2: Multiset<V>)\n    ensures\n        #[trigger] (m1 =~= m2) <==> (forall|v: V| m1.count(v) == m2.count(v)),",
        "ensures": [
          "#[trigger] (m1 =~= m2) <==> (forall|v: V| m1.count(v) == m2.count(v))",
          "#[trigger] (m1 =~~= m2) <==> m1 =~= m2",
          "(#[trigger] Multiset::<V>::empty().len()) == 0",
          "(#[trigger] Multiset::<V>::singleton(v).len()) == 1",
          "(#[trigger] m1.add(m2).len()) == m1.len() + m2.len()",
          "(#[trigger] m1.sub(m2).len()) == m1.len() - m2.len()",
          "#[trigger] m.count(v) <= #[trigger] m.len()",
          "(#[trigger] m.filter(f).count(v)) == if f(v)"
        ],
        "requires": [
          "m2.subset_of(m1)"
        ],
        "body": "{\n            m.count(v)\n        }",
        "doc_comment": "Two multisets are equivalent if and only if they have the same count for every value.",
        "triggers": [
          "(m1 =~= m2",
          "(m1 =~~= m2",
          "Multiset::<V>::empty(",
          "Multiset::<V>::singleton(v",
          "m1.add(m2",
          "m1.sub(m2",
          "m.count(v",
          "m.len(",
          "m.filter(f"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 261,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "empty",
          "filter",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_multiset_ext_equal_deep": {
        "name": "axiom_multiset_ext_equal_deep",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_ext_equal_deep<V>(m1: Multiset<V>, m2: Multiset<V>)\n    ensures\n        #[trigger] (m1 =~~= m2) <==> m1 =~= m2,",
        "ensures": [
          "#[trigger] (m1 =~~= m2) <==> m1 =~= m2",
          "(#[trigger] Multiset::<V>::empty().len()) == 0",
          "(#[trigger] Multiset::<V>::singleton(v).len()) == 1",
          "(#[trigger] m1.add(m2).len()) == m1.len() + m2.len()",
          "(#[trigger] m1.sub(m2).len()) == m1.len() - m2.len()",
          "#[trigger] m.count(v) <= #[trigger] m.len()",
          "(#[trigger] m.filter(f).count(v)) == if f(v)"
        ],
        "requires": [
          "m2.subset_of(m1)"
        ],
        "body": "{\n            m.count(v)\n        }",
        "doc_comment": null,
        "triggers": [
          "(m1 =~~= m2",
          "Multiset::<V>::empty(",
          "Multiset::<V>::singleton(v",
          "m1.add(m2",
          "m1.sub(m2",
          "m.count(v",
          "m.len(",
          "m.filter(f"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 266,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "empty",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_len_empty": {
        "name": "axiom_len_empty",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_len_empty<V>()\n    ensures\n        (#[trigger] Multiset::<V>::empty().len()) == 0,",
        "ensures": [
          "(#[trigger] Multiset::<V>::empty().len()) == 0",
          "(#[trigger] Multiset::<V>::singleton(v).len()) == 1",
          "(#[trigger] m1.add(m2).len()) == m1.len() + m2.len()",
          "(#[trigger] m1.sub(m2).len()) == m1.len() - m2.len()",
          "#[trigger] m.count(v) <= #[trigger] m.len()",
          "(#[trigger] m.filter(f).count(v)) == if f(v)"
        ],
        "requires": [
          "m2.subset_of(m1)"
        ],
        "body": "{\n            m.count(v)\n        }",
        "doc_comment": "The length of the empty multiset is 0.",
        "triggers": [
          "Multiset::<V>::empty(",
          "Multiset::<V>::singleton(v",
          "m1.add(m2",
          "m1.sub(m2",
          "m.count(v",
          "m.len(",
          "m.filter(f"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 273,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "empty",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_len_singleton": {
        "name": "axiom_len_singleton",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_len_singleton<V>(v: V)\n    ensures\n        (#[trigger] Multiset::<V>::singleton(v).len()) == 1,",
        "ensures": [
          "(#[trigger] Multiset::<V>::singleton(v).len()) == 1",
          "(#[trigger] m1.add(m2).len()) == m1.len() + m2.len()",
          "(#[trigger] m1.sub(m2).len()) == m1.len() - m2.len()",
          "#[trigger] m.count(v) <= #[trigger] m.len()",
          "(#[trigger] m.filter(f).count(v)) == if f(v)"
        ],
        "requires": [
          "m2.subset_of(m1)"
        ],
        "body": "{\n            m.count(v)\n        }",
        "doc_comment": "The length of a singleton multiset is 1.",
        "triggers": [
          "Multiset::<V>::singleton(v",
          "m1.add(m2",
          "m1.sub(m2",
          "m.count(v",
          "m.len(",
          "m.filter(f"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 278,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_len_add": {
        "name": "axiom_len_add",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_len_add<V>(m1: Multiset<V>, m2: Multiset<V>)\n    ensures\n        (#[trigger] m1.add(m2).len()) == m1.len() + m2.len(),",
        "ensures": [
          "(#[trigger] m1.add(m2).len()) == m1.len() + m2.len()",
          "(#[trigger] m1.sub(m2).len()) == m1.len() - m2.len()",
          "#[trigger] m.count(v) <= #[trigger] m.len()",
          "(#[trigger] m.filter(f).count(v)) == if f(v)"
        ],
        "requires": [
          "m2.subset_of(m1)"
        ],
        "body": "{\n            m.count(v)\n        }",
        "doc_comment": "The length of the addition of two multisets is equal to the sum of the lengths of each individual multiset.",
        "triggers": [
          "m1.add(m2",
          "m1.sub(m2",
          "m.count(v",
          "m.len(",
          "m.filter(f"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 284,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_len_sub": {
        "name": "axiom_len_sub",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_len_sub<V>(m1: Multiset<V>, m2: Multiset<V>)\n    requires\n        m2.subset_of(m1),\n    ensures\n        (#[trigger] m1.sub(m2).len()) == m1.len() - m2.len(),",
        "ensures": [
          "(#[trigger] m1.sub(m2).len()) == m1.len() - m2.len()",
          "#[trigger] m.count(v) <= #[trigger] m.len()",
          "(#[trigger] m.filter(f).count(v)) == if f(v)"
        ],
        "requires": [
          "m2.subset_of(m1)"
        ],
        "body": "{\n            m.count(v)\n        }",
        "doc_comment": "The length of the subtraction of two multisets is equal to the difference between the lengths of each individual multiset.",
        "triggers": [
          "m1.sub(m2",
          "m.count(v",
          "m.len(",
          "m.filter(f"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 292,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_count_le_len": {
        "name": "axiom_count_le_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_count_le_len<V>(m: Multiset<V>, v: V)\n    ensures\n        #[trigger] m.count(v) <= #[trigger] m.len(),",
        "ensures": [
          "#[trigger] m.count(v) <= #[trigger] m.len()",
          "(#[trigger] m.filter(f).count(v)) == if f(v)"
        ],
        "requires": [],
        "body": "{\n            m.count(v)\n        }",
        "doc_comment": "The count for any given value `v` in a multiset `m` must be less than or equal to the length of `m`.",
        "triggers": [
          "m.count(v",
          "m.len(",
          "m.filter(f"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 299,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_filter_count": {
        "name": "axiom_filter_count",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_filter_count<V>(m: Multiset<V>, f: spec_fn(V) -> bool, v: V)\n    ensures\n        (#[trigger] m.filter(f).count(v)) == if f(v)",
        "ensures": [
          "(#[trigger] m.filter(f).count(v)) == if f(v)"
        ],
        "requires": [],
        "body": "{\n            m.count(v)\n        }",
        "doc_comment": "For a given value `v` and boolean predicate `f`, if `f(v)` is true, then the count of `v` in\n`m.filter(f)` is the same as the count of `v` in `m`. Otherwise, the count of `v` in `m.filter(f)` is 0.",
        "triggers": [
          "m.filter(f"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 307,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "filter",
          "trigger"
        ],
        "callees": [
          "count"
        ]
      },
      "axiom_choose_count": {
        "name": "axiom_choose_count",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_choose_count<V>(m: Multiset<V>)\n    requires\n        #[trigger] m.len() != 0,\n    ensures\n        #[trigger] m.count(m.choose()) > 0,",
        "ensures": [
          "#[trigger] m.count(m.choose()) > 0",
          "#[trigger] m.dom().finite()"
        ],
        "requires": [
          "#[trigger] m.len() != 0"
        ],
        "body": "{\n    axiom_multiset_empty,\n    axiom_multiset_contained,\n    axiom_multiset_new_not_contained,\n    axiom_multiset_singleton,\n    axiom_multiset_singleton_different,\n    axiom_multiset_add,\n    axiom_multiset_sub,\n    axiom_multiset_ext_equal,\n    axiom_multiset_ext_equal_deep,\n    axiom_len_empty,\n    axiom_len_singleton,\n    axiom_len_add,\n    axiom_len_sub,\n    axiom_count_le_len,\n    axiom_filter_count,\n    axiom_choose_count,\n    axiom_multiset_always_finite,\n}",
        "doc_comment": "In a nonempty multiset `m`, the `choose` function will return a value that maps to a multiplicity\ngreater than 0 in `m`.",
        "triggers": [
          "m.count(m.choose(",
          "m.dom("
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 319,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "finite",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_multiset_always_finite": {
        "name": "axiom_multiset_always_finite",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_multiset_always_finite<V>(m: Multiset<V>)\n    ensures\n        #[trigger] m.dom().finite(),",
        "ensures": [
          "#[trigger] m.dom().finite()"
        ],
        "requires": [],
        "body": "{\n    axiom_multiset_empty,\n    axiom_multiset_contained,\n    axiom_multiset_new_not_contained,\n    axiom_multiset_singleton,\n    axiom_multiset_singleton_different,\n    axiom_multiset_add,\n    axiom_multiset_sub,\n    axiom_multiset_ext_equal,\n    axiom_multiset_ext_equal_deep,\n    axiom_len_empty,\n    axiom_len_singleton,\n    axiom_len_add,\n    axiom_len_sub,\n    axiom_count_le_len,\n    axiom_filter_count,\n    axiom_choose_count,\n    axiom_multiset_always_finite,\n}",
        "doc_comment": null,
        "triggers": [
          "m.dom("
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 332,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "finite",
          "trigger"
        ],
        "callees": []
      },
      "lemma_update_same": {
        "name": "lemma_update_same",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_update_same<V>(m: Multiset<V>, v: V, mult: nat)\n    ensures\n        #[trigger] m.update(v, mult).count(v) == mult,",
        "ensures": [
          "#[trigger] m.update(v, mult).count(v) == mult"
        ],
        "requires": [],
        "body": "{\n    broadcast use {group_set_axioms, group_map_axioms, group_multiset_axioms};\n\n    let map = Map::new(\n        |key: V| (m.contains(key) || key == v),\n        |key: V|\n            if key == v {\n                mult\n            } else {\n                m.count(key)\n            },\n    );\n    assert(map.dom() =~= m.dom().insert(v));\n}",
        "doc_comment": "The multiset resulting from updating a value `v` in a multiset `m` to multiplicity `mult` will\nhave a count of `mult` for `v`.",
        "triggers": [
          "m.update(v"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 358,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "contains",
          "insert",
          "count",
          "dom",
          "new"
        ]
      },
      "lemma_update_different": {
        "name": "lemma_update_different",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_update_different<V>(m: Multiset<V>, v1: V, mult: nat, v2: V)\n    requires\n        v1 != v2,\n    ensures\n        #[trigger] m.update(v1, mult).count(v2) == m.count(v2),",
        "ensures": [
          "#[trigger] m.update(v1, mult).count(v2) == m.count(v2)"
        ],
        "requires": [
          "v1 != v2"
        ],
        "body": "{\n    broadcast use {group_set_axioms, group_map_axioms, group_multiset_axioms};\n\n    let map = Map::new(\n        |key: V| (m.contains(key) || key == v1),\n        |key: V|\n            if key == v1 {\n                mult\n            } else {\n                m.count(key)\n            },\n    );\n    assert(map.dom() =~= m.dom().insert(v1));\n}",
        "doc_comment": "The multiset resulting from updating a value `v1` in a multiset `m` to multiplicity `mult` will\nnot change the multiplicities of any other values in `m`.",
        "triggers": [
          "m.update(v1"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 377,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "contains",
          "insert",
          "count",
          "dom",
          "new"
        ]
      },
      "lemma_insert_containment": {
        "name": "lemma_insert_containment",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_insert_containment<V>(m: Multiset<V>, x: V, y: V)\n    ensures\n        0 < #[trigger] m.insert(x).count(y) <==> x == y || 0 < m.count(y),",
        "ensures": [
          "0 < #[trigger] m.insert(x).count(y) <==> x == y || 0 < m.count(y)"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n}",
        "doc_comment": "If you insert element x into multiset m, then element y maps\nto a count greater than 0 if and only if x==y or y already\nmapped to a count greater than 0 before the insertion of x.",
        "triggers": [
          "m.insert(x"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 402,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "lemma_insert_increases_count_by_1": {
        "name": "lemma_insert_increases_count_by_1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_insert_increases_count_by_1<V>(m: Multiset<V>, x: V)\n    ensures\n        #[trigger] m.insert(x).count(x) == m.count(x) + 1,",
        "ensures": [
          "#[trigger] m.insert(x).count(x) == m.count(x) + 1"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n}",
        "doc_comment": "Inserting an element `x` into multiset `m` will increase the count of `x` in `m` by 1.",
        "triggers": [
          "m.insert(x"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 414,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "lemma_insert_non_decreasing": {
        "name": "lemma_insert_non_decreasing",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_insert_non_decreasing<V>(m: Multiset<V>, x: V, y: V)\n    ensures\n        0 < m.count(y) ==> 0 < #[trigger] m.insert(x).count(y),",
        "ensures": [
          "0 < m.count(y) ==> 0 < #[trigger] m.insert(x).count(y)"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n}",
        "doc_comment": "If multiset `m` maps element `y` to a multiplicity greater than 0, then inserting any element `x`\ninto `m` will not cause `y` to map to a multiplicity of 0. This is a way of saying that inserting `x`\nwill not cause any counts to decrease, because it accounts both for when x == y and when x != y.",
        "triggers": [
          "m.insert(x"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 424,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "lemma_insert_other_elements_unchanged": {
        "name": "lemma_insert_other_elements_unchanged",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_insert_other_elements_unchanged<V>(m: Multiset<V>, x: V, y: V)\n    ensures\n        x != y ==> m.count(y) == #[trigger] m.insert(x).count(y),",
        "ensures": [
          "x != y ==> m.count(y) == #[trigger] m.insert(x).count(y)"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n}",
        "doc_comment": "Inserting an element `x` into a multiset `m` will not change the count of any other element `y` in `m`.",
        "triggers": [
          "m.insert(x"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 436,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "lemma_insert_len": {
        "name": "lemma_insert_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_insert_len<V>(m: Multiset<V>, x: V)\n    ensures\n        #[trigger] m.insert(x).len() == m.len() + 1,",
        "ensures": [
          "#[trigger] m.insert(x).len() == m.len() + 1"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n}",
        "doc_comment": "Inserting an element `x` into a multiset `m` will increase the length of `m` by 1.",
        "triggers": [
          "m.insert(x"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 446,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "insert",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_intersection_count": {
        "name": "lemma_intersection_count",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_intersection_count<V>(a: Multiset<V>, b: Multiset<V>, x: V)\n    ensures\n        #[trigger] a.intersection_with(b).count(x) == min(a.count(x) as int, b.count(x) as int),",
        "ensures": [
          "#[trigger] a.intersection_with(b).count(x) == min(a.count(x) as int, b.count(x) as int)"
        ],
        "requires": [],
        "body": "{\n    broadcast use {group_set_axioms, group_map_axioms, group_multiset_axioms};\n\n    let m = Map::<V, nat>::new(\n        |v: V| a.contains(v),\n        |v: V| min(a.count(v) as int, b.count(v) as int) as nat,\n    );\n    assert(m.dom() =~= a.dom());\n}",
        "doc_comment": "The multiplicity of an element `x` in the intersection of multisets `a` and `b` will be the minimum\ncount of `x` in either `a` or `b`.",
        "triggers": [
          "a.intersection_with(b"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 457,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "min",
          "contains",
          "count",
          "dom",
          "new"
        ]
      },
      "lemma_left_pseudo_idempotence": {
        "name": "lemma_left_pseudo_idempotence",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_left_pseudo_idempotence<V>(a: Multiset<V>, b: Multiset<V>)\n    ensures\n        #[trigger] a.intersection_with(b).intersection_with(b) =~= a.intersection_with(b),",
        "ensures": [
          "#[trigger] a.intersection_with(b).intersection_with(b) =~= a.intersection_with(b)"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n    assert forall|x: V| #[trigger]\n        a.intersection_with(b).count(x) == min(a.count(x) as int, b.count(x) as int) by {\n        lemma_intersection_count(a, b, x);\n    }\n    assert forall|x: V| #[trigger]\n        a.intersection_with(b).intersection_with(b).count(x) == min(\n            a.count(x) as int,\n            b.count(x) as int,\n        ) by {\n        lemma_intersection_count(a.intersection_with(b), b, x);\n        assert(min(min(a.count(x) as int, b.count(x) as int) as int, b.count(x) as int) == min(\n            a.count(x) as int,\n            b.count(x) as int,\n        ));\n    }\n}",
        "doc_comment": "Taking the intersection of multisets `a` and `b` and then taking the resulting multiset's intersection\nwith `b` again is the same as just taking the intersection of `a` and `b` once.",
        "triggers": [
          "a.intersection_with(b"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 473,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "lemma_intersection_count",
          "intersection_with",
          "min",
          "count"
        ]
      },
      "lemma_right_pseudo_idempotence": {
        "name": "lemma_right_pseudo_idempotence",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_right_pseudo_idempotence<V>(a: Multiset<V>, b: Multiset<V>)\n    ensures\n        #[trigger] a.intersection_with(a.intersection_with(b)) =~= a.intersection_with(b),",
        "ensures": [
          "#[trigger] a.intersection_with(a.intersection_with(b)) =~= a.intersection_with(b)"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n    assert forall|x: V| #[trigger]\n        a.intersection_with(b).count(x) == min(a.count(x) as int, b.count(x) as int) by {\n        lemma_intersection_count(a, b, x);\n    }\n    assert forall|x: V| #[trigger]\n        a.intersection_with(a.intersection_with(b)).count(x) == min(\n            a.count(x) as int,\n            b.count(x) as int,\n        ) by {\n        lemma_intersection_count(a, a.intersection_with(b), x);\n        assert(min(a.count(x) as int, min(a.count(x) as int, b.count(x) as int) as int) == min(\n            a.count(x) as int,\n            b.count(x) as int,\n        ));\n    }\n}",
        "doc_comment": "Taking the intersection of multiset `a` with the result of taking the intersection of `a` and `b`\nis the same as just taking the intersection of `a` and `b` once.",
        "triggers": [
          "a.intersection_with(a.intersection_with(b"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 499,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "lemma_intersection_count",
          "intersection_with",
          "min",
          "count"
        ]
      },
      "lemma_difference_count": {
        "name": "lemma_difference_count",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_difference_count<V>(a: Multiset<V>, b: Multiset<V>, x: V)\n    ensures\n        #[trigger] a.difference_with(b).count(x) == clip(a.count(x) - b.count(x)),",
        "ensures": [
          "#[trigger] a.difference_with(b).count(x) == clip(a.count(x) - b.count(x))"
        ],
        "requires": [],
        "body": "{\n    broadcast use {group_set_axioms, group_map_axioms, group_multiset_axioms};\n\n    let m = Map::<V, nat>::new(|v: V| a.contains(v), |v: V| clip(a.count(v) - b.count(v)));\n    assert(m.dom() =~= a.dom());\n}",
        "doc_comment": "The multiplicity of an element `x` in the difference of multisets `a` and `b` will be\nequal to the difference of the counts of `x` in `a` and `b`, or 0 if this difference is negative.",
        "triggers": [
          "a.difference_with(b"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 526,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "contains",
          "count",
          "dom",
          "new",
          "clip"
        ]
      },
      "lemma_difference_bottoms_out": {
        "name": "lemma_difference_bottoms_out",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_difference_bottoms_out<V>(a: Multiset<V>, b: Multiset<V>, x: V)\n    ensures\n        #![trigger a.count(x), b.count(x), a.difference_with(b)]\n        a.count(x) <= b.count(x) ==> a.difference_with(b).count(x) == 0,",
        "ensures": [
          "#![trigger a.count(x), b.count(x), a.difference_with(b)]\n        a.count(x) <= b.count(x) ==> a.difference_with(b).count(x) == 0"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_multiset_axioms;\n\n    lemma_difference_count(a, b, x);\n}",
        "doc_comment": "If the multiplicity of element `x` is less in multiset `a` than in multiset `b`, then the multiplicity\nof `x` in the difference of `a` and `b` will be 0.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 539,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "trigger"
        ],
        "callees": [
          "lemma_difference_count"
        ]
      },
      "lemma_multiset_properties": {
        "name": "lemma_multiset_properties",
        "type": "proof",
        "signature": "pub proof fn lemma_multiset_properties<V>()\n    ensures\n        forall|m: Multiset<V>, v: V, mult: nat| #[trigger] m.update(v, mult).count(v) == mult,  //from lemma_update_same\n        forall|m: Multiset<V>, v1: V, mult: nat, v2: V|\n            v1 != v2 ==> #[trigger] m.update(v1, mult).count(v2) == m.count(v2),  //from lemma_update_different\n        forall|m: Multiset<V>|\n            (#[trigger] m.len() == 0 <==> m =~= Multiset::empty()) && (#[trigger] m.len() > 0\n                ==> exists|v: V| 0 < m.count(v)),  //from lemma_multiset_empty_len\n        forall|m: Multiset<V>, x: V, y: V|\n            0 < #[trigger] m.insert(x).count(y) <==> x == y || 0 < m.count(y),  //from lemma_insert_containment\n        forall|m: Multiset<V>, x: V| #[trigger] m.insert(x).count(x) == m.count(x) + 1,  //from lemma_insert_increases_count_by_1\n        forall|m: Multiset<V>, x: V, y: V| 0 < m.count(y) ==> 0 < #[trigger] m.insert(x).count(y),  //from lemma_insert_non_decreasing\n        forall|m: Multiset<V>, x: V, y: V|\n            x != y ==> #[trigger] m.count(y) == #[trigger] m.insert(x).count(y),  //from lemma_insert_other_elements_unchanged\n        forall|m: Multiset<V>, x: V| #[trigger] m.insert(x).len() == m.len() + 1,  //from lemma_insert_len\n        forall|a: Multiset<V>, b: Multiset<V>, x: V| #[trigger]\n            a.intersection_with(b).count(x) == min(a.count(x) as int, b.count(x) as int),  //from lemma_intersection_count\n        forall|a: Multiset<V>, b: Multiset<V>| #[trigger]\n            a.intersection_with(b).intersection_with(b) == a.intersection_with(b),  //from lemma_left_pseudo_idempotence\n        forall|a: Multiset<V>, b: Multiset<V>| #[trigger]\n            a.intersection_with(a.intersection_with(b)) == a.intersection_with(b),  //from lemma_right_pseudo_idempotence\n        forall|a: Multiset<V>, b: Multiset<V>, x: V| #[trigger]\n            a.difference_with(b).count(x) == clip(a.count(x) - b.count(x)),  //from lemma_difference_count\n        forall|a: Multiset<V>, b: Multiset<V>, x: V| #[trigger]\n            a.count(x) <= #[trigger] b.count(x) ==> (#[trigger] a.difference_with(b)).count(x)\n                == 0,  //from lemma_difference_bottoms_out",
        "ensures": [
          "forall|m: Multiset<V>, v: V, mult: nat| #[trigger] m.update(v, mult).count(v) == mult,  //from lemma_update_same\n        forall|m: Multiset<V>, v1: V, mult: nat, v2: V|\n            v1 != v2 ==> #[trigger] m.update(v1, mult).count(v2) == m.count(v2),  //from lemma_update_different\n        forall|m: Multiset<V>|\n            (#[trigger] m.len() == 0 <==> m =~= Multiset::empty()) && (#[trigger] m.len() > 0\n                ==> exists|v: V| 0 < m.count(v)),  //from lemma_multiset_empty_len\n        forall|m: Multiset<V>, x: V, y: V|\n            0 < #[trigger] m.insert(x).count(y) <==> x == y || 0 < m.count(y),  //from lemma_insert_containment\n        forall|m: Multiset<V>, x: V| #[trigger] m.insert(x).count(x) == m.count(x) + 1,  //from lemma_insert_increases_count_by_1\n        forall|m: Multiset<V>, x: V, y: V| 0 < m.count(y) ==> 0 < #[trigger] m.insert(x).count(y),  //from lemma_insert_non_decreasing\n        forall|m: Multiset<V>, x: V, y: V|\n            x != y ==> #[trigger] m.count(y) == #[trigger] m.insert(x).count(y),  //from lemma_insert_other_elements_unchanged\n        forall|m: Multiset<V>, x: V| #[trigger] m.insert(x).len() == m.len() + 1,  //from lemma_insert_len\n        forall|a: Multiset<V>, b: Multiset<V>, x: V| #[trigger]\n            a.intersection_with(b).count(x) == min(a.count(x) as int, b.count(x) as int),  //from lemma_intersection_count\n        forall|a: Multiset<V>, b: Multiset<V>| #[trigger]\n            a.intersection_with(b).intersection_with(b) == a.intersection_with(b),  //from lemma_left_pseudo_idempotence\n        forall|a: Multiset<V>, b: Multiset<V>| #[trigger]\n            a.intersection_with(a.intersection_with(b)) == a.intersection_with(b),  //from lemma_right_pseudo_idempotence\n        forall|a: Multiset<V>, b: Multiset<V>, x: V| #[trigger]\n            a.difference_with(b).count(x) == clip(a.count(x) - b.count(x)),  //from lemma_difference_count\n        forall|a: Multiset<V>, b: Multiset<V>, x: V| #[trigger]\n            a.count(x) <= #[trigger] b.count(x) ==> (#[trigger] a.difference_with(b)).count(x)\n                == 0,  //from lemma_difference_bottoms_out"
        ],
        "requires": [],
        "body": "{\n    broadcast use {group_multiset_axioms, group_multiset_properties};\n\n}",
        "doc_comment": "Properties of multisets from the Dafny prelude (which were axioms in Dafny, but proven here in Verus)",
        "triggers": [
          "m.update(v",
          "m.update(v1",
          "m.len(",
          "m.len(",
          "m.insert(x",
          "m.insert(x",
          "m.insert(x",
          "m.count(y",
          "m.insert(x",
          "m.insert(x",
          "a.intersection_with(b",
          "a.intersection_with(b",
          "a.intersection_with(a.intersection_with(b",
          "a.difference_with(b",
          "a.count(x",
          "b.count(x",
          "a.difference_with(b"
        ],
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 589,
        "module": "vstd::multiset",
        "keywords": [
          "Multiset",
          "empty",
          "exists",
          "forall",
          "insert",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_is_singleton_contains_elem_equal_singleton": {
        "name": "lemma_is_singleton_contains_elem_equal_singleton",
        "type": "proof",
        "signature": "pub proof fn lemma_is_singleton_contains_elem_equal_singleton(self, x: A)\n        requires\n            self.is_singleton(),\n            self.contains(x),\n        ensures\n            self =~= Multiset::singleton(x),",
        "ensures": [
          "self =~= Multiset::singleton(x)"
        ],
        "requires": [
          "self.is_singleton()",
          "self.contains(x)"
        ],
        "body": "{\n        assert forall|y: A| #[trigger] Multiset::singleton(x).count(y) == self.count(y) by {\n            if self.contains(y) {\n            } else {\n            }\n        };\n    }",
        "doc_comment": "A singleton multiset that contains an alement is equivalent to the singleton multiset with that element.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset_lib.rs",
        "line_number": 21,
        "module": "vstd::multiset_lib",
        "keywords": [
          "Multiset",
          "contains"
        ],
        "callees": [
          "singleton",
          "contains",
          "count"
        ]
      },
      "lemma_singleton_size": {
        "name": "vstd::multiset_lib::lemma_singleton_size",
        "type": "proof",
        "signature": "pub proof fn lemma_singleton_size(self)\n        requires\n            self.is_singleton(),\n        ensures\n            self.len() == 1,",
        "ensures": [
          "self.len() == 1"
        ],
        "requires": [
          "self.is_singleton()"
        ],
        "body": "{\n        self.lemma_is_singleton_contains_elem_equal_singleton(self.choose());\n    }",
        "doc_comment": "A singleton multiset has length 1.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset_lib.rs",
        "line_number": 36,
        "module": "vstd::multiset_lib",
        "keywords": [
          "len"
        ],
        "callees": [
          "lemma_is_singleton_contains_elem_equal_singleton"
        ]
      },
      "lemma_is_singleton": {
        "name": "vstd::multiset_lib::lemma_is_singleton",
        "type": "proof",
        "signature": "pub proof fn lemma_is_singleton(s: Multiset<A>)\n        ensures\n            s.is_singleton() <==> (s.len() == 1),",
        "ensures": [
          "s.is_singleton() <==> (s.len() == 1)"
        ],
        "requires": [],
        "body": "{\n        if s.is_singleton() {\n            s.lemma_singleton_size();\n        }\n        if s.len() == 1 {\n            assert forall|x: A, y: A| s.contains(x) && s.contains(y) implies x == y by {\n                assert(s.remove(x).len() == 0);\n                if x != y {\n                    assert(s.remove(x).count(y) == 0);\n                    assert(s.remove(x).insert(x) =~= s);\n                }\n            }\n        }\n    }",
        "doc_comment": "A multiset has exactly one element, if and only if, it has at least one element with multiplicity 1 and any two elements are equal.",
        "triggers": [],
        "file_path": "verus/source/vstd/multiset_lib.rs",
        "line_number": 46,
        "module": "vstd::multiset_lib",
        "keywords": [
          "Multiset",
          "len"
        ],
        "callees": [
          "remove",
          "contains",
          "lemma_singleton_size",
          "len",
          "insert",
          "count",
          "is_singleton"
        ]
      },
      "value": {
        "name": "vstd::pcm::value",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn value(self) -> P",
        "ensures": [
          "out.value() == value",
          "out.loc() == self.loc()",
          "out.value() == P::op(self.value(), other.value())",
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == left",
          "out.1.value() == right",
          "out.value() == P::unit()",
          "out.loc() == loc",
          "self.value().valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "value.valid()",
          "self.loc() == other.loc()",
          "self.value() == P::op(left, right)",
          "frame_preserving_update(self.value(), new_value)"
        ],
        "body": "{\n        let new_values = set![new_value];\n        assert(new_values.contains(new_value));\n        self.update_nondeterministic(new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 112,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "update_nondeterministic",
          "contains"
        ]
      },
      "loc": {
        "name": "vstd::pcm::loc",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn loc(self) -> Loc",
        "ensures": [
          "out.value() == value",
          "out.loc() == self.loc()",
          "out.value() == P::op(self.value(), other.value())",
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == left",
          "out.1.value() == right",
          "out.value() == P::unit()",
          "out.loc() == loc",
          "self.value().valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "value.valid()",
          "self.loc() == other.loc()",
          "self.value() == P::op(left, right)",
          "frame_preserving_update(self.value(), new_value)"
        ],
        "body": "{\n        let new_values = set![new_value];\n        assert(new_values.contains(new_value));\n        self.update_nondeterministic(new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 113,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "update_nondeterministic",
          "contains"
        ]
      },
      "alloc": {
        "name": "vstd::pcm::alloc",
        "type": "axiom",
        "signature": "pub axiom fn alloc(value: P) -> (tracked out: Self)\n        requires\n            value.valid(),\n        ensures\n            out.value() == value,",
        "ensures": [
          "out.value() == value",
          "out.loc() == self.loc()",
          "out.value() == P::op(self.value(), other.value())",
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == left",
          "out.1.value() == right",
          "out.value() == P::unit()",
          "out.loc() == loc",
          "self.value().valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "value.valid()",
          "self.loc() == other.loc()",
          "self.value() == P::op(left, right)",
          "frame_preserving_update(self.value(), new_value)"
        ],
        "body": "{\n        let new_values = set![new_value];\n        assert(new_values.contains(new_value));\n        self.update_nondeterministic(new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 115,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "update_nondeterministic",
          "contains"
        ]
      },
      "join": {
        "name": "vstd::pcm::join",
        "type": "axiom",
        "signature": "pub axiom fn join(tracked self, tracked other: Self) -> (tracked out: Self)\n        requires\n            self.loc() == other.loc(),\n        ensures\n            out.loc() == self.loc(),\n            out.value() == P::op(self.value(), other.value()),",
        "ensures": [
          "out.loc() == self.loc()",
          "out.value() == P::op(self.value(), other.value())",
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == left",
          "out.1.value() == right",
          "out.value() == P::unit()",
          "out.loc() == loc",
          "self.value().valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "self.loc() == other.loc()",
          "self.value() == P::op(left, right)",
          "frame_preserving_update(self.value(), new_value)"
        ],
        "body": "{\n        let new_values = set![new_value];\n        assert(new_values.contains(new_value));\n        self.update_nondeterministic(new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 122,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "update_nondeterministic",
          "contains"
        ]
      },
      "split": {
        "name": "vstd::pcm::split",
        "type": "axiom",
        "signature": "pub axiom fn split(tracked self, left: P, right: P) -> (tracked out: (Self, Self))\n        requires\n            self.value() == P::op(left, right),\n        ensures\n            out.0.loc() == self.loc(),\n            out.1.loc() == self.loc(),\n            out.0.value() == left,\n            out.1.value() == right,",
        "ensures": [
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == left",
          "out.1.value() == right",
          "out.value() == P::unit()",
          "out.loc() == loc",
          "self.value().valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "self.value() == P::op(left, right)",
          "frame_preserving_update(self.value(), new_value)"
        ],
        "body": "{\n        let new_values = set![new_value];\n        assert(new_values.contains(new_value));\n        self.update_nondeterministic(new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 130,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "update_nondeterministic",
          "contains"
        ]
      },
      "create_unit": {
        "name": "create_unit",
        "type": "axiom",
        "signature": "pub axiom fn create_unit(loc: Loc) -> (tracked out: Self)\n        ensures\n            out.value() == P::unit(),\n            out.loc() == loc,",
        "ensures": [
          "out.value() == P::unit()",
          "out.loc() == loc",
          "self.value().valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "frame_preserving_update(self.value(), new_value)"
        ],
        "body": "{\n        let new_values = set![new_value];\n        assert(new_values.contains(new_value));\n        self.update_nondeterministic(new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 140,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "update_nondeterministic",
          "contains"
        ]
      },
      "validate": {
        "name": "vstd::pcm::validate",
        "type": "axiom",
        "signature": "pub axiom fn validate(tracked &self)\n        ensures\n            self.value().valid(),",
        "ensures": [
          "self.value().valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "frame_preserving_update(self.value(), new_value)"
        ],
        "body": "{\n        let new_values = set![new_value];\n        assert(new_values.contains(new_value));\n        self.update_nondeterministic(new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 146,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "update_nondeterministic",
          "contains"
        ]
      },
      "update": {
        "name": "vstd::pcm::update",
        "type": "proof",
        "signature": "pub proof fn update(tracked self, new_value: P) -> (tracked out: Self)\n        requires\n            frame_preserving_update(self.value(), new_value),\n        ensures\n            out.loc() == self.loc(),\n            out.value() == new_value,",
        "ensures": [
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "frame_preserving_update(self.value(), new_value)"
        ],
        "body": "{\n        let new_values = set![new_value];\n        assert(new_values.contains(new_value));\n        self.update_nondeterministic(new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 151,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "update_nondeterministic",
          "contains"
        ]
      },
      "update_nondeterministic": {
        "name": "update_nondeterministic",
        "type": "axiom",
        "signature": "pub axiom fn update_nondeterministic(tracked self, new_values: Set<P>) -> (tracked out: Self)\n        requires\n            frame_preserving_update_nondeterministic(self.value(), new_values),\n        ensures\n            out.loc() == self.loc(),\n            new_values.contains(out.value()),",
        "ensures": [
          "out.loc() == self.loc()",
          "new_values.contains(out.value())",
          "out.loc() == self.loc()",
          "incl(self.value(), out.value())",
          "incl(other.value(), out.value())",
          "out.loc() == self.loc()",
          "out.value() == target"
        ],
        "requires": [
          "frame_preserving_update_nondeterministic(self.value(), new_values)",
          "self.loc() == other.loc()",
          "self.loc() == other.loc()",
          "conjunct_shared(self.value(), other.value(), target)"
        ],
        "body": "{\n        let tracked j = self.join_shared(other);\n        j.validate();\n        j.weaken(target)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 163,
        "module": "vstd::pcm",
        "keywords": [
          "Set",
          "contains"
        ],
        "callees": [
          "validate",
          "join_shared",
          "weaken"
        ]
      },
      "join_shared": {
        "name": "vstd::pcm::join_shared",
        "type": "axiom",
        "signature": "pub axiom fn join_shared<'a>(tracked &'a self, tracked other: &'a Self) -> (tracked out:\n        &'a Self)\n        requires\n            self.loc() == other.loc(),\n        ensures\n            out.loc() == self.loc(),\n            incl(self.value(), out.value()),\n            incl(other.value(), out.value()),",
        "ensures": [
          "out.loc() == self.loc()",
          "incl(self.value(), out.value())",
          "incl(other.value(), out.value())",
          "out.loc() == self.loc()",
          "out.value() == target"
        ],
        "requires": [
          "self.loc() == other.loc()",
          "self.loc() == other.loc()",
          "conjunct_shared(self.value(), other.value(), target)"
        ],
        "body": "{\n        let tracked j = self.join_shared(other);\n        j.validate();\n        j.weaken(target)\n    }",
        "doc_comment": "This is useful when you have two (or more) shared resources and want to learn\nthat they agree, as you can combine this validate, e.g., `x.join_shared(y).validate()`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 173,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "validate",
          "join_shared",
          "weaken"
        ]
      },
      "join_shared_to_target": {
        "name": "join_shared_to_target",
        "type": "proof",
        "signature": "pub proof fn join_shared_to_target<'a>(\n        tracked &'a self,\n        tracked other: &'a Self,\n        target: P,\n    ) -> (tracked out: &'a Self)\n        requires\n            self.loc() == other.loc(),\n            conjunct_shared(self.value(), other.value(), target),\n        ensures\n            out.loc() == self.loc(),\n            out.value() == target,",
        "ensures": [
          "out.loc() == self.loc()",
          "out.value() == target"
        ],
        "requires": [
          "self.loc() == other.loc()",
          "conjunct_shared(self.value(), other.value(), target)"
        ],
        "body": "{\n        let tracked j = self.join_shared(other);\n        j.validate();\n        j.weaken(target)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 184,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "validate",
          "join_shared",
          "weaken"
        ]
      },
      "weaken": {
        "name": "vstd::pcm::weaken",
        "type": "axiom",
        "signature": "pub axiom fn weaken<'a>(tracked &'a self, target: P) -> (tracked out: &'a Self)\n        requires\n            incl(target, self.value()),\n        ensures\n            out.loc() == self.loc(),\n            out.value() == target,",
        "ensures": [
          "out.loc() == self.loc()",
          "out.value() == target",
          "*self == *old(self)",
          "P::op(self.value(), other.value()).valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "incl(target, self.value())",
          "old(self).loc() == other.loc()",
          "self.loc() == other.loc()",
          "frame_preserving_update(\n                P::op(self.value(), other.value())",
          "P::op(new_value, other.value())",
          ")"
        ],
        "body": "{\n        let new_values = set![new_value];\n        let so = set_op(new_values, other.value());\n        assert(so.contains(P::op(new_value, other.value())));\n        self.update_nondeterministic_with_shared(other, new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 201,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "set_op",
          "value",
          "contains",
          "op",
          "update_nondeterministic_with_shared"
        ]
      },
      "validate_2": {
        "name": "validate_2",
        "type": "axiom",
        "signature": "pub axiom fn validate_2(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).loc() == other.loc(),\n        ensures\n            *self == *old(self),\n            P::op(self.value(), other.value()).valid(),",
        "ensures": [
          "*self == *old(self)",
          "P::op(self.value(), other.value()).valid()",
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "old(self).loc() == other.loc()",
          "self.loc() == other.loc()",
          "frame_preserving_update(\n                P::op(self.value(), other.value())",
          "P::op(new_value, other.value())",
          ")"
        ],
        "body": "{\n        let new_values = set![new_value];\n        let so = set_op(new_values, other.value());\n        assert(so.contains(P::op(new_value, other.value())));\n        self.update_nondeterministic_with_shared(other, new_values)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 209,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "set_op",
          "value",
          "contains",
          "op",
          "update_nondeterministic_with_shared"
        ]
      },
      "update_with_shared": {
        "name": "update_with_shared",
        "type": "proof",
        "signature": "pub proof fn update_with_shared(\n        tracked self,\n        tracked other: &Self,\n        new_value: P,\n    ) -> (tracked out: Self)\n        requires\n            self.loc() == other.loc(),\n            frame_preserving_update(\n                P::op(self.value(), other.value()),\n                P::op(new_value, other.value()),\n            ),\n        ensures\n            out.loc() == self.loc(),\n            out.value() == new_value,",
        "ensures": [
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "self.loc() == other.loc()",
          "frame_preserving_update(\n                P::op(self.value(), other.value())",
          "P::op(new_value, other.value())",
          ")"
        ],
        "body": "{\n        let new_values = set![new_value];\n        let so = set_op(new_values, other.value());\n        assert(so.contains(P::op(new_value, other.value())));\n        self.update_nondeterministic_with_shared(other, new_values)\n    }",
        "doc_comment": "If `x \u00b7 y --> x \u00b7 z` is a frame-perserving update, and we have a shared reference to `x`,\nwe can update the `y` resource to `z`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 217,
        "module": "vstd::pcm",
        "keywords": [],
        "callees": [
          "set_op",
          "value",
          "contains",
          "op",
          "update_nondeterministic_with_shared"
        ]
      },
      "update_nondeterministic_with_shared": {
        "name": "update_nondeterministic_with_shared",
        "type": "axiom",
        "signature": "pub axiom fn update_nondeterministic_with_shared(\n        tracked self,\n        tracked other: &Self,\n        new_values: Set<P>,\n    ) -> (tracked out: Self)\n        requires\n            self.loc() == other.loc(),\n            frame_preserving_update_nondeterministic(\n                P::op(self.value(), other.value()),\n                set_op(new_values, other.value()),\n            ),\n        ensures\n            out.loc() == self.loc(),\n            new_values.contains(out.value()),",
        "ensures": [
          "out.loc() == self.loc()",
          "new_values.contains(out.value())"
        ],
        "requires": [
          "self.loc() == other.loc()",
          "frame_preserving_update_nondeterministic(\n                P::op(self.value(), other.value())",
          "set_op(new_values, other.value())",
          ")"
        ],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 240,
        "module": "vstd::pcm",
        "keywords": [
          "Set",
          "contains"
        ],
        "callees": []
      },
      "lemma_pcm_properties": {
        "name": "lemma_pcm_properties",
        "type": "proof",
        "signature": "pub proof fn lemma_pcm_properties<P: PCM>()\n    ensures\n        forall|a: P, b: P| (#[trigger] P::op(a, b)).valid() ==> a.valid(),\n        forall|a: P, b: P| (#[trigger] P::op(a, b)) == P::op(b, a),\n        forall|a: P| (#[trigger] P::op(a, P::unit())) == a,\n        P::valid(P::unit()),",
        "ensures": [
          "forall|a: P, b: P| (#[trigger] P::op(a, b)).valid() ==> a.valid()",
          "forall|a: P, b: P| (#[trigger] P::op(a, b)) == P::op(b, a)",
          "forall|a: P| (#[trigger] P::op(a, P::unit())) == a",
          "P::valid(P::unit())"
        ],
        "requires": [],
        "body": "{\n    assert forall|a: P, b: P| (#[trigger] P::op(a, b)).valid() implies a.valid() by {\n        P::closed_under_incl(a, b);\n    }\n    assert forall|a: P, b: P| (#[trigger] P::op(a, b)) == P::op(b, a) by {\n        P::commutative(a, b);\n    }\n    assert forall|a: P| P::op(a, P::unit()) == a by {\n        P::op_unit(a);\n    }\n    assert(P::valid(P::unit())) by {\n        P::unit_valid();\n    }\n}",
        "doc_comment": "Provides four quantified facts about a partially commutative\nmonoid: that it's closed under inclusion, that it's commutative,\nthat it's a monoid, and that its unit element is valid. Note that,\nto avoid trigger loops, it doesn't provide associativity.",
        "triggers": [
          "P::op(a",
          "P::op(a",
          "P::op(a"
        ],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 21,
        "module": "vstd::pcm_lib",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "unit_valid",
          "closed_under_incl",
          "op",
          "op_unit",
          "valid",
          "unit",
          "commutative"
        ]
      },
      "copy_duplicable_part": {
        "name": "copy_duplicable_part",
        "type": "proof",
        "signature": "pub proof fn copy_duplicable_part<P: PCM>(tracked r: &Resource<P>, new_value: P) -> (tracked out:\n    Resource<P>)\n    requires\n        r.value() == P::op(r.value(), new_value),\n    ensures\n        out.loc() == r.loc(),\n        out.value() == new_value,",
        "ensures": [
          "out.loc() == r.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "r.value() == P::op(r.value(), new_value)"
        ],
        "body": "{\n    lemma_pcm_properties::<P>();\n    let tracked u = Resource::<P>::create_unit(r.loc());\n    u.update_with_shared(r, new_value)\n}",
        "doc_comment": "Produces a new resource with value `new_value` given an immutable\nreference to a resource `r` whose value has a duplicable part\n`new_value`. More precisely, produces a resource with value\n`new_value` given that `r.value() == P::op(r.value(), new_value)`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 46,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "update_with_shared",
          "loc",
          "create_unit"
        ]
      },
      "duplicate": {
        "name": "duplicate",
        "type": "proof",
        "signature": "pub proof fn duplicate<P: PCM>(tracked r: &Resource<P>) -> (tracked other: Resource<P>)\n    requires\n        P::op(r.value(), r.value()) == r.value(),\n    ensures\n        other.loc() == r.loc(),\n        other.value() == r.value(),",
        "ensures": [
          "other.loc() == r.loc()",
          "other.value() == r.value()"
        ],
        "requires": [
          "P::op(r.value(), r.value()) == r.value()"
        ],
        "body": "{\n    copy_duplicable_part(r, r.value())\n}",
        "doc_comment": "Duplicates `r`, returning an identical resource. The value of\n`r` must be duplicable, i.e., `r.value()` must be equal to\n`P::op(r.value(), r.value())`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 63,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "copy_duplicable_part",
          "value"
        ]
      },
      "incorporate": {
        "name": "incorporate",
        "type": "proof",
        "signature": "pub proof fn incorporate<P: PCM>(tracked r1: &mut Resource<P>, tracked r2: Resource<P>)\n    requires\n        old(r1).loc() == r2.loc(),\n    ensures\n        r1.loc() == old(r1).loc(),\n        r1.value() == P::op(old(r1).value(), r2.value()),",
        "ensures": [
          "r1.loc() == old(r1).loc()",
          "r1.value() == P::op(old(r1).value(), r2.value())"
        ],
        "requires": [
          "old(r1).loc() == r2.loc()"
        ],
        "body": "{\n    let tracked mut r3 = Resource::<P>::create_unit(r1.loc());\n    tracked_swap(r1, &mut r3);\n    let tracked mut r4 = r3.join(r2);\n    tracked_swap(r1, &mut r4);\n}",
        "doc_comment": "Incorporates the resources of `r2` into `r1`, consuming `r2`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 76,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "tracked_swap",
          "loc",
          "join",
          "create_unit"
        ]
      },
      "split_mut": {
        "name": "split_mut",
        "type": "proof",
        "signature": "pub proof fn split_mut<P: PCM>(tracked r: &mut Resource<P>, left: P, right: P) -> (tracked other:\n    Resource<P>)\n    requires\n        old(r).value() == P::op(left, right),\n    ensures\n        r.loc() == other.loc() == old(r).loc(),\n        r.value() == left,\n        other.value() == right,",
        "ensures": [
          "r.loc() == other.loc() == old(r).loc()",
          "r.value() == left",
          "other.value() == right"
        ],
        "requires": [
          "old(r).value() == P::op(left, right)"
        ],
        "body": "{\n    let tracked mut r3 = Resource::<P>::create_unit(r.loc());\n    tracked_swap(r, &mut r3);\n    let tracked (mut r1, r2) = r3.split(left, right);\n    tracked_swap(r, &mut r1);\n    r2\n}",
        "doc_comment": "Splits the value of `r` into `left` and `right`. At the end, `r`\nends up with `left` as its value and the function returns a new\nresource with value `right`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 90,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "tracked_swap",
          "loc",
          "split",
          "tracked",
          "create_unit"
        ]
      },
      "extract": {
        "name": "extract",
        "type": "proof",
        "signature": "pub proof fn extract<P: PCM>(tracked r: &mut Resource<P>) -> (tracked other: Resource<P>)\n    ensures\n        other.loc() == r.loc() == old(r).loc(),\n        r.value() == P::unit(),\n        other.value() == old(r).value(),",
        "ensures": [
          "other.loc() == r.loc() == old(r).loc()",
          "r.value() == P::unit()",
          "other.value() == old(r).value()"
        ],
        "requires": [],
        "body": "{\n    lemma_pcm_properties::<P>();\n    split_mut(r, P::unit(), r.value())\n}",
        "doc_comment": "Extracts the resource from `r`, leaving `r` empty (i.e., having\nvalue `P::unit`) and returning a new resource holding the previous\nvalue of `r`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 109,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "value",
          "split_mut",
          "unit"
        ]
      },
      "update_mut": {
        "name": "update_mut",
        "type": "proof",
        "signature": "pub proof fn update_mut<P: PCM>(tracked r: &mut Resource<P>, new_value: P)\n    requires\n        frame_preserving_update(old(r).value(), new_value),\n    ensures\n        r.loc() == old(r).loc(),\n        r.value() == new_value,",
        "ensures": [
          "r.loc() == old(r).loc()",
          "r.value() == new_value"
        ],
        "requires": [
          "frame_preserving_update(old(r).value(), new_value)"
        ],
        "body": "{\n    let tracked mut r3 = Resource::<P>::create_unit(r.loc());\n    tracked_swap(r, &mut r3);\n    let tracked mut r4 = r3.update(new_value);\n    tracked_swap(r, &mut r4);\n}",
        "doc_comment": "Updates `r` to have new value `new_value`. This must be a\nframe-preserving update. That is, `new_value` must be compatible\nwith all frames `old(r).value()` was compatible with.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 122,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "update",
          "tracked_swap",
          "loc",
          "create_unit"
        ]
      },
      "redistribute": {
        "name": "redistribute",
        "type": "proof",
        "signature": "pub proof fn redistribute<P: PCM>(\n    tracked r1: &mut Resource<P>,\n    tracked r2: &mut Resource<P>,\n    v1: P,\n    v2: P,\n)\n    requires\n        old(r1).loc() == old(r2).loc(),\n        P::op(old(r1).value(), old(r2).value()) == P::op(v1, v2),\n    ensures\n        r1.loc() == r2.loc() == old(r1).loc(),\n        r1.value() == v1,\n        r2.value() == v2,",
        "ensures": [
          "r1.loc() == r2.loc() == old(r1).loc()",
          "r1.value() == v1",
          "r2.value() == v2"
        ],
        "requires": [
          "old(r1).loc() == old(r2).loc()",
          "P::op(old(r1).value(), old(r2).value()) == P::op(v1, v2)"
        ],
        "body": "{\n    lemma_pcm_properties::<P>();\n    let tracked r2_extracted = extract(r2);\n    incorporate(r1, r2_extracted);\n    let tracked r2_new = split_mut(r1, v1, v2);\n    incorporate(r2, r2_new);\n}",
        "doc_comment": "Redistribute the values held by resources `r1` and `r2` such that they\nhave the same combination as before. The new value of `r1` will be `v1`\nand the new value of `r2` will be `v2`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 138,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "incorporate",
          "extract",
          "split_mut"
        ]
      },
      "update_and_redistribute": {
        "name": "update_and_redistribute",
        "type": "proof",
        "signature": "pub proof fn update_and_redistribute<P: PCM>(\n    tracked r1: &mut Resource<P>,\n    tracked r2: &mut Resource<P>,\n    v1: P,\n    v2: P,\n)\n    requires\n        old(r1).loc() == old(r2).loc(),\n        frame_preserving_update(P::op(old(r1).value(), old(r2).value()), P::op(v1, v2)),\n    ensures\n        r1.loc() == r2.loc() == old(r1).loc(),\n        r1.value() == v1,\n        r2.value() == v2,",
        "ensures": [
          "r1.loc() == r2.loc() == old(r1).loc()",
          "r1.value() == v1",
          "r2.value() == v2"
        ],
        "requires": [
          "old(r1).loc() == old(r2).loc()",
          "frame_preserving_update(P::op(old(r1).value(), old(r2).value()), P::op(v1, v2))"
        ],
        "body": "{\n    lemma_pcm_properties::<P>();\n    let tracked r2_extracted = extract(r2);\n    incorporate(r1, r2_extracted);\n    update_mut(r1, P::op(v1, v2));\n    let tracked r2_new = split_mut(r1, v1, v2);\n    incorporate(r2, r2_new);\n}",
        "doc_comment": "Update the values held by resources `r1` and `r2` such that their\nvalues' combination is updated in a frame-preserving way (i.e.,\nthat combination must be updatable in a frame-preserving way to\nthe combination of `v1` and `v2`). The new value of `r1` will be\n`v1` and the new value of `r2` will be `v2`.",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 162,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "update_mut",
          "op",
          "extract",
          "split_mut",
          "incorporate"
        ]
      },
      "validate_3": {
        "name": "validate_3",
        "type": "proof",
        "signature": "pub proof fn validate_3<P: PCM>(\n    tracked r1: &mut Resource<P>,\n    tracked r2: &mut Resource<P>,\n    tracked r3: &Resource<P>,\n)\n    requires\n        old(r1).loc() == old(r2).loc() == r3.loc(),\n    ensures\n        r1.loc() == r2.loc() == r3.loc(),\n        r1.value() == old(r1).value(),\n        r2.value() == old(r2).value(),\n        P::op(r1.value(), P::op(r2.value(), r3.value())).valid(),",
        "ensures": [
          "r1.loc() == r2.loc() == r3.loc()",
          "r1.value() == old(r1).value()",
          "r2.value() == old(r2).value()",
          "P::op(r1.value(), P::op(r2.value(), r3.value())).valid()"
        ],
        "requires": [
          "old(r1).loc() == old(r2).loc() == r3.loc()"
        ],
        "body": "{\n    lemma_pcm_properties::<P>();\n    P::associative(r1.value(), r2.value(), r3.value());\n    let tracked mut r2_extracted = extract(r2);\n    incorporate(r1, r2_extracted);\n    r1.validate();\n    r1.validate_2(r3);\n    let tracked r2_split = split_mut(r1, old(r1).value(), old(r2).value());\n    incorporate(r2, r2_split);\n    assume(false);\n}",
        "doc_comment": "Validates that the three given resources have values that combine\nto form a valid value. Although `r1` and `r2` are mutable, they\ndon't change. (They change during the function but are restored to\nthe way they were by the time the function returns.)",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 189,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "validate_2",
          "validate",
          "value",
          "associative",
          "extract",
          "split_mut",
          "incorporate"
        ]
      },
      "validate_multiple": {
        "name": "validate_multiple",
        "type": "proof",
        "signature": "pub proof fn validate_multiple<P: PCM>(\n    tracked m: &mut Map<int, Resource<P>>,\n    loc: int,\n    values: Seq<P>,\n)\n    requires\n        forall|i|\n            #![trigger old(m).dom().contains(i)]\n            0 <= i < values.len() ==> old(m).dom().contains(i),\n        forall|i|\n            #![trigger old(m)[i]]\n            0 <= i < values.len() ==> old(m)[i].loc() == loc && old(m)[i].value() == values[i],\n    ensures\n        forall|i| #![trigger m.dom().contains(i)] 0 <= i < values.len() ==> m.dom().contains(i),\n        forall|i|\n            #![trigger m[i]]\n            0 <= i < values.len() ==> m[i].loc() == loc && m[i].value() == values[i],\n        combine_values(values).valid(),",
        "ensures": [
          "forall|i| #![trigger m.dom().contains(i)] 0 <= i < values.len() ==> m.dom().contains(i)",
          "forall|i|\n            #![trigger m[i]]\n            0 <= i < values.len() ==> m[i].loc() == loc && m[i].value() == values[i]",
          "combine_values(values).valid()"
        ],
        "requires": [
          "forall|i|\n            #![trigger old(m).dom().contains(i)]\n            0 <= i < values.len() ==> old(m).dom().contains(i)",
          "forall|i|\n            #![trigger old(m)[i]]\n            0 <= i < values.len() ==> old(m)[i].loc() == loc && old(m)[i].value() == values[i]"
        ],
        "body": "{\n    if values.len() == 0 {\n        lemma_pcm_properties::<P>();\n    } else {\n        let tracked agg = aggregate_resources_from_map_starting_at_offset(m, loc, values, 0);\n        assert(agg.value() == combine_values(values)) by {\n            assert(values =~= values.skip(0));\n        }\n        agg.validate();\n        store_resources_into_map_starting_at_offset(m, loc, values, 0, agg);\n    }\n}",
        "doc_comment": "Validates that a given sequence of resources has values that\ncombine to form a valid value. Although that sequence consists of\nmutable references, none of those resources change. (They change\nin the middle of the function, but are restored by the time it\ncompletes.) The sequence of resources is specified using the\nfollowing input parameters:\n\n`m` -- a map from integers to resources, mapping 0 to the first\nresource, 1 to the second, etc.\n\n`loc` -- the `loc()` shared by all the resources in `m`\n\n`values` -- the sequence of resources",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 322,
        "module": "vstd::pcm_lib",
        "keywords": [
          "Map",
          "Seq",
          "contains",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "skip",
          "validate",
          "store_resources_into_map_starting_at_offset",
          "value",
          "len",
          "combine_values",
          "aggregate_resources_from_map_starting_at_offset"
        ]
      },
      "validate_4": {
        "name": "validate_4",
        "type": "proof",
        "signature": "pub proof fn validate_4<P: PCM>(\n    tracked r1: &mut Resource<P>,\n    tracked r2: &mut Resource<P>,\n    tracked r3: &mut Resource<P>,\n    tracked r4: &mut Resource<P>,\n)\n    requires\n        old(r1).loc() == old(r2).loc() == old(r3).loc() == old(r4).loc(),\n    ensures\n        r1.loc() == r2.loc() == r3.loc() == r4.loc() == old(r1).loc(),\n        r1.value() == old(r1).value(),\n        r2.value() == old(r2).value(),\n        r3.value() == old(r3).value(),\n        r4.value() == old(r4).value(),\n        P::op(r1.value(), P::op(r2.value(), P::op(r3.value(), r4.value()))).valid(),",
        "ensures": [
          "r1.loc() == r2.loc() == r3.loc() == r4.loc() == old(r1).loc()",
          "r1.value() == old(r1).value()",
          "r2.value() == old(r2).value()",
          "r3.value() == old(r3).value()",
          "r4.value() == old(r4).value()",
          "P::op(r1.value(), P::op(r2.value(), P::op(r3.value(), r4.value()))).valid()"
        ],
        "requires": [
          "old(r1).loc() == old(r2).loc() == old(r3).loc() == old(r4).loc()"
        ],
        "body": "{\n    lemma_pcm_properties::<P>();\n    let tracked mut m: Map<int, Resource<P>> = Map::<int, Resource<P>>::tracked_empty();\n    let values: Seq<P> = seq![r1.value(), r2.value(), r3.value(), r4.value()];\n    m.tracked_insert(0, extract(r1));\n    m.tracked_insert(1, extract(r2));\n    m.tracked_insert(2, extract(r3));\n    m.tracked_insert(3, extract(r4));\n    assert(combine_values(values) == P::op(\n        old(r1).value(),\n        P::op(old(r2).value(), P::op(old(r3).value(), old(r4).value())),\n    )) by {\n        lemma_pcm_properties::<P>();\n        reveal_with_fuel(combine_values, 5);\n    }\n    validate_multiple(&mut m, r1.loc(), values);\n    incorporate(r1, m.tracked_remove(0));\n    incorporate(r2, m.tracked_remove(1));\n    incorporate(r3, m.tracked_remove(2));\n    incorporate(r4, m.tracked_remove(3));\n}",
        "doc_comment": "Validates that the four given resources have values that combine\nto form a valid value. Although the inputs `r1`, `r2`, `r3`, and\n`r4` are mutable, they don't change. (They change during the\nfunction but are restored to the way they were by the time the\nfunction returns.)",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 366,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "validate_multiple",
          "reveal_with_fuel",
          "loc",
          "value",
          "op",
          "tracked_insert",
          "extract",
          "tracked_remove",
          "combine_values",
          "incorporate",
          "tracked_empty"
        ]
      },
      "validate_5": {
        "name": "validate_5",
        "type": "proof",
        "signature": "pub proof fn validate_5<P: PCM>(\n    tracked r1: &mut Resource<P>,\n    tracked r2: &mut Resource<P>,\n    tracked r3: &mut Resource<P>,\n    tracked r4: &mut Resource<P>,\n    tracked r5: &mut Resource<P>,\n)\n    requires\n        old(r1).loc() == old(r2).loc() == old(r3).loc() == old(r4).loc() == old(r5).loc(),\n    ensures\n        r1.loc() == r2.loc() == r3.loc() == r4.loc() == r5.loc() == old(r1).loc(),\n        r1.value() == old(r1).value(),\n        r2.value() == old(r2).value(),\n        r3.value() == old(r3).value(),\n        r4.value() == old(r4).value(),\n        r5.value() == old(r5).value(),\n        P::op(\n            r1.value(),\n            P::op(r2.value(), P::op(r3.value(), P::op(r4.value(), r5.value()))),\n        ).valid(),",
        "ensures": [
          "r1.loc() == r2.loc() == r3.loc() == r4.loc() == r5.loc() == old(r1).loc()",
          "r1.value() == old(r1).value()",
          "r2.value() == old(r2).value()",
          "r3.value() == old(r3).value()",
          "r4.value() == old(r4).value()",
          "r5.value() == old(r5).value()",
          "P::op(\n            r1.value()",
          "P::op(r2.value(), P::op(r3.value(), P::op(r4.value(), r5.value())))",
          ").valid()"
        ],
        "requires": [
          "old(r1).loc() == old(r2).loc() == old(r3).loc() == old(r4).loc() == old(r5).loc()"
        ],
        "body": "{\n    lemma_pcm_properties::<P>();\n    let tracked mut m: Map<int, Resource<P>> = Map::<int, Resource<P>>::tracked_empty();\n    let values: Seq<P> = seq![r1.value(), r2.value(), r3.value(), r4.value(), r5.value()];\n    m.tracked_insert(0, extract(r1));\n    m.tracked_insert(1, extract(r2));\n    m.tracked_insert(2, extract(r3));\n    m.tracked_insert(3, extract(r4));\n    m.tracked_insert(4, extract(r5));\n    assert(combine_values(values) == P::op(\n        old(r1).value(),\n        P::op(old(r2).value(), P::op(old(r3).value(), P::op(old(r4).value(), old(r5).value()))),\n    )) by {\n        lemma_pcm_properties::<P>();\n        reveal_with_fuel(combine_values, 6);\n    }\n    validate_multiple(&mut m, r1.loc(), values);\n    incorporate(r1, m.tracked_remove(0));\n    incorporate(r2, m.tracked_remove(1));\n    incorporate(r3, m.tracked_remove(2));\n    incorporate(r4, m.tracked_remove(3));\n    incorporate(r5, m.tracked_remove(4));\n}",
        "doc_comment": "Validates that the five given resources have values that combine\nto form a valid value. Although the inputs are mutable, they don't\nchange. (They change during the function but are restored to the\nway they were by the time the function returns.)",
        "triggers": [],
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 408,
        "module": "vstd::pcm_lib",
        "keywords": [],
        "callees": [
          "validate_multiple",
          "reveal_with_fuel",
          "loc",
          "value",
          "op",
          "tracked_insert",
          "extract",
          "tracked_remove",
          "combine_values",
          "incorporate",
          "tracked_empty"
        ]
      },
      "assume": {
        "name": "assume",
        "type": "proof",
        "signature": "pub proof fn assume(b: bool)\n    ensures\n        b,",
        "ensures": [
          "b"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 12,
        "module": "vstd::pervasive",
        "keywords": [],
        "callees": [
          "admit"
        ]
      },
      "assert": {
        "name": "assert",
        "type": "proof",
        "signature": "pub proof fn assert(b: bool)\n    requires\n        b,\n    ensures\n        b,",
        "ensures": [
          "b"
        ],
        "requires": [
          "b"
        ],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 20,
        "module": "vstd::pervasive",
        "keywords": [],
        "callees": []
      },
      "affirm": {
        "name": "affirm",
        "type": "proof",
        "signature": "pub proof fn affirm(b: bool)\n    requires\n        b,",
        "ensures": [],
        "requires": [
          "b"
        ],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 28,
        "module": "vstd::pervasive",
        "keywords": [],
        "callees": []
      },
      "arbitrary": {
        "name": "arbitrary",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn arbitrary<A>() -> A",
        "ensures": [],
        "requires": [
          "false",
          "false"
        ],
        "body": "{\n    panic!(\"unreached_external\")\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 179,
        "module": "vstd::pervasive",
        "keywords": [],
        "callees": []
      },
      "proof_from_false": {
        "name": "proof_from_false",
        "type": "axiom",
        "signature": "pub axiom fn proof_from_false<A>() -> (tracked a: A)\n    requires\n        false,",
        "ensures": [],
        "requires": [
          "false",
          "false"
        ],
        "body": "{\n    panic!(\"unreached_external\")\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 181,
        "module": "vstd::pervasive",
        "keywords": [],
        "callees": []
      },
      "vstd::proph::view": {
        "name": "vstd::proph::view",
        "type": "closed_spec",
        "signature": "pub closed spec fn view(self) -> T",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.v@\n    }",
        "doc_comment": "The prophecized value.",
        "triggers": [],
        "file_path": "verus/source/vstd/proph.rs",
        "line_number": 32,
        "module": "vstd::proph",
        "keywords": [],
        "callees": []
      },
      "vstd::proph::new": {
        "name": "vstd::proph::new",
        "type": "exec",
        "signature": "pub exec fn new() -> (result: Self)",
        "ensures": [],
        "requires": [],
        "body": "{\n        Prophecy::<T> { v: Ghost(arbitrary()) }\n    }",
        "doc_comment": "Allocate a new prophecy variable.",
        "triggers": [],
        "file_path": "verus/source/vstd/proph.rs",
        "line_number": 36,
        "module": "vstd::proph",
        "keywords": [],
        "callees": [
          "host",
          "arbitrary"
        ]
      },
      "resolve": {
        "name": "resolve",
        "type": "exec",
        "signature": "pub exec fn resolve(self, v: &T)\n        ensures\n            self@ == v,",
        "ensures": [
          "self@ == v"
        ],
        "requires": [],
        "body": "{\n    }",
        "doc_comment": "Resolve the prophecy variable to a concrete value.\nThis consumes `self`, so it can only be called once.",
        "triggers": [],
        "file_path": "verus/source/vstd/proph.rs",
        "line_number": 42,
        "module": "vstd::proph",
        "keywords": [],
        "callees": []
      },
      "null": {
        "name": "vstd::raw_ptr::null",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn null() -> Self",
        "ensures": [],
        "requires": [],
        "body": "{\n    t: *mut T,\n}",
        "doc_comment": "The provenance of the null ptr (or really, \"no provenance\")",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 69,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": []
      },
      "is_nonnull": {
        "name": "vstd::raw_ptr::is_nonnull",
        "type": "axiom",
        "signature": "pub axiom fn is_nonnull(tracked &self)\n        requires\n            size_of::<T>() != 0,\n        ensures\n            self@.ptr@.addr != 0,",
        "ensures": [
          "self@.ptr@.addr != 0",
          "self.ptr() == old(self).ptr()",
          "self.is_uninit()",
          "*old(self) == *self",
          "self.ptr() as int + size_of::<T>() <= other.ptr() as int || other.ptr() as int\n                + size_of::<S>() <= self.ptr() as int"
        ],
        "requires": [
          "size_of::<T>() != 0"
        ],
        "body": "{\n    /// Returns `true` if it is a [`MemContents::Init`] value.\n    #[verifier::inline]\n    pub open spec fn is_init(&self) -> bool {\n        self is Init\n    }\n\n    /// Returns `true` if it is a [`MemContents::Uninit`] value.\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self) -> bool {\n        self is Uninit\n    }\n\n    /// If it is a [`MemContents::Init`] value, returns the value.\n    /// Otherwise, the return value is meaningless.\n    #[verifier::inline]\n    pub open spec fn value(&self) -> T\n        recommends\n            self is Init,\n    {\n        self->0\n    }\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 236,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "is_uninit",
          "is_init",
          "value"
        ]
      },
      "leak_contents": {
        "name": "vstd::raw_ptr::leak_contents",
        "type": "axiom",
        "signature": "pub axiom fn leak_contents(tracked &mut self)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(),",
        "ensures": [
          "self.ptr() == old(self).ptr()",
          "self.is_uninit()",
          "*old(self) == *self",
          "self.ptr() as int + size_of::<T>() <= other.ptr() as int || other.ptr() as int\n                + size_of::<S>() <= self.ptr() as int"
        ],
        "requires": [],
        "body": "{\n    /// Returns `true` if it is a [`MemContents::Init`] value.\n    #[verifier::inline]\n    pub open spec fn is_init(&self) -> bool {\n        self is Init\n    }\n\n    /// Returns `true` if it is a [`MemContents::Uninit`] value.\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self) -> bool {\n        self is Uninit\n    }\n\n    /// If it is a [`MemContents::Init`] value, returns the value.\n    /// Otherwise, the return value is meaningless.\n    #[verifier::inline]\n    pub open spec fn value(&self) -> T\n        recommends\n            self is Init,\n    {\n        self->0\n    }\n}",
        "doc_comment": "\"Forgets\" about the value stored behind the pointer.\nUpdates the `PointsTo` value to [`MemContents::Uninit`](MemContents::Uninit).\nNote that this is a `proof` function, i.e.,\nit is operationally a no-op in executable code, even on the Rust Abstract Machine.\nOnly the proof-code representation changes.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 242,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "is_uninit",
          "is_init",
          "value"
        ]
      },
      "is_disjoint": {
        "name": "vstd::raw_ptr::is_disjoint",
        "type": "axiom",
        "signature": "pub axiom fn is_disjoint<S>(tracked &mut self, tracked other: &PointsTo<S>)\n        ensures\n            *old(self) == *self,\n            self.ptr() as int + size_of::<T>() <= other.ptr() as int || other.ptr() as int\n                + size_of::<S>() <= self.ptr() as int,",
        "ensures": [
          "*old(self) == *self",
          "self.ptr() as int + size_of::<T>() <= other.ptr() as int || other.ptr() as int\n                + size_of::<S>() <= self.ptr() as int"
        ],
        "requires": [],
        "body": "{\n    /// Returns `true` if it is a [`MemContents::Init`] value.\n    #[verifier::inline]\n    pub open spec fn is_init(&self) -> bool {\n        self is Init\n    }\n\n    /// Returns `true` if it is a [`MemContents::Uninit`] value.\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self) -> bool {\n        self is Uninit\n    }\n\n    /// If it is a [`MemContents::Init`] value, returns the value.\n    /// Otherwise, the return value is meaningless.\n    #[verifier::inline]\n    pub open spec fn value(&self) -> T\n        recommends\n            self is Init,\n    {\n        self->0\n    }\n}",
        "doc_comment": "Guarantees that the memory ranges associated with two permissions will not overlap,\nsince you cannot have two permissions to the same memory.\n\nNote: If both S and T are non-zero-sized, then this implies the pointers\nhave distinct addresses.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 253,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "is_uninit",
          "is_init",
          "value"
        ]
      },
      "ptr_mut_from_data": {
        "name": "ptr_mut_from_data",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn ptr_mut_from_data<T: ?Sized>(data: PtrData<T>) -> *mut T",
        "ensures": [],
        "requires": [],
        "body": "{\n    ptr_mut_from_data(data) as *const T\n}",
        "doc_comment": "Constructs a pointer from its underlying model.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 294,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "ptr_mut_from_data"
        ]
      },
      "axiom_ptr_mut_from_data": {
        "name": "axiom_ptr_mut_from_data",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_ptr_mut_from_data<T: ?Sized>(data: PtrData<T>)\n    ensures\n        (#[trigger] ptr_mut_from_data::<T>(data))@ == data,",
        "ensures": [
          "(#[trigger] ptr_mut_from_data::<T>(data))@ == data",
          "view_reverse_for_eq::<T>(#[trigger] a@) == a"
        ],
        "requires": [],
        "body": "{\n    view_reverse_for_eq(PtrData { addr: addr, provenance: provenance, metadata: () })\n}",
        "doc_comment": "The view of a pointer constructed from `data: PtrData` should be exactly that data.",
        "triggers": [
          "ptr_mut_from_data::<T>(data",
          "a@"
        ],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 304,
        "module": "vstd::raw_ptr",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "view_reverse_for_eq"
        ]
      },
      "view_reverse_for_eq": {
        "name": "view_reverse_for_eq",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn view_reverse_for_eq<T: ?Sized>(data: PtrData<T>) -> *mut T",
        "ensures": [
          "view_reverse_for_eq::<T>(#[trigger] a@) == a"
        ],
        "requires": [],
        "body": "{\n    view_reverse_for_eq(PtrData { addr: addr, provenance: provenance, metadata: () })\n}",
        "doc_comment": null,
        "triggers": [
          "a@"
        ],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 313,
        "module": "vstd::raw_ptr",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "view_reverse_for_eq"
        ]
      },
      "ptrs_mut_eq": {
        "name": "ptrs_mut_eq",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn ptrs_mut_eq<T: ?Sized>(a: *mut T)\n    ensures\n        view_reverse_for_eq::<T>(#[trigger] a@) == a,",
        "ensures": [
          "view_reverse_for_eq::<T>(#[trigger] a@) == a"
        ],
        "requires": [],
        "body": "{\n    view_reverse_for_eq(PtrData { addr: addr, provenance: provenance, metadata: () })\n}",
        "doc_comment": "Implies that `a@ == b@ ==> a == b`.",
        "triggers": [
          "a@"
        ],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 315,
        "module": "vstd::raw_ptr",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "view_reverse_for_eq"
        ]
      },
      "view_reverse_for_eq_sized": {
        "name": "view_reverse_for_eq_sized",
        "type": "closed_spec",
        "signature": "pub closed spec fn view_reverse_for_eq_sized<T>(addr: usize, provenance: Provenance) -> *mut T",
        "ensures": [],
        "requires": [],
        "body": "{\n    view_reverse_for_eq(PtrData { addr: addr, provenance: provenance, metadata: () })\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 326,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "view_reverse_for_eq"
        ]
      },
      "ptrs_mut_eq_sized": {
        "name": "ptrs_mut_eq_sized",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn ptrs_mut_eq_sized<T>(a: *mut T)\n    ensures\n        view_reverse_for_eq_sized::<T>((#[trigger] a@).addr, a@.provenance) == a,",
        "ensures": [
          "view_reverse_for_eq_sized::<T>((#[trigger] a@).addr, a@.provenance) == a"
        ],
        "requires": [],
        "body": "{\n    assert(a@.metadata == ());\n    ptrs_mut_eq(a);\n}",
        "doc_comment": null,
        "triggers": [
          "a@"
        ],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 330,
        "module": "vstd::raw_ptr",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "ptrs_mut_eq"
        ]
      },
      "provenance": {
        "name": "vstd::raw_ptr::provenance",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn provenance(self) -> Provenance",
        "ensures": [
          "exp.provenance() == Provenance::null()",
          "provenance@@ == m@.provenance",
          "opens_invariants none\n    no_unwind"
        ],
        "requires": [],
        "body": "{\n    let _ = m as usize;\n    Tracked::assume_new()\n}",
        "doc_comment": "Provenance we are exposing.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 591,
        "module": "vstd::raw_ptr",
        "keywords": [
          "invariant"
        ],
        "callees": [
          "assume_new"
        ]
      },
      "vstd::raw_ptr::null": {
        "name": "vstd::raw_ptr::null",
        "type": "axiom",
        "signature": "pub axiom fn null() -> (tracked exp: IsExposed)\n        ensures\n            exp.provenance() == Provenance::null(),",
        "ensures": [
          "exp.provenance() == Provenance::null()",
          "provenance@@ == m@.provenance",
          "opens_invariants none\n    no_unwind"
        ],
        "requires": [],
        "body": "{\n    let _ = m as usize;\n    Tracked::assume_new()\n}",
        "doc_comment": "It is always possible to expose/construct the null provenance.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 594,
        "module": "vstd::raw_ptr",
        "keywords": [
          "invariant"
        ],
        "callees": [
          "assume_new"
        ]
      },
      "vstd::raw_ptr::provenance": {
        "name": "vstd::raw_ptr::provenance",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn provenance(self) -> Provenance",
        "ensures": [],
        "requires": [],
        "body": "{\n        super::set_lib::set_int_range(start, start + len) =~= self.dom()\n    }",
        "doc_comment": "Provenance of the `PointsToRaw` permission;\nthis corresponds to the original allocation and does not change.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 645,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "dom",
          "set_int_range"
        ]
      },
      "vstd::raw_ptr::dom": {
        "name": "vstd::raw_ptr::dom",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn dom(self) -> Set<int>",
        "ensures": [],
        "requires": [],
        "body": "{\n        super::set_lib::set_int_range(start, start + len) =~= self.dom()\n    }",
        "doc_comment": "Memory addresses (domain) that the `PointsToRaw` permission gives access to.\nThis set may be split apart and/or recombined, in order to create permissions to smaller pieces of the allocation.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 648,
        "module": "vstd::raw_ptr",
        "keywords": [
          "Set"
        ],
        "callees": [
          "dom",
          "set_int_range"
        ]
      },
      "vstd::raw_ptr::empty": {
        "name": "vstd::raw_ptr::empty",
        "type": "axiom",
        "signature": "pub axiom fn empty(provenance: Provenance) -> (tracked points_to_raw: Self)\n        ensures\n            points_to_raw.dom() == Set::<int>::empty(),\n            points_to_raw.provenance() == provenance,",
        "ensures": [
          "points_to_raw.dom() == Set::<int>::empty()",
          "points_to_raw.provenance() == provenance",
          "res.0.provenance() == self.provenance()",
          "res.1.provenance() == self.provenance()",
          "res.0.dom() == range",
          "res.1.dom() == self.dom().difference(range)",
          "joined.provenance() == self.provenance()",
          "joined.dom() == self.dom() + other.dom()",
          "points_to.ptr() == ptr_mut_from_data::<V>(\n                PtrData"
        ],
        "requires": [
          "range.subset_of(self.dom())",
          "self.provenance() == other.provenance()",
          "start as int % align_of::<V>() as int == 0",
          "self.is_range(start as int, size_of::<V>() as int)"
        ],
        "body": "{ addr: start, provenance: self.provenance(), metadata: () }",
        "doc_comment": "Constructs a `PointsToRaw` permission over an empty domain with the given provenance.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 662,
        "module": "vstd::raw_ptr",
        "keywords": [
          "Set",
          "difference",
          "empty"
        ],
        "callees": [
          "provenance"
        ]
      },
      "vstd::raw_ptr::split": {
        "name": "vstd::raw_ptr::split",
        "type": "axiom",
        "signature": "pub axiom fn split(tracked self, range: Set<int>) -> (tracked res: (Self, Self))\n        requires\n            range.subset_of(self.dom()),\n        ensures\n            res.0.provenance() == self.provenance(),\n            res.1.provenance() == self.provenance(),\n            res.0.dom() == range,\n            res.1.dom() == self.dom().difference(range),",
        "ensures": [
          "res.0.provenance() == self.provenance()",
          "res.1.provenance() == self.provenance()",
          "res.0.dom() == range",
          "res.1.dom() == self.dom().difference(range)",
          "joined.provenance() == self.provenance()",
          "joined.dom() == self.dom() + other.dom()",
          "points_to.ptr() == ptr_mut_from_data::<V>(\n                PtrData"
        ],
        "requires": [
          "range.subset_of(self.dom())",
          "self.provenance() == other.provenance()",
          "start as int % align_of::<V>() as int == 0",
          "self.is_range(start as int, size_of::<V>() as int)"
        ],
        "body": "{ addr: start, provenance: self.provenance(), metadata: () }",
        "doc_comment": "Splits the current `PointsToRaw` permission into a permission with domain `range`\nand a permission containing the rest of the domain,\nprovided that `range` is contained in the domain of the current permission.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 669,
        "module": "vstd::raw_ptr",
        "keywords": [
          "Set",
          "difference"
        ],
        "callees": [
          "provenance"
        ]
      },
      "vstd::raw_ptr::join": {
        "name": "vstd::raw_ptr::join",
        "type": "axiom",
        "signature": "pub axiom fn join(tracked self, tracked other: Self) -> (tracked joined: Self)\n        requires\n            self.provenance() == other.provenance(),\n        ensures\n            joined.provenance() == self.provenance(),\n            joined.dom() == self.dom() + other.dom(),",
        "ensures": [
          "joined.provenance() == self.provenance()",
          "joined.dom() == self.dom() + other.dom()",
          "points_to.ptr() == ptr_mut_from_data::<V>(\n                PtrData"
        ],
        "requires": [
          "self.provenance() == other.provenance()",
          "start as int % align_of::<V>() as int == 0",
          "self.is_range(start as int, size_of::<V>() as int)"
        ],
        "body": "{ addr: start, provenance: self.provenance(), metadata: () }",
        "doc_comment": "Joins two `PointsToRaw` permissions into one,\nprovided that they have the same provenance.\nThe memory addresses of the new permission is the union of the domains of `self` and `other`.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 682,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "provenance"
        ]
      },
      "into_typed": {
        "name": "into_typed",
        "type": "axiom",
        "signature": "pub axiom fn into_typed<V>(tracked self, start: usize) -> (tracked points_to: PointsTo<V>)\n        requires\n            start as int % align_of::<V>() as int == 0,\n            self.is_range(start as int, size_of::<V>() as int),\n        ensures\n            points_to.ptr() == ptr_mut_from_data::<V>(\n                PtrData",
        "ensures": [
          "points_to.ptr() == ptr_mut_from_data::<V>(\n                PtrData"
        ],
        "requires": [
          "start as int % align_of::<V>() as int == 0",
          "self.is_range(start as int, size_of::<V>() as int)"
        ],
        "body": "{ addr: start, provenance: self.provenance(), metadata: () }",
        "doc_comment": "Creates a `PointsTo<V>` permission from a `PointsToRaw` permission\nwith address `start` and the same provanance as the `PointsToRaw` permission,\nprovided that `start` is aligned to `V` and\nthat the domain of the `PointsToRaw` permission matches the size of `V`.\n\nIn combination with PointsToRaw::empty(),\nthis lets us create a PointsTo for a ZST for _any_ pointer (any address and provenance).\n(even null).\nAdmittedly, this does violate ['strict provenance'](https://doc.rust-lang.org/std/ptr/#using-strict-provenance);\nbut that's ok. It is still allowed in Rust's more permissive semantics.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 693,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "provenance"
        ]
      },
      "into_raw": {
        "name": "into_raw",
        "type": "axiom",
        "signature": "pub axiom fn into_raw(tracked self) -> (tracked points_to_raw: PointsToRaw)\n        requires\n            self.is_uninit(),\n        ensures\n            points_to_raw.is_range(self.ptr().addr() as int, size_of::<V>() as int),\n            points_to_raw.provenance() == self.ptr()@.provenance,",
        "ensures": [
          "points_to_raw.is_range(self.ptr().addr() as int, size_of::<V>() as int)",
          "points_to_raw.provenance() == self.ptr()@.provenance"
        ],
        "requires": [
          "self.is_uninit()"
        ],
        "body": "{\n    no_copy: NoCopy,\n}",
        "doc_comment": "Creates a `PointsToRaw` from a `PointsTo<V>` with the same provenance\nand a range corresponding to the address of the `PointsTo<V>` and size of `V`,\nprovided that the memory tracked by the `PointsTo<V>`is uninitialized.",
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 717,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": []
      },
      "vstd::raw_ptr::view": {
        "name": "vstd::raw_ptr::view",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn view(self) -> DeallocData",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.view().addr\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 747,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "view"
        ]
      },
      "vstd::raw_ptr::value": {
        "name": "vstd::raw_ptr::value",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn value(self) -> T",
        "ensures": [
          "s.value() == t"
        ],
        "requires": [],
        "body": "{\n        SharedReference(t)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 866,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "eference"
        ]
      },
      "ptr": {
        "name": "ptr",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn ptr(self) -> *const T",
        "ensures": [
          "s.value() == t"
        ],
        "requires": [],
        "body": "{\n        SharedReference(t)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 867,
        "module": "vstd::raw_ptr",
        "keywords": [],
        "callees": [
          "eference"
        ]
      },
      "points_to": {
        "name": "points_to",
        "type": "axiom",
        "signature": "pub axiom fn points_to(tracked self) -> (tracked pt: &'a PointsTo<T>)\n        ensures\n            pt.ptr() == self.ptr(),\n            pt.is_init(),\n            pt.value() == self.value(),",
        "ensures": [
          "pt.ptr() == self.ptr()",
          "pt.is_init()",
          "pt.value() == self.value()",
          "v.value() == perm.value()",
          "v.ptr().addr() == ptr.addr()",
          "v.ptr()@.metadata == ptr@.metadata",
          "opens_invariants none\n    no_unwind"
        ],
        "requires": [
          "perm.ptr() == ptr",
          "perm.is_init()"
        ],
        "body": "{\n    SharedReference(unsafe { &*ptr })\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 893,
        "module": "vstd::raw_ptr",
        "keywords": [
          "invariant"
        ],
        "callees": [
          "eference"
        ]
      },
      "lemma_new_first_element_still_sorted_by": {
        "name": "lemma_new_first_element_still_sorted_by",
        "type": "proof",
        "signature": "pub proof fn lemma_new_first_element_still_sorted_by<T>(\n    x: T,\n    s: Seq<T>,\n    less_than: spec_fn(T, T) -> bool,\n)\n    requires\n        sorted_by(s, less_than),\n        s.len() == 0 || less_than(x, s[0]),\n        total_ordering(less_than),\n    ensures\n        sorted_by(seq![x].add(s), less_than),",
        "ensures": [
          "sorted_by(seq![x].add(s), less_than)"
        ],
        "requires": [
          "sorted_by(s, less_than)",
          "s.len() == 0 || less_than(x, s[0])",
          "total_ordering(less_than)"
        ],
        "body": "{\n    broadcast use group_seq_axioms;\n\n    if s.len() > 1 {\n        assert forall|index: int| 0 < index < s.len() implies #[trigger] less_than(x, s[index]) by {\n            assert(less_than(s[0], s[index]));\n        };\n    }\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 118,
        "module": "vstd::relations",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": [
          "len",
          "less_than"
        ]
      },
      "rwlock": {
        "name": "vstd::rwlock::rwlock",
        "type": "closed_spec",
        "signature": "pub closed spec fn rwlock(self) -> RwLock<V, Pred>",
        "ensures": [],
        "requires": [],
        "body": "{\n        *self.rwlock\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/rwlock.rs",
        "line_number": 396,
        "module": "vstd::rwlock",
        "keywords": [],
        "callees": []
      },
      "vstd::rwlock::view": {
        "name": "vstd::rwlock::view",
        "type": "closed_spec",
        "signature": "pub closed spec fn view(self) -> V",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.handle@.element().value()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/rwlock.rs",
        "line_number": 429,
        "module": "vstd::rwlock",
        "keywords": [],
        "callees": [
          "element",
          "value"
        ]
      },
      "vstd::rwlock::rwlock": {
        "name": "vstd::rwlock::rwlock",
        "type": "closed_spec",
        "signature": "pub closed spec fn rwlock(self) -> RwLock<V, Pred>",
        "ensures": [],
        "requires": [],
        "body": "{\n        *self.rwlock\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/rwlock.rs",
        "line_number": 433,
        "module": "vstd::rwlock",
        "keywords": [],
        "callees": []
      },
      "lemma_readers_match": {
        "name": "lemma_readers_match",
        "type": "proof",
        "signature": "pub proof fn lemma_readers_match(\n        tracked read_handle1: &ReadHandle<V, Pred>,\n        tracked read_handle2: &ReadHandle<V, Pred>,\n    )\n        requires\n            read_handle1.rwlock() == read_handle2.rwlock(),\n        ensures\n            (equal(read_handle1.view(), read_handle2.view())),",
        "ensures": [
          "(equal(read_handle1.view(), read_handle2.view()))"
        ],
        "requires": [
          "read_handle1.rwlock() == read_handle2.rwlock()"
        ],
        "body": "{\n        use_type_invariant(read_handle1);\n        use_type_invariant(read_handle2);\n        read_handle1.rwlock.inst.borrow().read_match(\n            read_handle1.handle@.element(),\n            read_handle2.handle@.element(),\n            &read_handle1.handle.borrow(),\n            &read_handle2.handle.borrow(),\n        );\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/rwlock.rs",
        "line_number": 452,
        "module": "vstd::rwlock",
        "keywords": [],
        "callees": [
          "read_match",
          "element",
          "use_type_invariant",
          "borrow"
        ]
      },
      "pred": {
        "name": "pred",
        "type": "closed_spec",
        "signature": "pub closed spec fn pred(&self) -> Pred",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.pred@\n    }",
        "doc_comment": "Predicate configured for this lock instance.",
        "triggers": [],
        "file_path": "verus/source/vstd/rwlock.rs",
        "line_number": 489,
        "module": "vstd::rwlock",
        "keywords": [],
        "callees": []
      },
      "vstd::seq::empty": {
        "name": "vstd::seq::empty",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn empty() -> Seq<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.index(i)\n    }",
        "doc_comment": "An empty sequence (i.e., a sequence of length 0).",
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 35,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "empty"
        ],
        "callees": [
          "index"
        ]
      },
      "vstd::seq::new": {
        "name": "vstd::seq::new",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn new(len: nat, f: impl Fn(int) -> A) -> Seq<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.index(i)\n    }",
        "doc_comment": "Construct a sequence `s` of length `len` where entry `s[i]` is given by `f(i)`.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 38,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": [
          "index"
        ]
      },
      "vstd::seq::len": {
        "name": "vstd::seq::len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn len(self) -> nat",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.index(i)\n    }",
        "doc_comment": "The length of a sequence.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 42,
        "module": "vstd::seq",
        "keywords": [
          "len"
        ],
        "callees": [
          "index"
        ]
      },
      "vstd::seq::index": {
        "name": "vstd::seq::index",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn index(self, i: int) -> A\n        recommends\n            0 <= i < self.len(),",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.index(i)\n    }",
        "doc_comment": "Gets the value at the given index `i`.\n\nIf `i` is not in the range `[0, self.len())`, then the resulting value\nis meaningless and arbitrary.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 46,
        "module": "vstd::seq",
        "keywords": [
          "len"
        ],
        "callees": [
          "index"
        ]
      },
      "vstd::seq::tracked_empty": {
        "name": "vstd::seq::tracked_empty",
        "type": "proof",
        "signature": "pub proof fn tracked_empty() -> (tracked ret: Self)\n        ensures\n            ret === Seq::empty(),",
        "ensures": [
          "ret === Seq::empty()"
        ],
        "requires": [],
        "body": "{\n        unimplemented!()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 166,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "empty"
        ],
        "callees": []
      },
      "vstd::seq::tracked_remove": {
        "name": "vstd::seq::tracked_remove",
        "type": "proof",
        "signature": "pub proof fn tracked_remove(tracked &mut self, i: int) -> (tracked ret: A)\n        requires\n            0 <= i < old(self).len(),\n        ensures\n            ret === old(self)[i],\n            self.len() == old(self).len() - 1,\n            self == old(self).remove(i),",
        "ensures": [
          "ret === old(self)[i]",
          "self.len() == old(self).len() - 1",
          "self == old(self).remove(i)"
        ],
        "requires": [
          "0 <= i < old(self).len()"
        ],
        "body": "{\n        unimplemented!()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 174,
        "module": "vstd::seq",
        "keywords": [
          "len",
          "remove"
        ],
        "callees": []
      },
      "vstd::seq::tracked_insert": {
        "name": "vstd::seq::tracked_insert",
        "type": "proof",
        "signature": "pub proof fn tracked_insert(tracked &mut self, i: int, tracked v: A)\n        requires\n            0 <= i <= old(self).len(),\n        ensures\n            self.len() == old(self).len() + 1,\n            self == old(self).insert(i, v),",
        "ensures": [
          "self.len() == old(self).len() + 1",
          "self == old(self).insert(i, v)"
        ],
        "requires": [
          "0 <= i <= old(self).len()"
        ],
        "body": "{\n        unimplemented!()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 186,
        "module": "vstd::seq",
        "keywords": [
          "insert",
          "len"
        ],
        "callees": []
      },
      "vstd::seq::tracked_borrow": {
        "name": "vstd::seq::tracked_borrow",
        "type": "proof",
        "signature": "pub proof fn tracked_borrow(tracked &self, i: int) -> (tracked ret: &A)\n        requires\n            0 <= i < self.len(),\n        ensures\n            *ret === self[i],",
        "ensures": [
          "*ret === self[i]"
        ],
        "requires": [
          "0 <= i < self.len()"
        ],
        "body": "{\n        unimplemented!()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 197,
        "module": "vstd::seq",
        "keywords": [
          "len"
        ],
        "callees": []
      },
      "tracked_push": {
        "name": "tracked_push",
        "type": "proof",
        "signature": "pub proof fn tracked_push(tracked &mut self, tracked v: A)\n        ensures\n            *self == old(self).push(v),\n            self.len() == old(self).len() + 1,",
        "ensures": [
          "*self == old(self).push(v)",
          "self.len() == old(self).len() + 1"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_seq_axioms;\n\n        assert(self.insert(self.len() as int, v) =~= self.push(v));\n        self.tracked_insert(self.len() as int, v);\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 207,
        "module": "vstd::seq",
        "keywords": [
          "len",
          "push"
        ],
        "callees": [
          "len",
          "tracked_insert",
          "insert",
          "push"
        ]
      },
      "tracked_pop": {
        "name": "tracked_pop",
        "type": "proof",
        "signature": "pub proof fn tracked_pop(tracked &mut self) -> (tracked ret: A)\n        requires\n            old(self).len() > 0,\n        ensures\n            ret === old(self).last(),\n            self.len() == old(self).len() - 1,\n            *self == old(self).take(old(self).len() - 1),",
        "ensures": [
          "ret === old(self).last()",
          "self.len() == old(self).len() - 1",
          "*self == old(self).take(old(self).len() - 1)"
        ],
        "requires": [
          "old(self).len() > 0"
        ],
        "body": "{\n        broadcast use group_seq_axioms;\n\n        assert(self.remove(self.len() - 1) =~= self.take(self.len() - 1));\n        self.tracked_remove(self.len() - 1)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 218,
        "module": "vstd::seq",
        "keywords": [
          "len",
          "take"
        ],
        "callees": [
          "len",
          "take",
          "remove",
          "tracked_remove"
        ]
      },
      "tracked_pop_front": {
        "name": "tracked_pop_front",
        "type": "proof",
        "signature": "pub proof fn tracked_pop_front(tracked &mut self) -> (tracked ret: A)\n        requires\n            old(self).len() > 0,\n        ensures\n            ret === old(self).first(),\n            self.len() == old(self).len() - 1,\n            *self == old(self).drop_first(),",
        "ensures": [
          "ret === old(self).first()",
          "self.len() == old(self).len() - 1",
          "*self == old(self).drop_first()"
        ],
        "requires": [
          "old(self).len() > 0"
        ],
        "body": "{\n        broadcast use group_seq_axioms;\n\n        assert(self.remove(0) =~= self.drop_first());\n        self.tracked_remove(0)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 232,
        "module": "vstd::seq",
        "keywords": [
          "len"
        ],
        "callees": [
          "drop_first",
          "tracked_remove",
          "remove"
        ]
      },
      "axiom_seq_index_decreases": {
        "name": "axiom_seq_index_decreases",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_index_decreases<A>(s: Seq<A>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        #[trigger] (decreases_to!(s => s[i])),",
        "ensures": [
          "#[trigger] (",
          "#[trigger] ("
        ],
        "requires": [
          "0 <= i < s.len()",
          "s2.len() < s1.len()",
          "forall|i2: int|\n            0 <= i2 < s2.len() && #[trigger] trigger(s2[i2]) ==> exists|i1: int|\n                0 <= i1 < s1.len() && s1[i1] == s2[i2]",
          "0 <= i <= j <= s.len()",
          "s.subrange(i, j).len() < s.len()"
        ],
        "body": "{\n    broadcast use {axiom_seq_subrange_len, axiom_seq_subrange_index};\n\n    let s2 = s.subrange(i, j);\n    assert forall|i2: int| 0 <= i2 < s2.len() && #[trigger] trigger(s2[i2]) implies exists|i1: int|\n        0 <= i1 < s.len() && s[i1] == s2[i2] by {\n        assert(s[i + i2] == s2[i2]);\n    }\n    axiom_seq_len_decreases(s, s2);\n}",
        "doc_comment": null,
        "triggers": [
          "(",
          "("
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 249,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "decreases",
          "exists",
          "forall",
          "len",
          "subrange",
          "trigger"
        ],
        "callees": [
          "len",
          "axiom_seq_len_decreases",
          "subrange",
          "trigger"
        ]
      },
      "axiom_seq_len_decreases": {
        "name": "axiom_seq_len_decreases",
        "type": "axiom",
        "signature": "pub axiom fn axiom_seq_len_decreases<A>(s1: Seq<A>, s2: Seq<A>)\n    requires\n        s2.len() < s1.len(),\n        forall|i2: int|\n            0 <= i2 < s2.len() && #[trigger] trigger(s2[i2]) ==> exists|i1: int|\n                0 <= i1 < s1.len() && s1[i1] == s2[i2],\n    ensures\n        decreases_to!(s1 => s2),",
        "ensures": [
          "#[trigger] ("
        ],
        "requires": [
          "s2.len() < s1.len()",
          "forall|i2: int|\n            0 <= i2 < s2.len() && #[trigger] trigger(s2[i2]) ==> exists|i1: int|\n                0 <= i1 < s1.len() && s1[i1] == s2[i2]",
          "0 <= i <= j <= s.len()",
          "s.subrange(i, j).len() < s.len()"
        ],
        "body": "{\n    broadcast use {axiom_seq_subrange_len, axiom_seq_subrange_index};\n\n    let s2 = s.subrange(i, j);\n    assert forall|i2: int| 0 <= i2 < s2.len() && #[trigger] trigger(s2[i2]) implies exists|i1: int|\n        0 <= i1 < s.len() && s[i1] == s2[i2] by {\n        assert(s[i + i2] == s2[i2]);\n    }\n    axiom_seq_len_decreases(s, s2);\n}",
        "doc_comment": null,
        "triggers": [
          "("
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 255,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "decreases",
          "exists",
          "forall",
          "len",
          "subrange",
          "trigger"
        ],
        "callees": [
          "len",
          "axiom_seq_len_decreases",
          "subrange",
          "trigger"
        ]
      },
      "axiom_seq_subrange_decreases": {
        "name": "axiom_seq_subrange_decreases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_seq_subrange_decreases<A>(s: Seq<A>, i: int, j: int)\n    requires\n        0 <= i <= j <= s.len(),\n        s.subrange(i, j).len() < s.len(),\n    ensures\n        #[trigger] (decreases_to!(s => s.subrange(i, j))),",
        "ensures": [
          "#[trigger] ("
        ],
        "requires": [
          "0 <= i <= j <= s.len()",
          "s.subrange(i, j).len() < s.len()"
        ],
        "body": "{\n    broadcast use {axiom_seq_subrange_len, axiom_seq_subrange_index};\n\n    let s2 = s.subrange(i, j);\n    assert forall|i2: int| 0 <= i2 < s2.len() && #[trigger] trigger(s2[i2]) implies exists|i1: int|\n        0 <= i1 < s.len() && s[i1] == s2[i2] by {\n        assert(s[i + i2] == s2[i2]);\n    }\n    axiom_seq_len_decreases(s, s2);\n}",
        "doc_comment": null,
        "triggers": [
          "("
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 265,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "decreases",
          "len",
          "subrange",
          "trigger"
        ],
        "callees": [
          "len",
          "axiom_seq_len_decreases",
          "subrange",
          "trigger"
        ]
      },
      "axiom_seq_empty": {
        "name": "axiom_seq_empty",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_empty<A>()\n    ensures\n        #[trigger] Seq::<A>::empty().len() == 0,",
        "ensures": [
          "#[trigger] Seq::<A>::empty().len() == 0",
          "#[trigger] Seq::new(len, f).len() == len",
          "#[trigger] Seq::new(len, f)[i] == f(i)",
          "#[trigger] s.push(a).len() == s.len() + 1",
          "#[trigger] s.push(a)[i] == a",
          "#[trigger] s.push(a)[i] == s[i]",
          "#[trigger] s.update(i, a).len() == s.len()",
          "#[trigger] s.update(i, a)[i] == a",
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "0 <= i < len",
          "i == s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "Seq::<A>::empty(",
          "Seq::new(len",
          "Seq::new(len",
          "s.push(a",
          "s.push(a",
          "s.push(a",
          "s.update(i",
          "s.update(i",
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 282,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "empty",
          "len",
          "push",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_new_len": {
        "name": "axiom_seq_new_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_new_len<A>(len: nat, f: spec_fn(int) -> A)\n    ensures\n        #[trigger] Seq::new(len, f).len() == len,",
        "ensures": [
          "#[trigger] Seq::new(len, f).len() == len",
          "#[trigger] Seq::new(len, f)[i] == f(i)",
          "#[trigger] s.push(a).len() == s.len() + 1",
          "#[trigger] s.push(a)[i] == a",
          "#[trigger] s.push(a)[i] == s[i]",
          "#[trigger] s.update(i, a).len() == s.len()",
          "#[trigger] s.update(i, a)[i] == a",
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "0 <= i < len",
          "i == s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "Seq::new(len",
          "Seq::new(len",
          "s.push(a",
          "s.push(a",
          "s.push(a",
          "s.update(i",
          "s.update(i",
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 287,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "push",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_new_index": {
        "name": "axiom_seq_new_index",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_new_index<A>(len: nat, f: spec_fn(int) -> A, i: int)\n    requires\n        0 <= i < len,\n    ensures\n        #[trigger] Seq::new(len, f)[i] == f(i),",
        "ensures": [
          "#[trigger] Seq::new(len, f)[i] == f(i)",
          "#[trigger] s.push(a).len() == s.len() + 1",
          "#[trigger] s.push(a)[i] == a",
          "#[trigger] s.push(a)[i] == s[i]",
          "#[trigger] s.update(i, a).len() == s.len()",
          "#[trigger] s.update(i, a)[i] == a",
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "0 <= i < len",
          "i == s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "Seq::new(len",
          "s.push(a",
          "s.push(a",
          "s.push(a",
          "s.update(i",
          "s.update(i",
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 292,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "push",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_push_len": {
        "name": "axiom_seq_push_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_push_len<A>(s: Seq<A>, a: A)\n    ensures\n        #[trigger] s.push(a).len() == s.len() + 1,",
        "ensures": [
          "#[trigger] s.push(a).len() == s.len() + 1",
          "#[trigger] s.push(a)[i] == a",
          "#[trigger] s.push(a)[i] == s[i]",
          "#[trigger] s.update(i, a).len() == s.len()",
          "#[trigger] s.update(i, a)[i] == a",
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "i == s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "s.push(a",
          "s.push(a",
          "s.push(a",
          "s.update(i",
          "s.update(i",
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 299,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "push",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_push_index_same": {
        "name": "axiom_seq_push_index_same",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_push_index_same<A>(s: Seq<A>, a: A, i: int)\n    requires\n        i == s.len(),\n    ensures\n        #[trigger] s.push(a)[i] == a,",
        "ensures": [
          "#[trigger] s.push(a)[i] == a",
          "#[trigger] s.push(a)[i] == s[i]",
          "#[trigger] s.update(i, a).len() == s.len()",
          "#[trigger] s.update(i, a)[i] == a",
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "i == s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "s.push(a",
          "s.push(a",
          "s.update(i",
          "s.update(i",
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 304,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "push",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_push_index_different": {
        "name": "axiom_seq_push_index_different",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_push_index_different<A>(s: Seq<A>, a: A, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        #[trigger] s.push(a)[i] == s[i],",
        "ensures": [
          "#[trigger] s.push(a)[i] == s[i]",
          "#[trigger] s.update(i, a).len() == s.len()",
          "#[trigger] s.update(i, a)[i] == a",
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "s.push(a",
          "s.update(i",
          "s.update(i",
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 311,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "push",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_update_len": {
        "name": "axiom_seq_update_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_update_len<A>(s: Seq<A>, i: int, a: A)\n    requires\n        0 <= i < s.len(),\n    ensures\n        #[trigger] s.update(i, a).len() == s.len(),",
        "ensures": [
          "#[trigger] s.update(i, a).len() == s.len()",
          "#[trigger] s.update(i, a)[i] == a",
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "0 <= i < s.len()",
          "0 <= i < s.len()",
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "s.update(i",
          "s.update(i",
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 318,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_update_same": {
        "name": "axiom_seq_update_same",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_update_same<A>(s: Seq<A>, i: int, a: A)\n    requires\n        0 <= i < s.len(),\n    ensures\n        #[trigger] s.update(i, a)[i] == a,",
        "ensures": [
          "#[trigger] s.update(i, a)[i] == a",
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "0 <= i < s.len()",
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "s.update(i",
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 325,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_update_different": {
        "name": "axiom_seq_update_different",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_update_different<A>(s: Seq<A>, i1: int, i2: int, a: A)\n    requires\n        0 <= i1 < s.len(),\n        0 <= i2 < s.len(),\n        i1 != i2,\n    ensures\n        #[trigger] s.update(i2, a)[i1] == s[i1],",
        "ensures": [
          "#[trigger] s.update(i2, a)[i1] == s[i1]",
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [
          "0 <= i1 < s.len()",
          "0 <= i2 < s.len()",
          "i1 != i2"
        ],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "s.update(i2",
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 332,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_ext_equal": {
        "name": "axiom_seq_ext_equal",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_ext_equal<A>(s1: Seq<A>, s2: Seq<A>)\n    ensures\n        #[trigger] (s1 =~= s2) <==>",
        "ensures": [
          "#[trigger] (s1 =~= s2) <==>"
        ],
        "requires": [],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] == s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 341,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_ext_equal_deep": {
        "name": "axiom_seq_ext_equal_deep",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_ext_equal_deep<A>(s1: Seq<A>, s2: Seq<A>)\n    ensures\n        #[trigger] (s1 =~~= s2) <==>",
        "ensures": [
          "#[trigger] (s1 =~~= s2) <==>"
        ],
        "requires": [],
        "body": "{\n            &&& s1.len() == s2.len()\n            &&& forall|i: int| 0 <= i < s1.len() ==> s1[i] =~~= s2[i]\n        }",
        "doc_comment": null,
        "triggers": [
          "(s1 =~~= s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 349,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "trigger"
        ],
        "callees": [
          "len"
        ]
      },
      "axiom_seq_subrange_len": {
        "name": "axiom_seq_subrange_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_subrange_len<A>(s: Seq<A>, j: int, k: int)\n    requires\n        0 <= j <= k <= s.len(),\n    ensures\n        #[trigger] s.subrange(j, k).len() == k - j,",
        "ensures": [
          "#[trigger] s.subrange(j, k).len() == k - j",
          "#[trigger] s.subrange(j, k)[i] == s[i + j]",
          "#[trigger] s1.add(s2).len() == s1.len() + s2.len()",
          "#[trigger] s1.add(s2)[i] == s1[i]",
          "#[trigger] s1.add(s2)[i] == s2[i - s1.len()]"
        ],
        "requires": [
          "0 <= j <= k <= s.len()",
          "0 <= j <= k <= s.len()",
          "0 <= i < k - j",
          "0 <= i < s1.len()",
          "s1.len() <= i < s1.len() + s2.len()"
        ],
        "body": "{\n    axiom_seq_index_decreases,\n    axiom_seq_subrange_decreases,\n    axiom_seq_empty,\n    axiom_seq_new_len,\n    axiom_seq_new_index,\n    axiom_seq_push_len,\n    axiom_seq_push_index_same,\n    axiom_seq_push_index_different,\n    axiom_seq_update_len,\n    axiom_seq_update_same,\n    axiom_seq_update_different,\n    axiom_seq_ext_equal,\n    axiom_seq_ext_equal_deep,\n    axiom_seq_subrange_len,\n    axiom_seq_subrange_index,\n    axiom_seq_add_len,\n    axiom_seq_add_index1,\n    axiom_seq_add_index2,\n}",
        "doc_comment": null,
        "triggers": [
          "s.subrange(j",
          "s.subrange(j",
          "s1.add(s2",
          "s1.add(s2",
          "s1.add(s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 357,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "subrange",
          "trigger"
        ],
        "callees": []
      },
      "axiom_seq_subrange_index": {
        "name": "axiom_seq_subrange_index",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_subrange_index<A>(s: Seq<A>, j: int, k: int, i: int)\n    requires\n        0 <= j <= k <= s.len(),\n        0 <= i < k - j,\n    ensures\n        #[trigger] s.subrange(j, k)[i] == s[i + j],",
        "ensures": [
          "#[trigger] s.subrange(j, k)[i] == s[i + j]",
          "#[trigger] s1.add(s2).len() == s1.len() + s2.len()",
          "#[trigger] s1.add(s2)[i] == s1[i]",
          "#[trigger] s1.add(s2)[i] == s2[i - s1.len()]"
        ],
        "requires": [
          "0 <= j <= k <= s.len()",
          "0 <= i < k - j",
          "0 <= i < s1.len()",
          "s1.len() <= i < s1.len() + s2.len()"
        ],
        "body": "{\n    axiom_seq_index_decreases,\n    axiom_seq_subrange_decreases,\n    axiom_seq_empty,\n    axiom_seq_new_len,\n    axiom_seq_new_index,\n    axiom_seq_push_len,\n    axiom_seq_push_index_same,\n    axiom_seq_push_index_different,\n    axiom_seq_update_len,\n    axiom_seq_update_same,\n    axiom_seq_update_different,\n    axiom_seq_ext_equal,\n    axiom_seq_ext_equal_deep,\n    axiom_seq_subrange_len,\n    axiom_seq_subrange_index,\n    axiom_seq_add_len,\n    axiom_seq_add_index1,\n    axiom_seq_add_index2,\n}",
        "doc_comment": null,
        "triggers": [
          "s.subrange(j",
          "s1.add(s2",
          "s1.add(s2",
          "s1.add(s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 364,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "subrange",
          "trigger"
        ],
        "callees": []
      },
      "axiom_seq_add_len": {
        "name": "axiom_seq_add_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_add_len<A>(s1: Seq<A>, s2: Seq<A>)\n    ensures\n        #[trigger] s1.add(s2).len() == s1.len() + s2.len(),",
        "ensures": [
          "#[trigger] s1.add(s2).len() == s1.len() + s2.len()",
          "#[trigger] s1.add(s2)[i] == s1[i]",
          "#[trigger] s1.add(s2)[i] == s2[i - s1.len()]"
        ],
        "requires": [
          "0 <= i < s1.len()",
          "s1.len() <= i < s1.len() + s2.len()"
        ],
        "body": "{\n    axiom_seq_index_decreases,\n    axiom_seq_subrange_decreases,\n    axiom_seq_empty,\n    axiom_seq_new_len,\n    axiom_seq_new_index,\n    axiom_seq_push_len,\n    axiom_seq_push_index_same,\n    axiom_seq_push_index_different,\n    axiom_seq_update_len,\n    axiom_seq_update_same,\n    axiom_seq_update_different,\n    axiom_seq_ext_equal,\n    axiom_seq_ext_equal_deep,\n    axiom_seq_subrange_len,\n    axiom_seq_subrange_index,\n    axiom_seq_add_len,\n    axiom_seq_add_index1,\n    axiom_seq_add_index2,\n}",
        "doc_comment": null,
        "triggers": [
          "s1.add(s2",
          "s1.add(s2",
          "s1.add(s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 372,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_seq_add_index1": {
        "name": "axiom_seq_add_index1",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_add_index1<A>(s1: Seq<A>, s2: Seq<A>, i: int)\n    requires\n        0 <= i < s1.len(),\n    ensures\n        #[trigger] s1.add(s2)[i] == s1[i],",
        "ensures": [
          "#[trigger] s1.add(s2)[i] == s1[i]",
          "#[trigger] s1.add(s2)[i] == s2[i - s1.len()]"
        ],
        "requires": [
          "0 <= i < s1.len()",
          "s1.len() <= i < s1.len() + s2.len()"
        ],
        "body": "{\n    axiom_seq_index_decreases,\n    axiom_seq_subrange_decreases,\n    axiom_seq_empty,\n    axiom_seq_new_len,\n    axiom_seq_new_index,\n    axiom_seq_push_len,\n    axiom_seq_push_index_same,\n    axiom_seq_push_index_different,\n    axiom_seq_update_len,\n    axiom_seq_update_same,\n    axiom_seq_update_different,\n    axiom_seq_ext_equal,\n    axiom_seq_ext_equal_deep,\n    axiom_seq_subrange_len,\n    axiom_seq_subrange_index,\n    axiom_seq_add_len,\n    axiom_seq_add_index1,\n    axiom_seq_add_index2,\n}",
        "doc_comment": null,
        "triggers": [
          "s1.add(s2",
          "s1.add(s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 377,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_seq_add_index2": {
        "name": "axiom_seq_add_index2",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_seq_add_index2<A>(s1: Seq<A>, s2: Seq<A>, i: int)\n    requires\n        s1.len() <= i < s1.len() + s2.len(),\n    ensures\n        #[trigger] s1.add(s2)[i] == s2[i - s1.len()],",
        "ensures": [
          "#[trigger] s1.add(s2)[i] == s2[i - s1.len()]"
        ],
        "requires": [
          "s1.len() <= i < s1.len() + s2.len()"
        ],
        "body": "{\n    axiom_seq_index_decreases,\n    axiom_seq_subrange_decreases,\n    axiom_seq_empty,\n    axiom_seq_new_len,\n    axiom_seq_new_index,\n    axiom_seq_push_len,\n    axiom_seq_push_index_same,\n    axiom_seq_push_index_different,\n    axiom_seq_update_len,\n    axiom_seq_update_same,\n    axiom_seq_update_different,\n    axiom_seq_ext_equal,\n    axiom_seq_ext_equal_deep,\n    axiom_seq_subrange_len,\n    axiom_seq_subrange_index,\n    axiom_seq_add_len,\n    axiom_seq_add_index1,\n    axiom_seq_add_index2,\n}",
        "doc_comment": null,
        "triggers": [
          "s1.add(s2"
        ],
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 384,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_sort_by_ensures": {
        "name": "lemma_sort_by_ensures",
        "type": "proof",
        "signature": "pub proof fn lemma_sort_by_ensures(self, leq: spec_fn(A, A) -> bool)\n        requires\n            total_ordering(leq),\n        ensures\n            self.to_multiset() =~= self.sort_by(leq).to_multiset(),\n            sorted_by(self.sort_by(leq), leq),\n            forall|x: A| !self.contains(x) ==> !(#[trigger] self.sort_by(leq).contains(x)),\n        decreases self.len(),",
        "ensures": [
          "self.to_multiset() =~= self.sort_by(leq).to_multiset()",
          "sorted_by(self.sort_by(leq), leq)",
          "forall|x: A| !self.contains(x) ==> !(#[trigger] self.sort_by(leq).contains(x))"
        ],
        "requires": [
          "total_ordering(leq)"
        ],
        "body": "{\n        if self.len() <= 1 {\n        } else {\n            let split_index = self.len() / 2;\n            let left = self.subrange(0, split_index as int);\n            let right = self.subrange(split_index as int, self.len() as int);\n            assert(self =~= left + right);\n            let left_sorted = left.sort_by(leq);\n            left.lemma_sort_by_ensures(leq);\n            let right_sorted = right.sort_by(leq);\n            right.lemma_sort_by_ensures(leq);\n            lemma_merge_sorted_with_ensures(left_sorted, right_sorted, leq);\n            lemma_multiset_commutative(left, right);\n            lemma_multiset_commutative(left_sorted, right_sorted);\n            assert forall|x: A| !self.contains(x) implies !(#[trigger] self.sort_by(leq).contains(\n                x,\n            )) by {\n                broadcast use group_to_multiset_ensures;\n\n                assert(!self.contains(x) ==> self.to_multiset().count(x) == 0);\n            }\n        }\n    }",
        "doc_comment": null,
        "triggers": [
          "self.sort_by(leq"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 149,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "decreases",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "lemma_multiset_commutative",
          "lemma_merge_sorted_with_ensures",
          "contains",
          "len",
          "to_multiset",
          "subrange",
          "lemma_sort_by_ensures",
          "sort_by",
          "count"
        ]
      },
      "lemma_filter_len": {
        "name": "lemma_filter_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_filter_len(self, pred: spec_fn(A) -> bool)\n        ensures\n    // the filtered list can't grow\n\n            #[trigger] self.filter(pred).len() <= self.len(),\n        decreases self.len(),",
        "ensures": [
          "// the filtered list can't grow\n\n            #[trigger] self.filter(pred).len() <= self.len()"
        ],
        "requires": [],
        "body": "{\n        reveal(Seq::filter);\n        let out = self.filter(pred);\n        if 0 < self.len() {\n            self.drop_last().lemma_filter_len(pred);\n        }\n    }",
        "doc_comment": null,
        "triggers": [
          "self.filter(pred"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 210,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "lemma_filter_len",
          "filter",
          "drop_last"
        ]
      },
      "lemma_filter_pred": {
        "name": "lemma_filter_pred",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_filter_pred(self, pred: spec_fn(A) -> bool, i: int)\n        requires\n            0 <= i < self.filter(pred).len(),\n        ensures\n            pred(#[trigger] self.filter(pred)[i]),",
        "ensures": [
          "pred(#[trigger] self.filter(pred)[i])"
        ],
        "requires": [
          "0 <= i < self.filter(pred).len()"
        ],
        "body": "{\n        // TODO: remove this after proved filter_lemma is proved\n        #[allow(deprecated)]\n        self.filter_lemma(pred);\n    }",
        "doc_comment": null,
        "triggers": [
          "self.filter(pred"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 224,
        "module": "vstd::seq_lib",
        "keywords": [
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "allow",
          "filter_lemma"
        ]
      },
      "lemma_filter_contains": {
        "name": "lemma_filter_contains",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_filter_contains(self, pred: spec_fn(A) -> bool, i: int)\n        requires\n            0 <= i < self.len() && pred(self[i]),\n        ensures\n            #[trigger] self.filter(pred).contains(self[i]),",
        "ensures": [
          "#[trigger] self.filter(pred).contains(self[i])"
        ],
        "requires": [
          "0 <= i < self.len() && pred(self[i])"
        ],
        "body": "{\n        // TODO: remove this after proved filter_lemma is proved\n        #[allow(deprecated)]\n        self.filter_lemma(pred);\n    }",
        "doc_comment": null,
        "triggers": [
          "self.filter(pred"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 235,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "allow",
          "filter_lemma"
        ]
      },
      "filter_lemma": {
        "name": "filter_lemma",
        "type": "proof",
        "signature": "pub proof fn filter_lemma(self, pred: spec_fn(A) -> bool)\n        ensures\n    // we don't keep anything bad\n    // TODO(andrea): recommends didn't catch this error, where i isn't known to be in\n    // self.filter(pred).len()\n    //forall |i: int| 0 <= i < self.len() ==> pred(#[trigger] self.filter(pred)[i]),\n\n            forall|i: int|\n                0 <= i < self.filter(pred).len() ==> pred(#[trigger] self.filter(pred)[i]),\n            // we keep everything we should\n            forall|i: int|\n                0 <= i < self.len() && pred(self[i]) ==> #[trigger] self.filter(pred).contains(\n                    self[i],\n                ),\n            // the filtered list can't grow\n            #[trigger] self.filter(pred).len() <= self.len(),\n        decreases self.len(),",
        "ensures": [
          "// we don't keep anything bad\n    // TODO(andrea):"
        ],
        "requires": [],
        "body": "{\n        reveal(Seq::filter);\n        let out = self.filter(pred);\n        if 0 < self.len() {\n            self.drop_last().filter_lemma(pred);\n            assert forall|i: int| 0 <= i < out.len() implies pred(out[i]) by {\n                if i < out.len() - 1 {\n                    assert(self.drop_last().filter(pred)[i] == out.drop_last()[i]);  // trigger drop_last\n                    assert(pred(out[i]));  // TODO(andrea): why is this line required? It's the conclusion of the assert-forall.\n                }\n            }\n            assert forall|i: int|\n                0 <= i < self.len() && pred(self[i]) implies #[trigger] out.contains(self[i]) by {\n                if i == self.len() - 1 {\n                    assert(self[i] == out[out.len() - 1]);  // witness to contains\n                } else {\n                    let subseq = self.drop_last().filter(pred);\n                    assert(subseq.contains(self.drop_last()[i]));  // trigger recursive invocation\n                    let j = choose|j| 0 <= j < subseq.len() && subseq[j] == self[i];\n                    assert(out[j] == self[i]);  // TODO(andrea): same, seems needless\n                }\n            }\n        }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 248,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "decreases",
          "filter",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "filter",
          "pred",
          "filter_lemma",
          "contains",
          "len",
          "drop_last"
        ]
      },
      "filter_distributes_over_add": {
        "name": "filter_distributes_over_add",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn filter_distributes_over_add(a: Self, b: Self, pred: spec_fn(A) -> bool)\n        ensures\n            #[trigger] (a + b).filter(pred) == a.filter(pred) + b.filter(pred),\n        decreases b.len(),",
        "ensures": [
          "#[trigger] (a + b).filter(pred) == a.filter(pred) + b.filter(pred)"
        ],
        "requires": [],
        "body": "{\n        reveal(Seq::filter);\n        if 0 < b.len() {\n            Self::drop_last_distributes_over_add(a, b);\n            Self::filter_distributes_over_add(a, b.drop_last(), pred);\n            if pred(b.last()) {\n                Self::push_distributes_over_add(\n                    a.filter(pred),\n                    b.drop_last().filter(pred),\n                    b.last(),\n                );\n            }\n        } else {\n            Self::add_empty_right(a, b);\n            Self::add_empty_right(a.filter(pred), b.filter(pred));\n        }\n    }",
        "doc_comment": null,
        "triggers": [
          "(a + b"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 290,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "filter",
          "filter_distributes_over_add",
          "drop_last_distributes_over_add",
          "pred",
          "len",
          "add_empty_right",
          "push_distributes_over_add",
          "last",
          "drop_last"
        ]
      },
      "add_empty_left": {
        "name": "add_empty_left",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn add_empty_left(a: Self, b: Self)\n        requires\n            a.len() == 0,\n        ensures\n            #[trigger] (a + b) == b,",
        "ensures": [
          "#[trigger] (a + b) == b"
        ],
        "requires": [
          "a.len() == 0"
        ],
        "body": "{\n        assert(a + b =~= b);\n    }",
        "doc_comment": null,
        "triggers": [
          "(a + b"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 312,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "trigger"
        ],
        "callees": []
      },
      "add_empty_right": {
        "name": "add_empty_right",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn add_empty_right(a: Self, b: Self)\n        requires\n            b.len() == 0,\n        ensures\n            #[trigger] (a + b) == a,",
        "ensures": [
          "#[trigger] (a + b) == a"
        ],
        "requires": [
          "b.len() == 0"
        ],
        "body": "{\n        assert(a + b =~= a);\n    }",
        "doc_comment": null,
        "triggers": [
          "(a + b"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 321,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "trigger"
        ],
        "callees": []
      },
      "push_distributes_over_add": {
        "name": "push_distributes_over_add",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn push_distributes_over_add(a: Self, b: Self, elt: A)\n        ensures\n            #[trigger] (a + b).push(elt) == a + b.push(elt),",
        "ensures": [
          "#[trigger] (a + b).push(elt) == a + b.push(elt)"
        ],
        "requires": [],
        "body": "{\n        assert((a + b).push(elt) =~= a + b.push(elt));\n    }",
        "doc_comment": null,
        "triggers": [
          "(a + b"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 330,
        "module": "vstd::seq_lib",
        "keywords": [
          "push",
          "trigger"
        ],
        "callees": [
          "push"
        ]
      },
      "index_of_first": {
        "name": "index_of_first",
        "type": "closed_spec",
        "signature": "pub closed spec fn index_of_first(self, needle: A) -> (result: Option<int>)",
        "ensures": [],
        "requires": [],
        "body": "{\n        if self.contains(needle) {\n            Some(self.first_index_helper(needle))\n        } else {\n            None\n        }\n    }",
        "doc_comment": "For an element that occurs at least once in a sequence, if its first occurence\nis at index i, Some(i) is returned. Otherwise, None is returned",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 384,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": [
          "first_index_helper",
          "ome",
          "contains"
        ]
      },
      "index_of_first_ensures": {
        "name": "index_of_first_ensures",
        "type": "proof",
        "signature": "pub proof fn index_of_first_ensures(self, needle: A)\n        ensures\n            match self.index_of_first(needle)",
        "ensures": [
          "match self.index_of_first(needle)"
        ],
        "requires": [],
        "body": "{\n                Some(index) => {\n                    &&& self.contains(needle)\n                    &&& 0 <= index < self.len()\n                    &&& self[index] == needle\n                    &&& forall|j: int| 0 <= j < index < self.len() ==> self[j] != needle\n                },\n                None => { !self.contains(needle) },\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 410,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": [
          "len",
          "ome",
          "contains"
        ]
      },
      "index_of_last": {
        "name": "index_of_last",
        "type": "closed_spec",
        "signature": "pub closed spec fn index_of_last(self, needle: A) -> Option<int>",
        "ensures": [],
        "requires": [],
        "body": "{\n        if self.contains(needle) {\n            Some(self.last_index_helper(needle))\n        } else {\n            None\n        }\n    }",
        "doc_comment": "For an element that occurs at least once in a sequence, if its last occurence\nis at index i, Some(i) is returned. Otherwise, None is returned",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 434,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": [
          "last_index_helper",
          "ome",
          "contains"
        ]
      },
      "index_of_last_ensures": {
        "name": "index_of_last_ensures",
        "type": "proof",
        "signature": "pub proof fn index_of_last_ensures(self, needle: A)\n        ensures\n            match self.index_of_last(needle)",
        "ensures": [
          "match self.index_of_last(needle)"
        ],
        "requires": [],
        "body": "{\n                Some(index) => {\n                    &&& self.contains(needle)\n                    &&& 0 <= index < self.len()\n                    &&& self[index] == needle\n                    &&& forall|j: int| 0 <= index < j < self.len() ==> self[j] != needle\n                },\n                None => { !self.contains(needle) },\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 460,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": [
          "len",
          "ome",
          "contains"
        ]
      },
      "drop_last_distributes_over_add": {
        "name": "drop_last_distributes_over_add",
        "type": "proof",
        "signature": "pub proof fn drop_last_distributes_over_add(a: Self, b: Self)\n        requires\n            0 < b.len(),\n        ensures\n            (a + b).drop_last() == a + b.drop_last(),",
        "ensures": [
          "(a + b).drop_last() == a + b.drop_last()"
        ],
        "requires": [
          "0 < b.len()"
        ],
        "body": "{\n        assert_seqs_equal!((a+b).drop_last(), a+b.drop_last());\n    }",
        "doc_comment": "Dropping the last element of a concatenation of `a` and `b` is equivalent\nto skipping the last element of `b` and then concatenating `a` and `b`",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 495,
        "module": "vstd::seq_lib",
        "keywords": [
          "len"
        ],
        "callees": [
          "drop_last"
        ]
      },
      "to_multiset": {
        "name": "to_multiset",
        "type": "closed_spec",
        "signature": "pub closed spec fn to_multiset(self) -> Multiset<A>\n        decreases self.len(),",
        "ensures": [],
        "requires": [],
        "body": "{\n        if self.len() == 0 {\n            Multiset::<A>::empty()\n        } else {\n            Multiset::<A>::empty().insert(self.first()).add(self.drop_first().to_multiset())\n        }\n    }",
        "doc_comment": "Converts a sequence into a multiset",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 528,
        "module": "vstd::seq_lib",
        "keywords": [
          "Multiset",
          "decreases",
          "len"
        ],
        "callees": [
          "first",
          "to_multiset",
          "len",
          "insert",
          "empty",
          "drop_first"
        ]
      },
      "to_multiset_ensures": {
        "name": "to_multiset_ensures",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn to_multiset_ensures(self)\n        ensures\n            forall|a: A| #[trigger] (self.push(a).to_multiset()) =~= self.to_multiset().insert(a),  // to_multiset_build\n            forall|i: int|\n                0 <= i < self.len() ==> #[trigger] (self.remove(i).to_multiset())\n                    =~= self.to_multiset().remove(self[i]),  // to_multiset_remove\n            self.len() == #[trigger] self.to_multiset().len(),  // to_multiset_len\n            forall|a: A|\n                self.contains(a) <==> #[trigger] self.to_multiset().count(a)\n                    > 0,  // to_multiset_contains",
        "ensures": [
          "forall|a: A| #[trigger] (self.push(a).to_multiset()) =~= self.to_multiset().insert(a),  // to_multiset_build\n            forall|i: int|\n                0 <= i < self.len() ==> #[trigger] (self.remove(i).to_multiset())\n                    =~= self.to_multiset().remove(self[i]),  // to_multiset_remove\n            self.len() == #[trigger] self.to_multiset().len(),  // to_multiset_len\n            forall|a: A|\n                self.contains(a) <==> #[trigger] self.to_multiset().count(a)\n                    > 0,  // to_multiset_contains"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_seq_properties;\n\n    }",
        "doc_comment": "Proof of function to_multiset() correctness",
        "triggers": [
          "(self.push(a",
          "(self.remove(i",
          "self.to_multiset(",
          "self.to_multiset("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 542,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "forall",
          "insert",
          "len",
          "push",
          "remove",
          "trigger"
        ],
        "callees": []
      },
      "insert_ensures": {
        "name": "insert_ensures",
        "type": "proof",
        "signature": "pub proof fn insert_ensures(self, pos: int, elt: A)\n        requires\n            0 <= pos <= self.len(),\n        ensures\n            self.insert(pos, elt).len() == self.len() + 1,\n            forall|i: int| 0 <= i < pos ==> #[trigger] self.insert(pos, elt)[i] == self[i],\n            forall|i: int| pos <= i < self.len() ==> self.insert(pos, elt)[i + 1] == self[i],\n            self.insert(pos, elt)[pos] == elt,",
        "ensures": [
          "self.insert(pos, elt).len() == self.len() + 1",
          "forall|i: int| 0 <= i < pos ==> #[trigger] self.insert(pos, elt)[i] == self[i]",
          "forall|i: int| pos <= i < self.len() ==> self.insert(pos, elt)[i + 1] == self[i]",
          "self.insert(pos, elt)[pos] == elt"
        ],
        "requires": [
          "0 <= pos <= self.len()"
        ],
        "body": "{\n    }",
        "doc_comment": "Proof of correctness and expected properties of insert function",
        "triggers": [
          "self.insert(pos"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 565,
        "module": "vstd::seq_lib",
        "keywords": [
          "forall",
          "insert",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "remove_ensures": {
        "name": "remove_ensures",
        "type": "proof",
        "signature": "pub proof fn remove_ensures(self, i: int)\n        requires\n            0 <= i < self.len(),\n        ensures\n            self.remove(i).len() == self.len() - 1,\n            forall|index: int| 0 <= index < i ==> #[trigger] self.remove(i)[index] == self[index],\n            forall|index: int|\n                i <= index < self.len() - 1 ==> #[trigger] self.remove(i)[index] == self[index + 1],",
        "ensures": [
          "self.remove(i).len() == self.len() - 1",
          "forall|index: int| 0 <= index < i ==> #[trigger] self.remove(i)[index] == self[index]",
          "forall|index: int|\n                i <= index < self.len() - 1 ==> #[trigger] self.remove(i)[index] == self[index + 1]"
        ],
        "requires": [
          "0 <= i < self.len()"
        ],
        "body": "{\n    }",
        "doc_comment": "Proof of function remove() correctness",
        "triggers": [
          "self.remove(i",
          "self.remove(i"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 585,
        "module": "vstd::seq_lib",
        "keywords": [
          "forall",
          "len",
          "remove",
          "trigger"
        ],
        "callees": []
      },
      "lemma_fold_left_split": {
        "name": "lemma_fold_left_split",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_fold_left_split<B>(self, b: B, f: spec_fn(B, A) -> B, k: int)\n        requires\n            0 <= k <= self.len(),\n        ensures\n            self.subrange(k, self.len() as int).fold_left(\n                (#[trigger] self.subrange(0, k).fold_left(b, f)),\n                f,\n            ) == self.fold_left(b, f),\n        decreases self.len(),",
        "ensures": [
          "self.subrange(k, self.len() as int).fold_left(\n                (#[trigger] self.subrange(0, k).fold_left(b, f))",
          "f",
          ") == self.fold_left(b, f)"
        ],
        "requires": [
          "0 <= k <= self.len()"
        ],
        "body": "{\n        reveal_with_fuel(Seq::fold_left, 2);\n        if k == self.len() {\n            assert(self.subrange(0, self.len() as int) == self);\n        } else {\n            self.drop_last().lemma_fold_left_split(b, f, k);\n            assert_seqs_equal!(\n                self.drop_last().subrange(k, self.drop_last().len() as int) ==\n                self.subrange(k, self.len()-1)\n            );\n            assert_seqs_equal!(\n                self.drop_last().subrange(0, k) ==\n                self.subrange(0, k)\n            );\n            assert_seqs_equal!(\n                self.subrange(k, self.len() as int).drop_last() ==\n                self.subrange(k, self.len() - 1)\n            );\n        }\n    }",
        "doc_comment": "A lemma that proves how [`Self::fold_left`] distributes over splitting a sequence.",
        "triggers": [
          "self.subrange(0"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 663,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len",
          "subrange",
          "trigger"
        ],
        "callees": [
          "lemma_fold_left_split",
          "reveal_with_fuel",
          "len",
          "subrange",
          "drop_last"
        ]
      },
      "lemma_fold_left_alt": {
        "name": "lemma_fold_left_alt",
        "type": "proof",
        "signature": "pub proof fn lemma_fold_left_alt<B>(self, b: B, f: spec_fn(B, A) -> B)\n        ensures\n            self.fold_left(b, f) == self.fold_left_alt(b, f),\n        decreases self.len(),",
        "ensures": [
          "self.fold_left(b, f) == self.fold_left_alt(b, f)"
        ],
        "requires": [],
        "body": "{\n        reveal_with_fuel(Seq::fold_left, 2);\n        reveal_with_fuel(Seq::fold_left_alt, 2);\n        if self.len() <= 1 {\n            // trivial base cases\n        } else {\n            self.aux_lemma_fold_left_alt(b, f, self.len() - 1);\n            self.subrange(self.len() - 1, self.len() as int).lemma_fold_left_alt(\n                self.drop_last().fold_left_alt(b, f),\n                f,\n            );\n            self.subrange(0, self.len() - 1).lemma_fold_left_alt(b, f);\n        }\n    }",
        "doc_comment": "[`Self::fold_left`] and [`Self::fold_left_alt`] are equivalent.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 726,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "aux_lemma_fold_left_alt",
          "reveal_with_fuel",
          "lemma_fold_left_alt",
          "len",
          "subrange",
          "fold_left_alt",
          "drop_last"
        ]
      },
      "lemma_reverse_fold_left": {
        "name": "lemma_reverse_fold_left",
        "type": "proof",
        "signature": "pub proof fn lemma_reverse_fold_left<B>(self, v: B, f: spec_fn(B, A) -> B)\n        ensures\n            self.reverse().fold_left(v, f) == self.fold_right(|a: A, b: B| f(b, a), v),",
        "ensures": [
          "self.reverse().fold_left(v, f) == self.fold_right(|a: A, b: B| f(b, a), v)"
        ],
        "requires": [],
        "body": "{\n        assert(self.reverse().reverse() =~= self);\n        let g = |a: A, b: B| f(b, a);\n        assert(f =~= |b: B, a: A| g(a, b));\n        self.reverse().lemma_reverse_fold_right(v, |a: A, b: B| f(b, a))\n    }",
        "doc_comment": "[`Self::fold_left`] on the reversed sequence is equivalent to\n[`Self::fold_right`] on the original sequence with corresponding folding operator",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 746,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": [
          "f",
          "lemma_reverse_fold_right",
          "reverse",
          "g"
        ]
      },
      "lemma_fold_right_split": {
        "name": "lemma_fold_right_split",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_fold_right_split<B>(self, f: spec_fn(A, B) -> B, b: B, k: int)\n        requires\n            0 <= k <= self.len(),\n        ensures\n            self.subrange(0, k).fold_right(\n                f,\n                (#[trigger] self.subrange(k, self.len() as int).fold_right(f, b)),\n            ) == self.fold_right(f, b),\n        decreases self.len(),",
        "ensures": [
          "self.subrange(0, k).fold_right(\n                f",
          "(#[trigger] self.subrange(k, self.len() as int).fold_right(f, b))",
          ") == self.fold_right(f, b)"
        ],
        "requires": [
          "0 <= k <= self.len()"
        ],
        "body": "{\n        reveal_with_fuel(Seq::fold_right, 2);\n        if k == self.len() {\n            assert(self.subrange(0, k) == self);\n        } else if k == self.len() - 1 {\n            // trivial base case\n        } else {\n            self.subrange(0, self.len() - 1).lemma_fold_right_split(f, f(self.last(), b), k);\n            assert_seqs_equal!(\n                self.subrange(0, self.len() - 1).subrange(0, k) ==\n                self.subrange(0, k)\n            );\n            assert_seqs_equal!(\n                self.subrange(0, self.len() - 1).subrange(k, self.subrange(0, self.len() - 1).len() as int) ==\n                self.subrange(k, self.len() - 1)\n            );\n            assert_seqs_equal!(\n                self.subrange(k, self.len() as int).drop_last() ==\n                self.subrange(k, self.len() - 1)\n            );\n        }\n    }",
        "doc_comment": "A lemma that proves how [`Self::fold_right`] distributes over splitting a sequence.",
        "triggers": [
          "self.subrange(k"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 787,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len",
          "subrange",
          "trigger"
        ],
        "callees": [
          "f",
          "reveal_with_fuel",
          "lemma_fold_right_split",
          "len",
          "subrange",
          "last",
          "drop_last"
        ]
      },
      "lemma_fold_right_commute_one": {
        "name": "lemma_fold_right_commute_one",
        "type": "proof",
        "signature": "pub proof fn lemma_fold_right_commute_one<B>(self, a: A, f: spec_fn(A, B) -> B, v: B)\n        requires\n            commutative_foldr(f),\n        ensures\n            self.fold_right(f, f(a, v)) == f(a, self.fold_right(f, v)),\n        decreases self.len(),",
        "ensures": [
          "self.fold_right(f, f(a, v)) == f(a, self.fold_right(f, v))"
        ],
        "requires": [
          "commutative_foldr(f)"
        ],
        "body": "{\n        if self.len() > 0 {\n            self.drop_last().lemma_fold_right_commute_one(a, f, f(self.last(), v));\n        }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 822,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "lemma_fold_right_commute_one",
          "f",
          "len",
          "last",
          "drop_last"
        ]
      },
      "lemma_fold_right_alt": {
        "name": "lemma_fold_right_alt",
        "type": "proof",
        "signature": "pub proof fn lemma_fold_right_alt<B>(self, f: spec_fn(A, B) -> B, b: B)\n        ensures\n            self.fold_right(f, b) == self.fold_right_alt(f, b),\n        decreases self.len(),",
        "ensures": [
          "self.fold_right(f, b) == self.fold_right_alt(f, b)"
        ],
        "requires": [],
        "body": "{\n        reveal_with_fuel(Seq::fold_right, 2);\n        reveal_with_fuel(Seq::fold_right_alt, 2);\n        if self.len() <= 1 {\n            // trivial base cases\n        } else {\n            self.subrange(1, self.len() as int).lemma_fold_right_alt(f, b);\n            self.lemma_fold_right_split(f, b, 1);\n        }\n    }",
        "doc_comment": "[`Self::fold_right`] and [`Self::fold_right_alt`] are equivalent.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 833,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "reveal_with_fuel",
          "lemma_fold_right_split",
          "len",
          "lemma_fold_right_alt",
          "subrange"
        ]
      },
      "lemma_reverse_fold_right": {
        "name": "lemma_reverse_fold_right",
        "type": "proof",
        "signature": "pub proof fn lemma_reverse_fold_right<B>(self, v: B, f: spec_fn(A, B) -> B)\n        ensures\n            self.reverse().fold_right(f, v) == self.fold_left(v, |b: B, a: A| f(a, b)),\n        decreases self.len(),",
        "ensures": [
          "self.reverse().fold_right(f, v) == self.fold_left(v, |b: B, a: A| f(a, b))"
        ],
        "requires": [],
        "body": "{\n        let g = |b: B, a: A| f(a, b);\n        if self.len() > 0 {\n            let last = self.last();\n            let s0 = self.drop_last();\n            assert(self.reverse() =~= seq![last] + s0.reverse());\n            let res1 = self.reverse().fold_right(f, v);\n            let res2 = self.fold_left(v, g);\n            assert(res1 == self.reverse().fold_right_alt(f, v)) by {\n                self.reverse().lemma_fold_right_alt(f, v)\n            }\n            assert(res2 == g(s0.fold_left(v, g), last));\n            assert(self.reverse().first() == last);\n            assert(self.reverse().subrange(1, self.reverse().len() as int) =~= s0.reverse());\n            assert(res1 == f(last, s0.reverse().fold_right_alt(f, v)));\n            assert(res1 == f(last, s0.reverse().fold_right(f, v))) by {\n                s0.reverse().lemma_fold_right_alt(f, v)\n            }\n            assert(res2 == g(s0.fold_left(v, g), last));\n            s0.lemma_reverse_fold_right(v, f);\n        }\n    }",
        "doc_comment": "[`Self::fold_right`] on the reversed sequence is equivalent to\n[`Self::fold_left`] on the original sequence with corresponding folding operator",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 849,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "f",
          "g",
          "lemma_reverse_fold_right",
          "fold_right_alt",
          "reverse",
          "first",
          "len",
          "fold_right",
          "lemma_fold_right_alt",
          "subrange",
          "last",
          "drop_last",
          "fold_left"
        ]
      },
      "lemma_multiset_has_no_duplicates": {
        "name": "lemma_multiset_has_no_duplicates",
        "type": "proof",
        "signature": "pub proof fn lemma_multiset_has_no_duplicates(self)\n        requires\n            self.no_duplicates(),\n        ensures\n            forall|x: A| self.to_multiset().contains(x) ==> self.to_multiset().count(x) == 1,\n        decreases self.len(),",
        "ensures": [
          "forall|x: A| self.to_multiset().contains(x) ==> self.to_multiset().count(x) == 1"
        ],
        "requires": [
          "self.no_duplicates()"
        ],
        "body": "{\n        broadcast use super::multiset::group_multiset_axioms;\n\n        if self.len() == 0 {\n            assert(forall|x: A|\n                self.to_multiset().contains(x) ==> self.to_multiset().count(x) == 1);\n        } else {\n            broadcast use group_seq_properties;\n\n            assert(self.drop_last().push(self.last()) =~= self);\n            self.drop_last().lemma_multiset_has_no_duplicates();\n        }\n    }",
        "doc_comment": "Given a sequence with no duplicates, each element occurs only\nonce in its conversion to a multiset",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 880,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "decreases",
          "forall",
          "len"
        ],
        "callees": [
          "push",
          "to_multiset",
          "contains",
          "len",
          "lemma_multiset_has_no_duplicates",
          "last",
          "count",
          "drop_last"
        ]
      },
      "lemma_multiset_has_no_duplicates_conv": {
        "name": "lemma_multiset_has_no_duplicates_conv",
        "type": "proof",
        "signature": "pub proof fn lemma_multiset_has_no_duplicates_conv(self)\n        requires\n            forall|x: A| self.to_multiset().contains(x) ==> self.to_multiset().count(x) == 1,\n        ensures\n            self.no_duplicates(),",
        "ensures": [
          "self.no_duplicates()"
        ],
        "requires": [
          "forall|x: A| self.to_multiset().contains(x) ==> self.to_multiset().count(x) == 1"
        ],
        "body": "{\n        broadcast use super::multiset::group_multiset_axioms;\n\n        assert forall|i, j| (0 <= i < self.len() && 0 <= j < self.len() && i != j) implies self[i]\n            != self[j] by {\n            let mut a = if (i < j) {\n                i\n            } else {\n                j\n            };\n            let mut b = if (i < j) {\n                j\n            } else {\n                i\n            };\n\n            if (self[a] == self[b]) {\n                let s0 = self.subrange(0, b);\n                let s1 = self.subrange(b, self.len() as int);\n                assert(self == s0 + s1);\n\n                broadcast use group_to_multiset_ensures;\n\n                lemma_multiset_commutative(s0, s1);\n                assert(self.to_multiset().count(self[a]) >= 2);\n            }\n        }\n    }",
        "doc_comment": "If, in a sequence's conversion to a multiset, each element occurs only once,\nthe sequence has no duplicates.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 901,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "forall"
        ],
        "callees": [
          "lemma_multiset_commutative",
          "to_multiset",
          "len",
          "subrange",
          "count"
        ]
      },
      "lemma_reverse_to_multiset": {
        "name": "lemma_reverse_to_multiset",
        "type": "proof",
        "signature": "pub proof fn lemma_reverse_to_multiset(self)\n        ensures\n            self.reverse().to_multiset() =~= self.to_multiset(),\n        decreases self.len(),",
        "ensures": [
          "self.reverse().to_multiset() =~= self.to_multiset()"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_seq_properties;\n        broadcast use super::multiset::group_multiset_axioms;\n\n        if self.len() > 0 {\n            let s2 = self.drop_first();\n            let e = self.first();\n            assert(self =~= seq![e] + s2);\n            assert(self.to_multiset() =~= seq![e].to_multiset().add(s2.to_multiset())) by {\n                lemma_multiset_commutative(seq![e], s2)\n            }\n            assert(self.reverse() =~= s2.reverse().push(e));\n            assert(self.reverse().to_multiset() =~= s2.reverse().to_multiset().insert(e));\n            s2.lemma_reverse_to_multiset();\n        }\n    }",
        "doc_comment": "Conversion of a sequence to multiset is equivalent to conversion of its reversion to multiset",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 937,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "push",
          "lemma_multiset_commutative",
          "lemma_reverse_to_multiset",
          "to_multiset",
          "first",
          "len",
          "reverse",
          "insert",
          "drop_first"
        ]
      },
      "lemma_add_last_back": {
        "name": "lemma_add_last_back",
        "type": "proof",
        "signature": "pub proof fn lemma_add_last_back(self)\n        requires\n            0 < self.len(),\n        ensures\n            #[trigger] self.drop_last().push(self.last()) =~= self,",
        "ensures": [
          "#[trigger] self.drop_last().push(self.last()) =~= self"
        ],
        "requires": [
          "0 < self.len()"
        ],
        "body": "{\n    }",
        "doc_comment": "The concatenation of two subsequences derived from a non-empty sequence,\nthe first obtained from skipping the last element, the second consisting only\nof the last element, is the original sequence.",
        "triggers": [
          "self.drop_last("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 959,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "push",
          "trigger"
        ],
        "callees": []
      },
      "lemma_indexing_implies_membership": {
        "name": "lemma_indexing_implies_membership",
        "type": "proof",
        "signature": "pub proof fn lemma_indexing_implies_membership(self, f: spec_fn(A) -> bool)\n        requires\n            forall|i: int| 0 <= i < self.len() ==> #[trigger] f(#[trigger] self[i]),\n        ensures\n            forall|x: A| #[trigger] self.contains(x) ==> #[trigger] f(x),",
        "ensures": [
          "forall|x: A| #[trigger] self.contains(x) ==> #[trigger] f(x)"
        ],
        "requires": [
          "forall|i: int| 0 <= i < self.len() ==> #[trigger] f(#[trigger] self[i])"
        ],
        "body": "{\n        assert(forall|i: int| 0 <= i < self.len() ==> #[trigger] self.contains(self[i]));\n    }",
        "doc_comment": "If a predicate is true at every index of a sequence,\nit is true for every member of the sequence as a collection.\nUseful for converting quantifiers between the two forms\nto satisfy a precondition in the latter form.",
        "triggers": [
          "self.contains(x",
          "f(x"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 970,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "contains"
        ]
      },
      "lemma_membership_implies_indexing": {
        "name": "lemma_membership_implies_indexing",
        "type": "proof",
        "signature": "pub proof fn lemma_membership_implies_indexing(self, f: spec_fn(A) -> bool)\n        requires\n            forall|x: A| #[trigger] self.contains(x) ==> #[trigger] f(x),\n        ensures\n            forall|i: int| 0 <= i < self.len() ==> #[trigger] f(self[i]),",
        "ensures": [
          "forall|i: int| 0 <= i < self.len() ==> #[trigger] f(self[i])"
        ],
        "requires": [
          "forall|x: A| #[trigger] self.contains(x) ==> #[trigger] f(x)"
        ],
        "body": "{\n        assert forall|i: int| 0 <= i < self.len() implies #[trigger] f(self[i]) by {\n            assert(self.contains(self[i]));\n        }\n    }",
        "doc_comment": "If a predicate is true for every member of a sequence as a collection,\nit is true at every index of the sequence.\nUseful for converting quantifiers between the two forms\nto satisfy a precondition in the latter form.",
        "triggers": [
          "f(self[i]"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 983,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "f",
          "contains"
        ]
      },
      "lemma_split_at": {
        "name": "lemma_split_at",
        "type": "proof",
        "signature": "pub proof fn lemma_split_at(self, pos: int)\n        requires\n            0 <= pos <= self.len(),\n        ensures\n            self.subrange(0, pos) + self.subrange(pos, self.len() as int) =~= self,",
        "ensures": [
          "self.subrange(0, pos) + self.subrange(pos, self.len() as int) =~= self"
        ],
        "requires": [
          "0 <= pos <= self.len()"
        ],
        "body": "{\n    }",
        "doc_comment": "A sequence that is sliced at the pos-th element, concatenated\nwith that same sequence sliced from the pos-th element, is equal to the\noriginal unsliced sequence.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 998,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "subrange"
        ],
        "callees": []
      },
      "lemma_element_from_slice": {
        "name": "lemma_element_from_slice",
        "type": "proof",
        "signature": "pub proof fn lemma_element_from_slice(self, new: Seq<A>, a: int, b: int, pos: int)\n        requires\n            0 <= a <= b <= self.len(),\n            new == self.subrange(a, b),\n            a <= pos < b,\n        ensures\n            pos - a < new.len(),\n            new[pos - a] == self[pos],",
        "ensures": [
          "pos - a < new.len()",
          "new[pos - a] == self[pos]"
        ],
        "requires": [
          "0 <= a <= b <= self.len()",
          "new == self.subrange(a, b)",
          "a <= pos < b"
        ],
        "body": "{\n    }",
        "doc_comment": "Any element in a slice is included in the original sequence.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1009,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "subrange"
        ],
        "callees": []
      },
      "lemma_slice_of_slice": {
        "name": "lemma_slice_of_slice",
        "type": "proof",
        "signature": "pub proof fn lemma_slice_of_slice(self, s1: int, e1: int, s2: int, e2: int)\n        requires\n            0 <= s1 <= e1 <= self.len(),\n            0 <= s2 <= e2 <= e1 - s1,\n        ensures\n            self.subrange(s1, e1).subrange(s2, e2) =~= self.subrange(s1 + s2, s1 + e2),",
        "ensures": [
          "self.subrange(s1, e1).subrange(s2, e2) =~= self.subrange(s1 + s2, s1 + e2)"
        ],
        "requires": [
          "0 <= s1 <= e1 <= self.len()",
          "0 <= s2 <= e2 <= e1 - s1"
        ],
        "body": "{\n    }",
        "doc_comment": "A slice (from s2..e2) of a slice (from s1..e1) of a sequence is equal to just a\nslice (s1+s2..s1+e2) of the original sequence.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1021,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "subrange"
        ],
        "callees": []
      },
      "unique_seq_to_set": {
        "name": "unique_seq_to_set",
        "type": "proof",
        "signature": "pub proof fn unique_seq_to_set(self)\n        requires\n            self.no_duplicates(),\n        ensures\n            self.len() == self.to_set().len(),\n        decreases self.len(),",
        "ensures": [
          "self.len() == self.to_set().len()"
        ],
        "requires": [
          "self.no_duplicates()"
        ],
        "body": "{\n        broadcast use super::set::group_set_axioms;\n\n        seq_to_set_equal_rec::<A>(self);\n        if self.len() == 0 {\n        } else {\n            let rest = self.drop_last();\n            rest.unique_seq_to_set();\n            seq_to_set_equal_rec::<A>(rest);\n            seq_to_set_rec_is_finite::<A>(rest);\n            assert(!seq_to_set_rec(rest).contains(self.last()));\n            assert(seq_to_set_rec(rest).insert(self.last()).len() == seq_to_set_rec(rest).len()\n                + 1);\n        }\n    }",
        "doc_comment": "A sequence of unique items, when converted to a set, produces a set with matching length",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1032,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "seq_to_set_rec",
          "contains",
          "len",
          "unique_seq_to_set",
          "insert",
          "last",
          "drop_last"
        ]
      },
      "lemma_cardinality_of_set": {
        "name": "lemma_cardinality_of_set",
        "type": "proof",
        "signature": "pub proof fn lemma_cardinality_of_set(self)\n        ensures\n            self.to_set().len() <= self.len(),\n        decreases self.len(),",
        "ensures": [
          "self.to_set().len() <= self.len()"
        ],
        "requires": [],
        "body": "{\n        broadcast use {super::set::group_set_axioms, seq_to_set_is_finite};\n        broadcast use group_seq_properties;\n        broadcast use super::set_lib::group_set_properties;\n\n        if self.len() == 0 {\n        } else {\n            assert(self.drop_last().to_set().insert(self.last()) =~= self.to_set());\n            self.drop_last().lemma_cardinality_of_set();\n        }\n    }",
        "doc_comment": "The cardinality of a set of elements is always less than or\nequal to that of the full sequence of elements.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1055,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "lemma_cardinality_of_set",
          "len",
          "insert",
          "last",
          "drop_last",
          "to_set"
        ]
      },
      "lemma_cardinality_of_empty_set_is_0": {
        "name": "lemma_cardinality_of_empty_set_is_0",
        "type": "proof",
        "signature": "pub proof fn lemma_cardinality_of_empty_set_is_0(self)\n        ensures\n            self.to_set().len() == 0 <==> self.len() == 0,",
        "ensures": [
          "self.to_set().len() == 0 <==> self.len() == 0"
        ],
        "requires": [],
        "body": "{\n        broadcast use {super::set::group_set_axioms, seq_to_set_is_finite};\n\n        assert(self.len() == 0 ==> self.to_set().len() == 0) by { self.lemma_cardinality_of_set() }\n        assert(!(self.len() == 0) ==> !(self.to_set().len() == 0)) by {\n            if self.len() > 0 {\n                assert(self.to_set().contains(self[0]));\n                assert(self.to_set().remove(self[0]).len() <= self.to_set().len());\n            }\n        }\n    }",
        "doc_comment": "A sequence is of length 0 if and only if its conversion to\na set results in the empty set.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1073,
        "module": "vstd::seq_lib",
        "keywords": [
          "len"
        ],
        "callees": [
          "remove",
          "lemma_cardinality_of_set",
          "contains",
          "len",
          "to_set"
        ]
      },
      "lemma_no_dup_set_cardinality": {
        "name": "lemma_no_dup_set_cardinality",
        "type": "proof",
        "signature": "pub proof fn lemma_no_dup_set_cardinality(self)\n        requires\n            self.to_set().len() == self.len(),\n        ensures\n            self.no_duplicates(),\n        decreases self.len(),",
        "ensures": [
          "self.no_duplicates()"
        ],
        "requires": [
          "self.to_set().len() == self.len()"
        ],
        "body": "{\n        broadcast use {super::set::group_set_axioms, seq_to_set_is_finite};\n\n        if self.len() == 0 {\n        } else {\n            assert(self =~= Seq::empty().push(self.first()).add(self.drop_first()));\n            if self.drop_first().contains(self.first()) {\n                // If there is a duplicate, then we show that |s.to_set()| == |s| cannot hold.\n                assert(self.to_set() =~= self.drop_first().to_set());\n                assert(self.to_set().len() <= self.drop_first().len()) by {\n                    self.drop_first().lemma_cardinality_of_set()\n                }\n            } else {\n                assert(self.to_set().len() == 1 + self.drop_first().to_set().len()) by {\n                    assert(self.drop_first().to_set().insert(self.first()) =~= self.to_set());\n                }\n                self.drop_first().lemma_no_dup_set_cardinality();\n            }\n        }\n    }",
        "doc_comment": "A sequence with cardinality equal to its set has no duplicates.\nInverse property of that shown in lemma unique_seq_to_set",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1090,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "push",
          "lemma_cardinality_of_set",
          "first",
          "contains",
          "len",
          "insert",
          "empty",
          "drop_first",
          "to_set",
          "lemma_no_dup_set_cardinality"
        ]
      },
      "lemma_to_set_map_commutes": {
        "name": "lemma_to_set_map_commutes",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_to_set_map_commutes<B>(self, f: spec_fn(A) -> B)\n        ensures\n            #[trigger] self.to_set().map(f) =~= self.map_values(f).to_set(),",
        "ensures": [
          "#[trigger] self.to_set().map(f) =~= self.map_values(f).to_set()"
        ],
        "requires": [],
        "body": "{\n        broadcast use crate::vstd::group_vstd_default;\n\n        assert forall|elem: B|\n            self.to_set().map(f).contains(elem) <==> self.map_values(f).to_set().contains(elem) by {\n            if self.to_set().map(f).contains(elem) {\n                let x = choose|x: A| self.to_set().contains(x) && f(x) == elem;\n                let i = choose|i: int| 0 <= i < self.len() && self[i] == x;\n                assert(self.map_values(f)[i] == elem);\n            }\n            if self.map_values(f).to_set().contains(elem) {\n                let i = choose|i: int|\n                    0 <= i < self.map_values(f).len() && self.map_values(f)[i] == elem;\n                let x = self[i];\n                assert(self.to_set().contains(x));\n            }\n        };\n    }",
        "doc_comment": "Mapping a function over a sequence and converting to a set is the same\nas mapping it over the sequence converted to a set.",
        "triggers": [
          "self.to_set("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1119,
        "module": "vstd::seq_lib",
        "keywords": [
          "map",
          "trigger"
        ],
        "callees": [
          "f",
          "contains",
          "map_values",
          "len",
          "to_set",
          "map"
        ]
      },
      "lemma_to_set_insert_commutes": {
        "name": "lemma_to_set_insert_commutes",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_to_set_insert_commutes(sq: Seq<A>, elt: A)\n        requires\n        ensures\n            #[trigger] (sq + seq![elt]).to_set() =~= sq.to_set().insert(elt),",
        "ensures": [
          "#[trigger] (sq + seq![elt]).to_set() =~= sq.to_set().insert(elt)"
        ],
        "requires": [],
        "body": "{\n        broadcast use crate::vstd::group_vstd_default;\n        broadcast use lemma_seq_concat_contains_all_elements;\n        broadcast use lemma_seq_empty_contains_nothing;\n        broadcast use lemma_seq_contains_after_push;\n        broadcast use super::seq::group_seq_axioms;\n        broadcast use super::set_lib::group_set_properties;\n\n    }",
        "doc_comment": "Appending an element to a sequence and converting to set, is equal\nto converting to set and inserting it.",
        "triggers": [
          "(sq + seq![elt]"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1143,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "lemma_filter_contains_rev": {
        "name": "lemma_filter_contains_rev",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_filter_contains_rev(self, p: spec_fn(A) -> bool, elem: A)\n        requires\n            #[trigger] self.filter(p).contains(elem),\n        ensures\n            self.contains(elem),\n        decreases self.len(),",
        "ensures": [
          "self.contains(elem)"
        ],
        "requires": [
          "#[trigger] self.filter(p).contains(elem)"
        ],
        "body": "{\n        broadcast use group_seq_properties;\n\n        reveal(Seq::filter);\n        if self.len() == 0 {\n        } else {\n            let rest = self.drop_last();\n            let last = self.last();\n            if !p(last) || last != elem {\n                rest.lemma_filter_contains_rev(p, elem);\n            }\n        }\n    }",
        "doc_comment": "If an element exists in the filtered sequence,\nit must exist in the original sequence\n```",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1512,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "decreases",
          "filter",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "p",
          "lemma_filter_contains_rev",
          "last",
          "drop_last"
        ]
      },
      "lemma_filter_map_contains": {
        "name": "lemma_filter_map_contains",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_filter_map_contains<B>(self, f: spec_fn(A) -> Option<B>, elt: B)\n        requires\n            #[trigger] self.filter_map(f).contains(elt),\n        ensures\n            exists|t: A| #[trigger] self.contains(t) && f(t) == Some(elt),\n        decreases self.len(),",
        "ensures": [
          "exists|t: A| #[trigger] self.contains(t) && f(t) == Some(elt)"
        ],
        "requires": [
          "#[trigger] self.filter_map(f).contains(elt)"
        ],
        "body": "{\n        broadcast use group_seq_properties;\n\n        if self.len() == 0 {\n        } else {\n            let last = self.last();\n            let rest = self.drop_last();\n            if f(last) == Some(elt) {\n                assert(self.contains(last));\n            } else {\n                rest.lemma_filter_map_contains(f, elt);\n                let t = choose|t: A| #[trigger] rest.contains(t) && f(t) == Some(elt);\n                assert(self.contains(t));\n            }\n        }\n    }",
        "doc_comment": "If an element exists in filter_map's output,\nthere must be an input element that mapped to it\n```",
        "triggers": [
          "self.contains(t"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1535,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "decreases",
          "exists",
          "len",
          "trigger"
        ],
        "callees": [
          "f",
          "lemma_filter_map_contains",
          "contains",
          "len",
          "ome",
          "last",
          "drop_last"
        ]
      },
      "lemma_take_succ": {
        "name": "lemma_take_succ",
        "type": "proof",
        "signature": "pub proof fn lemma_take_succ(xs: Seq<A>, k: int)\n        requires\n            0 <= k < xs.len(),\n        ensures\n            xs.take(k + 1) =~= xs.take(k) + seq![xs[k]],",
        "ensures": [
          "xs.take(k + 1) =~= xs.take(k) + seq![xs[k]]"
        ],
        "requires": [
          "0 <= k < xs.len()"
        ],
        "body": "{\n        broadcast use group_seq_properties;\n\n    }",
        "doc_comment": "Taking k+1 elements is the same as taking k elements plus the kth element\n\n## Example\n```rust\nlet s = seq![1, 2, 3];\nlemma_take_plus_one(s, 1);\nseq![1, 2] == seq![1] + seq![2]\n```",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1561,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "take"
        ],
        "callees": []
      },
      "lemma_filter_map_singleton": {
        "name": "lemma_filter_map_singleton",
        "type": "proof",
        "signature": "pub proof fn lemma_filter_map_singleton<B>(a: A, f: spec_fn(A) -> Option<B>)\n        ensures\n            seq![a].filter_map(f) =~= match f(a)",
        "ensures": [
          "seq![a].filter_map(f) =~= match f(a)"
        ],
        "requires": [],
        "body": "{\n                Option::Some(b) => seq![b],\n                Option::None => Seq::empty(),\n            }",
        "doc_comment": "filter_map on a single element sequence\neither produces a new single element sequence (if f returns Some)\nor an empty sequence (if f returns None)",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1579,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": [
          "ome",
          "empty"
        ]
      },
      "lemma_filter_eq_filter_alt": {
        "name": "lemma_filter_eq_filter_alt",
        "type": "proof",
        "signature": "pub proof fn lemma_filter_eq_filter_alt(self, p: spec_fn(A) -> bool)\n        ensures\n            self.filter(p) =~= self.filter_alt(p),\n        decreases self.len(),",
        "ensures": [
          "self.filter(p) =~= self.filter_alt(p)"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_seq_properties;\n        broadcast use Seq::lemma_filter_prepend;\n\n        reveal(Seq::filter);\n        if self.len() == 0 {\n        } else {\n            let first = self.first();\n            let but_first = self.drop_first();\n            assert(self =~= seq![first] + but_first);\n            self.drop_first().lemma_filter_eq_filter_alt(p);\n        }\n    }",
        "doc_comment": "The filter() and filter_alt() methods produce equivalent results for any sequence",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1693,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "filter",
          "len"
        ],
        "callees": [
          "len",
          "lemma_filter_eq_filter_alt",
          "drop_first",
          "first"
        ]
      },
      "lemma_index_contains": {
        "name": "lemma_index_contains",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_index_contains(self, i: int)\n        requires\n            0 <= i < self.len(),\n        ensures\n            self.contains(#[trigger] self[i]),",
        "ensures": [
          "self.contains(#[trigger] self[i])"
        ],
        "requires": [
          "0 <= i < self.len()"
        ],
        "body": "{\n    }",
        "doc_comment": "If an index i is valid for a sequence (0 \u2264 i < len), then the element at that index\nis contained in the sequence.",
        "triggers": [
          "self[i]"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1795,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_take_succ_push": {
        "name": "lemma_take_succ_push",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_take_succ_push(self, i: int)\n        requires\n            0 <= i < self.len(),\n        ensures\n            #[trigger] self.take(i + 1) =~= self.take(i).push(self[i]),",
        "ensures": [
          "#[trigger] self.take(i + 1) =~= self.take(i).push(self[i])"
        ],
        "requires": [
          "0 <= i < self.len()"
        ],
        "body": "{\n        broadcast use group_seq_properties;\n\n    }",
        "doc_comment": "Taking i+1 elements from a sequence is equivalent to taking i elements\nand then pushing the element at index i.",
        "triggers": [
          "self.take(i + 1"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1805,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "push",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "lemma_take_len": {
        "name": "lemma_take_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_take_len(self)\n        ensures\n            #[trigger] self.take(self.len() as int) == self,",
        "ensures": [
          "#[trigger] self.take(self.len() as int) == self"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_seq_properties;\n\n    }",
        "doc_comment": "Taking the full length of a sequence returns the sequence itself.",
        "triggers": [
          "self.take(self.len("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1817,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "lemma_flat_map_singleton": {
        "name": "lemma_flat_map_singleton",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_flat_map_singleton<B>(self, f: spec_fn(A) -> Seq<B>)\n        requires\n            #[trigger] self.len() == 1,\n        ensures\n            #[trigger] self.flat_map(f) == f(self[0]),",
        "ensures": [
          "#[trigger] self.flat_map(f) == f(self[0])"
        ],
        "requires": [
          "#[trigger] self.len() == 1"
        ],
        "body": "{\n        broadcast use Seq::lemma_flatten_singleton;\n\n    }",
        "doc_comment": "flat_mapping a sequence with a single element\nis equivalent to applying the function f to that element.",
        "triggers": [
          "self.flat_map(f"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2077,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_prefix_append_unique": {
        "name": "lemma_prefix_append_unique",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_prefix_append_unique(self, prefix1: Seq<A>, prefix2: Seq<A>, t: A)\n        requires\n            #[trigger] (prefix1 + seq![t]).is_prefix_of(self),\n            #[trigger] (prefix2 + seq![t]).is_prefix_of(self),\n            !prefix1.contains(t),\n            !prefix2.contains(t),\n        ensures\n            prefix1 == prefix2,",
        "ensures": [
          "prefix1 == prefix2"
        ],
        "requires": [
          "#[trigger] (prefix1 + seq![t]).is_prefix_of(self)",
          "#[trigger] (prefix2 + seq![t]).is_prefix_of(self)",
          "!prefix1.contains(t)",
          "!prefix2.contains(t)"
        ],
        "body": "{\n        broadcast use Seq::lemma_prefix_concat;\n        broadcast use Seq::lemma_prefix_index_eq;\n        broadcast use Seq::lemma_prefix_chain_contains;\n\n        if prefix1 != prefix2 {\n            assert(prefix1.is_prefix_of(prefix2) || prefix2.is_prefix_of(prefix1));\n        }\n    }",
        "doc_comment": "If `prefix1 + [t]` and `prefix2 + [t]` are both prefixes of a sequence,\nand neither `prefix1` nor `prefix2` contains `t`,\nthen `prefix1` equals `prefix2`.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2195,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "trigger"
        ],
        "callees": [
          "is_prefix_of"
        ]
      },
      "lemma_concat_injective": {
        "name": "lemma_concat_injective",
        "type": "proof",
        "signature": "pub proof fn lemma_concat_injective(self, s1: Seq<A>, s2: Seq<A>)\n        ensures\n            (self + s1 == self + s2) <==> (s1 == s2),",
        "ensures": [
          "(self + s1 == self + s2) <==> (s1 == s2)"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_seq_properties;\n\n        assert((self + s1).skip(self.len() as int) == s1);\n    }",
        "doc_comment": "Two sequences are equal when concatenated with the same prefix\niff those two sequences are equal.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2244,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ],
        "callees": [
          "skip",
          "len"
        ]
      },
      "unzip": {
        "name": "unzip",
        "type": "closed_spec",
        "signature": "pub closed spec fn unzip(self) -> (Seq<A>, Seq<B>)",
        "ensures": [],
        "requires": [],
        "body": "{\n        (Seq::new(self.len(), |i: int| self[i].0), Seq::new(self.len(), |i: int| self[i].1))\n    }",
        "doc_comment": "Unzips a sequence that contains pairs into two separate sequences.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2350,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ],
        "callees": [
          "len",
          "new"
        ]
      },
      "unzip_ensures": {
        "name": "unzip_ensures",
        "type": "proof",
        "signature": "pub proof fn unzip_ensures(self)\n        ensures\n            self.unzip().0.len() == self.unzip().1.len(),\n            self.unzip().0.len() == self.len(),\n            self.unzip().1.len() == self.len(),\n            forall|i: int|\n                0 <= i < self.len() ==> (#[trigger] self.unzip().0[i], #[trigger] self.unzip().1[i])\n                    == self[i],\n        decreases self.len(),",
        "ensures": [
          "self.unzip().0.len() == self.unzip().1.len()",
          "self.unzip().0.len() == self.len()",
          "self.unzip().1.len() == self.len()",
          "forall|i: int|\n                0 <= i < self.len() ==> (#[trigger] self.unzip().0[i], #[trigger] self.unzip().1[i])\n                    == self[i]"
        ],
        "requires": [],
        "body": "{\n        if self.len() > 0 {\n            self.drop_last().unzip_ensures();\n        }\n    }",
        "doc_comment": "Proof of correctness and expected properties of unzip function",
        "triggers": [
          "self.unzip(",
          "self.unzip("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2354,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "drop_last",
          "unzip_ensures"
        ]
      },
      "lemma_zip_of_unzip": {
        "name": "lemma_zip_of_unzip",
        "type": "proof",
        "signature": "pub proof fn lemma_zip_of_unzip(self)\n        ensures\n            self.unzip().0.zip_with(self.unzip().1) =~= self,",
        "ensures": [
          "self.unzip().0.zip_with(self.unzip().1) =~= self"
        ],
        "requires": [],
        "body": "{\n    }",
        "doc_comment": "Unzipping a sequence of sequences and then zipping the resulting two sequences\nback together results in the original sequence of sequences.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2370,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": []
      },
      "lemma_flatten_one_element": {
        "name": "lemma_flatten_one_element",
        "type": "proof",
        "signature": "pub proof fn lemma_flatten_one_element(self)\n        ensures\n            self.len() == 1 ==> self.flatten() == self.first(),",
        "ensures": [
          "self.len() == 1 ==> self.flatten() == self.first()"
        ],
        "requires": [],
        "body": "{\n        broadcast use Seq::add_empty_right;\n\n        if self.len() == 1 {\n            assert(self.flatten() =~= self.first().add(self.drop_first().flatten()));\n        }\n    }",
        "doc_comment": "Flattening a sequence of a sequence x, where x has length 1,\nresults in a sequence equivalent to the single element of x",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2417,
        "module": "vstd::seq_lib",
        "keywords": [
          "len"
        ],
        "callees": [
          "len",
          "flatten",
          "drop_first",
          "first"
        ]
      },
      "lemma_flatten_length_ge_single_element_length": {
        "name": "lemma_flatten_length_ge_single_element_length",
        "type": "proof",
        "signature": "pub proof fn lemma_flatten_length_ge_single_element_length(self, i: int)\n        requires\n            0 <= i < self.len(),\n        ensures\n            self.flatten_alt().len() >= self[i].len(),\n        decreases self.len(),",
        "ensures": [
          "self.flatten_alt().len() >= self[i].len()"
        ],
        "requires": [
          "0 <= i < self.len()"
        ],
        "body": "{\n        if self.len() == 1 {\n            self.lemma_flatten_one_element();\n            self.lemma_flatten_and_flatten_alt_are_equivalent();\n        } else if i < self.len() - 1 {\n            self.drop_last().lemma_flatten_length_ge_single_element_length(i);\n        } else {\n            assert(self.flatten_alt() == self.drop_last().flatten_alt().add(self.last()));\n        }\n    }",
        "doc_comment": "The length of a flattened sequence of sequences x is greater than or\nequal to any of the lengths of the elements of x.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2430,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "lemma_flatten_and_flatten_alt_are_equivalent",
          "lemma_flatten_one_element",
          "flatten_alt",
          "lemma_flatten_length_ge_single_element_length",
          "len",
          "last",
          "drop_last"
        ]
      },
      "lemma_flatten_length_le_mul": {
        "name": "lemma_flatten_length_le_mul",
        "type": "proof",
        "signature": "pub proof fn lemma_flatten_length_le_mul(self, j: int)\n        requires\n            forall|i: int| 0 <= i < self.len() ==> (#[trigger] self[i]).len() <= j,\n        ensures\n            self.flatten_alt().len() <= self.len() * j,\n        decreases self.len(),",
        "ensures": [
          "self.flatten_alt().len() <= self.len() * j"
        ],
        "requires": [
          "forall|i: int| 0 <= i < self.len() ==> (#[trigger] self[i]).len() <= j"
        ],
        "body": "{\n        broadcast use group_seq_properties;\n\n        if self.len() == 0 {\n        } else {\n            self.drop_last().lemma_flatten_length_le_mul(j);\n            assert((self.len() - 1) * j == (self.len() * j) - (1 * j)) by (nonlinear_arith);  //TODO: use math library after imported\n        }\n    }",
        "doc_comment": "The length of a flattened sequence of sequences x is less than or equal\nto the length of x multiplied by a number greater than or equal to the\nlength of the longest sequence in x.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2449,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "lemma_flatten_length_le_mul",
          "drop_last"
        ]
      },
      "lemma_flatten_and_flatten_alt_are_equivalent": {
        "name": "lemma_flatten_and_flatten_alt_are_equivalent",
        "type": "proof",
        "signature": "pub proof fn lemma_flatten_and_flatten_alt_are_equivalent(self)\n        ensures\n            self.flatten() =~= self.flatten_alt(),\n        decreases self.len(),",
        "ensures": [
          "self.flatten() =~= self.flatten_alt()"
        ],
        "requires": [],
        "body": "{\n        broadcast use {Seq::add_empty_right, Seq::push_distributes_over_add};\n\n        if self.len() != 0 {\n            self.drop_last().lemma_flatten_and_flatten_alt_are_equivalent();\n            // let s = self.drop_last().flatten();\n            // let s2 = self.drop_last().flatten_alt();\n            // assert(s == s2);\n            seq![self.last()].lemma_flatten_one_element();\n            assert(seq![self.last()].flatten() == self.last());\n            lemma_flatten_concat(self.drop_last(), seq![self.last()]);\n            assert((self.drop_last() + seq![self.last()]).flatten() == self.drop_last().flatten()\n                + self.last());\n            assert(self.drop_last() + seq![self.last()] =~= self);\n            assert(self.flatten_alt() == self.drop_last().flatten_alt() + self.last());\n        }\n    }",
        "doc_comment": "Flattening sequences of sequences in order (starting from the beginning)\nand in reverse order (starting from the end) results in the same sequence.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2468,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ],
        "callees": [
          "lemma_flatten_and_flatten_alt_are_equivalent",
          "lemma_flatten_one_element",
          "flatten_alt",
          "len",
          "flatten",
          "last",
          "drop_last",
          "lemma_flatten_concat"
        ]
      },
      "lemma_flatten_push": {
        "name": "lemma_flatten_push",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_flatten_push(self, elem: Seq<A>)\n        ensures\n            #[trigger] self.push(elem).flatten() =~= self.flatten() + elem,\n        decreases self.len(),",
        "ensures": [
          "#[trigger] self.push(elem).flatten() =~= self.flatten() + elem"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_seq_properties;\n\n        assert(self.push(elem).last() == elem);\n        assert(self.push(elem).drop_last() =~= self);\n        calc! {\n            (==)\n            self.push(elem).flatten(); {\n                self.push(elem).lemma_flatten_and_flatten_alt_are_equivalent();\n            }\n            self.push(elem).flatten_alt(); {}\n            self.flatten_alt() + elem; {\n                self.lemma_flatten_and_flatten_alt_are_equivalent();\n            }\n            self.flatten() + elem;\n        }\n    }",
        "doc_comment": "Flattening a sequence of sequences after pushing a new sequence is equivalent to\nconcatenating that sequence to the original flattened result.",
        "triggers": [
          "self.push(elem"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2492,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len",
          "push",
          "trigger"
        ],
        "callees": [
          "lemma_flatten_and_flatten_alt_are_equivalent",
          "flatten_alt",
          "push",
          "flatten",
          "last",
          "drop_last"
        ]
      },
      "lemma_flatten_singleton": {
        "name": "lemma_flatten_singleton",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_flatten_singleton(self)\n        requires\n            #[trigger] self.len() == 1,\n        ensures\n            #[trigger] self.flatten() == self[0],",
        "ensures": [
          "#[trigger] self.flatten() == self[0]"
        ],
        "requires": [
          "#[trigger] self.len() == 1"
        ],
        "body": "{\n        assert(self.flatten() == self[0] + self.drop_first().flatten());\n        assert(self.flatten() == self[0]);\n    }",
        "doc_comment": "Flattening a sequence containing a single sequence yields that inner sequence.",
        "triggers": [
          "self.flatten("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2516,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "trigger"
        ],
        "callees": [
          "drop_first",
          "flatten"
        ]
      },
      "max_ensures": {
        "name": "max_ensures",
        "type": "proof",
        "signature": "pub proof fn max_ensures(self)\n        ensures\n            forall|x: int| self.contains(x) ==> x <= self.max(),\n            forall|i: int| 0 <= i < self.len() ==> self[i] <= self.max(),\n            self.len() == 0 || self.contains(self.max()),\n        decreases self.len(),",
        "ensures": [
          "forall|x: int| self.contains(x) ==> x <= self.max()",
          "forall|i: int| 0 <= i < self.len() ==> self[i] <= self.max()",
          "self.len() == 0 || self.contains(self.max())"
        ],
        "requires": [],
        "body": "{\n        if self.len() <= 1 {\n        } else {\n            let elt = self.drop_first().max();\n            assert(self.drop_first().contains(elt)) by { self.drop_first().max_ensures() }\n            assert forall|i: int| 0 <= i < self.len() implies self[i] <= self.max() by {\n                assert(i == 0 || self[i] == self.drop_first()[i - 1]);\n                assert(forall|j: int|\n                    0 <= j < self.drop_first().len() ==> self.drop_first()[j]\n                        <= self.drop_first().max()) by { self.drop_first().max_ensures() }\n            }\n        }\n    }",
        "doc_comment": "Proof of correctness and expected properties for max function",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2556,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "decreases",
          "forall",
          "len"
        ],
        "callees": [
          "max_ensures",
          "contains",
          "len",
          "drop_first",
          "max"
        ]
      },
      "min_ensures": {
        "name": "min_ensures",
        "type": "proof",
        "signature": "pub proof fn min_ensures(self)\n        ensures\n            forall|x: int| self.contains(x) ==> self.min() <= x,\n            forall|i: int| 0 <= i < self.len() ==> self.min() <= self[i],\n            self.len() == 0 || self.contains(self.min()),\n        decreases self.len(),",
        "ensures": [
          "forall|x: int| self.contains(x) ==> self.min() <= x",
          "forall|i: int| 0 <= i < self.len() ==> self.min() <= self[i]",
          "self.len() == 0 || self.contains(self.min())"
        ],
        "requires": [],
        "body": "{\n        if self.len() <= 1 {\n        } else {\n            let elt = self.drop_first().min();\n            assert(self.subrange(1, self.len() as int).contains(elt)) by {\n                self.drop_first().min_ensures()\n            }\n            assert forall|i: int| 0 <= i < self.len() implies self.min() <= self[i] by {\n                assert(i == 0 || self[i] == self.drop_first()[i - 1]);\n                assert(forall|j: int|\n                    0 <= j < self.drop_first().len() ==> self.drop_first().min()\n                        <= self.drop_first()[j]) by { self.drop_first().min_ensures() }\n            }\n        }\n    }",
        "doc_comment": "Proof of correctness and expected properties for min function",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2597,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains",
          "decreases",
          "forall",
          "len"
        ],
        "callees": [
          "min_ensures",
          "min",
          "contains",
          "len",
          "subrange",
          "drop_first"
        ]
      },
      "sort": {
        "name": "sort",
        "type": "closed_spec",
        "signature": "pub closed spec fn sort(self) -> Self",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.sort_by(|x: int, y: int| x <= y)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2620,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": [
          "sort_by"
        ]
      },
      "lemma_sort_ensures": {
        "name": "lemma_sort_ensures",
        "type": "proof",
        "signature": "pub proof fn lemma_sort_ensures(self)\n        ensures\n            self.to_multiset() =~= self.sort().to_multiset(),\n            sorted_by(self.sort(), |x: int, y: int| x <= y),",
        "ensures": [
          "self.to_multiset() =~= self.sort().to_multiset()",
          "sorted_by(self.sort(), |x: int, y: int| x <= y)"
        ],
        "requires": [],
        "body": "{\n        self.lemma_sort_by_ensures(|x: int, y: int| x <= y);\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2624,
        "module": "vstd::seq_lib",
        "keywords": [],
        "callees": [
          "lemma_sort_by_ensures"
        ]
      },
      "lemma_subrange_max": {
        "name": "lemma_subrange_max",
        "type": "proof",
        "signature": "pub proof fn lemma_subrange_max(self, from: int, to: int)\n        requires\n            0 <= from < to <= self.len(),\n        ensures\n            self.subrange(from, to).max() <= self.max(),",
        "ensures": [
          "self.subrange(from, to).max() <= self.max()"
        ],
        "requires": [
          "0 <= from < to <= self.len()"
        ],
        "body": "{\n        self.max_ensures();\n        self.subrange(from, to).max_ensures();\n    }",
        "doc_comment": "The maximum element in a non-empty sequence is greater than or equal to\nthe maxima of its non-empty subsequences.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2632,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "subrange"
        ],
        "callees": [
          "max_ensures",
          "subrange"
        ]
      },
      "lemma_subrange_min": {
        "name": "lemma_subrange_min",
        "type": "proof",
        "signature": "pub proof fn lemma_subrange_min(self, from: int, to: int)\n        requires\n            0 <= from < to <= self.len(),\n        ensures\n            self.subrange(from, to).min() >= self.min(),",
        "ensures": [
          "self.subrange(from, to).min() >= self.min()"
        ],
        "requires": [
          "0 <= from < to <= self.len()"
        ],
        "body": "{\n        self.min_ensures();\n        self.subrange(from, to).min_ensures();\n    }",
        "doc_comment": "The minimum element in a non-empty sequence is less than or equal to\nthe minima of its non-empty subsequences.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2644,
        "module": "vstd::seq_lib",
        "keywords": [
          "len",
          "subrange"
        ],
        "callees": [
          "min_ensures",
          "subrange"
        ]
      },
      "lemma_max_of_concat": {
        "name": "lemma_max_of_concat",
        "type": "proof",
        "signature": "pub proof fn lemma_max_of_concat(x: Seq<int>, y: Seq<int>)\n    requires\n        0 < x.len() && 0 < y.len(),\n    ensures\n        x.max() <= (x + y).max(),\n        y.max() <= (x + y).max(),\n        forall|elt: int| (x + y).contains(elt) ==> elt <= (x + y).max(),\n    decreases x.len(),",
        "ensures": [
          "x.max() <= (x + y).max()",
          "y.max() <= (x + y).max()",
          "forall|elt: int| (x + y).contains(elt) ==> elt <= (x + y).max()"
        ],
        "requires": [
          "0 < x.len() && 0 < y.len()"
        ],
        "body": "{\n    broadcast use group_seq_properties;\n\n    x.max_ensures();\n    y.max_ensures();\n    (x + y).max_ensures();\n    assert(x.drop_first().len() == x.len() - 1);\n    if x.len() == 1 {\n        assert(y.max() <= (x + y).max()) by {\n            assert((x + y).contains(y.max()));\n        }\n    } else {\n        assert(x.max() <= (x + y).max()) by {\n            assert(x.contains(x.max()));\n            assert((x + y).contains(x.max()));\n        }\n        assert(x.drop_first() + y =~= (x + y).drop_first());\n        lemma_max_of_concat(x.drop_first(), y);\n    }\n}",
        "doc_comment": "The maximum of the concatenation of two non-empty sequences is greater than or\nequal to the maxima of its two non-empty subsequences.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2751,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "decreases",
          "forall",
          "len"
        ],
        "callees": [
          "max_ensures",
          "lemma_max_of_concat",
          "contains",
          "len",
          "drop_first",
          "max"
        ]
      },
      "lemma_min_of_concat": {
        "name": "lemma_min_of_concat",
        "type": "proof",
        "signature": "pub proof fn lemma_min_of_concat(x: Seq<int>, y: Seq<int>)\n    requires\n        0 < x.len() && 0 < y.len(),\n    ensures\n        (x + y).min() <= x.min(),\n        (x + y).min() <= y.min(),\n        forall|elt: int| (x + y).contains(elt) ==> (x + y).min() <= elt,\n    decreases x.len(),",
        "ensures": [
          "(x + y).min() <= x.min()",
          "(x + y).min() <= y.min()",
          "forall|elt: int| (x + y).contains(elt) ==> (x + y).min() <= elt"
        ],
        "requires": [
          "0 < x.len() && 0 < y.len()"
        ],
        "body": "{\n    x.min_ensures();\n    y.min_ensures();\n    (x + y).min_ensures();\n    broadcast use group_seq_properties;\n\n    if x.len() == 1 {\n        assert((x + y).min() <= y.min()) by {\n            assert((x + y).contains(y.min()));\n        }\n    } else {\n        assert((x + y).min() <= x.min()) by {\n            assert((x + y).contains(x.min()));\n        }\n        assert((x + y).min() <= y.min()) by {\n            assert((x + y).contains(y.min()));\n        }\n        assert(x.drop_first() + y =~= (x + y).drop_first());\n        lemma_max_of_concat(x.drop_first(), y)\n    }\n}",
        "doc_comment": "The minimum of the concatenation of two non-empty sequences is less than or\nequal to the minimum of its two non-empty subsequences.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2782,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "decreases",
          "forall",
          "len"
        ],
        "callees": [
          "min_ensures",
          "lemma_max_of_concat",
          "min",
          "contains",
          "len",
          "drop_first"
        ]
      },
      "to_multiset_build": {
        "name": "to_multiset_build",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn to_multiset_build<A>(s: Seq<A>, a: A)\n    ensures\n        #![trigger s.push(a).to_multiset()]\n        s.push(a).to_multiset() =~= s.to_multiset().insert(a),\n    decreases s.len(),",
        "ensures": [
          "#![trigger s.push(a).to_multiset()]\n        s.push(a).to_multiset() =~= s.to_multiset().insert(a)"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::multiset::group_multiset_axioms;\n\n    if s.len() == 0 {\n        assert(s.to_multiset() =~= Multiset::<A>::empty());\n        assert(s.push(a).drop_first() =~= Seq::<A>::empty());\n        assert(s.push(a).to_multiset() =~= Multiset::<A>::empty().insert(a).add(\n            Seq::<A>::empty().to_multiset(),\n        ));\n    } else {\n        to_multiset_build(s.drop_first(), a);\n        assert(s.drop_first().push(a).to_multiset() =~= s.drop_first().to_multiset().insert(a));\n        assert(s.push(a).drop_first() =~= s.drop_first().push(a));\n    }\n}",
        "doc_comment": "push(a) o to_multiset = to_multiset o insert(a)",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2816,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "insert",
          "len",
          "push",
          "trigger"
        ],
        "callees": [
          "push",
          "to_multiset_build",
          "to_multiset",
          "len",
          "insert",
          "empty",
          "drop_first"
        ]
      },
      "to_multiset_remove": {
        "name": "to_multiset_remove",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn to_multiset_remove<A>(s: Seq<A>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        #![trigger s.remove(i).to_multiset()]\n        s.remove(i).to_multiset() == s.to_multiset().remove(s[i]),",
        "ensures": [
          "#![trigger s.remove(i).to_multiset()]\n        s.remove(i).to_multiset() == s.to_multiset().remove(s[i])"
        ],
        "requires": [
          "0 <= i < s.len()"
        ],
        "body": "{\n    broadcast use super::multiset::group_multiset_axioms;\n\n    let s0 = s.subrange(0, i);\n    let s1 = s.subrange(i, s.len() as int);\n    let s2 = s.subrange(i + 1, s.len() as int);\n    lemma_seq_union_to_multiset_commutative(s0, s2);\n    lemma_seq_union_to_multiset_commutative(s0, s1);\n    assert(s == s0 + s1);\n    assert(s2 + s0 == (s1 + s0).drop_first());\n    assert(s.remove(i).to_multiset() =~= s.to_multiset().remove(s[i]));\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2838,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "remove",
          "trigger"
        ],
        "callees": [
          "remove",
          "to_multiset",
          "len",
          "subrange",
          "drop_first",
          "lemma_seq_union_to_multiset_commutative"
        ]
      },
      "to_multiset_insert": {
        "name": "to_multiset_insert",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn to_multiset_insert<A>(s: Seq<A>, i: int, a: A)\n    requires\n        0 <= i <= s.len(),\n    ensures\n        #![trigger s.insert(i, a).to_multiset()]\n        s.insert(i, a).to_multiset() == s.to_multiset().insert(a),\n    decreases s.len(),",
        "ensures": [
          "#![trigger s.insert(i, a).to_multiset()]\n        s.insert(i, a).to_multiset() == s.to_multiset().insert(a)"
        ],
        "requires": [
          "0 <= i <= s.len()"
        ],
        "body": "{\n    broadcast use super::multiset::group_multiset_axioms;\n\n    let s0 = s.subrange(0, i);\n    let s1 = s.subrange(i, s.len() as int);\n\n    assert(s =~= s0 + s1);\n    assert(s.insert(i, a) =~= s0 + seq![a] + s1);\n    assert(((s0 + seq![a]) + s1).to_multiset() =~= ((seq![a] + s0) + s1).to_multiset()) by {\n        broadcast use lemma_multiset_commutative;\n\n    };\n    assert((seq![a] + s0 + s1).drop_first() == s0 + s1);\n    assert(s.insert(i, a).to_multiset() =~= s.to_multiset().insert(a));\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2857,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "insert",
          "len",
          "trigger"
        ],
        "callees": [
          "to_multiset",
          "len",
          "insert",
          "subrange",
          "drop_first"
        ]
      },
      "to_multiset_len": {
        "name": "to_multiset_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn to_multiset_len<A>(s: Seq<A>)\n    ensures\n        s.len() == #[trigger] s.to_multiset().len(),\n    decreases s.len(),",
        "ensures": [
          "s.len() == #[trigger] s.to_multiset().len()"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::multiset::group_multiset_axioms;\n\n    if s.len() == 0 {\n        assert(s.to_multiset() =~= Multiset::<A>::empty());\n        assert(s.len() == 0);\n    } else {\n        to_multiset_len(s.drop_first());\n        assert(s.len() == s.drop_first().len() + 1);\n        assert(s.to_multiset().len() == s.drop_first().to_multiset().len() + 1);\n    }\n}",
        "doc_comment": "to_multiset() preserves length",
        "triggers": [
          "s.to_multiset("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2880,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len",
          "trigger"
        ],
        "callees": [
          "to_multiset_len",
          "to_multiset",
          "len",
          "empty",
          "drop_first"
        ]
      },
      "to_multiset_contains": {
        "name": "to_multiset_contains",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn to_multiset_contains<A>(s: Seq<A>, a: A)\n    ensures\n        #![trigger s.to_multiset().count(a)]\n        s.contains(a) <==> s.to_multiset().count(a) > 0,\n    decreases s.len(),",
        "ensures": [
          "#![trigger s.to_multiset().count(a)]\n        s.contains(a) <==> s.to_multiset().count(a) > 0"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::multiset::group_multiset_axioms;\n\n    if s.len() != 0 {\n        // ==>\n        if s.contains(a) {\n            if s.first() == a {\n                to_multiset_build(s, a);\n                assert(s.to_multiset() =~= Multiset::<A>::empty().insert(s.first()).add(\n                    s.drop_first().to_multiset(),\n                ));\n                assert(Multiset::<A>::empty().insert(s.first()).contains(s.first()));\n            } else {\n                to_multiset_contains(s.drop_first(), a);\n                assert(s.skip(1) =~= s.drop_first());\n                lemma_seq_skip_contains(s, 1, a);\n                assert(s.to_multiset().count(a) == s.drop_first().to_multiset().count(a));\n                assert(s.contains(a) <==> s.to_multiset().count(a) > 0);\n            }\n        }\n        // <==\n\n        if s.to_multiset().count(a) > 0 {\n            to_multiset_contains(s.drop_first(), a);\n            assert(s.contains(a) <==> s.to_multiset().count(a) > 0);\n        } else {\n            assert(s.contains(a) <==> s.to_multiset().count(a) > 0);\n        }\n    }\n}",
        "doc_comment": "to_multiset() contains only the elements of the sequence",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2898,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "decreases",
          "len",
          "trigger"
        ],
        "callees": [
          "skip",
          "lemma_seq_skip_contains",
          "to_multiset_build",
          "to_multiset_contains",
          "to_multiset",
          "first",
          "len",
          "contains",
          "insert",
          "empty",
          "count",
          "drop_first"
        ]
      },
      "to_multiset_update": {
        "name": "to_multiset_update",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn to_multiset_update<A>(s: Seq<A>, i: int, a: A)\n    requires\n        0 <= i < s.len(),\n    ensures\n        #[trigger] s.update(i, a).to_multiset() == s.to_multiset().insert(a).remove(s[i]),\n    decreases s.len(),",
        "ensures": [
          "#[trigger] s.update(i, a).to_multiset() == s.to_multiset().insert(a).remove(s[i])"
        ],
        "requires": [
          "0 <= i < s.len()"
        ],
        "body": "{\n    broadcast use {\n        super::seq_lib::lemma_seq_take_len,\n        super::multiset::group_multiset_properties,\n        super::multiset::group_multiset_axioms,\n        to_multiset_insert,\n        to_multiset_remove,\n        to_multiset_contains,\n        lemma_update_is_remove_insert,\n    };\n\n    assert(s.update(i, a).to_multiset() =~= s.to_multiset().insert(a).remove(s[i]));\n\n}",
        "doc_comment": null,
        "triggers": [
          "s.update(i"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2935,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "insert",
          "len",
          "remove",
          "trigger"
        ],
        "callees": [
          "insert",
          "remove",
          "to_multiset",
          "update"
        ]
      },
      "lemma_update_is_remove_insert": {
        "name": "lemma_update_is_remove_insert",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_update_is_remove_insert<A>(s: Seq<A>, i: int, a: A)\n    requires\n        0 <= i < s.len(),\n    ensures\n        #[trigger] s.update(i, a) =~= s.remove(i).insert(i, a),\n    decreases s.len(),",
        "ensures": [
          "#[trigger] s.update(i, a) =~= s.remove(i).insert(i, a)"
        ],
        "requires": [
          "0 <= i < s.len()"
        ],
        "body": "{\n}",
        "doc_comment": "Lemma showing that update is equivalent to a remove followed by an insertae",
        "triggers": [
          "s.update(i"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2956,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "insert",
          "len",
          "remove",
          "trigger"
        ],
        "callees": []
      },
      "lemma_append_last": {
        "name": "lemma_append_last",
        "type": "proof",
        "signature": "pub proof fn lemma_append_last<A>(s1: Seq<A>, s2: Seq<A>)\n    requires\n        0 < s2.len(),\n    ensures\n        (s1 + s2).last() == s2.last(),",
        "ensures": [
          "(s1 + s2).last() == s2.last()"
        ],
        "requires": [
          "0 < s2.len()"
        ],
        "body": "{\n}",
        "doc_comment": "The last element of two concatenated sequences, the second one being non-empty, will be the\nlast element of the latter sequence.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2966,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": []
      },
      "lemma_concat_associative": {
        "name": "lemma_concat_associative",
        "type": "proof",
        "signature": "pub proof fn lemma_concat_associative<A>(s1: Seq<A>, s2: Seq<A>, s3: Seq<A>)\n    ensures\n        s1.add(s2.add(s3)) =~= s1.add(s2).add(s3),",
        "ensures": [
          "s1.add(s2.add(s3)) =~= s1.add(s2).add(s3)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The concatenation of sequences is associative",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2976,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ],
        "callees": []
      },
      "seq_to_set_is_finite": {
        "name": "seq_to_set_is_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn seq_to_set_is_finite<A>(seq: Seq<A>)\n    ensures\n        #[trigger] seq.to_set().finite(),",
        "ensures": [
          "#[trigger] seq.to_set().finite()"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::set::group_set_axioms;\n\n    assert(seq.to_set().finite()) by {\n        seq_to_set_equal_rec(seq);\n        seq_to_set_rec_is_finite(seq);\n    }\n}",
        "doc_comment": "The set obtained from a sequence is finite",
        "triggers": [
          "seq.to_set("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3051,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "finite",
          "trigger"
        ],
        "callees": [
          "seq_to_set_rec_is_finite",
          "seq_to_set_equal_rec",
          "to_set",
          "finite"
        ]
      },
      "seq_to_set_distributes_over_add": {
        "name": "seq_to_set_distributes_over_add",
        "type": "proof",
        "signature": "pub proof fn seq_to_set_distributes_over_add<T>(s1: Seq<T>, s2: Seq<T>)\n    ensures\n        s1.to_set() + s2.to_set() =~= (s1 + s2).to_set(),",
        "ensures": [
          "s1.to_set() + s2.to_set() =~= (s1 + s2).to_set()"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::group_vstd_default;\n    broadcast use super::set_lib::group_set_properties;\n    broadcast use group_seq_properties;\n\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3064,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ],
        "callees": []
      },
      "lemma_no_dup_in_concat": {
        "name": "lemma_no_dup_in_concat",
        "type": "proof",
        "signature": "pub proof fn lemma_no_dup_in_concat<A>(a: Seq<A>, b: Seq<A>)\n    requires\n        a.no_duplicates(),\n        b.no_duplicates(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> a[i] != b[j],\n    ensures\n        #[trigger] (a + b).no_duplicates(),",
        "ensures": [
          "#[trigger] (a + b).no_duplicates()"
        ],
        "requires": [
          "a.no_duplicates()",
          "b.no_duplicates()",
          "forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> a[i] != b[j]"
        ],
        "body": "{\n}",
        "doc_comment": "If sequences a and b don't have duplicates, and there are no\nelements in common between them, then the concatenated sequence\na + b will not contain duplicates either.",
        "triggers": [
          "(a + b"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3074,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "forall",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_flatten_concat": {
        "name": "lemma_flatten_concat",
        "type": "proof",
        "signature": "pub proof fn lemma_flatten_concat<A>(x: Seq<Seq<A>>, y: Seq<Seq<A>>)\n    ensures\n        (x + y).flatten() =~= x.flatten() + y.flatten(),\n    decreases x.len(),",
        "ensures": [
          "(x + y).flatten() =~= x.flatten() + y.flatten()"
        ],
        "requires": [],
        "body": "{\n    if x.len() == 0 {\n        assert(x + y =~= y);\n    } else {\n        assert((x + y).drop_first() =~= x.drop_first() + y);\n        assert(x.first() + (x.drop_first() + y).flatten() =~= x.first() + x.drop_first().flatten()\n            + y.flatten()) by {\n            lemma_flatten_concat(x.drop_first(), y);\n        }\n    }\n}",
        "doc_comment": "Flattening sequences of sequences is distributive over concatenation. That is, concatenating\nthe flattening of two sequences of sequences is the same as flattening the\nconcatenation of two sequences of sequences.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3087,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ],
        "callees": [
          "first",
          "len",
          "flatten",
          "drop_first",
          "lemma_flatten_concat"
        ]
      },
      "lemma_flatten_alt_concat": {
        "name": "lemma_flatten_alt_concat",
        "type": "proof",
        "signature": "pub proof fn lemma_flatten_alt_concat<A>(x: Seq<Seq<A>>, y: Seq<Seq<A>>)\n    ensures\n        (x + y).flatten_alt() =~= x.flatten_alt() + y.flatten_alt(),\n    decreases y.len(),",
        "ensures": [
          "(x + y).flatten_alt() =~= x.flatten_alt() + y.flatten_alt()"
        ],
        "requires": [],
        "body": "{\n    if y.len() == 0 {\n        assert(x + y =~= x);\n    } else {\n        assert((x + y).drop_last() =~= x + y.drop_last());\n        assert((x + y.drop_last()).flatten_alt() + y.last() =~= x.flatten_alt()\n            + y.drop_last().flatten_alt() + y.last()) by {\n            lemma_flatten_alt_concat(x, y.drop_last());\n        }\n    }\n}",
        "doc_comment": "Flattening sequences of sequences in reverse order is distributive over concatentation.\nThat is, concatenating the flattening of two sequences of sequences in reverse\norder is the same as flattening the concatenation of two sequences of sequences\nin reverse order.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3106,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ],
        "callees": [
          "flatten_alt",
          "lemma_flatten_alt_concat",
          "len",
          "last",
          "drop_last"
        ]
      },
      "lemma_seq_union_to_multiset_commutative": {
        "name": "lemma_seq_union_to_multiset_commutative",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_union_to_multiset_commutative<A>(a: Seq<A>, b: Seq<A>)\n    ensures\n        #[trigger] (a + b).to_multiset() =~= (b + a).to_multiset(),",
        "ensures": [
          "#[trigger] (a + b).to_multiset() =~= (b + a).to_multiset()"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::multiset::group_multiset_axioms;\n\n    lemma_multiset_commutative(a, b);\n    lemma_multiset_commutative(b, a);\n}",
        "doc_comment": "The multiset of a concatenated sequence `a + b` is equivalent to the multiset of the\nconcatenated sequence `b + a`.",
        "triggers": [
          "(a + b"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3126,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "trigger"
        ],
        "callees": [
          "lemma_multiset_commutative"
        ]
      },
      "lemma_multiset_commutative": {
        "name": "lemma_multiset_commutative",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_multiset_commutative<A>(a: Seq<A>, b: Seq<A>)\n    ensures\n        #[trigger] (a + b).to_multiset() =~= a.to_multiset().add(b.to_multiset()),\n    decreases a.len(),",
        "ensures": [
          "#[trigger] (a + b).to_multiset() =~= a.to_multiset().add(b.to_multiset())"
        ],
        "requires": [],
        "body": "{\n    broadcast use super::multiset::group_multiset_axioms;\n\n    if a.len() == 0 {\n        assert(a + b =~= b);\n    } else {\n        lemma_multiset_commutative(a.drop_first(), b);\n        assert(a.drop_first() + b =~= (a + b).drop_first());\n    }\n}",
        "doc_comment": "The multiset of a concatenated sequence `a + b` is equivalent to the multiset of just\nsequence `a` added to the multiset of just sequence `b`.",
        "triggers": [
          "(a + b"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3138,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "lemma_multiset_commutative",
          "drop_first"
        ]
      },
      "lemma_sorted_unique": {
        "name": "lemma_sorted_unique",
        "type": "proof",
        "signature": "pub proof fn lemma_sorted_unique<A>(x: Seq<A>, y: Seq<A>, leq: spec_fn(A, A) -> bool)\n    requires\n        sorted_by(x, leq),\n        sorted_by(y, leq),\n        total_ordering(leq),\n        x.to_multiset() == y.to_multiset(),\n    ensures\n        x =~= y,\n    decreases x.len(), y.len(),",
        "ensures": [
          "x =~= y"
        ],
        "requires": [
          "sorted_by(x, leq)",
          "sorted_by(y, leq)",
          "total_ordering(leq)",
          "x.to_multiset() == y.to_multiset()"
        ],
        "body": "{\n    broadcast use super::multiset::group_multiset_axioms;\n    broadcast use group_to_multiset_ensures;\n\n    if x.len() == 0 || y.len() == 0 {\n    } else {\n        assert(x.to_multiset().contains(x[0]));\n        assert(x.to_multiset().contains(y[0]));\n        let i = choose|i: int| #![trigger x.spec_index(i) ] 0 <= i < x.len() && x[i] == y[0];\n        assert(leq(x[i], x[0]));\n        assert(leq(x[0], x[i]));\n        assert(x.drop_first().to_multiset() =~= x.to_multiset().remove(x[0]));\n        assert(y.drop_first().to_multiset() =~= y.to_multiset().remove(y[0]));\n        lemma_sorted_unique(x.drop_first(), y.drop_first(), leq);\n        assert(x.drop_first() =~= y.drop_first());\n        assert(x.first() == y.first());\n        assert(x =~= Seq::<A>::empty().push(x.first()).add(x.drop_first()));\n        assert(x =~= y);\n    }\n}",
        "doc_comment": "Any two sequences that are sorted by a total order and that have the same elements are equal.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3155,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ],
        "callees": [
          "remove",
          "push",
          "to_multiset",
          "contains",
          "len",
          "first",
          "lemma_sorted_unique",
          "empty",
          "spec_index",
          "drop_first",
          "leq"
        ]
      },
      "lemma_seq_contains": {
        "name": "lemma_seq_contains",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_contains<A>(s: Seq<A>, x: A)\n    ensures\n        #[trigger] s.contains(x) <==> exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == x,",
        "ensures": [
          "#[trigger] s.contains(x) <==> exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == x"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [
          "s.contains(x",
          "s[i] == x"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3188,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "exists",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_empty_contains_nothing": {
        "name": "lemma_seq_empty_contains_nothing",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_empty_contains_nothing<A>(x: A)\n    ensures\n        !(#[trigger] Seq::<A>::empty().contains(x)),",
        "ensures": [
          "!(#[trigger] Seq::<A>::empty().contains(x))"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The empty sequence contains nothing",
        "triggers": [
          "Seq::<A>::empty("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3195,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "empty",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_empty_equality": {
        "name": "lemma_seq_empty_equality",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_empty_equality<A>(s: Seq<A>)\n    ensures\n        #[trigger] s.len() == 0 ==> s =~= Seq::<A>::empty(),",
        "ensures": [
          "#[trigger] s.len() == 0 ==> s =~= Seq::<A>::empty()"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "A sequence with length 0 is equivalent to the empty sequence",
        "triggers": [
          "s.len("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3204,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "empty",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_concat_contains_all_elements": {
        "name": "lemma_seq_concat_contains_all_elements",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_concat_contains_all_elements<A>(x: Seq<A>, y: Seq<A>, elt: A)\n    ensures\n        #[trigger] (x + y).contains(elt) <==> x.contains(elt) || y.contains(elt),\n    decreases x.len(),",
        "ensures": [
          "#[trigger] (x + y).contains(elt) <==> x.contains(elt) || y.contains(elt)"
        ],
        "requires": [],
        "body": "{\n    if x.len() == 0 && y.len() > 0 {\n        assert((x + y) =~= y);\n    } else {\n        assert forall|elt: A| #[trigger] x.contains(elt) implies #[trigger] (x + y).contains(\n            elt,\n        ) by {\n            let index = choose|i: int| 0 <= i < x.len() && x[i] == elt;\n            assert((x + y)[index] == elt);\n        }\n        assert forall|elt: A| #[trigger] y.contains(elt) implies #[trigger] (x + y).contains(\n            elt,\n        ) by {\n            let index = choose|i: int| 0 <= i < y.len() && y[i] == elt;\n            assert((x + y)[index + x.len()] == elt);\n        }\n    }\n}",
        "doc_comment": "The concatenation of two sequences contains only the elements\nof the two sequences",
        "triggers": [
          "(x + y"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3212,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "decreases",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "contains"
        ]
      },
      "lemma_seq_contains_after_push": {
        "name": "lemma_seq_contains_after_push",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_contains_after_push<A>(s: Seq<A>, v: A, x: A)\n    ensures\n        #[trigger] s.push(v).contains(x) <==> v == x || s.contains(x),",
        "ensures": [
          "#[trigger] s.push(v).contains(x) <==> v == x || s.contains(x)"
        ],
        "requires": [],
        "body": "{\n    assert forall|elt: A| #[trigger] s.contains(elt) implies #[trigger] s.push(v).contains(elt) by {\n        let index = choose|i: int| 0 <= i < s.len() && s[i] == elt;\n        assert(s.push(v)[index] == elt);\n    }\n    assert(s.push(v)[s.len() as int] == v);\n}",
        "doc_comment": "After pushing an element onto a sequence, the sequence contains that element",
        "triggers": [
          "s.push(v"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3238,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "push",
          "trigger"
        ],
        "callees": [
          "len",
          "contains",
          "push"
        ]
      },
      "lemma_seq_subrange_elements": {
        "name": "lemma_seq_subrange_elements",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_subrange_elements<A>(s: Seq<A>, start: int, stop: int, x: A)\n    requires\n        0 <= start <= stop <= s.len(),\n    ensures\n        #[trigger] s.subrange(start, stop).contains(x) <==> (exists|i: int|\n            0 <= start <= i < stop <= s.len() && #[trigger] s[i] == x),",
        "ensures": [
          "#[trigger] s.subrange(start, stop).contains(x) <==> (exists|i: int|\n            0 <= start <= i < stop <= s.len() && #[trigger] s[i] == x)"
        ],
        "requires": [
          "0 <= start <= stop <= s.len()"
        ],
        "body": "{\n    assert((exists|i: int| 0 <= start <= i < stop <= s.len() && s[i] == x) ==> s.subrange(\n        start,\n        stop,\n    ).contains(x)) by {\n        if exists|i: int| 0 <= start <= i < stop <= s.len() && s[i] == x {\n            let index = choose|i: int| 0 <= start <= i < stop <= s.len() && s[i] == x;\n            assert(s.subrange(start, stop)[index - start] == s[index]);\n        }\n    }\n}",
        "doc_comment": "The subrange of a sequence contains only the elements within the indices `start` and `stop`\nof the original sequence.",
        "triggers": [
          "s.subrange(start",
          "s[i] == x"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3251,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "exists",
          "len",
          "subrange",
          "trigger"
        ],
        "callees": [
          "len",
          "subrange",
          "contains"
        ]
      },
      "lemma_fold_right_permutation": {
        "name": "lemma_fold_right_permutation",
        "type": "proof",
        "signature": "pub proof fn lemma_fold_right_permutation<A, B>(l1: Seq<A>, l2: Seq<A>, f: spec_fn(A, B) -> B, v: B)\n    requires\n        commutative_foldr(f),\n        l1.to_multiset() == l2.to_multiset(),\n    ensures\n        l1.fold_right(f, v) == l2.fold_right(f, v),\n    decreases l1.len(),",
        "ensures": [
          "l1.fold_right(f, v) == l2.fold_right(f, v)"
        ],
        "requires": [
          "commutative_foldr(f)",
          "l1.to_multiset() == l2.to_multiset()"
        ],
        "body": "{\n    broadcast use group_to_multiset_ensures;\n\n    if l1.len() > 0 {\n        let a = l1.last();\n        let i = l2.index_of(a);\n        let l2r = l2.subrange(i + 1, l2.len() as int).fold_right(f, v);\n\n        assert(l1.to_multiset().count(a) > 0);\n        l1.drop_last().lemma_fold_right_commute_one(a, f, v);\n        l2.subrange(0, i).lemma_fold_right_commute_one(a, f, l2r);\n\n        l2.lemma_fold_right_split(f, v, i + 1);\n        l2.remove(i).lemma_fold_right_split(f, v, i);\n\n        assert(l2.subrange(0, i + 1).drop_last() == l2.subrange(0, i));\n        assert(l1.drop_last() == l1.remove(l1.len() - 1));\n\n        assert(l2.remove(i).subrange(0, i) == l2.subrange(0, i));\n        assert(l2.remove(i).subrange(i, l2.remove(i).len() as int) == l2.subrange(\n            i + 1,\n            l2.len() as int,\n        ));\n\n        lemma_fold_right_permutation(l1.drop_last(), l2.remove(i), f, v);\n    } else {\n        assert(l2.to_multiset().len() == 0);\n    }\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3283,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ],
        "callees": [
          "lemma_fold_right_commute_one",
          "lemma_fold_right_permutation",
          "remove",
          "index_of",
          "to_multiset",
          "lemma_fold_right_split",
          "len",
          "fold_right",
          "subrange",
          "last",
          "drop_last",
          "count"
        ]
      },
      "lemma_fold_left_permutation": {
        "name": "lemma_fold_left_permutation",
        "type": "proof",
        "signature": "pub proof fn lemma_fold_left_permutation<A, B>(l1: Seq<A>, l2: Seq<A>, f: spec_fn(B, A) -> B, v: B)\n    requires\n        commutative_foldl(f),\n        l1.to_multiset() == l2.to_multiset(),\n    ensures\n        l1.fold_left(v, f) == l2.fold_left(v, f),",
        "ensures": [
          "l1.fold_left(v, f) == l2.fold_left(v, f)"
        ],
        "requires": [
          "commutative_foldl(f)",
          "l1.to_multiset() == l2.to_multiset()"
        ],
        "body": "{\n    let g = |a: A, b: B| f(b, a);\n    assert(f =~= |b: B, a: A| g(a, b));\n    assert(l1.fold_left(v, f) == l1.reverse().fold_right(g, v)) by {\n        l1.lemma_reverse_fold_right(v, g)\n    };\n    assert(l2.fold_left(v, f) == l2.reverse().fold_right(g, v)) by {\n        l2.lemma_reverse_fold_right(v, g)\n    };\n    assert(l1.reverse().to_multiset() =~= l2.reverse().to_multiset()) by {\n        l1.lemma_reverse_to_multiset();\n        l2.lemma_reverse_to_multiset();\n    }\n    assert(forall|x: A| #[trigger] l1.reverse().contains(x) ==> l1.contains(x));\n    assert(forall|x: A| #[trigger] l2.reverse().contains(x) ==> l2.contains(x));\n    lemma_fold_right_permutation(l1.reverse(), l2.reverse(), g, v);\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3322,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ],
        "callees": [
          "f",
          "lemma_fold_right_permutation",
          "g",
          "lemma_reverse_fold_right",
          "lemma_reverse_to_multiset",
          "reverse",
          "to_multiset",
          "contains",
          "fold_right",
          "fold_left"
        ]
      },
      "lemma_seq_take_len": {
        "name": "lemma_seq_take_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_take_len<A>(s: Seq<A>, n: int)\n    ensures\n        0 <= n <= s.len() ==> #[trigger] s.take(n).len() == n,",
        "ensures": [
          "0 <= n <= s.len() ==> #[trigger] s.take(n).len() == n"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Taking the first `n` elements of a sequence results in a sequence of length `n`,\nas long as `n` is within the bounds of the original sequence.",
        "triggers": [
          "s.take(n"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3349,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_take_contains": {
        "name": "lemma_seq_take_contains",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_take_contains<A>(s: Seq<A>, n: int, x: A)\n    requires\n        0 <= n <= s.len(),\n    ensures\n        #[trigger] s.take(n).contains(x) <==> (exists|i: int|\n            0 <= i < n <= s.len() && #[trigger] s[i] == x),",
        "ensures": [
          "#[trigger] s.take(n).contains(x) <==> (exists|i: int|\n            0 <= i < n <= s.len() && #[trigger] s[i] == x)"
        ],
        "requires": [
          "0 <= n <= s.len()"
        ],
        "body": "{\n    assert((exists|i: int| 0 <= i < n <= s.len() && #[trigger] s[i] == x) ==> s.take(n).contains(x))\n        by {\n        if exists|i: int| 0 <= i < n <= s.len() && #[trigger] s[i] == x {\n            let index = choose|i: int| 0 <= i < n <= s.len() && #[trigger] s[i] == x;\n            assert(s.take(n)[index] == s[index]);\n        }\n    }\n}",
        "doc_comment": "The resulting sequence after taking the first `n` elements from sequence `s` contains\nelement `x` if and only if `x` is contained in the first `n` elements of `s`.",
        "triggers": [
          "s.take(n",
          "s[i] == x"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3358,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "exists",
          "len",
          "take",
          "trigger"
        ],
        "callees": [
          "len",
          "take",
          "contains"
        ]
      },
      "lemma_seq_take_index": {
        "name": "lemma_seq_take_index",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_take_index<A>(s: Seq<A>, n: int, j: int)\n    ensures\n        0 <= j < n <= s.len() ==> #[trigger] s.take(n)[j] == s[j],",
        "ensures": [
          "0 <= j < n <= s.len() ==> #[trigger] s.take(n)[j] == s[j]"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `j` is a valid index less than `n`, then the `j`th element of the sequence `s`\nis the same as `j`th element of the sequence after taking the first `n` elements of `s`.",
        "triggers": [
          "s.take(n"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3377,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "subrange_of_matching_take": {
        "name": "subrange_of_matching_take",
        "type": "proof",
        "signature": "pub proof fn subrange_of_matching_take<T>(a: Seq<T>, b: Seq<T>, s: int, e: int, l: int)\n    requires\n        a.take(l) == b.take(l),\n        l <= a.len(),\n        l <= b.len(),\n        0 <= s <= e <= l,\n    ensures\n        a.subrange(s, e) == b.subrange(s, e),",
        "ensures": [
          "a.subrange(s, e) == b.subrange(s, e)"
        ],
        "requires": [
          "a.take(l) == b.take(l)",
          "l <= a.len()",
          "l <= b.len()",
          "0 <= s <= e <= l"
        ],
        "body": "{\n    assert forall|i| 0 <= i < e - s implies a.subrange(s, e)[i] == b.subrange(s, e)[i] by {\n        assert(a.subrange(s, e)[i] == a.take(l)[i + s]);\n        //             assert( b.subrange(s, e)[i] == b.take(l)[i + s] );   // either trigger will do\n    }\n    // trigger extn equality (verus issue #1257)\n\n    assert(a.subrange(s, e) == b.subrange(s, e));\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3384,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "subrange",
          "take"
        ],
        "callees": [
          "take",
          "subrange",
          "equality"
        ]
      },
      "lemma_seq_skip_len": {
        "name": "lemma_seq_skip_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_len<A>(s: Seq<A>, n: int)\n    ensures\n        0 <= n <= s.len() ==> #[trigger] s.skip(n).len() == s.len() - n,",
        "ensures": [
          "0 <= n <= s.len() ==> #[trigger] s.skip(n).len() == s.len() - n"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Skipping the first `n` elements of a sequence gives a sequence of length `n` less than\nthe original sequence's length.",
        "triggers": [
          "s.skip(n"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3404,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_skip_contains": {
        "name": "lemma_seq_skip_contains",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_contains<A>(s: Seq<A>, n: int, x: A)\n    requires\n        0 <= n <= s.len(),\n    ensures\n        #[trigger] s.skip(n).contains(x) <==> (exists|i: int|\n            0 <= n <= i < s.len() && #[trigger] s[i] == x),",
        "ensures": [
          "#[trigger] s.skip(n).contains(x) <==> (exists|i: int|\n            0 <= n <= i < s.len() && #[trigger] s[i] == x)"
        ],
        "requires": [
          "0 <= n <= s.len()"
        ],
        "body": "{\n    assert((exists|i: int| 0 <= n <= i < s.len() && #[trigger] s[i] == x) ==> s.skip(n).contains(x))\n        by {\n        let index = choose|i: int| 0 <= n <= i < s.len() && #[trigger] s[i] == x;\n        lemma_seq_skip_index(s, n, index - n);\n    }\n}",
        "doc_comment": "The resulting sequence after skipping the first `n` elements from sequence `s` contains\nelement `x` if and only if `x` is contained in `s` before index `n`.",
        "triggers": [
          "s.skip(n",
          "s[i] == x"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3413,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "exists",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "lemma_seq_skip_index",
          "skip",
          "contains"
        ]
      },
      "lemma_seq_skip_index": {
        "name": "lemma_seq_skip_index",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_index<A>(s: Seq<A>, n: int, j: int)\n    ensures\n        0 <= n && 0 <= j < (s.len() - n) ==> #[trigger] s.skip(n)[j] == s[j + n],",
        "ensures": [
          "0 <= n && 0 <= j < (s.len() - n) ==> #[trigger] s.skip(n)[j] == s[j + n]"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `j` is a valid index less than `s.len() - n`, then the `j`th element of the sequence\n`s.skip(n)` is the same as the `j+n`th element of the sequence `s`.",
        "triggers": [
          "s.skip(n"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3430,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_skip_index2": {
        "name": "lemma_seq_skip_index2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_index2<A>(s: Seq<A>, n: int, k: int)\n    ensures\n        0 <= n <= k < s.len() ==> (#[trigger] s.skip(n))[k - n] == #[trigger] s[k],",
        "ensures": [
          "0 <= n <= k < s.len() ==> (#[trigger] s.skip(n))[k - n] == #[trigger] s[k]"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `k` is a valid index between `n` (inclusive) and the length of sequence `s` (exclusive),\nthen the `k-n`th element of the sequence `s.skip(n)` is the same as the `k`th element of the\noriginal sequence `s`.",
        "triggers": [
          "s.skip(n",
          "s[k]"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3439,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_append_take_skip": {
        "name": "lemma_seq_append_take_skip",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_append_take_skip<A>(a: Seq<A>, b: Seq<A>, n: int)\n    ensures\n        #![trigger (a + b).take(n)]\n        #![trigger (a + b).skip(n)]\n        n == a.len() ==> ((a + b).take(n) =~= a && (a + b).skip(n) =~= b),",
        "ensures": [
          "#![trigger (a + b).take(n)]\n        #![trigger (a + b).skip(n)]\n        n == a.len() ==> ((a + b).take(n) =~= a && (a + b).skip(n) =~= b)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `n` is the length of sequence `a`, then taking the first `n` elements of the concatenation\n`a + b` is equivalent to the sequence `a` and skipping the first `n` elements of the concatenation\n`a + b` is equivalent to the sequence `b`.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3449,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_take_update_commut1": {
        "name": "lemma_seq_take_update_commut1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_take_update_commut1<A>(s: Seq<A>, i: int, v: A, n: int)\n    ensures\n        #![trigger s.update(i, v).take(n)]\n        0 <= i < n <= s.len() ==> #[trigger] s.update(i, v).take(n) =~= s.take(n).update(i, v),",
        "ensures": [
          "#![trigger s.update(i, v).take(n)]\n        0 <= i < n <= s.len() ==> #[trigger] s.update(i, v).take(n) =~= s.take(n).update(i, v)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `i` is in the first `n` indices of sequence `s`, updating sequence `s` at index `i` with\nvalue `v` and then taking the first `n` elements is equivalent to first taking the first `n`\nelements of `s` and then updating index `i` to value `v`.",
        "triggers": [
          "s.update(i"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3463,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_take_update_commut2": {
        "name": "lemma_seq_take_update_commut2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_take_update_commut2<A>(s: Seq<A>, i: int, v: A, n: int)\n    ensures\n        0 <= n <= i < s.len() ==> #[trigger] s.update(i, v).take(n) =~= s.take(n),",
        "ensures": [
          "0 <= n <= i < s.len() ==> #[trigger] s.update(i, v).take(n) =~= s.take(n)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `i` is a valid index after the first `n` indices of sequence `s`, updating sequence `s` at\nindex `i` with value `v` and then taking the first `n` elements is equivalent to just taking the first `n`\nelements of `s` without the update.",
        "triggers": [
          "s.update(i"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3474,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_skip_update_commut1": {
        "name": "lemma_seq_skip_update_commut1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_update_commut1<A>(s: Seq<A>, i: int, v: A, n: int)\n    ensures\n        0 <= n <= i < s.len() ==> #[trigger] s.update(i, v).skip(n) =~= s.skip(n).update(i - n, v),",
        "ensures": [
          "0 <= n <= i < s.len() ==> #[trigger] s.update(i, v).skip(n) =~= s.skip(n).update(i - n, v)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `i` is a valid index after the first `n` indices of sequence `s`, updating sequence `s` at\nindex `i` with value `v` and then skipping the first `n` elements is equivalent to skipping the first `n`\nelements of `s` and then updating index `i-n` to value `v`.",
        "triggers": [
          "s.update(i"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3484,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_skip_update_commut2": {
        "name": "lemma_seq_skip_update_commut2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_update_commut2<A>(s: Seq<A>, i: int, v: A, n: int)\n    ensures\n        0 <= i < n <= s.len() ==> #[trigger] s.update(i, v).skip(n) =~= s.skip(n),",
        "ensures": [
          "0 <= i < n <= s.len() ==> #[trigger] s.update(i, v).skip(n) =~= s.skip(n)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `i` is a valid index in the first `n` indices of sequence `s`, updating sequence `s` at\nindex `i` with value `v` and then skipping the first `n` elements is equivalent to just skipping\nthe first `n` elements without the update.",
        "triggers": [
          "s.update(i"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3494,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_skip_build_commut": {
        "name": "lemma_seq_skip_build_commut",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_build_commut<A>(s: Seq<A>, v: A, n: int)\n    ensures\n        #![trigger s.push(v).skip(n)]\n        0 <= n <= s.len() ==> s.push(v).skip(n) =~= s.skip(n).push(v),",
        "ensures": [
          "#![trigger s.push(v).skip(n)]\n        0 <= n <= s.len() ==> s.push(v).skip(n) =~= s.skip(n).push(v)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Pushing element `v` onto the end of sequence `s` and then skipping the first `n` elements is\nequivalent to skipping the first `n` elements of `s` and then pushing `v` onto the end.",
        "triggers": [],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3504,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "push",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_skip_nothing": {
        "name": "lemma_seq_skip_nothing",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_nothing<A>(s: Seq<A>, n: int)\n    ensures\n        n == 0 ==> #[trigger] s.skip(n) =~= s,",
        "ensures": [
          "n == 0 ==> #[trigger] s.skip(n) =~= s"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "`s.skip(0)` is equivalent to `s`.",
        "triggers": [
          "s.skip(n"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3514,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_take_nothing": {
        "name": "lemma_seq_take_nothing",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_take_nothing<A>(s: Seq<A>, n: int)\n    ensures\n        n == 0 ==> #[trigger] s.take(n) =~= Seq::<A>::empty(),",
        "ensures": [
          "n == 0 ==> #[trigger] s.take(n) =~= Seq::<A>::empty()"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "`s.take(0)` is equivalent to the empty sequence.",
        "triggers": [
          "s.take(n"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3522,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "empty",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_skip_of_skip": {
        "name": "lemma_seq_skip_of_skip",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_seq_skip_of_skip<A>(s: Seq<A>, m: int, n: int)\n    ensures\n        (0 <= m && 0 <= n && m + n <= s.len()) ==> #[trigger] s.skip(m).skip(n) =~= s.skip(m + n),",
        "ensures": [
          "(0 <= m && 0 <= n && m + n <= s.len()) ==> #[trigger] s.skip(m).skip(n) =~= s.skip(m + n)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If `m + n` is less than or equal to the length of sequence `s`, then skipping the first `m` elements\nand then skipping the first `n` elements of the resulting sequence is equivalent to just skipping\nthe first `m + n` elements.",
        "triggers": [
          "s.skip(m"
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3530,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "lemma_seq_properties": {
        "name": "lemma_seq_properties",
        "type": "proof",
        "signature": "pub proof fn lemma_seq_properties<A>()\n    ensures\n        forall|s: Seq<A>, x: A|\n            s.contains(x) <==> exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == x,  //from lemma_seq_contains(s, x),\n        forall|x: A| !(#[trigger] Seq::<A>::empty().contains(x)),  //from lemma_seq_empty_contains_nothing(x),\n        forall|s: Seq<A>| #[trigger] s.len() == 0 ==> s =~= Seq::<A>::empty(),  //from lemma_seq_empty_equality(s),\n        forall|x: Seq<A>, y: Seq<A>, elt: A| #[trigger]\n            (x + y).contains(elt) <==> x.contains(elt) || y.contains(elt),  //from lemma_seq_concat_contains_all_elements(x, y, elt),\n        forall|s: Seq<A>, v: A, x: A| #[trigger] s.push(v).contains(x) <==> v == x || s.contains(x),  //from lemma_seq_contains_after_push(s, v, x)\n        forall|s: Seq<A>, start: int, stop: int, x: A|\n            (0 <= start <= stop <= s.len() && #[trigger] s.subrange(start, stop).contains(x)) <==> (\n            exists|i: int| 0 <= start <= i < stop <= s.len() && #[trigger] s[i] == x),  //from lemma_seq_subrange_elements(s, start, stop, x),\n        forall|s: Seq<A>, n: int| 0 <= n <= s.len() ==> #[trigger] s.take(n).len() == n,  //from lemma_seq_take_len(s, n)\n        forall|s: Seq<A>, n: int, x: A|\n            (#[trigger] s.take(n).contains(x) && 0 <= n <= s.len()) <==> (exists|i: int|\n                0 <= i < n <= s.len() && #[trigger] s[i] == x),  //from lemma_seq_take_contains(s, n, x),\n        forall|s: Seq<A>, n: int, j: int| 0 <= j < n <= s.len() ==> #[trigger] s.take(n)[j] == s[j],  //from lemma_seq_take_index(s, n, j),\n        forall|s: Seq<A>, n: int| 0 <= n <= s.len() ==> #[trigger] s.skip(n).len() == s.len() - n,  //from lemma_seq_skip_len(s, n),\n        forall|s: Seq<A>, n: int, x: A|\n            (#[trigger] s.skip(n).contains(x) && 0 <= n <= s.len()) <==> (exists|i: int|\n                0 <= n <= i < s.len() && #[trigger] s[i] == x),  //from lemma_seq_skip_contains(s, n, x),\n        forall|s: Seq<A>, n: int, j: int|\n            0 <= n && 0 <= j < (s.len() - n) ==> #[trigger] s.skip(n)[j] == s[j + n],  //from lemma_seq_skip_index(s, n, j),\n        forall|a: Seq<A>, b: Seq<A>, n: int|\n            #![trigger (a+b).take(n)]\n            #![trigger (a+b).skip(n)]\n            n == a.len() ==> ((a + b).take(n) =~= a && (a + b).skip(n) =~= b),  //from lemma_seq_append_take_skip(a, b, n),\n        forall|s: Seq<A>, i: int, v: A, n: int|\n            0 <= i < n <= s.len() ==> #[trigger] s.update(i, v).take(n) == s.take(n).update(i, v),  //from lemma_seq_take_update_commut1(s, i, v, n),\n        forall|s: Seq<A>, i: int, v: A, n: int|\n            0 <= n <= i < s.len() ==> #[trigger] s.update(i, v).take(n) == s.take(n),  //from lemma_seq_take_update_commut2(s, i, v, n),\n        forall|s: Seq<A>, i: int, v: A, n: int|\n            0 <= n <= i < s.len() ==> #[trigger] s.update(i, v).skip(n) == s.skip(n).update(\n                i - n,\n                v,\n            ),  //from lemma_seq_skip_update_commut1(s, i, v, n),\n        forall|s: Seq<A>, i: int, v: A, n: int|\n            0 <= i < n <= s.len() ==> #[trigger] s.update(i, v).skip(n) == s.skip(n),  //from lemma_seq_skip_update_commut2(s, i, v, n),\n        forall|s: Seq<A>, v: A, n: int|\n            0 <= n <= s.len() ==> #[trigger] s.push(v).skip(n) == s.skip(n).push(v),  //from lemma_seq_skip_build_commut(s, v, n),\n        forall|s: Seq<A>, n: int| n == 0 ==> #[trigger] s.skip(n) == s,  //from lemma_seq_skip_nothing(s, n),\n        forall|s: Seq<A>, n: int| n == 0 ==> #[trigger] s.take(n) == Seq::<A>::empty(),  //from lemma_seq_take_nothing(s, n),\n        forall|s: Seq<A>, m: int, n: int|\n            (0 <= m && 0 <= n && m + n <= s.len()) ==> #[trigger] s.skip(m).skip(n) == s.skip(\n                m + n,\n            ),  //from lemma_seq_skip_of_skip(s, m, n),\n        forall|s: Seq<A>, a: A| #[trigger] (s.push(a).to_multiset()) =~= s.to_multiset().insert(a),  //from o_multiset_properties\n        forall|s: Seq<A>| s.len() == #[trigger] s.to_multiset().len(),  //from to_multiset_ensures\n        forall|s: Seq<A>, a: A|\n            s.contains(a) <==> #[trigger] s.to_multiset().count(a)\n                > 0,  //from to_multiset_ensures",
        "ensures": [
          "forall|s: Seq<A>, x: A|\n            s.contains(x) <==> exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == x,  //from lemma_seq_contains(s, x)",
          "forall|x: A| !(#[trigger] Seq::<A>::empty().contains(x)),  //from lemma_seq_empty_contains_nothing(x)",
          "forall|s: Seq<A>| #[trigger] s.len() == 0 ==> s =~= Seq::<A>::empty(),  //from lemma_seq_empty_equality(s)",
          "forall|x: Seq<A>, y: Seq<A>, elt: A| #[trigger]\n            (x + y).contains(elt) <==> x.contains(elt) || y.contains(elt),  //from lemma_seq_concat_contains_all_elements(x, y, elt)",
          "forall|s: Seq<A>, v: A, x: A| #[trigger] s.push(v).contains(x) <==> v == x || s.contains(x),  //from lemma_seq_contains_after_push(s, v, x)\n        forall|s: Seq<A>, start: int, stop: int, x: A|\n            (0 <= start <= stop <= s.len() && #[trigger] s.subrange(start, stop).contains(x)) <==> (\n            exists|i: int| 0 <= start <= i < stop <= s.len() && #[trigger] s[i] == x),  //from lemma_seq_subrange_elements(s, start, stop, x)",
          "forall|s: Seq<A>, n: int| 0 <= n <= s.len() ==> #[trigger] s.take(n).len() == n,  //from lemma_seq_take_len(s, n)\n        forall|s: Seq<A>, n: int, x: A|\n            (#[trigger] s.take(n).contains(x) && 0 <= n <= s.len()) <==> (exists|i: int|\n                0 <= i < n <= s.len() && #[trigger] s[i] == x),  //from lemma_seq_take_contains(s, n, x)",
          "forall|s: Seq<A>, n: int, j: int| 0 <= j < n <= s.len() ==> #[trigger] s.take(n)[j] == s[j],  //from lemma_seq_take_index(s, n, j)",
          "forall|s: Seq<A>, n: int| 0 <= n <= s.len() ==> #[trigger] s.skip(n).len() == s.len() - n,  //from lemma_seq_skip_len(s, n)",
          "forall|s: Seq<A>, n: int, x: A|\n            (#[trigger] s.skip(n).contains(x) && 0 <= n <= s.len()) <==> (exists|i: int|\n                0 <= n <= i < s.len() && #[trigger] s[i] == x),  //from lemma_seq_skip_contains(s, n, x)",
          "forall|s: Seq<A>, n: int, j: int|\n            0 <= n && 0 <= j < (s.len() - n) ==> #[trigger] s.skip(n)[j] == s[j + n],  //from lemma_seq_skip_index(s, n, j)",
          "forall|a: Seq<A>, b: Seq<A>, n: int|\n            #![trigger (a+b).take(n)]\n            #![trigger (a+b).skip(n)]\n            n == a.len() ==> ((a + b).take(n) =~= a && (a + b).skip(n) =~= b),  //from lemma_seq_append_take_skip(a, b, n)",
          "forall|s: Seq<A>, i: int, v: A, n: int|\n            0 <= i < n <= s.len() ==> #[trigger] s.update(i, v).take(n) == s.take(n).update(i, v),  //from lemma_seq_take_update_commut1(s, i, v, n)",
          "forall|s: Seq<A>, i: int, v: A, n: int|\n            0 <= n <= i < s.len() ==> #[trigger] s.update(i, v).take(n) == s.take(n),  //from lemma_seq_take_update_commut2(s, i, v, n)",
          "forall|s: Seq<A>, i: int, v: A, n: int|\n            0 <= n <= i < s.len() ==> #[trigger] s.update(i, v).skip(n) == s.skip(n).update(\n                i - n",
          "v",
          "),  //from lemma_seq_skip_update_commut1(s, i, v, n)",
          "forall|s: Seq<A>, i: int, v: A, n: int|\n            0 <= i < n <= s.len() ==> #[trigger] s.update(i, v).skip(n) == s.skip(n),  //from lemma_seq_skip_update_commut2(s, i, v, n)",
          "forall|s: Seq<A>, v: A, n: int|\n            0 <= n <= s.len() ==> #[trigger] s.push(v).skip(n) == s.skip(n).push(v),  //from lemma_seq_skip_build_commut(s, v, n)",
          "forall|s: Seq<A>, n: int| n == 0 ==> #[trigger] s.skip(n) == s,  //from lemma_seq_skip_nothing(s, n)",
          "forall|s: Seq<A>, n: int| n == 0 ==> #[trigger] s.take(n) == Seq::<A>::empty(),  //from lemma_seq_take_nothing(s, n)",
          "forall|s: Seq<A>, m: int, n: int|\n            (0 <= m && 0 <= n && m + n <= s.len()) ==> #[trigger] s.skip(m).skip(n) == s.skip(\n                m + n",
          "),  //from lemma_seq_skip_of_skip(s, m, n)",
          "forall|s: Seq<A>, a: A| #[trigger] (s.push(a).to_multiset()) =~= s.to_multiset().insert(a),  //from o_multiset_properties\n        forall|s: Seq<A>| s.len() == #[trigger] s.to_multiset().len(),  //from to_multiset_",
          "forall|s: Seq<A>, a: A|\n            s.contains(a) <==> #[trigger] s.to_multiset().count(a)\n                > 0,  //from to_multiset_"
        ],
        "requires": [],
        "body": "{\n    broadcast use {group_seq_properties, lemma_seq_skip_of_skip};\n\n}",
        "doc_comment": "Properties of sequences from the Dafny prelude (which were axioms in Dafny, but proven here in Verus)",
        "triggers": [
          "s[i] == x",
          "Seq::<A>::empty(",
          "s.len(",
          "(x + y",
          "s.push(v",
          "s.subrange(start",
          "s[i] == x",
          "s.take(n",
          "s.take(n",
          "s[i] == x",
          "s.take(n",
          "s.skip(n",
          "s.skip(n",
          "s[i] == x",
          "s.skip(n",
          "s.update(i",
          "s.update(i",
          "s.update(i",
          "s.update(i",
          "s.push(v",
          "s.skip(n",
          "s.take(n",
          "s.skip(m",
          "(s.push(a",
          "s.to_multiset(",
          "s.to_multiset("
        ],
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3538,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "contains",
          "empty",
          "exists",
          "forall",
          "insert",
          "len",
          "push",
          "subrange",
          "take",
          "trigger"
        ],
        "callees": []
      },
      "vstd::set::empty": {
        "name": "vstd::set::empty",
        "type": "closed_spec",
        "signature": "pub closed spec fn empty() -> Set<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set { set: |a| false }\n    }",
        "doc_comment": "The \"empty\" set.\n\nUsage Example: <br>\n```rust\nlet empty_set = Set::<A>::empty();\n\nassert(empty_set.is_empty());\nassert(empty_set.complement() =~= Set::<A>::full());\nassert(Set::<A>::empty().finite());\nassert(Set::<A>::empty().len() == 0);\nassert(forall |x: A| !Set::<A>::empty().contains(x));\n```\nAxioms around the empty set are: <br>\n* [`axiom_set_empty_finite`](crate::set::axiom_set_empty_finite) <br>\n* [`axiom_set_empty_len`](crate::set::axiom_set_empty_len) <br>\n* [`axiom_set_empty`](crate::set::axiom_set_empty)",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 35,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "empty"
        ],
        "callees": []
      },
      "vstd::set::new": {
        "name": "vstd::set::new",
        "type": "closed_spec",
        "signature": "pub closed spec fn new(f: spec_fn(A) -> bool) -> Set<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set {\n            set: |a|\n                if f(a) {\n                    true\n                } else {\n                    false\n                },\n        }\n    }",
        "doc_comment": "Set whose membership is determined by the given boolean predicate.\n\nUsage Examples:\n```rust\nlet set_a = Set::new(|x : nat| x < 42);\nlet set_b = Set::<A>::new(|x| some_predicate(x));\nassert(forall|x| some_predicate(x) <==> set_b.contains(x));\n```",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 55,
        "module": "vstd::set",
        "keywords": [
          "Set"
        ],
        "callees": [
          "f"
        ]
      },
      "contains": {
        "name": "contains",
        "type": "closed_spec",
        "signature": "pub closed spec fn contains(self, a: A) -> bool",
        "ensures": [],
        "requires": [],
        "body": "{\n        (self.set)(a)\n    }",
        "doc_comment": "Predicate indicating if the set contains the given element.",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 80,
        "module": "vstd::set",
        "keywords": [
          "contains"
        ],
        "callees": []
      },
      "vstd::set::insert": {
        "name": "vstd::set::insert",
        "type": "closed_spec",
        "signature": "pub closed spec fn insert(self, a: A) -> Set<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set {\n            set: |a2|\n                if a2 == a {\n                    true\n                } else {\n                    (self.set)(a2)\n                },\n        }\n    }",
        "doc_comment": "Returns a new set with the given element inserted.\nIf that element is already in the set, then an identical set is returned.",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 103,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "insert"
        ],
        "callees": []
      },
      "vstd::set::remove": {
        "name": "vstd::set::remove",
        "type": "closed_spec",
        "signature": "pub closed spec fn remove(self, a: A) -> Set<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set {\n            set: |a2|\n                if a2 == a {\n                    false\n                } else {\n                    (self.set)(a2)\n                },\n        }\n    }",
        "doc_comment": "Returns a new set with the given element removed.\nIf that element is already absent from the set, then an identical set is returned.",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 117,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "remove"
        ],
        "callees": []
      },
      "union": {
        "name": "union",
        "type": "closed_spec",
        "signature": "pub closed spec fn union(self, s2: Set<A>) -> Set<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set { set: |a| (self.set)(a) || (s2.set)(a) }\n    }",
        "doc_comment": "Union of two sets.",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 131,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "union"
        ],
        "callees": []
      },
      "intersect": {
        "name": "intersect",
        "type": "closed_spec",
        "signature": "pub closed spec fn intersect(self, s2: Set<A>) -> Set<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set { set: |a| (self.set)(a) && (s2.set)(a) }\n    }",
        "doc_comment": "Intersection of two sets.",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 142,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "intersect"
        ],
        "callees": []
      },
      "difference": {
        "name": "difference",
        "type": "closed_spec",
        "signature": "pub closed spec fn difference(self, s2: Set<A>) -> Set<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set { set: |a| (self.set)(a) && !(s2.set)(a) }\n    }",
        "doc_comment": "Set difference, i.e., the set of all elements in the first one but not in the second.",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 153,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "difference"
        ],
        "callees": []
      },
      "complement": {
        "name": "complement",
        "type": "closed_spec",
        "signature": "pub closed spec fn complement(self) -> Set<A>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set { set: |a| !(self.set)(a) }\n    }",
        "doc_comment": "Set complement (within the space of all possible elements in `A`).",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 164,
        "module": "vstd::set",
        "keywords": [
          "Set"
        ],
        "callees": []
      },
      "finite": {
        "name": "finite",
        "type": "closed_spec",
        "signature": "pub closed spec fn finite(self) -> bool",
        "ensures": [],
        "requires": [],
        "body": "{\n        exists|f: spec_fn(A) -> nat, ub: nat|\n            {\n                &&& #[trigger] trigger_finite(f, ub)\n                &&& surj_on(f, self)\n                &&& forall|a| self.contains(a) ==> f(a) < ub\n            }\n    }",
        "doc_comment": "Returns `true` if the set is finite.",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 174,
        "module": "vstd::set",
        "keywords": [
          "finite"
        ],
        "callees": [
          "f",
          "trigger_finite",
          "contains",
          "surj_on",
          "spec_fn"
        ]
      },
      "vstd::set::len": {
        "name": "vstd::set::len",
        "type": "closed_spec",
        "signature": "pub closed spec fn len(self) -> nat",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.fold(0, |acc: nat, a| acc + 1)\n    }",
        "doc_comment": "Cardinality of the set. (Only meaningful if a set is finite.)",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 184,
        "module": "vstd::set",
        "keywords": [
          "len"
        ],
        "callees": [
          "fold"
        ]
      },
      "mk_map": {
        "name": "mk_map",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn mk_map<V>(self, f: spec_fn(A) -> V) -> Map<A, V>",
        "ensures": [],
        "requires": [],
        "body": "{\n        forall|a: A| self.contains(a) ==> !s2.contains(a)\n    }",
        "doc_comment": "Creates a [`Map`] whose domain is the given set.\nThe values of the map are given by `f`, a function of the keys.",
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 199,
        "module": "vstd::set",
        "keywords": [
          "Map"
        ],
        "callees": [
          "contains"
        ]
      },
      "lemma_finite_set_induct": {
        "name": "lemma_finite_set_induct",
        "type": "proof",
        "signature": "pub proof fn lemma_finite_set_induct<A>(s: Set<A>, pred: spec_fn(Set<A>) -> bool)\n        requires\n            s.finite(),\n            pred(Set::empty()),\n            forall|s, a| pred(s) && s.finite() && !s.contains(a) ==> #[trigger] pred(s.insert(a)),\n        ensures\n            pred(s),",
        "ensures": [
          "pred(s)"
        ],
        "requires": [
          "s.finite()",
          "pred(Set::empty())",
          "forall|s, a| pred(s) && s.finite() && !s.contains(a) ==> #[trigger] pred(s.insert(a))"
        ],
        "body": "{\n        let (f, ub) = choose|f: spec_fn(A) -> nat, ub: nat| #[trigger]\n            trigger_finite(f, ub) && surj_on(f, s) && (forall|a| s.contains(a) ==> f(a) < ub);\n        lemma_finite_set_induct_aux(s, f, ub, pred);\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 538,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "empty",
          "finite",
          "forall",
          "insert",
          "trigger"
        ],
        "callees": [
          "f",
          "trigger_finite",
          "contains",
          "lemma_finite_set_induct_aux",
          "surj_on",
          "spec_fn"
        ]
      },
      "lemma_fold_insert": {
        "name": "lemma_fold_insert",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_fold_insert<A, B>(s: Set<A>, z: B, f: spec_fn(B, A) -> B, a: A)\n        requires\n            s.finite(),\n            !s.contains(a),\n            is_fun_commutative(f),\n        ensures\n            #[trigger] s.insert(a).fold(z, f) == f(s.fold(z, f), a),",
        "ensures": [
          "#[trigger] s.insert(a).fold(z, f) == f(s.fold(z, f), a)"
        ],
        "requires": [
          "s.finite()",
          "!s.contains(a)",
          "is_fun_commutative(f)"
        ],
        "body": "{\n        lemma_fold_graph_exists(z, f, s);\n        let (y, d): (B, nat) = choose|y, d| fold_graph(z, f, s, y, d);\n        lemma_fold_graph_insert_intro(z, f, s, s.fold(z, f), d, a);\n        lemma_fold_is_fold_graph(z, f, s.insert(a), f(s.fold(z, f), a), d + 1);\n    }",
        "doc_comment": null,
        "triggers": [
          "s.insert(a"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 604,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "finite",
          "fold",
          "insert",
          "trigger"
        ],
        "callees": [
          "f",
          "fold_graph",
          "fold",
          "insert",
          "lemma_fold_graph_exists",
          "lemma_fold_is_fold_graph",
          "lemma_fold_graph_insert_intro"
        ]
      },
      "lemma_fold_empty": {
        "name": "lemma_fold_empty",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_fold_empty<A, B>(z: B, f: spec_fn(B, A) -> B)\n        ensures\n            #[trigger] Set::empty().fold(z, f) == z,",
        "ensures": [
          "#[trigger] Set::empty().fold(z, f) == z"
        ],
        "requires": [],
        "body": "{\n        let (y, d): (B, nat) = choose|y, d| fold_graph(z, f, Set::empty(), y, d);\n        lemma_fold_graph_empty_intro(z, f);\n        lemma_fold_graph_empty_elim(z, f, y, d);\n    }",
        "doc_comment": null,
        "triggers": [
          "Set::empty("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 618,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "empty",
          "fold",
          "trigger"
        ],
        "callees": [
          "lemma_fold_graph_empty_elim",
          "fold_graph",
          "lemma_fold_graph_empty_intro",
          "empty"
        ]
      },
      "axiom_set_empty": {
        "name": "axiom_set_empty",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_empty<A>(a: A)\n    ensures\n        !(#[trigger] Set::empty().contains(a)),",
        "ensures": [
          "!(#[trigger] Set::empty().contains(a))"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The empty set contains no elements",
        "triggers": [
          "Set::empty("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 631,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "empty",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_new": {
        "name": "axiom_set_new",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_new<A>(f: spec_fn(A) -> bool, a: A)\n    ensures\n        #[trigger] Set::new(f).contains(a) == f(a),",
        "ensures": [
          "#[trigger] Set::new(f).contains(a) == f(a)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "A call to `Set::new` with the predicate `f` contains `a` if and only if `f(a)` is true.",
        "triggers": [
          "Set::new(f"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 637,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_insert_same": {
        "name": "axiom_set_insert_same",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_insert_same<A>(s: Set<A>, a: A)\n    ensures\n        #[trigger] s.insert(a).contains(a),",
        "ensures": [
          "#[trigger] s.insert(a).contains(a)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The result of inserting element `a` into set `s` must contains `a`.",
        "triggers": [
          "s.insert(a"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 644,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_insert_different": {
        "name": "axiom_set_insert_different",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_insert_different<A>(s: Set<A>, a1: A, a2: A)\n    requires\n        a1 != a2,\n    ensures\n        #[trigger] s.insert(a2).contains(a1) == s.contains(a1),",
        "ensures": [
          "#[trigger] s.insert(a2).contains(a1) == s.contains(a1)"
        ],
        "requires": [
          "a1 != a2"
        ],
        "body": "{\n}",
        "doc_comment": "If `a1` does not equal `a2`, then the result of inserting element `a2` into set `s`\nmust contain `a1` if and only if the set contained `a1` before the insertion of `a2`.",
        "triggers": [
          "s.insert(a2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 651,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "insert",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_remove_same": {
        "name": "axiom_set_remove_same",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_remove_same<A>(s: Set<A>, a: A)\n    ensures\n        !(#[trigger] s.remove(a).contains(a)),",
        "ensures": [
          "!(#[trigger] s.remove(a).contains(a))"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The result of removing element `a` from set `s` must not contain `a`.",
        "triggers": [
          "s.remove(a"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 661,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "remove",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_remove_insert": {
        "name": "axiom_set_remove_insert",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_remove_insert<A>(s: Set<A>, a: A)\n    requires\n        s.contains(a),\n    ensures\n        (#[trigger] s.remove(a)).insert(a) == s,",
        "ensures": [
          "(#[trigger] s.remove(a)).insert(a) == s"
        ],
        "requires": [
          "s.contains(a)"
        ],
        "body": "{\n    assert forall|aa| #![all_triggers] s.remove(a).insert(a).contains(aa) implies s.contains(\n        aa,\n    ) by {\n        if a == aa {\n        } else {\n            axiom_set_remove_different(s, aa, a);\n            axiom_set_insert_different(s.remove(a), aa, a);\n        }\n    };\n    assert forall|aa| #![all_triggers] s.contains(aa) implies s.remove(a).insert(a).contains(\n        aa,\n    ) by {\n        if a == aa {\n            axiom_set_insert_same(s.remove(a), a);\n        } else {\n            axiom_set_remove_different(s, aa, a);\n            axiom_set_insert_different(s.remove(a), aa, a);\n        }\n    };\n    axiom_set_ext_equal(s.remove(a).insert(a), s);\n}",
        "doc_comment": "Removing an element `a` from a set `s` and then inserting `a` back into the set`\nis equivalent to the original set `s`.",
        "triggers": [
          "s.remove(a"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 668,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "insert",
          "remove",
          "trigger"
        ],
        "callees": [
          "remove",
          "axiom_set_insert_same",
          "axiom_set_insert_different",
          "axiom_set_remove_different",
          "contains",
          "insert",
          "axiom_set_ext_equal"
        ]
      },
      "axiom_set_remove_different": {
        "name": "axiom_set_remove_different",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_remove_different<A>(s: Set<A>, a1: A, a2: A)\n    requires\n        a1 != a2,\n    ensures\n        #[trigger] s.remove(a2).contains(a1) == s.contains(a1),",
        "ensures": [
          "#[trigger] s.remove(a2).contains(a1) == s.contains(a1)"
        ],
        "requires": [
          "a1 != a2"
        ],
        "body": "{\n}",
        "doc_comment": "If `a1` does not equal `a2`, then the result of removing element `a2` from set `s`\nmust contain `a1` if and only if the set contained `a1` before the removal of `a2`.",
        "triggers": [
          "s.remove(a2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 698,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "remove",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_union": {
        "name": "axiom_set_union",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_union<A>(s1: Set<A>, s2: Set<A>, a: A)\n    ensures\n        #[trigger] s1.union(s2).contains(a) == (s1.contains(a) || s2.contains(a)),",
        "ensures": [
          "#[trigger] s1.union(s2).contains(a) == (s1.contains(a) || s2.contains(a))"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The union of sets `s1` and `s2` contains element `a` if and only if\n`s1` contains `a` and/or `s2` contains `a`.",
        "triggers": [
          "s1.union(s2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 708,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "trigger",
          "union"
        ],
        "callees": []
      },
      "axiom_set_intersect": {
        "name": "axiom_set_intersect",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_intersect<A>(s1: Set<A>, s2: Set<A>, a: A)\n    ensures\n        #[trigger] s1.intersect(s2).contains(a) == (s1.contains(a) && s2.contains(a)),",
        "ensures": [
          "#[trigger] s1.intersect(s2).contains(a) == (s1.contains(a) && s2.contains(a))"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The intersection of sets `s1` and `s2` contains element `a` if and only if\nboth `s1` and `s2` contain `a`.",
        "triggers": [
          "s1.intersect(s2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 716,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "intersect",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_difference": {
        "name": "axiom_set_difference",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_difference<A>(s1: Set<A>, s2: Set<A>, a: A)\n    ensures\n        #[trigger] s1.difference(s2).contains(a) == (s1.contains(a) && !s2.contains(a)),",
        "ensures": [
          "#[trigger] s1.difference(s2).contains(a) == (s1.contains(a) && !s2.contains(a))"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The set difference between `s1` and `s2` contains element `a` if and only if\n`s1` contains `a` and `s2` does not contain `a`.",
        "triggers": [
          "s1.difference(s2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 724,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "difference",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_complement": {
        "name": "axiom_set_complement",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_complement<A>(s: Set<A>, a: A)\n    ensures\n        #[trigger] s.complement().contains(a) == !s.contains(a),",
        "ensures": [
          "#[trigger] s.complement().contains(a) == !s.contains(a)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "The complement of set `s` contains element `a` if and only if `s` does not contain `a`.",
        "triggers": [
          "s.complement("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 732,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_ext_equal": {
        "name": "axiom_set_ext_equal",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_ext_equal<A>(s1: Set<A>, s2: Set<A>)\n    ensures\n        #[trigger] (s1 =~= s2) <==> (forall|a: A| s1.contains(a) == s2.contains(a)),",
        "ensures": [
          "#[trigger] (s1 =~= s2) <==> (forall|a: A| s1.contains(a) == s2.contains(a))"
        ],
        "requires": [],
        "body": "{\n    if s1 =~= s2 {\n        assert(forall|a: A| s1.contains(a) == s2.contains(a));\n    }\n    if forall|a: A| s1.contains(a) == s2.contains(a) {\n        if !(forall|a: A| #[trigger] (s1.set)(a) <==> (s2.set)(a)) {\n            assert(exists|a: A| #[trigger] (s1.set)(a) != (s2.set)(a));\n            let a = choose|a: A| #[trigger] (s1.set)(a) != (s2.set)(a);\n            assert(s1.contains(a));\n            assert(false);\n        }\n        assert(s1 =~= s2);\n    }\n}",
        "doc_comment": "Sets `s1` and `s2` are equal if and only if they contain all of the same elements.",
        "triggers": [
          "(s1 =~= s2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 739,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "forall",
          "trigger"
        ],
        "callees": [
          "contains"
        ]
      },
      "axiom_set_ext_equal_deep": {
        "name": "axiom_set_ext_equal_deep",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_ext_equal_deep<A>(s1: Set<A>, s2: Set<A>)\n    ensures\n        #[trigger] (s1 =~~= s2) <==> s1 =~= s2,",
        "ensures": [
          "#[trigger] (s1 =~~= s2) <==> s1 =~= s2"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [
          "(s1 =~~= s2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 758,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "trigger"
        ],
        "callees": []
      },
      "axiom_mk_map_domain": {
        "name": "axiom_mk_map_domain",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_mk_map_domain<K, V>(s: Set<K>, f: spec_fn(K) -> V)\n    ensures\n        #[trigger] s.mk_map(f).dom() == s,",
        "ensures": [
          "#[trigger] s.mk_map(f).dom() == s",
          "#[trigger] s.mk_map(f)[key] == f(key)",
          "#[trigger] Set::<A>::empty().finite()"
        ],
        "requires": [
          "s.contains(key)"
        ],
        "body": "{\n    let f = |a: A| 0;\n    let ub = 0;\n    let _ = trigger_finite(f, ub);\n}",
        "doc_comment": null,
        "triggers": [
          "s.mk_map(f",
          "s.mk_map(f",
          "Set::<A>::empty("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 764,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "empty",
          "finite",
          "trigger"
        ],
        "callees": [
          "trigger_finite"
        ]
      },
      "axiom_mk_map_index": {
        "name": "axiom_mk_map_index",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_mk_map_index<K, V>(s: Set<K>, f: spec_fn(K) -> V, key: K)\n    requires\n        s.contains(key),\n    ensures\n        #[trigger] s.mk_map(f)[key] == f(key),",
        "ensures": [
          "#[trigger] s.mk_map(f)[key] == f(key)",
          "#[trigger] Set::<A>::empty().finite()"
        ],
        "requires": [
          "s.contains(key)"
        ],
        "body": "{\n    let f = |a: A| 0;\n    let ub = 0;\n    let _ = trigger_finite(f, ub);\n}",
        "doc_comment": null,
        "triggers": [
          "s.mk_map(f",
          "Set::<A>::empty("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 769,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "empty",
          "finite",
          "trigger"
        ],
        "callees": [
          "trigger_finite"
        ]
      },
      "axiom_set_empty_finite": {
        "name": "axiom_set_empty_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_empty_finite<A>()\n    ensures\n        #[trigger] Set::<A>::empty().finite(),",
        "ensures": [
          "#[trigger] Set::<A>::empty().finite()"
        ],
        "requires": [],
        "body": "{\n    let f = |a: A| 0;\n    let ub = 0;\n    let _ = trigger_finite(f, ub);\n}",
        "doc_comment": "The empty set is finite.",
        "triggers": [
          "Set::<A>::empty("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 778,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "empty",
          "finite",
          "trigger"
        ],
        "callees": [
          "trigger_finite"
        ]
      },
      "axiom_set_insert_finite": {
        "name": "axiom_set_insert_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_insert_finite<A>(s: Set<A>, a: A)\n    requires\n        s.finite(),\n    ensures\n        #[trigger] s.insert(a).finite(),",
        "ensures": [
          "#[trigger] s.insert(a).finite()"
        ],
        "requires": [
          "s.finite()"
        ],
        "body": "{\n    let (f, ub) = choose|f: spec_fn(A) -> nat, ub: nat| #[trigger]\n        trigger_finite(f, ub) && surj_on(f, s) && (forall|a| s.contains(a) ==> f(a) < ub);\n    let f2 = |a2: A|\n        if a2 == a {\n            ub\n        } else {\n            f(a2)\n        };\n    let ub2 = ub + 1;\n    let _ = trigger_finite(f2, ub2);\n    assert forall|a1, a2|\n        #![all_triggers]\n        s.insert(a).contains(a1) && s.insert(a).contains(a2) && a1 != a2 implies f2(a1) != f2(\n        a2,\n    ) by {\n        if a != a1 {\n            assert(s.contains(a1));\n        }\n        if a != a2 {\n            assert(s.contains(a2));\n        }\n    };\n    assert forall|a2| s.insert(a).contains(a2) implies #[trigger] f2(a2) < ub2 by {\n        if a == a2 {\n        } else {\n            assert(s.contains(a2));\n        }\n    };\n}",
        "doc_comment": "The result of inserting an element `a` into a finite set `s` is also finite.",
        "triggers": [
          "s.insert(a"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 787,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "finite",
          "insert",
          "trigger"
        ],
        "callees": [
          "f",
          "trigger_finite",
          "contains",
          "f2",
          "insert",
          "surj_on",
          "spec_fn"
        ]
      },
      "axiom_set_remove_finite": {
        "name": "axiom_set_remove_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_remove_finite<A>(s: Set<A>, a: A)\n    requires\n        s.finite(),\n    ensures\n        #[trigger] s.remove(a).finite(),",
        "ensures": [
          "#[trigger] s.remove(a).finite()"
        ],
        "requires": [
          "s.finite()"
        ],
        "body": "{\n    let (f, ub) = choose|f: spec_fn(A) -> nat, ub: nat| #[trigger]\n        trigger_finite(f, ub) && surj_on(f, s) && (forall|a| s.contains(a) ==> f(a) < ub);\n    assert forall|a1, a2|\n        #![all_triggers]\n        s.remove(a).contains(a1) && s.remove(a).contains(a2) && a1 != a2 implies f(a1) != f(a2) by {\n        if a != a1 {\n            assert(s.contains(a1));\n        }\n        if a != a2 {\n            assert(s.contains(a2));\n        }\n    };\n    assert(surj_on(f, s.remove(a)));\n    assert forall|a2| s.remove(a).contains(a2) implies #[trigger] f(a2) < ub by {\n        if a == a2 {\n        } else {\n            assert(s.contains(a2));\n        }\n    };\n}",
        "doc_comment": "The result of removing an element `a` from a finite set `s` is also finite.",
        "triggers": [
          "s.remove(a"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 824,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "finite",
          "remove",
          "trigger"
        ],
        "callees": [
          "f",
          "trigger_finite",
          "remove",
          "contains",
          "surj_on",
          "spec_fn"
        ]
      },
      "axiom_set_union_finite": {
        "name": "axiom_set_union_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_union_finite<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n        s2.finite(),\n    ensures\n        #[trigger] s1.union(s2).finite(),",
        "ensures": [
          "#[trigger] s1.union(s2).finite()"
        ],
        "requires": [
          "s1.finite()",
          "s2.finite()"
        ],
        "body": "{\n    let (f1, ub1) = choose|f: spec_fn(A) -> nat, ub: nat| #[trigger]\n        trigger_finite(f, ub) && surj_on(f, s1) && (forall|a| s1.contains(a) ==> f(a) < ub);\n    let (f2, ub2) = choose|f: spec_fn(A) -> nat, ub: nat| #[trigger]\n        trigger_finite(f, ub) && surj_on(f, s2) && (forall|a| s2.contains(a) ==> f(a) < ub);\n    let f3 = |a|\n        if s1.contains(a) {\n            f1(a)\n        } else {\n            ub1 + f2(a)\n        };\n    let ub3 = ub1 + ub2;\n    assert(trigger_finite(f3, ub3));\n    assert(forall|a|\n        #![all_triggers]\n        s1.union(s2).contains(a) ==> s1.contains(a) || s2.contains(a));\n}",
        "doc_comment": "The union of two finite sets is finite.",
        "triggers": [
          "s1.union(s2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 852,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "finite",
          "trigger",
          "union"
        ],
        "callees": [
          "f",
          "trigger_finite",
          "contains",
          "union",
          "f2",
          "f1",
          "surj_on",
          "spec_fn"
        ]
      },
      "axiom_set_intersect_finite": {
        "name": "axiom_set_intersect_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_intersect_finite<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite() || s2.finite(),\n    ensures\n        #[trigger] s1.intersect(s2).finite(),",
        "ensures": [
          "#[trigger] s1.intersect(s2).finite()"
        ],
        "requires": [
          "s1.finite() || s2.finite()"
        ],
        "body": "{\n    assert(forall|a|\n        #![all_triggers]\n        s1.intersect(s2).contains(a) ==> s1.contains(a) && s2.contains(a));\n}",
        "doc_comment": "The intersection of two finite sets is finite.",
        "triggers": [
          "s1.intersect(s2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 877,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "finite",
          "intersect",
          "trigger"
        ],
        "callees": [
          "intersect",
          "contains"
        ]
      },
      "axiom_set_difference_finite": {
        "name": "axiom_set_difference_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_difference_finite<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        #[trigger] s1.difference(s2).finite(),",
        "ensures": [
          "#[trigger] s1.difference(s2).finite()"
        ],
        "requires": [
          "s1.finite()"
        ],
        "body": "{\n    assert(forall|a|\n        #![all_triggers]\n        s1.difference(s2).contains(a) ==> s1.contains(a) && !s2.contains(a));\n}",
        "doc_comment": "The set difference between two finite sets is finite.",
        "triggers": [
          "s1.difference(s2"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 889,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "difference",
          "finite",
          "trigger"
        ],
        "callees": [
          "difference",
          "contains"
        ]
      },
      "axiom_set_choose_infinite": {
        "name": "axiom_set_choose_infinite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_choose_infinite<A>(s: Set<A>)\n    requires\n        !s.finite(),\n    ensures\n        #[trigger] s.contains(s.choose()),",
        "ensures": [
          "#[trigger] s.contains(s.choose())"
        ],
        "requires": [
          "!s.finite()"
        ],
        "body": "{\n    let f = |a: A| 0;\n    let ub = 0;\n    let _ = trigger_finite(f, ub);\n}",
        "doc_comment": "An infinite set `s` contains the element `s.choose()`.",
        "triggers": [
          "s.contains(s.choose("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 901,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "finite",
          "trigger"
        ],
        "callees": [
          "trigger_finite"
        ]
      },
      "axiom_set_empty_len": {
        "name": "axiom_set_empty_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_empty_len<A>()\n    ensures\n        #[trigger] Set::<A>::empty().len() == 0,",
        "ensures": [
          "#[trigger] Set::<A>::empty().len() == 0"
        ],
        "requires": [],
        "body": "{\n    fold::lemma_fold_empty(0, |b: nat, a: A| b + 1);\n}",
        "doc_comment": "The empty set has length 0.",
        "triggers": [
          "Set::<A>::empty("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 917,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "empty",
          "len",
          "trigger"
        ],
        "callees": [
          "lemma_fold_empty"
        ]
      },
      "axiom_set_insert_len": {
        "name": "axiom_set_insert_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_insert_len<A>(s: Set<A>, a: A)\n    requires\n        s.finite(),\n    ensures\n        #[trigger] s.insert(a).len() == s.len() + (if s.contains(a)",
        "ensures": [
          "#[trigger] s.insert(a).len() == s.len() + (if s.contains(a)"
        ],
        "requires": [
          "s.finite()"
        ],
        "body": "{\n            0int\n        }",
        "doc_comment": "The result of inserting an element `a` into a finite set `s` has length\n`s.len() + 1` if `a` is not already in `s` and length `s.len()` otherwise.",
        "triggers": [
          "s.insert(a"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 924,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "finite",
          "insert",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_remove_len": {
        "name": "axiom_set_remove_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_remove_len<A>(s: Set<A>, a: A)\n    requires\n        s.finite(),\n    ensures\n        s.len() == #[trigger] s.remove(a).len() + (if s.contains(a)",
        "ensures": [
          "s.len() == #[trigger] s.remove(a).len() + (if s.contains(a)"
        ],
        "requires": [
          "s.finite()"
        ],
        "body": "{\n            1int\n        }",
        "doc_comment": "The result of removing an element `a` from a finite set `s` has length\n`s.len() - 1` if `a` is in `s` and length `s.len()` otherwise.",
        "triggers": [
          "s.remove(a"
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 943,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "finite",
          "len",
          "remove",
          "trigger"
        ],
        "callees": []
      },
      "axiom_set_contains_len": {
        "name": "axiom_set_contains_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_contains_len<A>(s: Set<A>, a: A)\n    requires\n        s.finite(),\n        #[trigger] s.contains(a),\n    ensures\n        #[trigger] s.len() != 0,",
        "ensures": [
          "#[trigger] s.len() != 0"
        ],
        "requires": [
          "s.finite()",
          "#[trigger] s.contains(a)"
        ],
        "body": "{\n    let a = s.choose();\n    assert(s.remove(a).insert(a) =~= s);\n    axiom_set_remove_finite(s, a);\n    axiom_set_insert_finite(s.remove(a), a);\n    axiom_set_insert_len(s.remove(a), a);\n}",
        "doc_comment": "If a finite set `s` contains any element, it has length greater than 0.",
        "triggers": [
          "s.len("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 964,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "finite",
          "len",
          "trigger"
        ],
        "callees": [
          "remove",
          "axiom_set_insert_finite",
          "axiom_set_remove_finite",
          "axiom_set_insert_len",
          "insert"
        ]
      },
      "axiom_set_choose_len": {
        "name": "axiom_set_choose_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_choose_len<A>(s: Set<A>)\n    requires\n        s.finite(),\n        #[trigger] s.len() != 0,\n    ensures\n        #[trigger] s.contains(s.choose()),",
        "ensures": [
          "#[trigger] s.contains(s.choose())"
        ],
        "requires": [
          "s.finite()",
          "#[trigger] s.len() != 0"
        ],
        "body": "{\n    // Separate statements to work around https://github.com/verus-lang/verusfmt/issues/86\n    broadcast use axiom_set_contains_len;\n    broadcast use axiom_set_empty_len;\n    broadcast use axiom_set_ext_equal;\n    broadcast use axiom_set_insert_finite;\n\n    let pred = |s: Set<A>| s.finite() ==> s.len() == 0 <==> s =~= Set::empty();\n    fold::lemma_finite_set_induct(s, pred);\n}",
        "doc_comment": "A finite set `s` contains the element `s.choose()` if it has length greater than 0.",
        "triggers": [
          "s.contains(s.choose("
        ],
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 979,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "contains",
          "finite",
          "len",
          "trigger"
        ],
        "callees": [
          "len",
          "lemma_finite_set_induct",
          "finite",
          "empty"
        ]
      },
      "find_unique_minimal": {
        "name": "find_unique_minimal",
        "type": "closed_spec",
        "signature": "pub closed spec fn find_unique_minimal(self, r: spec_fn(A, A) -> bool) -> A\n        recommends\n            total_ordering(r),\n            self.len() > 0,\n            self.finite(),\n        decreases self.len(),\n        when self.finite()",
        "ensures": [],
        "requires": [],
        "body": "{\n        proof {\n            broadcast use group_set_properties;\n\n        }\n        if self.len() <= 1 {\n            self.choose()\n        } else {\n            let x = choose|x: A| self.contains(x);\n            let min = self.remove(x).find_unique_minimal(r);\n            if r(min, x) {\n                min\n            } else {\n                x\n            }\n        }\n    }",
        "doc_comment": "Any totally-ordered set contains a unique minimal (equivalently, least) element.\nReturns an arbitrary value if r is not a total ordering",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 57,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "finite",
          "len"
        ],
        "callees": [
          "remove",
          "find_unique_minimal",
          "contains",
          "len",
          "r"
        ]
      },
      "find_unique_minimal_ensures": {
        "name": "find_unique_minimal_ensures",
        "type": "proof",
        "signature": "pub proof fn find_unique_minimal_ensures(self, r: spec_fn(A, A) -> bool)\n        requires\n            self.finite(),\n            self.len() > 0,\n            total_ordering(r),\n        ensures\n            is_minimal(r, self.find_unique_minimal(r), self) && (forall|min: A|\n                is_minimal(r, min, self) ==> self.find_unique_minimal(r) == min),\n        decreases self.len(),",
        "ensures": [
          "is_minimal(r, self.find_unique_minimal(r), self) && (forall|min: A|\n                is_minimal(r, min, self) ==> self.find_unique_minimal(r) == min)"
        ],
        "requires": [
          "self.finite()",
          "self.len() > 0",
          "total_ordering(r)"
        ],
        "body": null,
        "doc_comment": "Proof of correctness and expected behavior for `Set::find_unique_minimal`.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 84,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "finite",
          "forall",
          "len"
        ],
        "callees": []
      },
      "find_unique_maximal": {
        "name": "find_unique_maximal",
        "type": "closed_spec",
        "signature": "pub closed spec fn find_unique_maximal(self, r: spec_fn(A, A) -> bool) -> A\n        recommends\n            total_ordering(r),\n            self.len() > 0,\n        decreases self.len(),\n        when self.finite()",
        "ensures": [],
        "requires": [],
        "body": "{\n        proof {\n            broadcast use group_set_properties;\n\n        }\n        if self.len() <= 1 {\n            self.choose()\n        } else {\n            let x = choose|x: A| self.contains(x);\n            let max = self.remove(x).find_unique_maximal(r);\n            if r(x, max) {\n                max\n            } else {\n                x\n            }\n        }\n    }",
        "doc_comment": "Any totally-ordered set contains a unique maximal (equivalently, greatest) element.\nReturns an arbitrary value if r is not a total ordering",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 139,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "finite",
          "len"
        ],
        "callees": [
          "find_unique_maximal",
          "remove",
          "contains",
          "r",
          "len"
        ]
      },
      "find_unique_maximal_ensures": {
        "name": "find_unique_maximal_ensures",
        "type": "proof",
        "signature": "pub proof fn find_unique_maximal_ensures(self, r: spec_fn(A, A) -> bool)\n        requires\n            self.finite(),\n            self.len() > 0,\n            total_ordering(r),\n        ensures\n            is_maximal(r, self.find_unique_maximal(r), self) && (forall|max: A|\n                is_maximal(r, max, self) ==> self.find_unique_maximal(r) == max),\n        decreases self.len(),",
        "ensures": [
          "is_maximal(r, self.find_unique_maximal(r), self) && (forall|max: A|\n                is_maximal(r, max, self) ==> self.find_unique_maximal(r) == max)"
        ],
        "requires": [
          "self.finite()",
          "self.len() > 0",
          "total_ordering(r)"
        ],
        "body": null,
        "doc_comment": "Proof of correctness and expected behavior for `Set::find_unique_maximal`.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 165,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "finite",
          "forall",
          "len"
        ],
        "callees": []
      },
      "lemma_len0_is_empty": {
        "name": "lemma_len0_is_empty",
        "type": "proof",
        "signature": "pub proof fn lemma_len0_is_empty(self)\n        requires\n            self.finite(),\n            self.len() == 0,\n        ensures\n            self == Set::<A>::empty(),",
        "ensures": [
          "self == Set::<A>::empty()"
        ],
        "requires": [
          "self.finite()",
          "self.len() == 0"
        ],
        "body": "{\n        if exists|a: A| self.contains(a) {\n            // derive contradiction:\n            assert(self.remove(self.choose()).len() + 1 == 0);\n        }\n        assert(self =~= Set::empty());\n    }",
        "doc_comment": "A finite set with length 0 is equivalent to the empty set.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 241,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "empty",
          "finite",
          "len"
        ],
        "callees": [
          "len",
          "empty",
          "remove",
          "contains"
        ]
      },
      "vstd::set_lib::lemma_singleton_size": {
        "name": "vstd::set_lib::lemma_singleton_size",
        "type": "proof",
        "signature": "pub proof fn lemma_singleton_size(self)\n        requires\n            self.is_singleton(),\n        ensures\n            self.len() == 1,",
        "ensures": [
          "self.len() == 1"
        ],
        "requires": [
          "self.is_singleton()"
        ],
        "body": "{\n        broadcast use group_set_properties;\n\n        assert(self.remove(self.choose()) =~= Set::empty());\n    }",
        "doc_comment": "A singleton set has length 1.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 256,
        "module": "vstd::set_lib",
        "keywords": [
          "len"
        ],
        "callees": [
          "remove",
          "empty"
        ]
      },
      "vstd::set_lib::lemma_is_singleton": {
        "name": "vstd::set_lib::lemma_is_singleton",
        "type": "proof",
        "signature": "pub proof fn lemma_is_singleton(s: Set<A>)\n        requires\n            s.finite(),\n        ensures\n            s.is_singleton() == (s.len() == 1),",
        "ensures": [
          "s.is_singleton() == (s.len() == 1)"
        ],
        "requires": [
          "s.finite()"
        ],
        "body": "{\n        if s.is_singleton() {\n            s.lemma_singleton_size();\n        }\n        if s.len() == 1 {\n            assert forall|x: A, y: A| s.contains(x) && s.contains(y) implies x == y by {\n                let x = choose|x: A| s.contains(x);\n                broadcast use group_set_properties;\n\n                assert(s.remove(x).len() == 0);\n                assert(s.insert(x) =~= s);\n            }\n        }\n    }",
        "doc_comment": "A set has exactly one element, if and only if, it has at least one element and any two elements are equal.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 268,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "finite",
          "len"
        ],
        "callees": [
          "remove",
          "contains",
          "lemma_singleton_size",
          "len",
          "insert",
          "is_singleton"
        ]
      },
      "lemma_len_filter": {
        "name": "lemma_len_filter",
        "type": "proof",
        "signature": "pub proof fn lemma_len_filter(self, f: spec_fn(A) -> bool)\n        requires\n            self.finite(),\n        ensures\n            self.filter(f).finite(),\n            self.filter(f).len() <= self.len(),\n        decreases self.len(),",
        "ensures": [
          "self.filter(f).finite()",
          "self.filter(f).len() <= self.len()"
        ],
        "requires": [
          "self.finite()"
        ],
        "body": "{\n        lemma_len_intersect::<A>(self, Set::new(f));\n    }",
        "doc_comment": "The result of filtering a finite set is finite and has size less than or equal to the original set.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 289,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "filter",
          "finite",
          "len"
        ],
        "callees": [
          "new"
        ]
      },
      "lemma_greatest_implies_maximal": {
        "name": "lemma_greatest_implies_maximal",
        "type": "proof",
        "signature": "pub proof fn lemma_greatest_implies_maximal(self, r: spec_fn(A, A) -> bool, max: A)\n        requires\n            pre_ordering(r),\n        ensures\n            is_greatest(r, max, self) ==> is_maximal(r, max, self),",
        "ensures": [
          "is_greatest(r, max, self) ==> is_maximal(r, max, self)"
        ],
        "requires": [
          "pre_ordering(r)"
        ],
        "body": "{\n    }",
        "doc_comment": "In a pre-ordered set, a greatest element is necessarily maximal.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 301,
        "module": "vstd::set_lib",
        "keywords": [],
        "callees": []
      },
      "lemma_least_implies_minimal": {
        "name": "lemma_least_implies_minimal",
        "type": "proof",
        "signature": "pub proof fn lemma_least_implies_minimal(self, r: spec_fn(A, A) -> bool, min: A)\n        requires\n            pre_ordering(r),\n        ensures\n            is_least(r, min, self) ==> is_minimal(r, min, self),",
        "ensures": [
          "is_least(r, min, self) ==> is_minimal(r, min, self)"
        ],
        "requires": [
          "pre_ordering(r)"
        ],
        "body": "{\n    }",
        "doc_comment": "In a pre-ordered set, a least element is necessarily minimal.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 310,
        "module": "vstd::set_lib",
        "keywords": [],
        "callees": []
      },
      "lemma_maximal_equivalent_greatest": {
        "name": "lemma_maximal_equivalent_greatest",
        "type": "proof",
        "signature": "pub proof fn lemma_maximal_equivalent_greatest(self, r: spec_fn(A, A) -> bool, max: A)\n        requires\n            total_ordering(r),\n        ensures\n            is_greatest(r, max, self) <==> is_maximal(r, max, self),",
        "ensures": [
          "is_greatest(r, max, self) <==> is_maximal(r, max, self)"
        ],
        "requires": [
          "total_ordering(r)"
        ],
        "body": "{\n        assert(is_maximal(r, max, self) ==> forall|x: A|\n            !self.contains(x) || !r(max, x) || r(x, max));\n    }",
        "doc_comment": "In a totally-ordered set, an element is maximal if and only if it is a greatest element.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 319,
        "module": "vstd::set_lib",
        "keywords": [],
        "callees": [
          "is_maximal",
          "contains",
          "r"
        ]
      },
      "lemma_minimal_equivalent_least": {
        "name": "lemma_minimal_equivalent_least",
        "type": "proof",
        "signature": "pub proof fn lemma_minimal_equivalent_least(self, r: spec_fn(A, A) -> bool, min: A)\n        requires\n            total_ordering(r),\n        ensures\n            is_least(r, min, self) <==> is_minimal(r, min, self),",
        "ensures": [
          "is_least(r, min, self) <==> is_minimal(r, min, self)"
        ],
        "requires": [
          "total_ordering(r)"
        ],
        "body": "{\n        assert(is_minimal(r, min, self) ==> forall|x: A|\n            !self.contains(x) || !r(x, min) || r(min, x));\n    }",
        "doc_comment": "In a totally-ordered set, an element is maximal if and only if it is a greatest element.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 330,
        "module": "vstd::set_lib",
        "keywords": [],
        "callees": [
          "is_minimal",
          "contains",
          "r"
        ]
      },
      "lemma_least_is_unique": {
        "name": "lemma_least_is_unique",
        "type": "proof",
        "signature": "pub proof fn lemma_least_is_unique(self, r: spec_fn(A, A) -> bool)\n        requires\n            partial_ordering(r),\n        ensures\n            forall|min: A, min_prime: A|\n                is_least(r, min, self) && is_least(r, min_prime, self) ==> min == min_prime,",
        "ensures": [
          "forall|min: A, min_prime: A|\n                is_least(r, min, self) && is_least(r, min_prime, self) ==> min == min_prime"
        ],
        "requires": [
          "partial_ordering(r)"
        ],
        "body": "{\n        assert forall|min: A, min_prime: A|\n            is_least(r, min, self) && is_least(r, min_prime, self) implies min == min_prime by {\n            assert(r(min, min_prime));\n            assert(r(min_prime, min));\n        }\n    }",
        "doc_comment": "In a partially-ordered set, there exists at most one least element.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 341,
        "module": "vstd::set_lib",
        "keywords": [
          "forall"
        ],
        "callees": [
          "is_least",
          "r"
        ]
      },
      "lemma_greatest_is_unique": {
        "name": "lemma_greatest_is_unique",
        "type": "proof",
        "signature": "pub proof fn lemma_greatest_is_unique(self, r: spec_fn(A, A) -> bool)\n        requires\n            partial_ordering(r),\n        ensures\n            forall|max: A, max_prime: A|\n                is_greatest(r, max, self) && is_greatest(r, max_prime, self) ==> max == max_prime,",
        "ensures": [
          "forall|max: A, max_prime: A|\n                is_greatest(r, max, self) && is_greatest(r, max_prime, self) ==> max == max_prime"
        ],
        "requires": [
          "partial_ordering(r)"
        ],
        "body": "{\n        assert forall|max: A, max_prime: A|\n            is_greatest(r, max, self) && is_greatest(r, max_prime, self) implies max\n            == max_prime by {\n            assert(r(max_prime, max));\n            assert(r(max, max_prime));\n        }\n    }",
        "doc_comment": "In a partially-ordered set, there exists at most one greatest element.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 356,
        "module": "vstd::set_lib",
        "keywords": [
          "forall"
        ],
        "callees": [
          "is_greatest",
          "r"
        ]
      },
      "lemma_minimal_is_unique": {
        "name": "lemma_minimal_is_unique",
        "type": "proof",
        "signature": "pub proof fn lemma_minimal_is_unique(self, r: spec_fn(A, A) -> bool)\n        requires\n            total_ordering(r),\n        ensures\n            forall|min: A, min_prime: A|\n                is_minimal(r, min, self) && is_minimal(r, min_prime, self) ==> min == min_prime,",
        "ensures": [
          "forall|min: A, min_prime: A|\n                is_minimal(r, min, self) && is_minimal(r, min_prime, self) ==> min == min_prime"
        ],
        "requires": [
          "total_ordering(r)"
        ],
        "body": "{\n        assert forall|min: A, min_prime: A|\n            is_minimal(r, min, self) && is_minimal(r, min_prime, self) implies min == min_prime by {\n            self.lemma_minimal_equivalent_least(r, min);\n            self.lemma_minimal_equivalent_least(r, min_prime);\n            self.lemma_least_is_unique(r);\n        }\n    }",
        "doc_comment": "In a totally-ordered set, there exists at most one minimal element.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 372,
        "module": "vstd::set_lib",
        "keywords": [
          "forall"
        ],
        "callees": [
          "lemma_least_is_unique",
          "is_minimal",
          "lemma_minimal_equivalent_least"
        ]
      },
      "lemma_maximal_is_unique": {
        "name": "lemma_maximal_is_unique",
        "type": "proof",
        "signature": "pub proof fn lemma_maximal_is_unique(self, r: spec_fn(A, A) -> bool)\n        requires\n            self.finite(),\n            total_ordering(r),\n        ensures\n            forall|max: A, max_prime: A|\n                is_maximal(r, max, self) && is_maximal(r, max_prime, self) ==> max == max_prime,",
        "ensures": [
          "forall|max: A, max_prime: A|\n                is_maximal(r, max, self) && is_maximal(r, max_prime, self) ==> max == max_prime"
        ],
        "requires": [
          "self.finite()",
          "total_ordering(r)"
        ],
        "body": "{\n        assert forall|max: A, max_prime: A|\n            is_maximal(r, max, self) && is_maximal(r, max_prime, self) implies max == max_prime by {\n            self.lemma_maximal_equivalent_greatest(r, max);\n            self.lemma_maximal_equivalent_greatest(r, max_prime);\n            self.lemma_greatest_is_unique(r);\n        }\n    }",
        "doc_comment": "In a totally-ordered set, there exists at most one maximal element.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 388,
        "module": "vstd::set_lib",
        "keywords": [
          "finite",
          "forall"
        ],
        "callees": [
          "lemma_greatest_is_unique",
          "lemma_maximal_equivalent_greatest",
          "is_maximal"
        ]
      },
      "lemma_set_insert_diff_decreases": {
        "name": "lemma_set_insert_diff_decreases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_insert_diff_decreases(self, s: Set<A>, elt: A)\n        requires\n            self.contains(elt),\n            !s.contains(elt),\n            self.finite(),\n        ensures\n            #[trigger] self.difference(s.insert(elt)).len() < self.difference(s).len(),",
        "ensures": [
          "#[trigger] self.difference(s.insert(elt)).len() < self.difference(s).len()"
        ],
        "requires": [
          "self.contains(elt)",
          "!s.contains(elt)",
          "self.finite()"
        ],
        "body": "{\n        self.difference(s.insert(elt)).lemma_subset_not_in_lt(self.difference(s), elt);\n    }",
        "doc_comment": "Set difference with an additional element inserted decreases the size of\nthe result. This can be useful for proving termination when traversing\na set while tracking the elements that have already been handled.",
        "triggers": [
          "self.difference(s.insert(elt"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 405,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "contains",
          "decreases",
          "difference",
          "finite",
          "insert",
          "len",
          "trigger"
        ],
        "callees": [
          "insert",
          "difference",
          "lemma_subset_not_in_lt"
        ]
      },
      "lemma_subset_not_in_lt": {
        "name": "lemma_subset_not_in_lt",
        "type": "proof",
        "signature": "pub proof fn lemma_subset_not_in_lt(self: Set<A>, s2: Set<A>, elt: A)\n        requires\n            self.subset_of(s2),\n            s2.finite(),\n            !self.contains(elt),\n            s2.contains(elt),\n        ensures\n            self.len() < s2.len(),",
        "ensures": [
          "self.len() < s2.len()"
        ],
        "requires": [
          "self.subset_of(s2)",
          "s2.finite()",
          "!self.contains(elt)",
          "s2.contains(elt)"
        ],
        "body": "{\n        let s2_no_elt = s2.remove(elt);\n        assert(self.len() <= s2_no_elt.len()) by {\n            lemma_len_subset(self, s2_no_elt);\n        }\n    }",
        "doc_comment": "If there is an element not present in a subset, its length is stricly smaller.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 419,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "contains",
          "finite",
          "len"
        ],
        "callees": [
          "len",
          "lemma_len_subset",
          "remove"
        ]
      },
      "lemma_set_map_insert_commute": {
        "name": "lemma_set_map_insert_commute",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_map_insert_commute<B>(self, elt: A, f: spec_fn(A) -> B)\n        ensures\n            #[trigger] self.insert(elt).map(f) =~= self.map(f).insert(f(elt)),",
        "ensures": [
          "#[trigger] self.insert(elt).map(f) =~= self.map(f).insert(f(elt))"
        ],
        "requires": [],
        "body": "{\n        assert forall|x: B| self.map(f).insert(f(elt)).contains(x) implies self.insert(elt).map(\n            f,\n        ).contains(x) by {\n            if x == f(elt) {\n                assert(self.insert(elt).contains(elt));\n            } else {\n                let y = choose|y: A| self.contains(y) && f(y) == x;\n                assert(self.insert(elt).contains(y));\n            }\n        }\n    }",
        "doc_comment": "Inserting an element and mapping a function over a set commute",
        "triggers": [
          "self.insert(elt"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 435,
        "module": "vstd::set_lib",
        "keywords": [
          "insert",
          "map",
          "trigger"
        ],
        "callees": [
          "f",
          "insert",
          "contains",
          "map"
        ]
      },
      "lemma_map_union_commute": {
        "name": "lemma_map_union_commute",
        "type": "proof",
        "signature": "pub proof fn lemma_map_union_commute<B>(self, t: Set<A>, f: spec_fn(A) -> B)\n        ensures\n            (self.union(t)).map(f) =~= self.map(f).union(t.map(f)),",
        "ensures": [
          "(self.union(t)).map(f) =~= self.map(f).union(t.map(f))"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_set_axioms;\n\n        let lhs = self.union(t).map(f);\n        let rhs = self.map(f).union(t.map(f));\n\n        assert forall|elem: B| rhs.contains(elem) implies lhs.contains(elem) by {\n            if self.map(f).contains(elem) {\n                let preimage = choose|preimage: A| self.contains(preimage) && f(preimage) == elem;\n                assert(self.union(t).contains(preimage));\n            } else {\n                assert(t.map(f).contains(elem));\n                let preimage = choose|preimage: A| t.contains(preimage) && f(preimage) == elem;\n                assert(self.union(t).contains(preimage));\n            }\n        }\n    }",
        "doc_comment": "`map` and `union` commute",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 452,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "map",
          "union"
        ],
        "callees": [
          "map",
          "f",
          "contains",
          "union"
        ]
      },
      "lemma_any_map_preserved_pred": {
        "name": "lemma_any_map_preserved_pred",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_any_map_preserved_pred<B>(\n        self,\n        p: spec_fn(A) -> bool,\n        q: spec_fn(B) -> bool,\n        f: spec_fn(A) -> B,\n    )\n        requires\n            #[trigger] self.any(p),\n            forall|x: A| #[trigger] p(x) ==> q(f(x)),\n        ensures\n            #[trigger] self.map(f).any(q),",
        "ensures": [
          "#[trigger] self.map(f).any(q)"
        ],
        "requires": [
          "#[trigger] self.any(p)",
          "forall|x: A| #[trigger] p(x) ==> q(f(x))"
        ],
        "body": "{\n        let x = choose|x: A| self.contains(x) && p(x);\n        assert(self.map(f).contains(f(x)));\n    }",
        "doc_comment": "`any` is preserved between predicates `p` and `q` if `p` implies `q`.",
        "triggers": [
          "self.map(f"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 484,
        "module": "vstd::set_lib",
        "keywords": [
          "forall",
          "map",
          "trigger"
        ],
        "callees": [
          "f",
          "p",
          "contains",
          "map"
        ]
      },
      "lemma_filter_map_insert": {
        "name": "lemma_filter_map_insert",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_filter_map_insert<B>(\n        s: Set<A>,\n        f: spec_fn(A) -> Option<B>,\n        elem: A,\n    )\n        ensures\n            #[trigger] s.insert(elem).filter_map(f) == (match f(elem)",
        "ensures": [
          "#[trigger] s.insert(elem).filter_map(f) == (match f(elem)"
        ],
        "requires": [],
        "body": "{\n                Some(res) => s.filter_map(f).insert(res),\n                None => s.filter_map(f),\n            }",
        "doc_comment": "Inserting commutes with `filter_map`",
        "triggers": [
          "s.insert(elem"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 512,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "insert",
          "trigger"
        ],
        "callees": [
          "filter_map",
          "insert",
          "ome"
        ]
      },
      "lemma_filter_map_union": {
        "name": "lemma_filter_map_union",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_filter_map_union<B>(self, f: spec_fn(A) -> Option<B>, t: Set<A>)\n        ensures\n            #[trigger] self.union(t).filter_map(f) == self.filter_map(f).union(t.filter_map(f)),",
        "ensures": [
          "#[trigger] self.union(t).filter_map(f) == self.filter_map(f).union(t.filter_map(f))"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_set_axioms;\n\n        let lhs = self.union(t).filter_map(f);\n        let rhs = self.filter_map(f).union(t.filter_map(f));\n        let to_set = |elem: A|\n            match f(elem) {\n                Option::Some(r) => set!{r},\n                Option::None => set!{},\n            };\n\n        assert forall|elem: B| rhs.contains(elem) implies lhs.contains(elem) by {\n            if self.filter_map(f).contains(elem) {\n                let x = choose|x: A| self.contains(x) && f(x) == Option::Some(elem);\n                assert(self.union(t).contains(x));\n                assert(self.union(t).map(to_set).contains(to_set(x)));\n            }\n            if t.filter_map(f).contains(elem) {\n                let x = choose|x: A| t.contains(x) && f(x) == Option::Some(elem);\n                assert(self.union(t).contains(x));\n                assert(self.union(t).map(to_set).contains(to_set(x)));\n            }\n        }\n        assert forall|elem: B| lhs.contains(elem) implies rhs.contains(elem) by {\n            let x = choose|x: A| self.union(t).contains(x) && f(x) == Option::Some(elem);\n            if self.contains(x) {\n                assert(self.map(to_set).contains(to_set(x)));\n                assert(self.filter_map(f).contains(elem));\n            } else {\n                assert(t.contains(x));\n                assert(t.map(to_set).contains(to_set(x)));\n                assert(t.filter_map(f).contains(elem));\n            }\n        }\n        assert(lhs =~= rhs);\n    }",
        "doc_comment": "`filter_map` and `union` commute.",
        "triggers": [
          "self.union(t"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 557,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "trigger",
          "union"
        ],
        "callees": [
          "f",
          "map",
          "contains",
          "filter_map",
          "ome",
          "to_set",
          "union"
        ]
      },
      "lemma_map_finite": {
        "name": "lemma_map_finite",
        "type": "proof",
        "signature": "pub proof fn lemma_map_finite<B>(self, f: spec_fn(A) -> B)\n        requires\n            self.finite(),\n        ensures\n            self.map(f).finite(),\n        decreases self.len(),",
        "ensures": [
          "self.map(f).finite()"
        ],
        "requires": [
          "self.finite()"
        ],
        "body": "{\n        broadcast use group_set_axioms;\n        broadcast use lemma_set_empty_equivalency_len;\n\n        if self.len() == 0 {\n            assert(forall|elem: A| !(#[trigger] self.contains(elem)));\n            assert forall|res: B| #[trigger] self.map(f).contains(res) implies false by {\n                let x = choose|x: A| self.contains(x) && f(x) == res;\n            }\n            assert(self.map(f) =~= Set::<B>::empty());\n        } else {\n            let x = choose|x: A| self.contains(x);\n            assert(self.map(f).contains(f(x)));\n            self.remove(x).lemma_map_finite(f);\n            assert(self.remove(x).insert(x) == self);\n            assert(self.map(f) == self.remove(x).map(f).insert(f(x)));\n        }\n    }",
        "doc_comment": "`map` preserves finiteness",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 598,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "finite",
          "len",
          "map"
        ],
        "callees": [
          "f",
          "remove",
          "contains",
          "len",
          "insert",
          "lemma_map_finite",
          "empty",
          "map"
        ]
      },
      "lemma_set_all_subset": {
        "name": "lemma_set_all_subset",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_all_subset(self, s2: Set<A>, p: spec_fn(A) -> bool)\n        requires\n            #[trigger] self.subset_of(s2),\n            s2.all(p),\n        ensures\n            #[trigger] self.all(p),",
        "ensures": [
          "#[trigger] self.all(p)"
        ],
        "requires": [
          "#[trigger] self.subset_of(s2)",
          "s2.all(p)"
        ],
        "body": "{\n        broadcast use group_set_axioms;\n\n    }",
        "doc_comment": null,
        "triggers": [
          "self.all(p"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 624,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "trigger"
        ],
        "callees": []
      },
      "lemma_filter_map_finite": {
        "name": "lemma_filter_map_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_filter_map_finite<B>(self, f: spec_fn(A) -> Option<B>)\n        requires\n            self.finite(),\n        ensures\n            #[trigger] self.filter_map(f).finite(),\n        decreases self.len(),",
        "ensures": [
          "#[trigger] self.filter_map(f).finite()"
        ],
        "requires": [
          "self.finite()"
        ],
        "body": "{\n        broadcast use group_set_axioms;\n        broadcast use Set::lemma_filter_map_insert;\n\n        let mapped = self.filter_map(f);\n        if self.len() == 0 {\n            assert(self.filter_map(f) =~= Set::<B>::empty());\n        } else {\n            let elem = self.choose();\n            self.remove(elem).lemma_filter_map_finite(f);\n            assert(self =~= self.remove(elem).insert(elem));\n        }\n    }",
        "doc_comment": "`filter_map` preserves finiteness.",
        "triggers": [
          "self.filter_map(f"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 635,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "finite",
          "len",
          "trigger"
        ],
        "callees": [
          "remove",
          "len",
          "filter_map",
          "lemma_filter_map_finite",
          "insert",
          "empty"
        ]
      },
      "lemma_to_seq_to_set_id": {
        "name": "lemma_to_seq_to_set_id",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_to_seq_to_set_id(self)\n        requires\n            self.finite(),\n        ensures\n            #[trigger] self.to_seq().to_set() =~= self,\n        decreases self.len(),",
        "ensures": [
          "#[trigger] self.to_seq().to_set() =~= self"
        ],
        "requires": [
          "self.finite()"
        ],
        "body": "{\n        broadcast use group_set_axioms;\n        broadcast use lemma_set_empty_equivalency_len;\n        broadcast use super::seq_lib::group_seq_properties;\n\n        if self.len() == 0 {\n            assert(self.to_seq().to_set() =~= Set::<A>::empty());\n        } else {\n            let elem = self.choose();\n            self.remove(elem).lemma_to_seq_to_set_id();\n            assert(self =~= self.remove(elem).insert(elem));\n            assert(self.to_seq().to_set() =~= self.remove(elem).to_seq().to_set().insert(elem));\n        }\n    }",
        "doc_comment": "Conversion to a sequence and back to a set is the identity function.",
        "triggers": [
          "self.to_seq("
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 656,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "finite",
          "len",
          "trigger"
        ],
        "callees": [
          "remove",
          "lemma_to_seq_to_set_id",
          "to_seq",
          "len",
          "insert",
          "empty",
          "to_set"
        ]
      },
      "flatten_insert_union_commute": {
        "name": "flatten_insert_union_commute",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn flatten_insert_union_commute(self, other: Set<A>)\n        ensures\n            self.flatten().union(other) =~= #[trigger] self.insert(other).flatten(),",
        "ensures": [
          "self.flatten().union(other) =~= #[trigger] self.insert(other).flatten()"
        ],
        "requires": [],
        "body": "{\n        broadcast use group_set_axioms;\n\n        let lhs = self.flatten().union(other);\n        let rhs = self.insert(other).flatten();\n\n        assert forall|elem: A| lhs.contains(elem) implies rhs.contains(elem) by {\n            if exists|s: Set<A>| self.contains(s) && s.contains(elem) {\n                let s = choose|s: Set<A>| self.contains(s) && s.contains(elem);\n                assert(self.insert(other).contains(s));\n                assert(s.contains(elem));\n            } else {\n                assert(self.insert(other).contains(other));\n            }\n        }\n    }",
        "doc_comment": null,
        "triggers": [
          "self.insert(other"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 686,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "insert",
          "trigger",
          "union"
        ],
        "callees": [
          "flatten",
          "contains",
          "insert",
          "union"
        ]
      },
      "lemma_sets_eq_iff_injective_map_eq": {
        "name": "lemma_sets_eq_iff_injective_map_eq",
        "type": "proof",
        "signature": "pub proof fn lemma_sets_eq_iff_injective_map_eq<T, S>(s1: Set<T>, s2: Set<T>, f: spec_fn(T) -> S)\n    requires\n        super::relations::injective(f),\n    ensures\n        (s1 == s2) <==> (s1.map(f) == s2.map(f)),",
        "ensures": [
          "(s1 == s2) <==> (s1.map(f) == s2.map(f))"
        ],
        "requires": [
          "super::relations::injective(f)"
        ],
        "body": "{\n    broadcast use group_set_axioms;\n\n    if (s1.map(f) == s2.map(f)) {\n        assert(s1.map(f).len() == s2.map(f).len());\n        if !s1.subset_of(s2) {\n            let x = choose|x: T| s1.contains(x) && !s2.contains(x);\n            assert(s1.map(f).contains(f(x)));\n        } else if !s2.subset_of(s1) {\n            let x = choose|x: T| s2.contains(x) && !s1.contains(x);\n            assert(s2.map(f).contains(f(x)));\n        }\n        assert(s1 =~= s2);\n    }\n}",
        "doc_comment": "Two sets are equal iff mapping `f` results in equal sets, if `f` is injective.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 707,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "map"
        ],
        "callees": [
          "f",
          "subset_of",
          "contains",
          "len",
          "map"
        ]
      },
      "lemma_set_insert_finite_iff": {
        "name": "lemma_set_insert_finite_iff",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_insert_finite_iff<A>(s: Set<A>, a: A)\n    ensures\n        #[trigger] s.insert(a).finite() <==> s.finite(),",
        "ensures": [
          "#[trigger] s.insert(a).finite() <==> s.finite()"
        ],
        "requires": [],
        "body": "{\n    if s.insert(a).finite() {\n        if s.contains(a) {\n            assert(s == s.insert(a));\n        } else {\n            assert(s == s.insert(a).remove(a));\n        }\n    }\n    assert(s.insert(a).finite() ==> s.finite());\n}",
        "doc_comment": "The result of inserting an element `a` into a set `s` is finite iff `s` is finite.",
        "triggers": [
          "s.insert(a"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 729,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "finite",
          "insert",
          "trigger"
        ],
        "callees": [
          "insert",
          "finite",
          "remove",
          "contains"
        ]
      },
      "lemma_set_remove_finite_iff": {
        "name": "lemma_set_remove_finite_iff",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_remove_finite_iff<A>(s: Set<A>, a: A)\n    ensures\n        #[trigger] s.remove(a).finite() <==> s.finite(),",
        "ensures": [
          "#[trigger] s.remove(a).finite() <==> s.finite()"
        ],
        "requires": [],
        "body": "{\n    if s.remove(a).finite() {\n        if s.contains(a) {\n            assert(s == s.remove(a).insert(a));\n        } else {\n            assert(s == s.remove(a));\n        }\n    }\n}",
        "doc_comment": "The result of removing an element `a` into a set `s` is finite iff `s` is finite.",
        "triggers": [
          "s.remove(a"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 744,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "finite",
          "remove",
          "trigger"
        ],
        "callees": [
          "insert",
          "finite",
          "remove",
          "contains"
        ]
      },
      "lemma_set_union_finite_iff": {
        "name": "lemma_set_union_finite_iff",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_union_finite_iff<A>(s1: Set<A>, s2: Set<A>)\n    ensures\n        #[trigger] s1.union(s2).finite() <==> s1.finite() && s2.finite(),",
        "ensures": [
          "#[trigger] s1.union(s2).finite() <==> s1.finite() && s2.finite()"
        ],
        "requires": [],
        "body": "{\n    if s1.union(s2).finite() {\n        lemma_set_union_finite_implies_sets_finite(s1, s2);\n    }\n}",
        "doc_comment": "The union of two sets is finite iff both sets are finite.",
        "triggers": [
          "s1.union(s2"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 758,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "finite",
          "trigger",
          "union"
        ],
        "callees": [
          "lemma_set_union_finite_implies_sets_finite",
          "finite",
          "union"
        ]
      },
      "lemma_set_union_finite_implies_sets_finite": {
        "name": "lemma_set_union_finite_implies_sets_finite",
        "type": "proof",
        "signature": "pub proof fn lemma_set_union_finite_implies_sets_finite<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.union(s2).finite(),\n    ensures\n        s1.finite(),\n        s2.finite(),\n    decreases s1.union(s2).len(),",
        "ensures": [
          "s1.finite()",
          "s2.finite()"
        ],
        "requires": [
          "s1.union(s2).finite()"
        ],
        "body": "{\n    if s1.union(s2) =~= set![] {\n        assert(s1 =~= set![]);\n        assert(s2 =~= set![]);\n    } else {\n        let a = s1.union(s2).choose();\n        assert(s1.remove(a).union(s2.remove(a)) == s1.union(s2).remove(a));\n        axiom_set_remove_len(s1.union(s2), a);\n        lemma_set_union_finite_implies_sets_finite(s1.remove(a), s2.remove(a));\n        assert(forall|s: Set<A>|\n            #![auto]\n            s.remove(a).insert(a) == if s.contains(a) {\n                s\n            } else {\n                s.insert(a)\n            });\n        lemma_set_insert_finite_iff(s1, a);\n        lemma_set_insert_finite_iff(s2, a);\n    }\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 768,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "finite",
          "len",
          "union"
        ],
        "callees": [
          "lemma_set_union_finite_implies_sets_finite",
          "remove",
          "axiom_set_remove_len",
          "contains",
          "insert",
          "lemma_set_insert_finite_iff",
          "union"
        ]
      },
      "lemma_len_union": {
        "name": "lemma_len_union",
        "type": "proof",
        "signature": "pub proof fn lemma_len_union<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n        s2.finite(),\n    ensures\n        s1.union(s2).len() <= s1.len() + s2.len(),\n    decreases s1.len(),",
        "ensures": [
          "s1.union(s2).len() <= s1.len() + s2.len()"
        ],
        "requires": [
          "s1.finite()",
          "s2.finite()"
        ],
        "body": "{\n    if s1.is_empty() {\n        assert(s1.union(s2) =~= s2);\n    } else {\n        let a = s1.choose();\n        if s2.contains(a) {\n            assert(s1.union(s2) =~= s1.remove(a).union(s2));\n        } else {\n            assert(s1.union(s2).remove(a) =~= s1.remove(a).union(s2));\n        }\n        lemma_len_union::<A>(s1.remove(a), s2);\n    }\n}",
        "doc_comment": "The size of a union of two sets is less than or equal to the size of\nboth individual sets combined.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 796,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "finite",
          "len",
          "union"
        ],
        "callees": [
          "union",
          "remove",
          "contains",
          "is_empty"
        ]
      },
      "lemma_len_union_ind": {
        "name": "lemma_len_union_ind",
        "type": "proof",
        "signature": "pub proof fn lemma_len_union_ind<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n        s2.finite(),\n    ensures\n        s1.union(s2).len() >= s1.len(),\n        s1.union(s2).len() >= s2.len(),\n    decreases s2.len(),",
        "ensures": [
          "s1.union(s2).len() >= s1.len()",
          "s1.union(s2).len() >= s2.len()"
        ],
        "requires": [
          "s1.finite()",
          "s2.finite()"
        ],
        "body": "{\n    broadcast use group_set_properties;\n\n    if s2.len() == 0 {\n    } else {\n        let y = choose|y: A| s2.contains(y);\n        if s1.contains(y) {\n            assert(s1.remove(y).union(s2.remove(y)) =~= s1.union(s2).remove(y));\n            lemma_len_union_ind(s1.remove(y), s2.remove(y))\n        } else {\n            assert(s1.union(s2.remove(y)) =~= s1.union(s2).remove(y));\n            lemma_len_union_ind(s1, s2.remove(y))\n        }\n    }\n}",
        "doc_comment": "The size of a union of two sets is greater than or equal to the size of\nboth individual sets.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 819,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "finite",
          "len",
          "union"
        ],
        "callees": [
          "lemma_len_union_ind",
          "remove",
          "contains",
          "len",
          "union"
        ]
      },
      "lemma_len_intersect": {
        "name": "lemma_len_intersect",
        "type": "proof",
        "signature": "pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),",
        "ensures": [
          "s1.intersect(s2).len() <= s1.len()"
        ],
        "requires": [
          "s1.finite()"
        ],
        "body": "{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect::<A>(s1.remove(a), s2);\n    }\n}",
        "doc_comment": "The size of the intersection of finite set `s1` and set `s2` is less than or equal to the size of `s1`.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 845,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "finite",
          "intersect",
          "len"
        ],
        "callees": [
          "remove",
          "intersect",
          "is_empty"
        ]
      },
      "lemma_len_subset": {
        "name": "lemma_len_subset",
        "type": "proof",
        "signature": "pub proof fn lemma_len_subset<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s2.finite(),\n        s1.subset_of(s2),\n    ensures\n        s1.len() <= s2.len(),\n        s1.finite(),",
        "ensures": [
          "s1.len() <= s2.len()",
          "s1.finite()"
        ],
        "requires": [
          "s2.finite()",
          "s1.subset_of(s2)"
        ],
        "body": "{\n    lemma_len_intersect::<A>(s2, s1);\n    assert(s2.intersect(s1) =~= s1);\n}",
        "doc_comment": "If `s1` is a subset of finite set `s2`, then the size of `s1` is less than or equal to\nthe size of `s2` and `s1` must be finite.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 862,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "finite",
          "len"
        ],
        "callees": [
          "intersect"
        ]
      },
      "lemma_set_subset_finite": {
        "name": "lemma_set_subset_finite",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_subset_finite<A>(s: Set<A>, sub: Set<A>)\n    requires\n        s.finite(),\n        sub.subset_of(s),\n    ensures\n        #![trigger sub.subset_of(s)]\n        sub.finite(),",
        "ensures": [
          "#![trigger sub.subset_of(s)]\n        sub.finite()"
        ],
        "requires": [
          "s.finite()",
          "sub.subset_of(s)"
        ],
        "body": "{\n    let complement = s.difference(sub);\n    assert(sub =~= s.difference(complement));\n}",
        "doc_comment": "A subset of a finite set `s` is finite.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 876,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "finite",
          "trigger"
        ],
        "callees": [
          "difference"
        ]
      },
      "lemma_len_difference": {
        "name": "lemma_len_difference",
        "type": "proof",
        "signature": "pub proof fn lemma_len_difference<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.difference(s2).len() <= s1.len(),\n    decreases s1.len(),",
        "ensures": [
          "s1.difference(s2).len() <= s1.len()"
        ],
        "requires": [
          "s1.finite()"
        ],
        "body": "{\n    if s1.is_empty() {\n        assert(s1.difference(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.difference(s2).remove(a) =~= s1.remove(a).difference(s2));\n        lemma_len_difference::<A>(s1.remove(a), s2);\n    }\n}",
        "doc_comment": "The size of the difference of finite set `s1` and set `s2` is less than or equal to the size of `s1`.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 889,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "difference",
          "finite",
          "len"
        ],
        "callees": [
          "difference",
          "remove",
          "is_empty"
        ]
      },
      "lemma_int_range": {
        "name": "lemma_int_range",
        "type": "proof",
        "signature": "pub proof fn lemma_int_range(lo: int, hi: int)\n    requires\n        lo <= hi,\n    ensures\n        set_int_range(lo, hi).finite(),\n        set_int_range(lo, hi).len() == hi - lo,\n    decreases hi - lo,",
        "ensures": [
          "set_int_range(lo, hi).finite()",
          "set_int_range(lo, hi).len() == hi - lo"
        ],
        "requires": [
          "lo <= hi"
        ],
        "body": "{\n    if lo == hi {\n        assert(set_int_range(lo, hi) =~= Set::empty());\n    } else {\n        lemma_int_range(lo, hi - 1);\n        assert(set_int_range(lo, hi - 1).insert(hi - 1) =~= set_int_range(lo, hi));\n    }\n}",
        "doc_comment": "If a set solely contains integers in the range [a, b), then its size is\nbounded by b - a.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 911,
        "module": "vstd::set_lib",
        "keywords": [
          "decreases",
          "finite",
          "len"
        ],
        "callees": [
          "insert",
          "set_int_range",
          "lemma_int_range",
          "empty"
        ]
      },
      "lemma_subset_equality": {
        "name": "lemma_subset_equality",
        "type": "proof",
        "signature": "pub proof fn lemma_subset_equality<A>(x: Set<A>, y: Set<A>)\n    requires\n        x.subset_of(y),\n        x.finite(),\n        y.finite(),\n        x.len() == y.len(),\n    ensures\n        x =~= y,\n    decreases x.len(),",
        "ensures": [
          "x =~= y"
        ],
        "requires": [
          "x.subset_of(y)",
          "x.finite()",
          "y.finite()",
          "x.len() == y.len()"
        ],
        "body": "{\n    broadcast use group_set_properties;\n\n    if x =~= Set::<A>::empty() {\n    } else {\n        let e = x.choose();\n        lemma_subset_equality(x.remove(e), y.remove(e));\n    }\n}",
        "doc_comment": "If x is a subset of y and the size of x is equal to the size of y, x is equal to y.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 929,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "finite",
          "len"
        ],
        "callees": [
          "lemma_subset_equality",
          "remove",
          "empty"
        ]
      },
      "lemma_map_size": {
        "name": "lemma_map_size",
        "type": "proof",
        "signature": "pub proof fn lemma_map_size<A, B>(x: Set<A>, y: Set<B>, f: spec_fn(A) -> B)\n    requires\n        injective(f),\n        forall|a: A| x.contains(a) ==> y.contains(#[trigger] f(a)),\n        forall|b: B| (#[trigger] y.contains(b)) ==> exists|a: A| x.contains(a) && f(a) == b,\n        x.finite(),\n    ensures\n        y.finite(),\n        x.len() == y.len(),\n    decreases x.len(),",
        "ensures": [
          "y.finite()",
          "x.len() == y.len()"
        ],
        "requires": [
          "injective(f)",
          "forall|a: A| x.contains(a) ==> y.contains(#[trigger] f(a))",
          "forall|b: B| (#[trigger] y.contains(b)) ==> exists|a: A| x.contains(a) && f(a) == b",
          "x.finite()"
        ],
        "body": "{\n    broadcast use group_set_properties;\n\n    if x.len() == 0 {\n        if !y.is_empty() {\n            let e = y.choose();\n        }\n    } else {\n        let a = x.choose();\n        lemma_map_size(x.remove(a), y.remove(f(a)), f);\n        assert(y == y.remove(f(a)).insert(f(a)));\n    }\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 953,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "contains",
          "decreases",
          "exists",
          "finite",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "f",
          "remove",
          "is_empty",
          "len",
          "insert",
          "lemma_map_size"
        ]
      },
      "lemma_set_union_again1": {
        "name": "lemma_set_union_again1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_union_again1<A>(a: Set<A>, b: Set<A>)\n    ensures\n        #[trigger] a.union(b).union(b) =~= a.union(b),",
        "ensures": [
          "#[trigger] a.union(b).union(b) =~= a.union(b)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Taking the union of sets `a` and `b` and then taking the union of the result with `b`\nis the same as taking the union of `a` and `b` once.",
        "triggers": [
          "a.union(b"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 978,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "trigger",
          "union"
        ],
        "callees": []
      },
      "lemma_set_union_again2": {
        "name": "lemma_set_union_again2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_union_again2<A>(a: Set<A>, b: Set<A>)\n    ensures\n        #[trigger] a.union(b).union(a) =~= a.union(b),",
        "ensures": [
          "#[trigger] a.union(b).union(a) =~= a.union(b)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Taking the union of sets `a` and `b` and then taking the union of the result with `a`\nis the same as taking the union of `a` and `b` once.",
        "triggers": [
          "a.union(b"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 987,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "trigger",
          "union"
        ],
        "callees": []
      },
      "lemma_set_intersect_again1": {
        "name": "lemma_set_intersect_again1",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_intersect_again1<A>(a: Set<A>, b: Set<A>)\n    ensures\n        #![trigger (a.intersect(b)).intersect(b)]\n        (a.intersect(b)).intersect(b) =~= a.intersect(b),",
        "ensures": [
          "#![trigger (a.intersect(b)).intersect(b)]\n        (a.intersect(b)).intersect(b) =~= a.intersect(b)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Taking the intersection of sets `a` and `b` and then taking the intersection of the result with `b`\nis the same as taking the intersection of `a` and `b` once.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 996,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "intersect",
          "trigger"
        ],
        "callees": []
      },
      "lemma_set_intersect_again2": {
        "name": "lemma_set_intersect_again2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_intersect_again2<A>(a: Set<A>, b: Set<A>)\n    ensures\n        #![trigger (a.intersect(b)).intersect(a)]\n        (a.intersect(b)).intersect(a) =~= a.intersect(b),",
        "ensures": [
          "#![trigger (a.intersect(b)).intersect(a)]\n        (a.intersect(b)).intersect(a) =~= a.intersect(b)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "Taking the intersection of sets `a` and `b` and then taking the intersection of the result with `a`\nis the same as taking the intersection of `a` and `b` once.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1006,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "intersect",
          "trigger"
        ],
        "callees": []
      },
      "lemma_set_difference2": {
        "name": "lemma_set_difference2",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_difference2<A>(s1: Set<A>, s2: Set<A>, a: A)\n    ensures\n        #![trigger s1.difference(s2).contains(a)]\n        s2.contains(a) ==> !s1.difference(s2).contains(a),",
        "ensures": [
          "#![trigger s1.difference(s2).contains(a)]\n        s2.contains(a) ==> !s1.difference(s2).contains(a)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If set `s2` contains element `a`, then the set difference of `s1` and `s2` does not contain `a`.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1016,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "contains",
          "difference",
          "trigger"
        ],
        "callees": []
      },
      "lemma_set_disjoint": {
        "name": "lemma_set_disjoint",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_disjoint<A>(a: Set<A>, b: Set<A>)\n    ensures\n        #![trigger (a + b).difference(a)]  //TODO: this might be too free\n        a.disjoint(b) ==> ((a + b).difference(a) =~= b && (a + b).difference(b) =~= a),",
        "ensures": [
          "#![trigger (a + b).difference(a)]  //TODO: this might be too free\n        a.disjoint(b) ==> ((a + b).difference(a) =~= b && (a + b).difference(b) =~= a)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": "If sets `a` and `b` are disjoint, meaning they have no elements in common, then the set difference\nof `a + b` and `b` is equal to `a` and the set difference of `a + b` and `a` is equal to `b`.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1025,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "difference",
          "trigger"
        ],
        "callees": []
      },
      "lemma_set_empty_equivalency_len": {
        "name": "lemma_set_empty_equivalency_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_empty_equivalency_len<A>(s: Set<A>)\n    requires\n        s.finite(),\n    ensures\n        #![trigger s.len()]\n        (s.len() == 0 <==> s == Set::<A>::empty()) && (s.len() != 0 ==> exists|x: A| s.contains(x)),",
        "ensures": [
          "#![trigger s.len()]\n        (s.len() == 0 <==> s == Set::<A>::empty()) && (s.len() != 0 ==> exists|x: A| s.contains(x))"
        ],
        "requires": [
          "s.finite()"
        ],
        "body": "{\n    assert(s.len() == 0 ==> s =~= Set::empty()) by {\n        if s.len() == 0 {\n            assert(forall|a: A| !(Set::empty().contains(a)));\n            assert(Set::<A>::empty().len() == 0);\n            assert(Set::<A>::empty().len() == s.len());\n            assert((exists|a: A| s.contains(a)) || (forall|a: A| !s.contains(a)));\n            if exists|a: A| s.contains(a) {\n                let a = s.choose();\n                assert(s.remove(a).len() == s.len() - 1) by {\n                    axiom_set_remove_len(s, a);\n                }\n            }\n        }\n    }\n    assert(s.len() == 0 <== s =~= Set::empty());\n}",
        "doc_comment": "Set `s` has length 0 if and only if it is equal to the empty set. If `s` has length greater than 0,\nThen there must exist an element `x` such that `s` contains `x`.",
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1039,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "contains",
          "empty",
          "exists",
          "finite",
          "len",
          "trigger"
        ],
        "callees": [
          "remove",
          "axiom_set_remove_len",
          "contains",
          "len",
          "empty"
        ]
      },
      "lemma_set_disjoint_lens": {
        "name": "lemma_set_disjoint_lens",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_disjoint_lens<A>(a: Set<A>, b: Set<A>)\n    requires\n        a.finite(),\n        b.finite(),\n    ensures\n        a.disjoint(b) ==> #[trigger] (a + b).len() == a.len() + b.len(),\n    decreases a.len(),",
        "ensures": [
          "a.disjoint(b) ==> #[trigger] (a + b).len() == a.len() + b.len()"
        ],
        "requires": [
          "a.finite()",
          "b.finite()"
        ],
        "body": "{\n    if a.len() == 0 {\n        lemma_set_empty_equivalency_len(a);\n        assert(a + b =~= b);\n    } else {\n        if a.disjoint(b) {\n            let x = a.choose();\n            assert(a.remove(x) + b =~= (a + b).remove(x));\n            lemma_set_disjoint_lens(a.remove(x), b);\n        }\n    }\n}",
        "doc_comment": "If sets `a` and `b` are disjoint, meaning they share no elements in common, then the length\nof the union `a + b` is equal to the sum of the lengths of `a` and `b`.",
        "triggers": [
          "(a + b"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1066,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "finite",
          "len",
          "trigger"
        ],
        "callees": [
          "lemma_set_disjoint_lens",
          "remove",
          "disjoint",
          "lemma_set_empty_equivalency_len",
          "len"
        ]
      },
      "lemma_set_intersect_union_lens": {
        "name": "lemma_set_intersect_union_lens",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_intersect_union_lens<A>(a: Set<A>, b: Set<A>)\n    requires\n        a.finite(),\n        b.finite(),\n    ensures\n        #[trigger] (a + b).len() + #[trigger] a.intersect(b).len() == a.len() + b.len(),\n    decreases a.len(),",
        "ensures": [
          "#[trigger] (a + b).len() + #[trigger] a.intersect(b).len() == a.len() + b.len()"
        ],
        "requires": [
          "a.finite()",
          "b.finite()"
        ],
        "body": "{\n    if a.len() == 0 {\n        lemma_set_empty_equivalency_len(a);\n        assert(a + b =~= b);\n        assert(a.intersect(b) =~= Set::empty());\n        assert(a.intersect(b).len() == 0);\n    } else {\n        let x = a.choose();\n        lemma_set_intersect_union_lens(a.remove(x), b);\n        if (b.contains(x)) {\n            assert(a.remove(x) + b =~= (a + b));\n            assert(a.intersect(b).remove(x) =~= a.remove(x).intersect(b));\n        } else {\n            assert(a.remove(x) + b =~= (a + b).remove(x));\n            assert(a.remove(x).intersect(b) =~= a.intersect(b));\n        }\n    }\n}",
        "doc_comment": "The length of the union between two sets added to the length of the intersection between the\ntwo sets is equal to the sum of the lengths of the two sets.",
        "triggers": [
          "(a + b",
          "a.intersect(b"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1089,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "finite",
          "intersect",
          "len",
          "trigger"
        ],
        "callees": [
          "remove",
          "intersect",
          "lemma_set_empty_equivalency_len",
          "contains",
          "len",
          "empty",
          "lemma_set_intersect_union_lens"
        ]
      },
      "lemma_set_difference_len": {
        "name": "lemma_set_difference_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_set_difference_len<A>(a: Set<A>, b: Set<A>)\n    requires\n        a.finite(),\n        b.finite(),\n    ensures\n        (#[trigger] a.difference(b).len() + b.difference(a).len() + a.intersect(b).len() == (a\n            + b).len()) && (a.difference(b).len() == a.len() - a.intersect(b).len()),\n    decreases a.len(),",
        "ensures": [
          "(#[trigger] a.difference(b).len() + b.difference(a).len() + a.intersect(b).len() == (a\n            + b).len()) && (a.difference(b).len() == a.len() - a.intersect(b).len())"
        ],
        "requires": [
          "a.finite()",
          "b.finite()"
        ],
        "body": "{\n    if a.len() == 0 {\n        lemma_set_empty_equivalency_len(a);\n        assert(a.difference(b) =~= Set::empty());\n        assert(b.difference(a) =~= b);\n        assert(a.intersect(b) =~= Set::empty());\n        assert(a + b =~= b);\n    } else {\n        let x = a.choose();\n        lemma_set_difference_len(a.remove(x), b);\n        if b.contains(x) {\n            assert(a.intersect(b).remove(x) =~= a.remove(x).intersect(b));\n            assert(a.remove(x).difference(b) =~= a.difference(b));\n            assert(b.difference(a.remove(x)).remove(x) =~= b.difference(a));\n            assert(a.remove(x) + b =~= a + b);\n        } else {\n            assert(a.remove(x) + b =~= (a + b).remove(x));\n            assert(a.remove(x).difference(b) =~= a.difference(b).remove(x));\n            assert(b.difference(a.remove(x)) =~= b.difference(a));\n            assert(a.remove(x).intersect(b) =~= a.intersect(b));\n        }\n    }\n}",
        "doc_comment": "The length of the set difference `A \\ B` added to the length of the set difference `B \\ A` added to\nthe length of the intersection `A \u2229 B` is equal to the length of the union `A + B`.\n\nThe length of the set difference `A \\ B` is equal to the length of `A` minus the length of the\nintersection `A \u2229 B`.",
        "triggers": [
          "a.difference(b"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1118,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "decreases",
          "difference",
          "finite",
          "intersect",
          "len",
          "trigger"
        ],
        "callees": [
          "lemma_set_difference_len",
          "remove",
          "intersect",
          "lemma_set_empty_equivalency_len",
          "difference",
          "contains",
          "len",
          "empty"
        ]
      },
      "lemma_set_properties": {
        "name": "lemma_set_properties",
        "type": "proof",
        "signature": "pub proof fn lemma_set_properties<A>()\n    ensures\n        forall|a: Set<A>, b: Set<A>| #[trigger] a.union(b).union(b) == a.union(b),  //from lemma_set_union_again1\n        forall|a: Set<A>, b: Set<A>| #[trigger] a.union(b).union(a) == a.union(b),  //from lemma_set_union_again2\n        forall|a: Set<A>, b: Set<A>| #[trigger] (a.intersect(b)).intersect(b) == a.intersect(b),  //from lemma_set_intersect_again1\n        forall|a: Set<A>, b: Set<A>| #[trigger] (a.intersect(b)).intersect(a) == a.intersect(b),  //from lemma_set_intersect_again2\n        forall|s1: Set<A>, s2: Set<A>, a: A| s2.contains(a) ==> !s1.difference(s2).contains(a),  //from lemma_set_difference2\n        forall|a: Set<A>, b: Set<A>|\n            #![trigger (a + b).difference(a)]\n            a.disjoint(b) ==> ((a + b).difference(a) =~= b && (a + b).difference(b) =~= a),  //from lemma_set_disjoint\n        forall|s: Set<A>| #[trigger] s.len() != 0 && s.finite() ==> exists|a: A| s.contains(a),  // half of lemma_set_empty_equivalency_len\n        forall|a: Set<A>, b: Set<A>|\n            (a.finite() && b.finite() && a.disjoint(b)) ==> #[trigger] (a + b).len() == a.len()\n                + b.len(),  //from lemma_set_disjoint_lens\n        forall|a: Set<A>, b: Set<A>|\n            (a.finite() && b.finite()) ==> #[trigger] (a + b).len() + #[trigger] a.intersect(\n                b,\n            ).len() == a.len() + b.len(),  //from lemma_set_intersect_union_lens\n        forall|a: Set<A>, b: Set<A>|\n            (a.finite() && b.finite()) ==> ((#[trigger] a.difference(b).len() + b.difference(\n                a,\n            ).len() + a.intersect(b).len() == (a + b).len()) && (a.difference(b).len() == a.len()\n                - a.intersect(b).len())),  //from lemma_set_difference_len",
        "ensures": [
          "forall|a: Set<A>, b: Set<A>| #[trigger] a.union(b).union(b) == a.union(b),  //from lemma_set_union_again1\n        forall|a: Set<A>, b: Set<A>| #[trigger] a.union(b).union(a) == a.union(b),  //from lemma_set_union_again2\n        forall|a: Set<A>, b: Set<A>| #[trigger] (a.intersect(b)).intersect(b) == a.intersect(b),  //from lemma_set_intersect_again1\n        forall|a: Set<A>, b: Set<A>| #[trigger] (a.intersect(b)).intersect(a) == a.intersect(b),  //from lemma_set_intersect_again2\n        forall|s1: Set<A>, s2: Set<A>, a: A| s2.contains(a) ==> !s1.difference(s2).contains(a),  //from lemma_set_difference2\n        forall|a: Set<A>, b: Set<A>|\n            #![trigger (a + b).difference(a)]\n            a.disjoint(b) ==> ((a + b).difference(a) =~= b && (a + b).difference(b) =~= a),  //from lemma_set_disjoint\n        forall|s: Set<A>| #[trigger] s.len() != 0 && s.finite() ==> exists|a: A| s.contains(a),  // half of lemma_set_empty_equivalency_len\n        forall|a: Set<A>, b: Set<A>|\n            (a.finite() && b.finite() && a.disjoint(b)) ==> #[trigger] (a + b).len() == a.len()\n                + b.len(),  //from lemma_set_disjoint_lens\n        forall|a: Set<A>, b: Set<A>|\n            (a.finite() && b.finite()) ==> #[trigger] (a + b).len() + #[trigger] a.intersect(\n                b",
          ").len() == a.len() + b.len(),  //from lemma_set_intersect_union_lens\n        forall|a: Set<A>, b: Set<A>|\n            (a.finite() && b.finite()) ==> ((#[trigger] a.difference(b).len() + b.difference(\n                a",
          ").len() + a.intersect(b).len() == (a + b).len()) && (a.difference(b).len() == a.len()\n                - a.intersect(b).len())),  //from lemma_set_difference_len"
        ],
        "requires": [],
        "body": "{\n    broadcast use group_set_properties;\n\n    assert forall|s: Set<A>| #[trigger] s.len() != 0 && s.finite() implies exists|a: A|\n        s.contains(a) by {\n        assert(s.contains(s.choose()));\n    }\n}",
        "doc_comment": "Properties of sets from the Dafny prelude (which were axioms in Dafny, but proven here in Verus)",
        "triggers": [
          "a.union(b",
          "a.union(b",
          "(a.intersect(b",
          "(a.intersect(b",
          "s.len(",
          "(a + b",
          "(a + b",
          "a.intersect(",
          "a.difference(b"
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1154,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "contains",
          "difference",
          "exists",
          "finite",
          "forall",
          "intersect",
          "len",
          "trigger",
          "union"
        ],
        "callees": [
          "len",
          "finite",
          "contains"
        ]
      },
      "axiom_is_empty": {
        "name": "axiom_is_empty",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_is_empty<A>(s: Set<A>)\n    requires\n        !(#[trigger] s.is_empty()),\n    ensures\n        exists|a: A| s.contains(a),",
        "ensures": [
          "exists|a: A| s.contains(a)"
        ],
        "requires": [
          "!(#[trigger] s.is_empty())"
        ],
        "body": "{\n    admit();  // REVIEW, should this be in `set`, or have a proof?\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1203,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "contains",
          "exists",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_is_empty_len0": {
        "name": "axiom_is_empty_len0",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_is_empty_len0<A>(s: Set<A>)\n    ensures\n        #[trigger] s.is_empty() <==> (s.finite() && s.len() == 0),",
        "ensures": [
          "#[trigger] s.is_empty() <==> (s.finite() && s.len() == 0)"
        ],
        "requires": [],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [
          "s.is_empty("
        ],
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1212,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "finite",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "vstd::shared::view": {
        "name": "vstd::shared::view",
        "type": "closed_spec",
        "signature": "pub closed spec fn view(self) -> T",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.inst.val()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/shared.rs",
        "line_number": 50,
        "module": "vstd::shared",
        "keywords": [],
        "callees": [
          "val"
        ]
      },
      "vstd::shared::new": {
        "name": "vstd::shared::new",
        "type": "proof",
        "signature": "pub proof fn new(tracked t: T) -> (tracked s: Self)\n        ensures\n            s@ == t,",
        "ensures": [
          "s@ == t"
        ],
        "requires": [],
        "body": "{\n        let tracked inst = Dupe::Instance::initialize_one(t, Option::Some(t));\n        Shared { inst }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/shared.rs",
        "line_number": 53,
        "module": "vstd::shared",
        "keywords": [],
        "callees": [
          "ome",
          "initialize_one"
        ]
      },
      "clone": {
        "name": "clone",
        "type": "proof",
        "signature": "pub proof fn clone(tracked &self) -> (tracked other: Self)\n        ensures\n            self@ == other@,",
        "ensures": [
          "self@ == other@"
        ],
        "requires": [],
        "body": "{\n        Shared { inst: self.inst.clone() }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/shared.rs",
        "line_number": 61,
        "module": "vstd::shared",
        "keywords": [],
        "callees": []
      },
      "borrow": {
        "name": "vstd::shared::borrow",
        "type": "proof",
        "signature": "pub proof fn borrow(tracked &self) -> (tracked t: &T)\n        ensures\n            *t == self@,",
        "ensures": [
          "*t == self@"
        ],
        "requires": [],
        "body": "{\n        self.inst.borrow()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/shared.rs",
        "line_number": 68,
        "module": "vstd::shared",
        "keywords": [],
        "callees": [
          "borrow"
        ]
      },
      "addr": {
        "name": "addr",
        "type": "closed_spec",
        "signature": "pub closed spec fn addr(self) -> usize",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.points_to.ptr().addr()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 224,
        "module": "vstd::simple_pptr",
        "keywords": [],
        "callees": [
          "addr",
          "ptr"
        ]
      },
      "vstd::simple_pptr::mem_contents": {
        "name": "vstd::simple_pptr::mem_contents",
        "type": "closed_spec",
        "signature": "pub closed spec fn mem_contents(&self) -> MemContents<V>",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.points_to.opt_value()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 244,
        "module": "vstd::simple_pptr",
        "keywords": [],
        "callees": [
          "opt_value"
        ]
      },
      "vstd::simple_pptr::is_nonnull": {
        "name": "vstd::simple_pptr::is_nonnull",
        "type": "proof",
        "signature": "pub proof fn is_nonnull(tracked &self)\n        ensures\n            self.addr() != 0,",
        "ensures": [
          "self.addr() != 0"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(self);\n    }",
        "doc_comment": "Guarantee that the `PointsTo` points to a non-null address.",
        "triggers": [],
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 272,
        "module": "vstd::simple_pptr",
        "keywords": [],
        "callees": [
          "use_type_invariant"
        ]
      },
      "vstd::simple_pptr::leak_contents": {
        "name": "vstd::simple_pptr::leak_contents",
        "type": "proof",
        "signature": "pub proof fn leak_contents(tracked &mut self)\n        ensures\n            self.pptr() == old(self).pptr(),\n            self.is_uninit(),",
        "ensures": [
          "self.pptr() == old(self).pptr()",
          "self.is_uninit()"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(&*self);\n        self.points_to.leak_contents();\n    }",
        "doc_comment": "\"Forgets\" about the value stored behind the pointer.\nUpdates the `PointsTo` value to [`MemContents::Uninit`](MemContents::Uninit).\nNote that this is a `proof` function, i.e., it is operationally a no-op in executable code.",
        "triggers": [],
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 280,
        "module": "vstd::simple_pptr",
        "keywords": [],
        "callees": [
          "leak_contents",
          "use_type_invariant"
        ]
      },
      "vstd::simple_pptr::is_disjoint": {
        "name": "vstd::simple_pptr::is_disjoint",
        "type": "proof",
        "signature": "pub proof fn is_disjoint<S>(tracked &mut self, tracked other: &PointsTo<S>)\n        ensures\n            *old(self) == *self,\n            self.addr() + size_of::<V>() <= other.addr() || other.addr() + size_of::<S>()\n                <= self.addr(),",
        "ensures": [
          "*old(self) == *self",
          "self.addr() + size_of::<V>() <= other.addr() || other.addr() + size_of::<S>()\n                <= self.addr()"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(&*self);\n        self.points_to.is_disjoint(&other.points_to);\n    }",
        "doc_comment": "Guarantees that two distinct `PointsTo<V>` objects point to disjoint ranges of memory.\nIf both S and V are non-zero-sized, then this also implies the pointers\nhave distinct addresses.",
        "triggers": [],
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 292,
        "module": "vstd::simple_pptr",
        "keywords": [],
        "callees": [
          "is_disjoint",
          "use_type_invariant"
        ]
      },
      "is_distinct": {
        "name": "is_distinct",
        "type": "proof",
        "signature": "pub proof fn is_distinct<S>(tracked &mut self, tracked other: &PointsTo<S>)\n        requires\n            size_of::<V>() != 0,\n            size_of::<S>() != 0,\n        ensures\n            *old(self) == *self,\n            self.addr() != other.addr(),",
        "ensures": [
          "*old(self) == *self",
          "self.addr() != other.addr()"
        ],
        "requires": [
          "size_of::<V>() != 0",
          "size_of::<S>() != 0"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        self.points_to.is_disjoint(&other.points_to);\n    }",
        "doc_comment": "Guarantees that two distinct, non-ZST `PointsTo<V>` objects point to different\naddresses. This is a corollary of [`PointsTo::is_disjoint`].",
        "triggers": [],
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 305,
        "module": "vstd::simple_pptr",
        "keywords": [],
        "callees": [
          "is_disjoint",
          "use_type_invariant"
        ]
      },
      "slice_index_get": {
        "name": "slice_index_get",
        "type": "exec",
        "signature": "pub exec fn slice_index_get<T>(slice: &[T], i: usize) -> (out: &T)\n    requires\n        0 <= i < slice.view().len(),\n    ensures\n        *out == slice@.index(i as int),",
        "ensures": [
          "*out == slice@.index(i as int)"
        ],
        "requires": [
          "0 <= i < slice.view().len()"
        ],
        "body": "{\n    &slice[i]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/slice.rs",
        "line_number": 56,
        "module": "vstd::slice",
        "keywords": [
          "len"
        ],
        "callees": []
      },
      "spec_slice_len": {
        "name": "spec_slice_len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_slice_len<T>(slice: &[T]) -> usize",
        "ensures": [
          "#[trigger] spec_slice_len(slice) == slice@.len()",
          "len == spec_slice_len(slice)",
          "out@ == slice@"
        ],
        "requires": [],
        "body": "{\n    slice.to_vec()\n}",
        "doc_comment": "/// Len (with autospec)",
        "triggers": [
          "spec_slice_len(slice"
        ],
        "file_path": "verus/source/vstd/slice.rs",
        "line_number": 67,
        "module": "vstd::slice",
        "keywords": [
          "len",
          "trigger"
        ],
        "callees": [
          "to_vec"
        ]
      },
      "axiom_spec_len": {
        "name": "vstd::slice::axiom_spec_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_spec_len<T>(slice: &[T])\n    ensures\n        #[trigger] spec_slice_len(slice) == slice@.len(),",
        "ensures": [
          "#[trigger] spec_slice_len(slice) == slice@.len()",
          "len == spec_slice_len(slice)",
          "out@ == slice@"
        ],
        "requires": [],
        "body": "{\n    slice.to_vec()\n}",
        "doc_comment": null,
        "triggers": [
          "spec_slice_len(slice"
        ],
        "file_path": "verus/source/vstd/slice.rs",
        "line_number": 73,
        "module": "vstd::slice",
        "keywords": [
          "len",
          "trigger"
        ],
        "callees": [
          "to_vec"
        ]
      },
      "slice_to_vec": {
        "name": "slice_to_vec",
        "type": "exec",
        "signature": "pub exec fn slice_to_vec<T: Copy>(slice: &[T]) -> (out: alloc::vec::Vec<T>)\n    ensures\n        out@ == slice@,",
        "ensures": [
          "out@ == slice@"
        ],
        "requires": [],
        "body": "{\n    slice.to_vec()\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/slice.rs",
        "line_number": 83,
        "module": "vstd::slice",
        "keywords": [
          "Vec"
        ],
        "callees": [
          "to_vec"
        ]
      },
      "slice_subrange": {
        "name": "slice_subrange",
        "type": "exec",
        "signature": "pub exec fn slice_subrange<T, 'a>(slice: &'a [T], i: usize, j: usize) -> (out: &'a [T])\n    requires\n        0 <= i <= j <= slice@.len(),\n    ensures\n        out@ == slice@.subrange(i as int, j as int),",
        "ensures": [
          "out@ == slice@.subrange(i as int, j as int)"
        ],
        "requires": [
          "0 <= i <= j <= slice@.len()"
        ],
        "body": "{\n    &slice[i..j]\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/slice.rs",
        "line_number": 92,
        "module": "vstd::slice",
        "keywords": [
          "len",
          "subrange"
        ],
        "callees": []
      },
      "spec_slice_get": {
        "name": "spec_slice_get",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_slice_get<T: ?Sized, I: core::slice::SliceIndex<T>>(\n    val: &T,\n    idx: I,\n) -> Option<&<I as core::slice::SliceIndex<T>>::Output>",
        "ensures": [
          "i < v.len() ==> #[trigger] spec_slice_get(v, i) === Some(&v[i as int])",
          "i >= v.len() ==> spec_slice_get(v, i).is_none()",
          "#[trigger] (a1 =~= a2) <==> (a1.len() == a2.len() && forall|i: int|\n            0 <= i < a1.len() ==> a1[i] == a2[i])"
        ],
        "requires": [],
        "body": "{\n    axiom_spec_len,\n    axiom_slice_get_usize,\n    axiom_slice_ext_equal,\n}",
        "doc_comment": null,
        "triggers": [
          "spec_slice_get(v",
          "(a1 =~= a2"
        ],
        "file_path": "verus/source/vstd/slice.rs",
        "line_number": 116,
        "module": "vstd::slice",
        "keywords": [
          "forall",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_slice_get_usize": {
        "name": "axiom_slice_get_usize",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_slice_get_usize<T>(v: &[T], i: usize)\n    ensures\n        i < v.len() ==> #[trigger] spec_slice_get(v, i) === Some(&v[i as int]),\n        i >= v.len() ==> spec_slice_get(v, i).is_none(),",
        "ensures": [
          "i < v.len() ==> #[trigger] spec_slice_get(v, i) === Some(&v[i as int])",
          "i >= v.len() ==> spec_slice_get(v, i).is_none()",
          "#[trigger] (a1 =~= a2) <==> (a1.len() == a2.len() && forall|i: int|\n            0 <= i < a1.len() ==> a1[i] == a2[i])"
        ],
        "requires": [],
        "body": "{\n    axiom_spec_len,\n    axiom_slice_get_usize,\n    axiom_slice_ext_equal,\n}",
        "doc_comment": null,
        "triggers": [
          "spec_slice_get(v",
          "(a1 =~= a2"
        ],
        "file_path": "verus/source/vstd/slice.rs",
        "line_number": 121,
        "module": "vstd::slice",
        "keywords": [
          "forall",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_slice_ext_equal": {
        "name": "axiom_slice_ext_equal",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_slice_ext_equal<T>(a1: &[T], a2: &[T])\n    ensures\n        #[trigger] (a1 =~= a2) <==> (a1.len() == a2.len() && forall|i: int|\n            0 <= i < a1.len() ==> a1[i] == a2[i]),",
        "ensures": [
          "#[trigger] (a1 =~= a2) <==> (a1.len() == a2.len() && forall|i: int|\n            0 <= i < a1.len() ==> a1[i] == a2[i])"
        ],
        "requires": [],
        "body": "{\n    axiom_spec_len,\n    axiom_slice_get_usize,\n    axiom_slice_ext_equal,\n}",
        "doc_comment": null,
        "triggers": [
          "(a1 =~= a2"
        ],
        "file_path": "verus/source/vstd/slice.rs",
        "line_number": 127,
        "module": "vstd::slice",
        "keywords": [
          "forall",
          "len",
          "trigger"
        ],
        "callees": []
      },
      "u8_trailing_zeros": {
        "name": "u8_trailing_zeros",
        "type": "closed_spec",
        "signature": "pub closed spec fn u8_trailing_zeros(i: u8) -> u32\n    decreases i,",
        "ensures": [],
        "requires": [],
        "body": "{\n    if i == 0 {\n        8\n    } else if (i & 1) != 0 {\n        0\n    } else {\n        (1 + u8_trailing_zeros(i / 2)) as u32\n    }\n}",
        "doc_comment": "////////////////////////\n//////////////////////// For u8\nEquivalent to `i.trailing_zeros()`.\nSee [`axiom_u8_trailing_zeros`] for useful properties.",
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 6,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "u8_trailing_zeros"
        ]
      },
      "u8_leading_zeros": {
        "name": "u8_leading_zeros",
        "type": "closed_spec",
        "signature": "pub closed spec fn u8_leading_zeros(i: u8) -> u32\n    decreases i,",
        "ensures": [],
        "requires": [],
        "body": "{\n    if i == 0 {\n        8\n    } else {\n        (u8_leading_zeros(i / 2) - 1) as u32\n    }\n}",
        "doc_comment": "Equivalent to `i.leading_zeros()`.\nSee [`axiom_u8_leading_zeros`] for useful properties.",
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 21,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "u8_leading_zeros"
        ]
      },
      "axiom_u8_trailing_zeros": {
        "name": "axiom_u8_trailing_zeros",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u8_trailing_zeros(i: u8)\n    ensures\n        0 <= #[trigger] u8_trailing_zeros(i) <= 8,\n        i == 0 <==> u8_trailing_zeros(i) == 8,\n        // i^th bit is 1\n        0 <= u8_trailing_zeros(i) < 8 ==> (i >> u8_trailing_zeros(i) as u8) & 1u8 == 1u8,\n        // trailing bits are 0\n        i << sub(8, u8_trailing_zeros(i) as u8) == 0,\n        forall|j: u8| 0 <= j < u8_trailing_zeros(i) ==> #[trigger] (i >> j) & 1u8 == 0u8,\n    decreases i,",
        "ensures": [
          "0 <= #[trigger] u8_trailing_zeros(i) <= 8",
          "i == 0 <==> u8_trailing_zeros(i) == 8",
          "// i^th bit is 1\n        0 <= u8_trailing_zeros(i) < 8 ==> (i >> u8_trailing_zeros(i) as u8) & 1u8 == 1u8",
          "// trailing bits are 0\n        i << sub(8, u8_trailing_zeros(i) as u8) == 0",
          "forall|j: u8| 0 <= j < u8_trailing_zeros(i) ==> #[trigger] (i >> j) & 1u8 == 0u8"
        ],
        "requires": [],
        "body": "{\n    assert(i >> 0 == i) by (bit_vector);\n    assert(i << 0 == i) by (bit_vector);\n    assert(i & 0 == 0) by (bit_vector);\n    assert(i / 2 == (i >> 1u8)) by (bit_vector);\n    assert((i & 1) == 0 ==> i != 1) by (bit_vector);\n    let x = u8_trailing_zeros(i / 2) as u8;\n    assert(x < 8 ==> (i >> 1) >> x == (i >> add(x, 1))) by (bit_vector);\n    assert(i << 8 == 0) by (bit_vector);\n    assert(i & 1 != 0 ==> i & 1 == 1) by (bit_vector);\n    assert((i & 1) == 0 ==> (i >> 1) << sub(8, x) == 0 ==> i << sub(8, add(x, 1)) == 0)\n        by (bit_vector);\n    if i != 0 {\n        axiom_u8_trailing_zeros(i / 2);\n    }\n    assert forall|j: u8| 0 <= j < u8_trailing_zeros(i) implies #[trigger] (i >> j) & 1u8 == 0u8 by {\n        let y = u8_trailing_zeros(i) as u8;\n        assert(y <= 8 ==> i << sub(8, y) == 0 && 0 <= j < y ==> (i >> j) & 1u8 == 0u8)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u8_trailing_zeros(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 69,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u8_trailing_zeros",
          "u8_trailing_zeros"
        ]
      },
      "axiom_u8_trailing_ones": {
        "name": "axiom_u8_trailing_ones",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u8_trailing_ones(i: u8)\n    ensures\n        0 <= #[trigger] u8_trailing_ones(i) <= 8,\n        i == 0xffu8 <==> u8_trailing_ones(i) == 8,\n        // i^th bit is 0\n        0 <= u8_trailing_ones(i) < 8 ==> (i >> u8_trailing_ones(i) as u8) & 1u8 == 0u8,\n        // trailing bits are 1\n        (!i) << sub(8, u8_trailing_ones(i) as u8) == 0,\n        forall|j: u8| 0 <= j < u8_trailing_ones(i) ==> #[trigger] (i >> j) & 1u8 == 1u8,",
        "ensures": [
          "0 <= #[trigger] u8_trailing_ones(i) <= 8",
          "i == 0xffu8 <==> u8_trailing_ones(i) == 8",
          "// i^th bit is 0\n        0 <= u8_trailing_ones(i) < 8 ==> (i >> u8_trailing_ones(i) as u8) & 1u8 == 0u8",
          "// trailing bits are 1\n        (!i) << sub(8, u8_trailing_ones(i) as u8) == 0",
          "forall|j: u8| 0 <= j < u8_trailing_ones(i) ==> #[trigger] (i >> j) & 1u8 == 1u8"
        ],
        "requires": [],
        "body": "{\n    axiom_u8_trailing_zeros(!i);\n    assert(!0xffu8 == 0) by (bit_vector);\n    assert(!i == 0 ==> i == 0xffu8) by (bit_vector);\n    let x = u8_trailing_ones(i) as u8;\n    assert(((!i) >> x) & 1u8 == 1u8 ==> (i >> x) & 1u8 == 0u8) by (bit_vector);\n    assert forall|j: u8| 0 <= j < u8_trailing_ones(i) implies #[trigger] (i >> j) & 1u8 == 1u8 by {\n        let y = u8_trailing_ones(i) as u8;\n        assert(y <= 8 ==> (!i) << sub(8, y) == 0 && 0 <= j < y ==> (i >> j) & 1u8 == 1u8)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u8_trailing_ones(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 101,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u8_trailing_zeros",
          "u8_trailing_ones"
        ]
      },
      "axiom_u8_leading_zeros": {
        "name": "axiom_u8_leading_zeros",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u8_leading_zeros(i: u8)\n    ensures\n        0 <= #[trigger] u8_leading_zeros(i) <= 8,\n        i == 0 <==> u8_leading_zeros(i) == 8,\n        // i^th bit from the left is 1\n        0 <= u8_leading_zeros(i) < 8 ==> (i >> sub(7u8, u8_leading_zeros(i) as u8)) & 1u8 != 0u8,\n        // leading bits are 0\n        i >> sub(8, u8_leading_zeros(i) as u8) == 0,\n        forall|j: u8| 8 - u8_leading_zeros(i) <= j < 8 ==> #[trigger] (i >> j) & 1u8 == 0u8,\n    decreases i,",
        "ensures": [
          "0 <= #[trigger] u8_leading_zeros(i) <= 8",
          "i == 0 <==> u8_leading_zeros(i) == 8",
          "// i^th bit from the left is 1\n        0 <= u8_leading_zeros(i) < 8 ==> (i >> sub(7u8, u8_leading_zeros(i) as u8)) & 1u8 != 0u8",
          "// leading bits are 0\n        i >> sub(8, u8_leading_zeros(i) as u8) == 0",
          "forall|j: u8| 8 - u8_leading_zeros(i) <= j < 8 ==> #[trigger] (i >> j) & 1u8 == 0u8"
        ],
        "requires": [],
        "body": "{\n    assert(i / 2 == (i >> 1u8)) by (bit_vector);\n    assert(((i >> 1) >> sub(7u8, 0)) & 1u8 == 0u8) by (bit_vector);\n    let x = u8_leading_zeros(i / 2) as u8;\n    assert(i >> 0 == i) by (bit_vector);\n    assert(1u8 & 1u8 == 1u8) by (bit_vector);\n    assert(0 < x < 8 ==> ((i >> 1) >> sub(7u8, x)) == (i >> sub(7u8, sub(x, 1)))) by (bit_vector);\n    assert(0 < x <= 8 ==> (i >> 1) >> sub(8, x) == 0 ==> i >> sub(8, sub(x, 1)) == 0)\n        by (bit_vector);\n    if i != 0 {\n        axiom_u8_leading_zeros(i / 2);\n    }\n    assert forall|j: u8| 8 - u8_leading_zeros(i) <= j < 8 implies #[trigger] (i >> j) & 1u8\n        == 0u8 by {\n        let y = u8_leading_zeros(i) as u8;\n        assert(y <= 8 ==> i >> sub(8, y) == 0 ==> sub(8, y) <= j < 8 ==> (i >> j) & 1u8 == 0u8)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u8_leading_zeros(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 123,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "u8_leading_zeros",
          "axiom_u8_leading_zeros"
        ]
      },
      "axiom_u8_leading_ones": {
        "name": "axiom_u8_leading_ones",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u8_leading_ones(i: u8)\n    ensures\n        0 <= #[trigger] u8_leading_ones(i) <= 8,\n        i == 0xffu8 <==> u8_leading_ones(i) == 8,\n        // i^th bit from the left is 0\n        0 <= u8_leading_ones(i) < 8 ==> (i >> sub(7u8, u8_leading_ones(i) as u8)) & 1u8 == 0u8,\n        (!i) >> sub(8, u8_leading_ones(i) as u8) == 0,\n        forall|j: u8| 8 - u8_leading_ones(i) <= j < 8 ==> #[trigger] (i >> j) & 1u8 == 1u8,",
        "ensures": [
          "0 <= #[trigger] u8_leading_ones(i) <= 8",
          "i == 0xffu8 <==> u8_leading_ones(i) == 8",
          "// i^th bit from the left is 0\n        0 <= u8_leading_ones(i) < 8 ==> (i >> sub(7u8, u8_leading_ones(i) as u8)) & 1u8 == 0u8",
          "(!i) >> sub(8, u8_leading_ones(i) as u8) == 0",
          "forall|j: u8| 8 - u8_leading_ones(i) <= j < 8 ==> #[trigger] (i >> j) & 1u8 == 1u8"
        ],
        "requires": [],
        "body": "{\n    axiom_u8_leading_zeros(!i);\n    assert(!0xffu8 == 0) by (bit_vector);\n    assert(!i == 0 ==> i == 0xffu8) by (bit_vector);\n    let x = u8_leading_ones(i) as u8;\n    assert(((!i) >> sub(7u8, x)) & 1u8 != 0u8 ==> (i >> sub(7u8, x)) & 1u8 == 0u8) by (bit_vector);\n    assert forall|j: u8| 8 - u8_leading_ones(i) <= j < 8 implies #[trigger] (i >> j) & 1u8\n        == 1u8 by {\n        let y = u8_leading_ones(i) as u8;\n        assert(y <= 8 ==> (!i) >> sub(8, y) == 0 ==> sub(8, y) <= j < 8 ==> (i >> j) & 1u8 == 1u8)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u8_leading_ones(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 153,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "u8_leading_ones",
          "axiom_u8_leading_zeros"
        ]
      },
      "u16_trailing_zeros": {
        "name": "u16_trailing_zeros",
        "type": "closed_spec",
        "signature": "pub closed spec fn u16_trailing_zeros(i: u16) -> u32\n    decreases i,",
        "ensures": [],
        "requires": [],
        "body": "{\n    if i == 0 {\n        16\n    } else if (i & 1) != 0 {\n        0\n    } else {\n        (1 + u16_trailing_zeros(i / 2)) as u32\n    }\n}",
        "doc_comment": "////////////////////////\n//////////////////////// For u16\nEquivalent to `i.trailing_zeros()`.\nSee [`axiom_u16_trailing_zeros`] for useful properties.",
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 175,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "u16_trailing_zeros"
        ]
      },
      "u16_leading_zeros": {
        "name": "u16_leading_zeros",
        "type": "closed_spec",
        "signature": "pub closed spec fn u16_leading_zeros(i: u16) -> u32\n    decreases i,",
        "ensures": [],
        "requires": [],
        "body": "{\n    if i == 0 {\n        16\n    } else {\n        (u16_leading_zeros(i / 2) - 1) as u32\n    }\n}",
        "doc_comment": "Equivalent to `i.leading_zeros()`.\nSee [`axiom_u16_leading_zeros`] for useful properties.",
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 191,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "u16_leading_zeros"
        ]
      },
      "axiom_u16_trailing_zeros": {
        "name": "axiom_u16_trailing_zeros",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u16_trailing_zeros(i: u16)\n    ensures\n        0 <= #[trigger] u16_trailing_zeros(i) <= 16,\n        i == 0 <==> u16_trailing_zeros(i) == 16,\n        // i^th bit is 1\n        0 <= u16_trailing_zeros(i) < 16 ==> (i >> u16_trailing_zeros(i) as u16) & 1u16 == 1u16,\n        // trailing bits are 0\n        i << sub(16, u16_trailing_zeros(i) as u16) == 0,\n        forall|j: u16| 0 <= j < u16_trailing_zeros(i) ==> #[trigger] (i >> j) & 1u16 == 0u16,\n    decreases i,",
        "ensures": [
          "0 <= #[trigger] u16_trailing_zeros(i) <= 16",
          "i == 0 <==> u16_trailing_zeros(i) == 16",
          "// i^th bit is 1\n        0 <= u16_trailing_zeros(i) < 16 ==> (i >> u16_trailing_zeros(i) as u16) & 1u16 == 1u16",
          "// trailing bits are 0\n        i << sub(16, u16_trailing_zeros(i) as u16) == 0",
          "forall|j: u16| 0 <= j < u16_trailing_zeros(i) ==> #[trigger] (i >> j) & 1u16 == 0u16"
        ],
        "requires": [],
        "body": "{\n    assert(i >> 0 == i) by (bit_vector);\n    assert(i << 0 == i) by (bit_vector);\n    assert(i & 0 == 0) by (bit_vector);\n    assert(i / 2 == (i >> 1u16)) by (bit_vector);\n    assert((i & 1) == 0 ==> i != 1) by (bit_vector);\n    let x = u16_trailing_zeros(i / 2) as u16;\n    assert(x < 16 ==> (i >> 1) >> x == (i >> add(x, 1))) by (bit_vector);\n    assert(i << 16 == 0) by (bit_vector);\n    assert(i & 1 != 0 ==> i & 1 == 1) by (bit_vector);\n    assert((i & 1) == 0 ==> (i >> 1) << sub(16, x) == 0 ==> i << sub(16, add(x, 1)) == 0)\n        by (bit_vector);\n    if i != 0 {\n        axiom_u16_trailing_zeros(i / 2);\n    }\n    assert forall|j: u16| 0 <= j < u16_trailing_zeros(i) implies #[trigger] (i >> j) & 1u16\n        == 0u16 by {\n        let y = u16_trailing_zeros(i) as u16;\n        assert(y <= 16 ==> i << sub(16, y) == 0 && 0 <= j < y ==> (i >> j) & 1u16 == 0u16)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u16_trailing_zeros(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 239,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u16_trailing_zeros",
          "u16_trailing_zeros"
        ]
      },
      "axiom_u16_trailing_ones": {
        "name": "axiom_u16_trailing_ones",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u16_trailing_ones(i: u16)\n    ensures\n        0 <= #[trigger] u16_trailing_ones(i) <= 16,\n        i == 0xffffu16 <==> u16_trailing_ones(i) == 16,\n        // i^th bit is 0\n        0 <= u16_trailing_ones(i) < 16 ==> (i >> u16_trailing_ones(i) as u16) & 1u16 == 0u16,\n        // trailing bits are 1\n        (!i) << sub(16, u16_trailing_ones(i) as u16) == 0,\n        forall|j: u16| 0 <= j < u16_trailing_ones(i) ==> #[trigger] (i >> j) & 1u16 == 1u16,",
        "ensures": [
          "0 <= #[trigger] u16_trailing_ones(i) <= 16",
          "i == 0xffffu16 <==> u16_trailing_ones(i) == 16",
          "// i^th bit is 0\n        0 <= u16_trailing_ones(i) < 16 ==> (i >> u16_trailing_ones(i) as u16) & 1u16 == 0u16",
          "// trailing bits are 1\n        (!i) << sub(16, u16_trailing_ones(i) as u16) == 0",
          "forall|j: u16| 0 <= j < u16_trailing_ones(i) ==> #[trigger] (i >> j) & 1u16 == 1u16"
        ],
        "requires": [],
        "body": "{\n    axiom_u16_trailing_zeros(!i);\n    assert(!0xffffu16 == 0) by (bit_vector);\n    assert(!i == 0 ==> i == 0xffffu16) by (bit_vector);\n    let x = u16_trailing_ones(i) as u16;\n    assert(((!i) >> x) & 1u16 == 1u16 ==> (i >> x) & 1u16 == 0u16) by (bit_vector);\n    assert forall|j: u16| 0 <= j < u16_trailing_ones(i) implies #[trigger] (i >> j) & 1u16\n        == 1u16 by {\n        let y = u16_trailing_ones(i) as u16;\n        assert(y <= 16 ==> (!i) << sub(16, y) == 0 && 0 <= j < y ==> (i >> j) & 1u16 == 1u16)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u16_trailing_ones(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 272,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u16_trailing_zeros",
          "u16_trailing_ones"
        ]
      },
      "axiom_u16_leading_zeros": {
        "name": "axiom_u16_leading_zeros",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u16_leading_zeros(i: u16)\n    ensures\n        0 <= #[trigger] u16_leading_zeros(i) <= 16,\n        i == 0 <==> u16_leading_zeros(i) == 16,\n        // i^th bit from the left is 1\n        0 <= u16_leading_zeros(i) < 16 ==> (i >> sub(15u16, u16_leading_zeros(i) as u16)) & 1u16\n            != 0u16,\n        // leading bits are 0\n        i >> sub(16, u16_leading_zeros(i) as u16) == 0,\n        forall|j: u16| 16 - u16_leading_zeros(i) <= j < 16 ==> #[trigger] (i >> j) & 1u16 == 0u16,\n    decreases i,",
        "ensures": [
          "0 <= #[trigger] u16_leading_zeros(i) <= 16",
          "i == 0 <==> u16_leading_zeros(i) == 16",
          "// i^th bit from the left is 1\n        0 <= u16_leading_zeros(i) < 16 ==> (i >> sub(15u16, u16_leading_zeros(i) as u16)) & 1u16\n            != 0u16",
          "// leading bits are 0\n        i >> sub(16, u16_leading_zeros(i) as u16) == 0",
          "forall|j: u16| 16 - u16_leading_zeros(i) <= j < 16 ==> #[trigger] (i >> j) & 1u16 == 0u16"
        ],
        "requires": [],
        "body": "{\n    assert(i / 2 == (i >> 1u16)) by (bit_vector);\n    assert(((i >> 1) >> sub(15u16, 0)) & 1u16 == 0u16) by (bit_vector);\n    let x = u16_leading_zeros(i / 2) as u16;\n    assert(i >> 0 == i) by (bit_vector);\n    assert(1u16 & 1u16 == 1u16) by (bit_vector);\n    assert(0 < x < 16 ==> ((i >> 1) >> sub(15u16, x)) == (i >> sub(15u16, sub(x, 1))))\n        by (bit_vector);\n    assert(0 < x <= 16 ==> (i >> 1) >> sub(16, x) == 0 ==> i >> sub(16, sub(x, 1)) == 0)\n        by (bit_vector);\n    if i != 0 {\n        axiom_u16_leading_zeros(i / 2);\n    }\n    assert forall|j: u16| 16 - u16_leading_zeros(i) <= j < 16 implies #[trigger] (i >> j) & 1u16\n        == 0u16 by {\n        let y = u16_leading_zeros(i) as u16;\n        assert(y <= 16 ==> i >> sub(16, y) == 0 ==> sub(16, y) <= j < 16 ==> (i >> j) & 1u16\n            == 0u16) by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u16_leading_zeros(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 295,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u16_leading_zeros",
          "u16_leading_zeros"
        ]
      },
      "axiom_u16_leading_ones": {
        "name": "axiom_u16_leading_ones",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u16_leading_ones(i: u16)\n    ensures\n        0 <= #[trigger] u16_leading_ones(i) <= 16,\n        i == 0xffffu16 <==> u16_leading_ones(i) == 16,\n        // i^th bit from the left is 0\n        0 <= u16_leading_ones(i) < 16 ==> (i >> sub(15u16, u16_leading_ones(i) as u16)) & 1u16\n            == 0u16,\n        (!i) >> sub(16, u16_leading_ones(i) as u16) == 0,\n        forall|j: u16| 16 - u16_leading_ones(i) <= j < 16 ==> #[trigger] (i >> j) & 1u16 == 1u16,",
        "ensures": [
          "0 <= #[trigger] u16_leading_ones(i) <= 16",
          "i == 0xffffu16 <==> u16_leading_ones(i) == 16",
          "// i^th bit from the left is 0\n        0 <= u16_leading_ones(i) < 16 ==> (i >> sub(15u16, u16_leading_ones(i) as u16)) & 1u16\n            == 0u16",
          "(!i) >> sub(16, u16_leading_ones(i) as u16) == 0",
          "forall|j: u16| 16 - u16_leading_ones(i) <= j < 16 ==> #[trigger] (i >> j) & 1u16 == 1u16"
        ],
        "requires": [],
        "body": "{\n    axiom_u16_leading_zeros(!i);\n    assert(!0xffffu16 == 0) by (bit_vector);\n    assert(!i == 0 ==> i == 0xffffu16) by (bit_vector);\n    let x = u16_leading_ones(i) as u16;\n    assert(((!i) >> sub(15u16, x)) & 1u16 != 0u16 ==> (i >> sub(15u16, x)) & 1u16 == 0u16)\n        by (bit_vector);\n    assert forall|j: u16| 16 - u16_leading_ones(i) <= j < 16 implies #[trigger] (i >> j) & 1u16\n        == 1u16 by {\n        let y = u16_leading_ones(i) as u16;\n        assert(y <= 16 ==> (!i) >> sub(16, y) == 0 ==> sub(16, y) <= j < 16 ==> (i >> j) & 1u16\n            == 1u16) by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u16_leading_ones(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 327,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u16_leading_zeros",
          "u16_leading_ones"
        ]
      },
      "u32_trailing_zeros": {
        "name": "u32_trailing_zeros",
        "type": "closed_spec",
        "signature": "pub closed spec fn u32_trailing_zeros(i: u32) -> u32\n    decreases i,",
        "ensures": [],
        "requires": [],
        "body": "{\n    if i == 0 {\n        32\n    } else if (i & 1) != 0 {\n        0\n    } else {\n        (1 + u32_trailing_zeros(i / 2)) as u32\n    }\n}",
        "doc_comment": "////////////////////////\n//////////////////////// For u32\nEquivalent to `i.trailing_zeros()`.\nSee [`axiom_u32_trailing_zeros`] for useful properties.",
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 351,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "u32_trailing_zeros"
        ]
      },
      "u32_leading_zeros": {
        "name": "u32_leading_zeros",
        "type": "closed_spec",
        "signature": "pub closed spec fn u32_leading_zeros(i: u32) -> u32\n    decreases i,",
        "ensures": [],
        "requires": [],
        "body": "{\n    if i == 0 {\n        32\n    } else {\n        (u32_leading_zeros(i / 2) - 1) as u32\n    }\n}",
        "doc_comment": "Equivalent to `i.leading_zeros()`.\nSee [`axiom_u32_leading_zeros`] for useful properties.",
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 367,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "u32_leading_zeros"
        ]
      },
      "axiom_u32_trailing_zeros": {
        "name": "axiom_u32_trailing_zeros",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u32_trailing_zeros(i: u32)\n    ensures\n        0 <= #[trigger] u32_trailing_zeros(i) <= 32,\n        i == 0 <==> u32_trailing_zeros(i) == 32,\n        // i^th bit is 1\n        0 <= u32_trailing_zeros(i) < 32 ==> (i >> u32_trailing_zeros(i) as u32) & 1u32 == 1u32,\n        // trailing bits are 0\n        i << sub(32, u32_trailing_zeros(i) as u32) == 0,\n        forall|j: u32| 0 <= j < u32_trailing_zeros(i) ==> #[trigger] (i >> j) & 1u32 == 0u32,\n    decreases i,",
        "ensures": [
          "0 <= #[trigger] u32_trailing_zeros(i) <= 32",
          "i == 0 <==> u32_trailing_zeros(i) == 32",
          "// i^th bit is 1\n        0 <= u32_trailing_zeros(i) < 32 ==> (i >> u32_trailing_zeros(i) as u32) & 1u32 == 1u32",
          "// trailing bits are 0\n        i << sub(32, u32_trailing_zeros(i) as u32) == 0",
          "forall|j: u32| 0 <= j < u32_trailing_zeros(i) ==> #[trigger] (i >> j) & 1u32 == 0u32"
        ],
        "requires": [],
        "body": "{\n    assert(i >> 0 == i) by (bit_vector);\n    assert(i << 0 == i) by (bit_vector);\n    assert(i & 0 == 0) by (bit_vector);\n    assert(i / 2 == (i >> 1u32)) by (bit_vector);\n    assert((i & 1) == 0 ==> i != 1) by (bit_vector);\n    let x = u32_trailing_zeros(i / 2) as u32;\n    assert(x < 32 ==> (i >> 1) >> x == (i >> add(x, 1))) by (bit_vector);\n    assert(i << 32 == 0) by (bit_vector);\n    assert(i & 1 != 0 ==> i & 1 == 1) by (bit_vector);\n    assert((i & 1) == 0 ==> (i >> 1) << sub(32, x) == 0 ==> i << sub(32, add(x, 1)) == 0)\n        by (bit_vector);\n    if i != 0 {\n        axiom_u32_trailing_zeros(i / 2);\n    }\n    assert forall|j: u32| 0 <= j < u32_trailing_zeros(i) implies #[trigger] (i >> j) & 1u32\n        == 0u32 by {\n        let y = u32_trailing_zeros(i) as u32;\n        assert(y <= 32 ==> i << sub(32, y) == 0 && 0 <= j < y ==> (i >> j) & 1u32 == 0u32)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u32_trailing_zeros(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 415,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "u32_trailing_zeros",
          "axiom_u32_trailing_zeros"
        ]
      },
      "axiom_u32_trailing_ones": {
        "name": "axiom_u32_trailing_ones",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u32_trailing_ones(i: u32)\n    ensures\n        0 <= #[trigger] u32_trailing_ones(i) <= 32,\n        i == 0xffff_ffffu32 <==> u32_trailing_ones(i) == 32,\n        // i^th bit is 0\n        0 <= u32_trailing_ones(i) < 32 ==> (i >> u32_trailing_ones(i) as u32) & 1u32 == 0u32,\n        // trailing bits are 1\n        (!i) << sub(32, u32_trailing_ones(i) as u32) == 0,\n        forall|j: u32| 0 <= j < u32_trailing_ones(i) ==> #[trigger] (i >> j) & 1u32 == 1u32,",
        "ensures": [
          "0 <= #[trigger] u32_trailing_ones(i) <= 32",
          "i == 0xffff_ffffu32 <==> u32_trailing_ones(i) == 32",
          "// i^th bit is 0\n        0 <= u32_trailing_ones(i) < 32 ==> (i >> u32_trailing_ones(i) as u32) & 1u32 == 0u32",
          "// trailing bits are 1\n        (!i) << sub(32, u32_trailing_ones(i) as u32) == 0",
          "forall|j: u32| 0 <= j < u32_trailing_ones(i) ==> #[trigger] (i >> j) & 1u32 == 1u32"
        ],
        "requires": [],
        "body": "{\n    axiom_u32_trailing_zeros(!i);\n    assert(!0xffff_ffffu32 == 0) by (bit_vector);\n    assert(!i == 0 ==> i == 0xffff_ffffu32) by (bit_vector);\n    let x = u32_trailing_ones(i) as u32;\n    assert(((!i) >> x) & 1u32 == 1u32 ==> (i >> x) & 1u32 == 0u32) by (bit_vector);\n    assert forall|j: u32| 0 <= j < u32_trailing_ones(i) implies #[trigger] (i >> j) & 1u32\n        == 1u32 by {\n        let y = u32_trailing_ones(i) as u32;\n        assert(y <= 32 ==> (!i) << sub(32, y) == 0 && 0 <= j < y ==> (i >> j) & 1u32 == 1u32)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u32_trailing_ones(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 448,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "u32_trailing_ones",
          "axiom_u32_trailing_zeros"
        ]
      },
      "axiom_u32_leading_zeros": {
        "name": "axiom_u32_leading_zeros",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u32_leading_zeros(i: u32)\n    ensures\n        0 <= #[trigger] u32_leading_zeros(i) <= 32,\n        i == 0 <==> u32_leading_zeros(i) == 32,\n        // i^th bit from the left is 1\n        0 <= u32_leading_zeros(i) < 32 ==> (i >> sub(31u32, u32_leading_zeros(i) as u32)) & 1u32\n            != 0u32,\n        // leading bits are 0\n        i >> sub(32, u32_leading_zeros(i) as u32) == 0,\n        forall|j: u32| 32 - u32_leading_zeros(i) <= j < 32 ==> #[trigger] (i >> j) & 1u32 == 0u32,\n    decreases i,",
        "ensures": [
          "0 <= #[trigger] u32_leading_zeros(i) <= 32",
          "i == 0 <==> u32_leading_zeros(i) == 32",
          "// i^th bit from the left is 1\n        0 <= u32_leading_zeros(i) < 32 ==> (i >> sub(31u32, u32_leading_zeros(i) as u32)) & 1u32\n            != 0u32",
          "// leading bits are 0\n        i >> sub(32, u32_leading_zeros(i) as u32) == 0",
          "forall|j: u32| 32 - u32_leading_zeros(i) <= j < 32 ==> #[trigger] (i >> j) & 1u32 == 0u32"
        ],
        "requires": [],
        "body": "{\n    assert(i / 2 == (i >> 1u32)) by (bit_vector);\n    assert(((i >> 1) >> sub(31u32, 0)) & 1u32 == 0u32) by (bit_vector);\n    let x = u32_leading_zeros(i / 2) as u32;\n    assert(i >> 0 == i) by (bit_vector);\n    assert(1u32 & 1u32 == 1u32) by (bit_vector);\n    assert(0 < x < 32 ==> ((i >> 1) >> sub(31u32, x)) == (i >> sub(31u32, sub(x, 1))))\n        by (bit_vector);\n    assert(0 < x <= 32 ==> (i >> 1) >> sub(32, x) == 0 ==> i >> sub(32, sub(x, 1)) == 0)\n        by (bit_vector);\n    if i != 0 {\n        axiom_u32_leading_zeros(i / 2);\n    }\n    assert forall|j: u32| 32 - u32_leading_zeros(i) <= j < 32 implies #[trigger] (i >> j) & 1u32\n        == 0u32 by {\n        let y = u32_leading_zeros(i) as u32;\n        assert(y <= 32 ==> i >> sub(32, y) == 0 ==> sub(32, y) <= j < 32 ==> (i >> j) & 1u32\n            == 0u32) by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u32_leading_zeros(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 471,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u32_leading_zeros",
          "u32_leading_zeros"
        ]
      },
      "axiom_u32_leading_ones": {
        "name": "axiom_u32_leading_ones",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u32_leading_ones(i: u32)\n    ensures\n        0 <= #[trigger] u32_leading_ones(i) <= 32,\n        i == 0xffff_ffffu32 <==> u32_leading_ones(i) == 32,\n        // i^th bit from the left is 0\n        0 <= u32_leading_ones(i) < 32 ==> (i >> sub(31u32, u32_leading_ones(i) as u32)) & 1u32\n            == 0u32,\n        (!i) >> sub(32, u32_leading_ones(i) as u32) == 0,\n        forall|j: u32| 32 - u32_leading_ones(i) <= j < 32 ==> #[trigger] (i >> j) & 1u32 == 1u32,",
        "ensures": [
          "0 <= #[trigger] u32_leading_ones(i) <= 32",
          "i == 0xffff_ffffu32 <==> u32_leading_ones(i) == 32",
          "// i^th bit from the left is 0\n        0 <= u32_leading_ones(i) < 32 ==> (i >> sub(31u32, u32_leading_ones(i) as u32)) & 1u32\n            == 0u32",
          "(!i) >> sub(32, u32_leading_ones(i) as u32) == 0",
          "forall|j: u32| 32 - u32_leading_ones(i) <= j < 32 ==> #[trigger] (i >> j) & 1u32 == 1u32"
        ],
        "requires": [],
        "body": "{\n    axiom_u32_leading_zeros(!i);\n    assert(!0xffff_ffffu32 == 0) by (bit_vector);\n    assert(!i == 0 ==> i == 0xffff_ffffu32) by (bit_vector);\n    let x = u32_leading_ones(i) as u32;\n    assert(((!i) >> sub(31u32, x)) & 1u32 != 0u32 ==> (i >> sub(31u32, x)) & 1u32 == 0u32)\n        by (bit_vector);\n    assert forall|j: u32| 32 - u32_leading_ones(i) <= j < 32 implies #[trigger] (i >> j) & 1u32\n        == 1u32 by {\n        let y = u32_leading_ones(i) as u32;\n        assert(y <= 32 ==> (!i) >> sub(32, y) == 0 ==> sub(32, y) <= j < 32 ==> (i >> j) & 1u32\n            == 1u32) by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u32_leading_ones(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 503,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u32_leading_zeros",
          "u32_leading_ones"
        ]
      },
      "u64_trailing_zeros": {
        "name": "u64_trailing_zeros",
        "type": "closed_spec",
        "signature": "pub closed spec fn u64_trailing_zeros(i: u64) -> u32\n    decreases i,",
        "ensures": [],
        "requires": [],
        "body": "{\n    if i == 0 {\n        64\n    } else if (i & 1) != 0 {\n        0\n    } else {\n        (1 + u64_trailing_zeros(i / 2)) as u32\n    }\n}",
        "doc_comment": "////////////////////////\n//////////////////////// For u64\nEquivalent to `i.trailing_zeros()`.\nSee [`axiom_u64_trailing_zeros`] for useful properties.",
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 527,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases"
        ],
        "callees": [
          "u64_trailing_zeros"
        ]
      },
      "axiom_u64_trailing_zeros": {
        "name": "axiom_u64_trailing_zeros",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u64_trailing_zeros(i: u64)\n    ensures\n        0 <= #[trigger] u64_trailing_zeros(i) <= 64,\n        i == 0 <==> u64_trailing_zeros(i) == 64,\n        // i^th bit is 1\n        0 <= u64_trailing_zeros(i) < 64 ==> (i >> u64_trailing_zeros(i) as u64) & 1u64 == 1u64,\n        // trailing bits are 0\n        i << sub(64, u64_trailing_zeros(i) as u64) == 0,\n        forall|j: u64| 0 <= j < u64_trailing_zeros(i) ==> #[trigger] (i >> j) & 1u64 == 0u64,\n    decreases i,",
        "ensures": [
          "0 <= #[trigger] u64_trailing_zeros(i) <= 64",
          "i == 0 <==> u64_trailing_zeros(i) == 64",
          "// i^th bit is 1\n        0 <= u64_trailing_zeros(i) < 64 ==> (i >> u64_trailing_zeros(i) as u64) & 1u64 == 1u64",
          "// trailing bits are 0\n        i << sub(64, u64_trailing_zeros(i) as u64) == 0",
          "forall|j: u64| 0 <= j < u64_trailing_zeros(i) ==> #[trigger] (i >> j) & 1u64 == 0u64"
        ],
        "requires": [],
        "body": "{\n    assert(i >> 0 == i) by (bit_vector);\n    assert(i << 0 == i) by (bit_vector);\n    assert(i & 0 == 0) by (bit_vector);\n    assert(i / 2 == (i >> 1u64)) by (bit_vector);\n    assert((i & 1) == 0 ==> i != 1) by (bit_vector);\n    let x = u64_trailing_zeros(i / 2) as u64;\n    assert(x < 64 ==> (i >> 1) >> x == (i >> add(x, 1))) by (bit_vector);\n    assert(i << 64 == 0) by (bit_vector);\n    assert(i & 1 != 0 ==> i & 1 == 1) by (bit_vector);\n    assert((i & 1) == 0 ==> (i >> 1) << sub(64, x) == 0 ==> i << sub(64, add(x, 1)) == 0)\n        by (bit_vector);\n    if i != 0 {\n        axiom_u64_trailing_zeros(i / 2);\n    }\n    assert forall|j: u64| 0 <= j < u64_trailing_zeros(i) implies #[trigger] (i >> j) & 1u64\n        == 0u64 by {\n        let y = u64_trailing_zeros(i) as u64;\n        assert(y <= 64 ==> i << sub(64, y) == 0 && 0 <= j < y ==> (i >> j) & 1u64 == 0u64)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u64_trailing_zeros(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 592,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u64_trailing_zeros",
          "u64_trailing_zeros"
        ]
      },
      "axiom_u64_trailing_ones": {
        "name": "axiom_u64_trailing_ones",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u64_trailing_ones(i: u64)\n    ensures\n        0 <= #[trigger] u64_trailing_ones(i) <= 64,\n        i == 0xffff_ffff_ffff_ffffu64 <==> u64_trailing_ones(i) == 64,\n        // i^th bit is 0\n        0 <= u64_trailing_ones(i) < 64 ==> (i >> u64_trailing_ones(i) as u64) & 1u64 == 0u64,\n        // trailing bits are 1\n        (!i) << sub(64, u64_trailing_ones(i) as u64) == 0,\n        forall|j: u64| 0 <= j < u64_trailing_ones(i) ==> #[trigger] (i >> j) & 1u64 == 1u64,",
        "ensures": [
          "0 <= #[trigger] u64_trailing_ones(i) <= 64",
          "i == 0xffff_ffff_ffff_ffffu64 <==> u64_trailing_ones(i) == 64",
          "// i^th bit is 0\n        0 <= u64_trailing_ones(i) < 64 ==> (i >> u64_trailing_ones(i) as u64) & 1u64 == 0u64",
          "// trailing bits are 1\n        (!i) << sub(64, u64_trailing_ones(i) as u64) == 0",
          "forall|j: u64| 0 <= j < u64_trailing_ones(i) ==> #[trigger] (i >> j) & 1u64 == 1u64"
        ],
        "requires": [],
        "body": "{\n    axiom_u64_trailing_zeros(!i);\n    assert(!0xffff_ffff_ffff_ffffu64 == 0) by (bit_vector);\n    assert(!i == 0 ==> i == 0xffff_ffff_ffff_ffffu64) by (bit_vector);\n    let x = u64_trailing_ones(i) as u64;\n    assert(((!i) >> x) & 1u64 == 1u64 ==> (i >> x) & 1u64 == 0u64) by (bit_vector);\n    assert forall|j: u64| 0 <= j < u64_trailing_ones(i) implies #[trigger] (i >> j) & 1u64\n        == 1u64 by {\n        let y = u64_trailing_ones(i) as u64;\n        assert(y <= 64 ==> (!i) << sub(64, y) == 0 && 0 <= j < y ==> (i >> j) & 1u64 == 1u64)\n            by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u64_trailing_ones(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 625,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "u64_trailing_ones",
          "axiom_u64_trailing_zeros"
        ]
      },
      "axiom_u64_leading_zeros": {
        "name": "axiom_u64_leading_zeros",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u64_leading_zeros(i: u64)\n    ensures\n        0 <= #[trigger] u64_leading_zeros(i) <= 64,\n        i == 0 <==> u64_leading_zeros(i) == 64,\n        // i^th bit from the left is 1\n        0 <= u64_leading_zeros(i) < 64 ==> (i >> sub(63u64, u64_leading_zeros(i) as u64)) & 1u64\n            != 0u64,\n        // leading bits are 0\n        i >> sub(64, u64_leading_zeros(i) as u64) == 0,\n        forall|j: u64| 64 - u64_leading_zeros(i) <= j < 64 ==> #[trigger] (i >> j) & 1u64 == 0u64,\n    decreases i,",
        "ensures": [
          "0 <= #[trigger] u64_leading_zeros(i) <= 64",
          "i == 0 <==> u64_leading_zeros(i) == 64",
          "// i^th bit from the left is 1\n        0 <= u64_leading_zeros(i) < 64 ==> (i >> sub(63u64, u64_leading_zeros(i) as u64)) & 1u64\n            != 0u64",
          "// leading bits are 0\n        i >> sub(64, u64_leading_zeros(i) as u64) == 0",
          "forall|j: u64| 64 - u64_leading_zeros(i) <= j < 64 ==> #[trigger] (i >> j) & 1u64 == 0u64"
        ],
        "requires": [],
        "body": "{\n    reveal(u64_leading_zeros);\n    assert(i / 2 == (i >> 1u64)) by (bit_vector);\n    assert(((i >> 1) >> sub(63u64, 0)) & 1u64 == 0u64) by (bit_vector);\n    let x = u64_leading_zeros(i / 2) as u64;\n    assert(i >> 0 == i) by (bit_vector);\n    assert(1u64 & 1u64 == 1u64) by (bit_vector);\n    assert(0 < x < 64 ==> ((i >> 1) >> sub(63u64, x)) == (i >> sub(63u64, sub(x, 1))))\n        by (bit_vector);\n    assert(0 < x <= 64 ==> (i >> 1) >> sub(64, x) == 0 ==> i >> sub(64, sub(x, 1)) == 0)\n        by (bit_vector);\n    if i != 0 {\n        axiom_u64_leading_zeros(i / 2);\n    }\n    assert forall|j: u64| 64 - u64_leading_zeros(i) <= j < 64 implies #[trigger] (i >> j) & 1u64\n        == 0u64 by {\n        let y = u64_leading_zeros(i) as u64;\n        assert(y <= 64 ==> i >> sub(64, y) == 0 ==> sub(64, y) <= j < 64 ==> (i >> j) & 1u64\n            == 0u64) by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u64_leading_zeros(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 648,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases",
          "forall",
          "trigger"
        ],
        "callees": [
          "axiom_u64_leading_zeros",
          "u64_leading_zeros"
        ]
      },
      "axiom_u64_leading_ones": {
        "name": "axiom_u64_leading_ones",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u64_leading_ones(i: u64)\n    ensures\n        0 <= #[trigger] u64_leading_ones(i) <= 64,\n        i == 0xffff_ffff_ffff_ffffu64 <==> u64_leading_ones(i) == 64,\n        // i^th bit from the left is 0\n        0 <= u64_leading_ones(i) < 64 ==> (i >> sub(63u64, u64_leading_ones(i) as u64)) & 1u64\n            == 0u64,\n        (!i) >> sub(64, u64_leading_ones(i) as u64) == 0,\n        forall|j: u64| 64 - u64_leading_ones(i) <= j < 64 ==> #[trigger] (i >> j) & 1u64 == 1u64,",
        "ensures": [
          "0 <= #[trigger] u64_leading_ones(i) <= 64",
          "i == 0xffff_ffff_ffff_ffffu64 <==> u64_leading_ones(i) == 64",
          "// i^th bit from the left is 0\n        0 <= u64_leading_ones(i) < 64 ==> (i >> sub(63u64, u64_leading_ones(i) as u64)) & 1u64\n            == 0u64",
          "(!i) >> sub(64, u64_leading_ones(i) as u64) == 0",
          "forall|j: u64| 64 - u64_leading_ones(i) <= j < 64 ==> #[trigger] (i >> j) & 1u64 == 1u64"
        ],
        "requires": [],
        "body": "{\n    axiom_u64_leading_zeros(!i);\n    assert(!0xffff_ffff_ffff_ffffu64 == 0) by (bit_vector);\n    assert(!i == 0 ==> i == 0xffff_ffff_ffff_ffffu64) by (bit_vector);\n    let x = u64_leading_ones(i) as u64;\n    assert(((!i) >> sub(63u64, x)) & 1u64 != 0u64 ==> (i >> sub(63u64, x)) & 1u64 == 0u64)\n        by (bit_vector);\n    assert forall|j: u64| 64 - u64_leading_ones(i) <= j < 64 implies #[trigger] (i >> j) & 1u64\n        == 1u64 by {\n        let y = u64_leading_ones(i) as u64;\n        assert(y <= 64 ==> (!i) >> sub(64, y) == 0 ==> sub(64, y) <= j < 64 ==> (i >> j) & 1u64\n            == 1u64) by (bit_vector);\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "u64_leading_ones(i",
          "(i >> j"
        ],
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 681,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "forall",
          "trigger"
        ],
        "callees": [
          "u64_leading_ones",
          "axiom_u64_leading_zeros"
        ]
      },
      "eq_ensures": {
        "name": "eq_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn eq_ensures<A>(x: A, y: A, o: bool) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/cmp.rs",
        "line_number": 250,
        "module": "vstd::std_specs::cmp",
        "keywords": [],
        "callees": []
      },
      "ne_ensures": {
        "name": "ne_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn ne_ensures<A>(x: A, y: A, o: bool) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/cmp.rs",
        "line_number": 252,
        "module": "vstd::std_specs::cmp",
        "keywords": [],
        "callees": []
      },
      "partial_cmp_ensures": {
        "name": "partial_cmp_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn partial_cmp_ensures<A>(x: A, y: A, o: Option<Ordering>) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/cmp.rs",
        "line_number": 254,
        "module": "vstd::std_specs::cmp",
        "keywords": [],
        "callees": []
      },
      "lt_ensures": {
        "name": "lt_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn lt_ensures<A>(x: A, y: A, o: bool) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/cmp.rs",
        "line_number": 256,
        "module": "vstd::std_specs::cmp",
        "keywords": [],
        "callees": []
      },
      "le_ensures": {
        "name": "le_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn le_ensures<A>(x: A, y: A, o: bool) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/cmp.rs",
        "line_number": 258,
        "module": "vstd::std_specs::cmp",
        "keywords": [],
        "callees": []
      },
      "gt_ensures": {
        "name": "gt_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn gt_ensures<A>(x: A, y: A, o: bool) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/cmp.rs",
        "line_number": 260,
        "module": "vstd::std_specs::cmp",
        "keywords": [],
        "callees": []
      },
      "ge_ensures": {
        "name": "ge_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn ge_ensures<A>(x: A, y: A, o: bool) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/cmp.rs",
        "line_number": 262,
        "module": "vstd::std_specs::cmp",
        "keywords": [],
        "callees": []
      },
      "spec_from": {
        "name": "spec_from",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_from<S, T>(value: T, ret: S) -> bool",
        "ensures": [
          "#[trigger] spec_from::<T, T>(t, s) ==> t == s"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_from::<T"
        ],
        "file_path": "verus/source/vstd/std_specs/control_flow.rs",
        "line_number": 45,
        "module": "vstd::std_specs::control_flow",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "spec_from_blanket_identity": {
        "name": "spec_from_blanket_identity",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn spec_from_blanket_identity<T>(t: T, s: T)\n    ensures\n        #[trigger] spec_from::<T, T>(t, s) ==> t == s,",
        "ensures": [
          "#[trigger] spec_from::<T, T>(t, s) ==> t == s"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_from::<T"
        ],
        "file_path": "verus/source/vstd/std_specs/control_flow.rs",
        "line_number": 47,
        "module": "vstd::std_specs::control_flow",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "obeys_key_model": {
        "name": "obeys_key_model",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn obeys_key_model<Key: ?Sized>() -> bool",
        "ensures": [
          "#[trigger] obeys_key_model::<bool>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": "Specifies whether a type `Key` conforms to our requirements to be\na key in our hash table (and hash set) model.\n\nThe three requirements are (1) the hash function is deterministic,\n(2) any two keys of type `Key` are identical if and only if they\nare considered equal by the executable `==` operator, and (3) the\nexecutable `Key::clone` function produces a result identical to\nits input. Requirement (1) isn't satisfied by having `Key`\nimplement `Hash`, since this trait doesn't mandate determinism.\n\nThe standard library has axioms that all primitive types and `Box`es\nthereof obey this model. If you want to use some other key\ntype `MyKey`, you need to explicitly state your assumption that it\ndoes so with\n`assume(vstd::std_specs::hash::obeys_key_model::<MyKey>())`.\nIn the future, we plan to devise a way for you to prove that it\ndoes so, so that you don't have to make such an assumption.",
        "triggers": [
          "obeys_key_model::<bool>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 83,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_bool_obeys_hash_table_key_model": {
        "name": "axiom_bool_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_bool_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<bool>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<bool>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<bool>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 108,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_u8_obeys_hash_table_key_model": {
        "name": "axiom_u8_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u8_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<u8>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<u8>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<u8>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 114,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_u16_obeys_hash_table_key_model": {
        "name": "axiom_u16_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u16_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<u16>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<u16>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<u16>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 121,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_u32_obeys_hash_table_key_model": {
        "name": "axiom_u32_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u32_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<u32>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<u32>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<u32>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 128,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_u64_obeys_hash_table_key_model": {
        "name": "axiom_u64_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u64_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<u64>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<u64>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<u64>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 135,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_u128_obeys_hash_table_key_model": {
        "name": "axiom_u128_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_u128_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<u128>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<u128>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<u128>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 142,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_usize_obeys_hash_table_key_model": {
        "name": "axiom_usize_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_usize_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<usize>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<usize>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<usize>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 149,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_i8_obeys_hash_table_key_model": {
        "name": "axiom_i8_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_i8_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<i8>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<i8>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<i8>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 156,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_i16_obeys_hash_table_key_model": {
        "name": "axiom_i16_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_i16_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<i16>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<i16>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<i16>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 163,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_i32_obeys_hash_table_key_model": {
        "name": "axiom_i32_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_i32_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<i32>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<i32>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<i32>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 170,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_i164_obeys_hash_table_key_model": {
        "name": "axiom_i164_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_i164_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<i64>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<i64>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<i64>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 177,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_i128_obeys_hash_table_key_model": {
        "name": "axiom_i128_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_i128_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<i128>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<i128>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<i128>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 184,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_isize_obeys_hash_table_key_model": {
        "name": "axiom_isize_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_isize_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<isize>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<isize>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<isize>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 191,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_box_bool_obeys_hash_table_key_model": {
        "name": "axiom_box_bool_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_box_bool_obeys_hash_table_key_model()\n    ensures\n        #[trigger] obeys_key_model::<Box<bool>>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<Box<bool>>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<Box<bool>>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 198,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_box_integer_type_obeys_hash_table_key_model": {
        "name": "axiom_box_integer_type_obeys_hash_table_key_model",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_box_integer_type_obeys_hash_table_key_model<Key: Integer + ?Sized>()\n    requires\n        obeys_key_model::<Key>(),\n    ensures\n        #[trigger] obeys_key_model::<Box<Key>>(),",
        "ensures": [
          "#[trigger] obeys_key_model::<Box<Key>>()"
        ],
        "requires": [
          "obeys_key_model::<Key>()"
        ],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "obeys_key_model::<Box<Key>>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 205,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "builds_valid_hashers": {
        "name": "builds_valid_hashers",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn builds_valid_hashers<T: ?Sized>() -> bool",
        "ensures": [
          "#[trigger] builds_valid_hashers::<RandomState>()"
        ],
        "requires": [
          "that for any two `Hasher`s that the `BuildHasher` builds",
          "/// if they're both given the same write sequence\n/// then their states will match and they'll produce the same digest\n/// when invoked with `finish()`.\n///\n/// The standard library has an axiom that `RandomState`, the default `BuildHasher`\n/// used by `HashMap` and `HashSet`, implements this model.\n/// If you want to use some other hash builder type `MyHashBuilder`",
          "/// you need to explicitly state your assumption that it does so with\n/// `assume(vstd::std_specs::hash::builds_valid_hashers::<MyHashBuilder>())`.\n#[verifier::external_body]\npub uninterp spec fn builds_valid_hashers<T: ?Sized>() -> bool"
        ],
        "body": "{\n    admit();\n}",
        "doc_comment": "Specifies whether a type conforms to our requirements to be a hash builder\nin our hash table (and hash set) model.\n\nOur model requires that for any two `Hasher`s that the `BuildHasher` builds,\nif they're both given the same write sequence\nthen their states will match and they'll produce the same digest\nwhen invoked with `finish()`.\n\nThe standard library has an axiom that `RandomState`, the default `BuildHasher`\nused by `HashMap` and `HashSet`, implements this model.\nIf you want to use some other hash builder type `MyHashBuilder`,\nyou need to explicitly state your assumption that it does so with\n`assume(vstd::std_specs::hash::builds_valid_hashers::<MyHashBuilder>())`.",
        "triggers": [
          "builds_valid_hashers::<RandomState>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 234,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "Set",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_random_state_builds_valid_hashers": {
        "name": "axiom_random_state_builds_valid_hashers",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_random_state_builds_valid_hashers()\n    ensures\n        #[trigger] builds_valid_hashers::<RandomState>(),",
        "ensures": [
          "#[trigger] builds_valid_hashers::<RandomState>()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "builds_valid_hashers::<RandomState>("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 260,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "spec_hash_map_iter": {
        "name": "spec_hash_map_iter",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_hash_map_iter<'a, Key, Value, S>(m: &'a HashMap<Key, Value, S>) -> (r:\n    hash_map::Iter<'a, Key, Value>)",
        "ensures": [
          "("
        ],
        "requires": [],
        "body": "{\n            let (pos, v) = #[trigger] spec_hash_map_iter(m)@;\n            &&& pos == 0int\n            &&& forall|i: int| 0 <= i < v.len() ==> #[trigger] m@[v[i].0] == v[i].1\n        }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 611,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map"
        ],
        "callees": [
          "len",
          "spec_hash_map_iter"
        ]
      },
      "axiom_spec_hash_map_iter": {
        "name": "axiom_spec_hash_map_iter",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_spec_hash_map_iter<'a, Key, Value, S>(m: &'a HashMap<Key, Value, S>)\n    ensures\n        (",
        "ensures": [
          "("
        ],
        "requires": [],
        "body": "{\n            let (pos, v) = #[trigger] spec_hash_map_iter(m)@;\n            &&& pos == 0int\n            &&& forall|i: int| 0 <= i < v.len() ==> #[trigger] m@[v[i].0] == v[i].1\n        }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 613,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map"
        ],
        "callees": [
          "len",
          "spec_hash_map_iter"
        ]
      },
      "lemma_hashmap_deepview_dom": {
        "name": "lemma_hashmap_deepview_dom",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_hashmap_deepview_dom<K: DeepView, V: DeepView>(m: HashMap<K, V>)\n    ensures\n        #[trigger] m.deep_view().dom() == m@.dom().map(|k: K| k.deep_view()),",
        "ensures": [
          "#[trigger] m.deep_view().dom() == m@.dom().map(|k: K| k.deep_view())"
        ],
        "requires": [],
        "body": "{\n    reveal(hash_map_deep_view_impl);\n    broadcast use group_hash_axioms;\n    broadcast use crate::vstd::group_vstd_default;\n\n    assert(m.deep_view().dom() =~= m@.dom().map(|k: K| k.deep_view()));\n}",
        "doc_comment": null,
        "triggers": [
          "m.deep_view("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 703,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "map",
          "trigger"
        ],
        "callees": [
          "deep_view",
          "dom",
          "map"
        ]
      },
      "lemma_hashmap_deepview_properties": {
        "name": "lemma_hashmap_deepview_properties",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_hashmap_deepview_properties<K: DeepView, V: DeepView>(m: HashMap<K, V>)\n    requires\n        crate::relations::injective(|k: K| k.deep_view()),\n    ensures\n        #![trigger m.deep_view()]\n        // all elements in m.view() are present in m.deep_view()\n        forall|k: K| #[trigger]\n            m@.contains_key(k) ==> m.deep_view().contains_key(k.deep_view())\n                && m.deep_view()[k.deep_view()] == m@[k].deep_view(),\n        // all elements in m.deep_view() are present in m.view()\n        forall|dk: <K as DeepView>::V| #[trigger]\n            m.deep_view().contains_key(dk) ==> exists|k: K|\n                k.deep_view() == dk && #[trigger] m@.contains_key(k),",
        "ensures": [
          "#![trigger m.deep_view()]\n        // all elements in m.view() are present in m.deep_view()\n        forall|k: K| #[trigger]\n            m@.contains_key(k) ==> m.deep_view().contains_key(k.deep_view())\n                && m.deep_view()[k.deep_view()] == m@[k].deep_view()",
          "// all elements in m.deep_view() are present in m.view()\n        forall|dk: <K as DeepView>::V| #[trigger]\n            m.deep_view().contains_key(dk) ==> exists|k: K|\n                k.deep_view() == dk && #[trigger] m@.contains_key(k)"
        ],
        "requires": [
          "crate::relations::injective(|k: K| k.deep_view())"
        ],
        "body": "{\n    reveal(hash_map_deep_view_impl);\n    broadcast use group_hash_axioms;\n    broadcast use crate::vstd::group_vstd_default;\n\n    assert(m.deep_view().dom() == m@.dom().map(|k: K| k.deep_view()));\n    assert forall|k: K| #[trigger] m@.contains_key(k) implies m.deep_view().contains_key(\n        k.deep_view(),\n    ) && m.deep_view()[k.deep_view()] == m@[k].deep_view() by {\n        assert forall|k1: K, k2: K| #[trigger]\n            k1.deep_view() == #[trigger] k2.deep_view() implies k1 == k2 by {\n            let ghost k_deepview = |k: K| k.deep_view();\n            assert(crate::relations::injective(k_deepview));\n            assert(k_deepview(k1) == k_deepview(k2));\n        }\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "m@.contains_key(k",
          "m.deep_view(",
          "m@.contains_key(k"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 714,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "exists",
          "forall",
          "trigger"
        ],
        "callees": [
          "injective",
          "deep_view",
          "k_deepview",
          "contains_key",
          "dom",
          "map"
        ]
      },
      "lemma_hashmap_deepview_values": {
        "name": "lemma_hashmap_deepview_values",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn lemma_hashmap_deepview_values<K: DeepView, V: DeepView>(m: HashMap<K, V>)\n    requires\n        crate::relations::injective(|k: K| k.deep_view()),\n    ensures\n        #[trigger] m.deep_view().values() =~= m@.values().map(|v: V| v.deep_view()),",
        "ensures": [
          "#[trigger] m.deep_view().values() =~= m@.values().map(|v: V| v.deep_view())"
        ],
        "requires": [
          "crate::relations::injective(|k: K| k.deep_view())"
        ],
        "body": "{\n    reveal(hash_map_deep_view_impl);\n    broadcast use group_hash_axioms;\n    broadcast use lemma_hashmap_deepview_properties;\n    broadcast use crate::vstd::group_vstd_default;\n\n    let lhs = m.deep_view().values();\n    let rhs = m@.values().map(|v: V| v.deep_view());\n    assert forall|v: V::V| #[trigger] lhs.contains(v) implies rhs.contains(v) by {\n        let dk = choose|dk: K::V| #[trigger]\n            m.deep_view().contains_key(dk) && m.deep_view()[dk] == v;\n        let k = choose|k: K| #[trigger] m@.contains_key(k) && k.deep_view() == dk;\n        let ov = choose|ov: V| #[trigger] m@.contains_key(k) && m@[k] == ov && ov.deep_view() == v;\n        assert(v == ov.deep_view());\n        assert(m@.values().contains(ov));\n    }\n}",
        "doc_comment": null,
        "triggers": [
          "m.deep_view("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 745,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "map",
          "trigger"
        ],
        "callees": [
          "values",
          "deep_view",
          "contains",
          "contains_key",
          "map"
        ]
      },
      "axiom_hashmap_deepview_borrow": {
        "name": "axiom_hashmap_deepview_borrow",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_hashmap_deepview_borrow<\n    K: DeepView + Borrow<Q>,\n    V: DeepView,\n    Q: View<V = <K as DeepView>::V> + Hash + Eq + ?Sized,\n>(m: HashMap<K, V>, k: &Q)\n    requires\n        obeys_key_model::<K>(),\n        crate::relations::injective(|k: K| k.deep_view()),\n    ensures\n        #[trigger] contains_borrowed_key(m@, k) <==> m.deep_view().contains_key(k@),",
        "ensures": [
          "#[trigger] contains_borrowed_key(m@, k) <==> m.deep_view().contains_key(k@)"
        ],
        "requires": [
          "obeys_key_model::<K>()",
          "crate::relations::injective(|k: K| k.deep_view())"
        ],
        "body": "{\n    admit();\n}",
        "doc_comment": "Borrowing a key works the same way on deep_view as on view,\nif deep_view is injective; see `axiom_contains_deref_key`.",
        "triggers": [
          "contains_borrowed_key(m@"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 768,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_hashmap_view_finite_dom": {
        "name": "axiom_hashmap_view_finite_dom",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_hashmap_view_finite_dom<K, V>(m: HashMap<K, V>)\n    ensures\n        #[trigger] m@.dom().finite(),",
        "ensures": [
          "#[trigger] m@.dom().finite()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": "A `Map` constructed from a `HashMap` is always finite.",
        "triggers": [
          "m@.dom("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 784,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "finite",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "spec_hash_map_len": {
        "name": "spec_hash_map_len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_hash_map_len<Key, Value, S>(m: &HashMap<Key, Value, S>) -> usize",
        "ensures": [
          "obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> #[trigger] spec_hash_map_len(m)\n            == m@.len()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_hash_map_len(m"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 792,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_spec_hash_map_len": {
        "name": "axiom_spec_hash_map_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_spec_hash_map_len<Key, Value, S>(m: &HashMap<Key, Value, S>)\n    ensures\n        obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> #[trigger] spec_hash_map_len(m)\n            == m@.len(),",
        "ensures": [
          "obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> #[trigger] spec_hash_map_len(m)\n            == m@.len()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_hash_map_len(m"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 794,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "contains_borrowed_key": {
        "name": "contains_borrowed_key",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn contains_borrowed_key<Key, Value, Q: ?Sized>(\n    m: Map<Key, Value>,\n    k: &Q,\n) -> bool",
        "ensures": [
          "#[trigger] contains_borrowed_key::<Q, Value, Q>(m, k) <==> m.contains_key(*k)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "contains_borrowed_key::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 878,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_contains_deref_key": {
        "name": "axiom_contains_deref_key",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_contains_deref_key<Q, Value>(m: Map<Q, Value>, k: &Q)\n    ensures\n        #[trigger] contains_borrowed_key::<Q, Value, Q>(m, k) <==> m.contains_key(*k),",
        "ensures": [
          "#[trigger] contains_borrowed_key::<Q, Value, Q>(m, k) <==> m.contains_key(*k)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "contains_borrowed_key::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 882,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_contains_box": {
        "name": "axiom_contains_box",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_contains_box<Q, Value>(m: Map<Box<Q>, Value>, k: &Q)\n    ensures\n        #[trigger] contains_borrowed_key::<Box<Q>, Value, Q>(m, k) <==> m.contains_key(\n            Box::new(*k),\n        ),",
        "ensures": [
          "#[trigger] contains_borrowed_key::<Box<Q>, Value, Q>(m, k) <==> m.contains_key(\n            Box::new(*k)",
          ")"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "contains_borrowed_key::<Box<Q>"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 889,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "maps_borrowed_key_to_value": {
        "name": "maps_borrowed_key_to_value",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn maps_borrowed_key_to_value<Key, Value, Q: ?Sized>(\n    m: Map<Key, Value>,\n    k: &Q,\n    v: Value,\n) -> bool",
        "ensures": [
          "#[trigger] maps_borrowed_key_to_value::<Q, Value, Q>(m, k, v) <==> m.contains_key(*k)\n            && m[*k] == v"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "maps_borrowed_key_to_value::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 929,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_maps_deref_key_to_value": {
        "name": "axiom_maps_deref_key_to_value",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_maps_deref_key_to_value<Q, Value>(m: Map<Q, Value>, k: &Q, v: Value)\n    ensures\n        #[trigger] maps_borrowed_key_to_value::<Q, Value, Q>(m, k, v) <==> m.contains_key(*k)\n            && m[*k] == v,",
        "ensures": [
          "#[trigger] maps_borrowed_key_to_value::<Q, Value, Q>(m, k, v) <==> m.contains_key(*k)\n            && m[*k] == v"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "maps_borrowed_key_to_value::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 934,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_maps_box_key_to_value": {
        "name": "axiom_maps_box_key_to_value",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_maps_box_key_to_value<Q, Value>(m: Map<Box<Q>, Value>, q: &Q, v: Value)\n    ensures\n        #[trigger] maps_borrowed_key_to_value::<Box<Q>, Value, Q>(m, q, v) <==>",
        "ensures": [
          "#[trigger] maps_borrowed_key_to_value::<Box<Q>, Value, Q>(m, q, v) <==>"
        ],
        "requires": [],
        "body": "{\n            let k = Box::new(*q);\n            &&& m.contains_key(k)\n            &&& m[k] == v\n        }",
        "doc_comment": null,
        "triggers": [
          "maps_borrowed_key_to_value::<Box<Q>"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 942,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "trigger"
        ],
        "callees": [
          "new",
          "contains_key"
        ]
      },
      "borrowed_key_removed": {
        "name": "borrowed_key_removed",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn borrowed_key_removed<Key, Value, Q: ?Sized>(\n    old_m: Map<Key, Value>,\n    new_m: Map<Key, Value>,\n    k: &Q,\n) -> bool",
        "ensures": [
          "#[trigger] borrowed_key_removed::<Q, Value, Q>(old_m, new_m, k) <==> new_m == old_m.remove(\n            *k",
          ")"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "borrowed_key_removed::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 985,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "remove",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_deref_key_removed": {
        "name": "axiom_deref_key_removed",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_deref_key_removed<Q, Value>(\n    old_m: Map<Q, Value>,\n    new_m: Map<Q, Value>,\n    k: &Q,\n)\n    ensures\n        #[trigger] borrowed_key_removed::<Q, Value, Q>(old_m, new_m, k) <==> new_m == old_m.remove(\n            *k,\n        ),",
        "ensures": [
          "#[trigger] borrowed_key_removed::<Q, Value, Q>(old_m, new_m, k) <==> new_m == old_m.remove(\n            *k",
          ")"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "borrowed_key_removed::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 990,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "remove",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_box_key_removed": {
        "name": "axiom_box_key_removed",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_box_key_removed<Q, Value>(\n    old_m: Map<Box<Q>, Value>,\n    new_m: Map<Box<Q>, Value>,\n    q: &Q,\n)\n    ensures\n        #[trigger] borrowed_key_removed::<Box<Q>, Value, Q>(old_m, new_m, q) <==> new_m\n            == old_m.remove(Box::new(*q)),",
        "ensures": [
          "#[trigger] borrowed_key_removed::<Box<Q>, Value, Q>(old_m, new_m, q) <==> new_m\n            == old_m.remove(Box::new(*q))"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "borrowed_key_removed::<Box<Q>"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1003,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "remove",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_hashmap_decreases": {
        "name": "axiom_hashmap_decreases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_hashmap_decreases<Key, Value, S>(m: HashMap<Key, Value, S>)\n    ensures\n        #[trigger] (decreases_to!(m => m@)),",
        "ensures": [
          "#[trigger] ("
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1062,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map",
          "decreases",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "spec_hash_set_len": {
        "name": "spec_hash_set_len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_hash_set_len<Key, S>(m: &HashSet<Key, S>) -> usize",
        "ensures": [
          "obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> #[trigger] spec_hash_set_len(m)\n            == m@.len()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_hash_set_len(m"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1195,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_spec_hash_set_len": {
        "name": "axiom_spec_hash_set_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_spec_hash_set_len<Key, S>(m: &HashSet<Key, S>)\n    ensures\n        obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> #[trigger] spec_hash_set_len(m)\n            == m@.len(),",
        "ensures": [
          "obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> #[trigger] spec_hash_set_len(m)\n            == m@.len()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_hash_set_len(m"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1197,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "set_contains_borrowed_key": {
        "name": "set_contains_borrowed_key",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn set_contains_borrowed_key<Key, Q: ?Sized>(m: Set<Key>, k: &Q) -> bool",
        "ensures": [
          "#[trigger] set_contains_borrowed_key::<Q, Q>(m, k) <==> m.contains(*k)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "set_contains_borrowed_key::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1263,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "contains",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_set_contains_deref_key": {
        "name": "axiom_set_contains_deref_key",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_contains_deref_key<Q>(m: Set<Q>, k: &Q)\n    ensures\n        #[trigger] set_contains_borrowed_key::<Q, Q>(m, k) <==> m.contains(*k),",
        "ensures": [
          "#[trigger] set_contains_borrowed_key::<Q, Q>(m, k) <==> m.contains(*k)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "set_contains_borrowed_key::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1264,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "contains",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_set_contains_box": {
        "name": "axiom_set_contains_box",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_contains_box<Q>(m: Set<Box<Q>>, k: &Q)\n    ensures\n        #[trigger] set_contains_borrowed_key::<Box<Q>, Q>(m, k) <==> m.contains(Box::new(*k)),",
        "ensures": [
          "#[trigger] set_contains_borrowed_key::<Box<Q>, Q>(m, k) <==> m.contains(Box::new(*k))"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "set_contains_borrowed_key::<Box<Q>"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1271,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "contains",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "sets_borrowed_key_to_key": {
        "name": "sets_borrowed_key_to_key",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn sets_borrowed_key_to_key<Key, Q: ?Sized>(m: Set<Key>, k: &Q, v: &Key) -> bool",
        "ensures": [
          "#[trigger] sets_borrowed_key_to_key::<Q, Q>(m, k, v) <==> m.contains(*k) && k == v"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "sets_borrowed_key_to_key::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1305,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "contains",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_set_deref_key_to_value": {
        "name": "axiom_set_deref_key_to_value",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_deref_key_to_value<Q>(m: Set<Q>, k: &Q, v: &Q)\n    ensures\n        #[trigger] sets_borrowed_key_to_key::<Q, Q>(m, k, v) <==> m.contains(*k) && k == v,",
        "ensures": [
          "#[trigger] sets_borrowed_key_to_key::<Q, Q>(m, k, v) <==> m.contains(*k) && k == v"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "sets_borrowed_key_to_key::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1306,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "contains",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_set_box_key_to_value": {
        "name": "axiom_set_box_key_to_value",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_box_key_to_value<Q>(m: Set<Box<Q>>, q: &Q, v: &Box<Q>)\n    ensures\n        #[trigger] sets_borrowed_key_to_key::<Box<Q>, Q>(m, q, v) <==> (m.contains(*v) && Box::new(\n            *q,\n        ) == v),",
        "ensures": [
          "#[trigger] sets_borrowed_key_to_key::<Box<Q>, Q>(m, q, v) <==> (m.contains(*v) && Box::new(\n            *q",
          ") == v)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "sets_borrowed_key_to_key::<Box<Q>"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1313,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "contains",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "sets_differ_by_borrowed_key": {
        "name": "sets_differ_by_borrowed_key",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn sets_differ_by_borrowed_key<Key, Q: ?Sized>(\n    old_m: Set<Key>,\n    new_m: Set<Key>,\n    k: &Q,\n) -> bool",
        "ensures": [
          "#[trigger] sets_differ_by_borrowed_key::<Q, Q>(old_m, new_m, k) <==> new_m == old_m.remove(\n            *k",
          ")"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "sets_differ_by_borrowed_key::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1350,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "remove",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_set_deref_key_removed": {
        "name": "axiom_set_deref_key_removed",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_deref_key_removed<Q>(old_m: Set<Q>, new_m: Set<Q>, k: &Q)\n    ensures\n        #[trigger] sets_differ_by_borrowed_key::<Q, Q>(old_m, new_m, k) <==> new_m == old_m.remove(\n            *k,\n        ),",
        "ensures": [
          "#[trigger] sets_differ_by_borrowed_key::<Q, Q>(old_m, new_m, k) <==> new_m == old_m.remove(\n            *k",
          ")"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "sets_differ_by_borrowed_key::<Q"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1355,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "remove",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_set_box_key_removed": {
        "name": "axiom_set_box_key_removed",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_set_box_key_removed<Q>(old_m: Set<Box<Q>>, new_m: Set<Box<Q>>, q: &Q)\n    ensures\n        #[trigger] sets_differ_by_borrowed_key::<Box<Q>, Q>(old_m, new_m, q) <==> new_m\n            == old_m.remove(Box::new(*q)),",
        "ensures": [
          "#[trigger] sets_differ_by_borrowed_key::<Box<Q>, Q>(old_m, new_m, q) <==> new_m\n            == old_m.remove(Box::new(*q))"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "sets_differ_by_borrowed_key::<Box<Q>"
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1364,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "remove",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_hashset_decreases": {
        "name": "axiom_hashset_decreases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_hashset_decreases<Key, S>(m: HashSet<Key, S>)\n    ensures\n        #[trigger] (decreases_to!(m => m@)),",
        "ensures": [
          "#[trigger] ("
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "("
        ],
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 1400,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Set",
          "decreases",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "neg_ensures": {
        "name": "neg_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn neg_ensures<A>(x: A, o: A) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/ops.rs",
        "line_number": 451,
        "module": "vstd::std_specs::ops",
        "keywords": [],
        "callees": []
      },
      "add_ensures": {
        "name": "add_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn add_ensures<A>(x: A, y: A, o: A) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/ops.rs",
        "line_number": 454,
        "module": "vstd::std_specs::ops",
        "keywords": [],
        "callees": []
      },
      "sub_ensures": {
        "name": "sub_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn sub_ensures<A>(x: A, y: A, o: A) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/ops.rs",
        "line_number": 456,
        "module": "vstd::std_specs::ops",
        "keywords": [],
        "callees": []
      },
      "mul_ensures": {
        "name": "mul_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn mul_ensures<A>(x: A, y: A, o: A) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/ops.rs",
        "line_number": 458,
        "module": "vstd::std_specs::ops",
        "keywords": [],
        "callees": []
      },
      "div_ensures": {
        "name": "div_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn div_ensures<A>(x: A, y: A, o: A) -> bool",
        "ensures": [],
        "requires": [],
        "body": null,
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/ops.rs",
        "line_number": 460,
        "module": "vstd::std_specs::ops",
        "keywords": [],
        "callees": []
      },
      "spec_range_next": {
        "name": "spec_range_next",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_range_next<A>(a: Range<A>) -> (Range<A>, Option<A>)",
        "ensures": [
          "(*range, r) == spec_range_next(*old(range))",
          "(U::obeys_partial_cmp_spec() && <Idx as PartialOrdSpec<U>>::obeys_partial_cmp_spec())\n            ==> ret == (r.start.is_le(i) && i.is_lt(&r.end))"
        ],
        "requires": [],
        "body": "{\n    pub start: A,\n    pub cur: A,\n    pub end: A,\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/range.rs",
        "line_number": 27,
        "module": "vstd::std_specs::range",
        "keywords": [],
        "callees": []
      },
      "spec_slice_iter": {
        "name": "spec_slice_iter",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_slice_iter<'a, T>(s: &'a [T]) -> (iter: Iter<'a, T>)",
        "ensures": [
          "(#[trigger] spec_slice_iter(s))@ == (0int, s@)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_slice_iter(s"
        ],
        "file_path": "verus/source/vstd/std_specs/slice.rs",
        "line_number": 152,
        "module": "vstd::std_specs::slice",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_spec_slice_iter": {
        "name": "axiom_spec_slice_iter",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_spec_slice_iter<'a, T>(s: &'a [T])\n    ensures\n        (#[trigger] spec_slice_iter(s))@ == (0int, s@),",
        "ensures": [
          "(#[trigger] spec_slice_iter(s))@ == (0int, s@)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_slice_iter(s"
        ],
        "file_path": "verus/source/vstd/std_specs/slice.rs",
        "line_number": 153,
        "module": "vstd::std_specs::slice",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "spec_vec_len": {
        "name": "spec_vec_len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_vec_len<T, A: Allocator>(v: &Vec<T, A>) -> usize",
        "ensures": [
          "#[trigger] spec_vec_len(v) == v@.len()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": "/// Len (with autospec)",
        "triggers": [
          "spec_vec_len(v"
        ],
        "file_path": "verus/source/vstd/std_specs/vec.rs",
        "line_number": 54,
        "module": "vstd::std_specs::vec",
        "keywords": [
          "Vec",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "vstd::std_specs::vec::axiom_spec_len": {
        "name": "vstd::std_specs::vec::axiom_spec_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_spec_len<A>(v: &Vec<A>)\n    ensures\n        #[trigger] spec_vec_len(v) == v@.len(),",
        "ensures": [
          "#[trigger] spec_vec_len(v) == v@.len()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_vec_len(v"
        ],
        "file_path": "verus/source/vstd/std_specs/vec.rs",
        "line_number": 60,
        "module": "vstd::std_specs::vec",
        "keywords": [
          "Vec",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "vec_clone_deep_view_proof": {
        "name": "vec_clone_deep_view_proof",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn vec_clone_deep_view_proof<T: DeepView, A: Allocator>(\n    v1: Vec<T, A>,\n    v2: Vec<T, A>,\n)\n    requires\n        #[trigger] vec_clone_trigger(v1, v2),\n        v1.deep_view() =~= v2.deep_view(),\n    ensures\n        v1.deep_view() == v2.deep_view(),",
        "ensures": [
          "v1.deep_view() == v2.deep_view()"
        ],
        "requires": [
          "#[trigger] vec_clone_trigger(v1, v2)",
          "v1.deep_view() =~= v2.deep_view()"
        ],
        "body": "{\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/std_specs/vec.rs",
        "line_number": 217,
        "module": "vstd::std_specs::vec",
        "keywords": [
          "Vec",
          "trigger"
        ],
        "callees": []
      },
      "axiom_vec_index_decreases": {
        "name": "axiom_vec_index_decreases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_vec_index_decreases<A>(v: Vec<A>, i: int)\n    requires\n        0 <= i < v.len(),\n    ensures\n        #[trigger] (decreases_to!(v => v[i])),",
        "ensures": [
          "#[trigger] ("
        ],
        "requires": [
          "0 <= i < v.len()"
        ],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "("
        ],
        "file_path": "verus/source/vstd/std_specs/vec.rs",
        "line_number": 249,
        "module": "vstd::std_specs::vec",
        "keywords": [
          "Vec",
          "decreases",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "spec_into_iter": {
        "name": "spec_into_iter",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_into_iter<T, A: Allocator>(v: Vec<T, A>) -> (iter: <Vec<\n    T,\n    A,\n> as core::iter::IntoIterator>::IntoIter)",
        "ensures": [
          "(#[trigger] spec_into_iter(v))@ == (0int, v@)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_into_iter(v"
        ],
        "file_path": "verus/source/vstd/std_specs/vec.rs",
        "line_number": 381,
        "module": "vstd::std_specs::vec",
        "keywords": [
          "Vec",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_spec_into_iter": {
        "name": "axiom_spec_into_iter",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_spec_into_iter<T, A: Allocator>(v: Vec<T, A>)\n    ensures\n        (#[trigger] spec_into_iter(v))@ == (0int, v@),",
        "ensures": [
          "(#[trigger] spec_into_iter(v))@ == (0int, v@)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_into_iter(v"
        ],
        "file_path": "verus/source/vstd/std_specs/vec.rs",
        "line_number": 385,
        "module": "vstd::std_specs::vec",
        "keywords": [
          "Vec",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "spec_vec_dequeue_len": {
        "name": "spec_vec_dequeue_len",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_vec_dequeue_len<T, A: Allocator>(v: &VecDeque<T, A>) -> usize",
        "ensures": [
          "#[trigger] spec_vec_dequeue_len(v) == v@.len()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": "/// Len (with autospec)",
        "triggers": [
          "spec_vec_dequeue_len(v"
        ],
        "file_path": "verus/source/vstd/std_specs/vecdeque.rs",
        "line_number": 48,
        "module": "vstd::std_specs::vecdeque",
        "keywords": [
          "Vec",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "vstd::std_specs::vecdeque::axiom_spec_len": {
        "name": "vstd::std_specs::vecdeque::axiom_spec_len",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_spec_len<T, A: Allocator>(v: &VecDeque<T, A>)\n    ensures\n        #[trigger] spec_vec_dequeue_len(v) == v@.len(),",
        "ensures": [
          "#[trigger] spec_vec_dequeue_len(v) == v@.len()"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_vec_dequeue_len(v"
        ],
        "file_path": "verus/source/vstd/std_specs/vecdeque.rs",
        "line_number": 54,
        "module": "vstd::std_specs::vecdeque",
        "keywords": [
          "Vec",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_vec_dequeue_index_decreases": {
        "name": "axiom_vec_dequeue_index_decreases",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_vec_dequeue_index_decreases<A>(v: VecDeque<A>, i: int)\n    requires\n        0 <= i < v.len(),\n    ensures\n        #[trigger] (decreases_to!(v => v[i])),",
        "ensures": [
          "#[trigger] ("
        ],
        "requires": [
          "0 <= i < v.len()"
        ],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "("
        ],
        "file_path": "verus/source/vstd/std_specs/vecdeque.rs",
        "line_number": 239,
        "module": "vstd::std_specs::vecdeque",
        "keywords": [
          "Vec",
          "decreases",
          "len",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "spec_iter": {
        "name": "spec_iter",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn spec_iter<'a, T, A: Allocator>(v: &'a VecDeque<T, A>) -> (r: Iter<'a, T>)",
        "ensures": [
          "(#[trigger] spec_iter(v))@ == (0int, v@)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_iter(v"
        ],
        "file_path": "verus/source/vstd/std_specs/vecdeque.rs",
        "line_number": 353,
        "module": "vstd::std_specs::vecdeque",
        "keywords": [
          "Vec",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_spec_iter": {
        "name": "axiom_spec_iter",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn axiom_spec_iter<'a, T, A: Allocator>(v: &'a VecDeque<T, A>)\n    ensures\n        (#[trigger] spec_iter(v))@ == (0int, v@),",
        "ensures": [
          "(#[trigger] spec_iter(v))@ == (0int, v@)"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "spec_iter(v"
        ],
        "file_path": "verus/source/vstd/std_specs/vecdeque.rs",
        "line_number": 354,
        "module": "vstd::std_specs::vecdeque",
        "keywords": [
          "Vec",
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "vstd::storage_protocol::value": {
        "name": "vstd::storage_protocol::value",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn value(self) -> P",
        "ensures": [
          "out.value() == p",
          "out.loc() == a.loc()",
          "out.value() == P::op(a.value(), b.value())",
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == a_value",
          "out.1.value() == b_value",
          "("
        ],
        "requires": [
          "P::rel(p, s)",
          "a.loc() == b.loc()",
          "self.value() == P::op(a_value, b_value)"
        ],
        "body": "{\n                let (q, t) = out;\n                P::rel(P::op(self.value(), q), t)\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 131,
        "module": "vstd::storage_protocol",
        "keywords": [],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "vstd::storage_protocol::loc": {
        "name": "vstd::storage_protocol::loc",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn loc(self) -> Loc",
        "ensures": [
          "out.value() == p",
          "out.loc() == a.loc()",
          "out.value() == P::op(a.value(), b.value())",
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == a_value",
          "out.1.value() == b_value",
          "("
        ],
        "requires": [
          "P::rel(p, s)",
          "a.loc() == b.loc()",
          "self.value() == P::op(a_value, b_value)"
        ],
        "body": "{\n                let (q, t) = out;\n                P::rel(P::op(self.value(), q), t)\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 132,
        "module": "vstd::storage_protocol",
        "keywords": [],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "vstd::storage_protocol::alloc": {
        "name": "vstd::storage_protocol::alloc",
        "type": "axiom",
        "signature": "pub axiom fn alloc(p: P, tracked s: Map<K, V>) -> (tracked out: Self)\n        requires\n            P::rel(p, s),\n        ensures\n            out.value() == p,",
        "ensures": [
          "out.value() == p",
          "out.loc() == a.loc()",
          "out.value() == P::op(a.value(), b.value())",
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == a_value",
          "out.1.value() == b_value",
          "("
        ],
        "requires": [
          "P::rel(p, s)",
          "a.loc() == b.loc()",
          "self.value() == P::op(a_value, b_value)"
        ],
        "body": "{\n                let (q, t) = out;\n                P::rel(P::op(self.value(), q), t)\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 134,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "vstd::storage_protocol::join": {
        "name": "vstd::storage_protocol::join",
        "type": "axiom",
        "signature": "pub axiom fn join(tracked a: Self, tracked b: Self) -> (tracked out: Self)\n        requires\n            a.loc() == b.loc(),\n        ensures\n            out.loc() == a.loc(),\n            out.value() == P::op(a.value(), b.value()),",
        "ensures": [
          "out.loc() == a.loc()",
          "out.value() == P::op(a.value(), b.value())",
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == a_value",
          "out.1.value() == b_value",
          "("
        ],
        "requires": [
          "a.loc() == b.loc()",
          "self.value() == P::op(a_value, b_value)"
        ],
        "body": "{\n                let (q, t) = out;\n                P::rel(P::op(self.value(), q), t)\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 141,
        "module": "vstd::storage_protocol",
        "keywords": [],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "vstd::storage_protocol::split": {
        "name": "vstd::storage_protocol::split",
        "type": "axiom",
        "signature": "pub axiom fn split(tracked self, a_value: P, b_value: P) -> (tracked out: (Self, Self))\n        requires\n            self.value() == P::op(a_value, b_value),\n        ensures\n            out.0.loc() == self.loc(),\n            out.1.loc() == self.loc(),\n            out.0.value() == a_value,\n            out.1.value() == b_value,",
        "ensures": [
          "out.0.loc() == self.loc()",
          "out.1.loc() == self.loc()",
          "out.0.value() == a_value",
          "out.1.value() == b_value",
          "("
        ],
        "requires": [
          "self.value() == P::op(a_value, b_value)"
        ],
        "body": "{\n                let (q, t) = out;\n                P::rel(P::op(self.value(), q), t)\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 149,
        "module": "vstd::storage_protocol",
        "keywords": [],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "vstd::storage_protocol::validate": {
        "name": "vstd::storage_protocol::validate",
        "type": "axiom",
        "signature": "pub axiom fn validate(tracked self: &Self) -> (out: (P, Map<K, V>))\n        ensures\n            (",
        "ensures": [
          "("
        ],
        "requires": [],
        "body": "{\n                let (q, t) = out;\n                P::rel(P::op(self.value(), q), t)\n            }",
        "doc_comment": "Since `inv` isn't closed under inclusion, validity for an element\nis defined as the inclusion-closure of invariant, i.e., an element\nis valid if there exists another element `x` that, added to it,\nmeets the invariant.",
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 159,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "exchange": {
        "name": "exchange",
        "type": "proof",
        "signature": "pub proof fn exchange(\n        tracked p: Self,\n        tracked s: Map<K, V>,\n        new_p_value: P,\n        new_s_value: Map<K, V>,\n    ) -> (tracked out: (Self, Map<K, V>))\n        requires\n            exchanges(p.value(), s, new_p_value, new_s_value),\n        ensures\n            (",
        "ensures": [
          "("
        ],
        "requires": [
          "exchanges(p.value(), s, new_p_value, new_s_value)"
        ],
        "body": "{\n                let (new_p, new_s) = out;\n                new_p.loc() == p.loc() && new_p.value() == new_p_value && new_s == new_s_value\n            }",
        "doc_comment": "Most general kind of update, potentially depositing and withdrawing",
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 173,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ],
        "callees": [
          "value",
          "loc"
        ]
      },
      "deposit": {
        "name": "deposit",
        "type": "proof",
        "signature": "pub proof fn deposit(tracked self, tracked base: Map<K, V>, new_value: P) -> (tracked out: Self)\n        requires\n            deposits(self.value(), base, new_value),\n        ensures\n            out.loc() == self.loc(),\n            out.value() == new_value,",
        "ensures": [
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "deposits(self.value(), base, new_value)"
        ],
        "body": "{\n        Self::exchange(self, base, new_value, Map::empty()).0\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 191,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ],
        "callees": [
          "exchange",
          "empty"
        ]
      },
      "withdraw": {
        "name": "withdraw",
        "type": "proof",
        "signature": "pub proof fn withdraw(tracked self, new_value: P, new_base: Map<K, V>) -> (tracked out: (\n        Self,\n        Map<K, V>,\n    ))\n        requires\n            withdraws(self.value(), new_value, new_base),\n        ensures\n            out.0.loc() == self.loc(),\n            out.0.value() == new_value,\n            out.1 == new_base,",
        "ensures": [
          "out.0.loc() == self.loc()",
          "out.0.value() == new_value",
          "out.1 == new_base"
        ],
        "requires": [
          "withdraws(self.value(), new_value, new_base)"
        ],
        "body": "{\n        Self::exchange(self, Map::tracked_empty(), new_value, new_base)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 201,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ],
        "callees": [
          "exchange",
          "tracked_empty"
        ]
      },
      "vstd::storage_protocol::update": {
        "name": "vstd::storage_protocol::update",
        "type": "proof",
        "signature": "pub proof fn update(tracked self, new_value: P) -> (tracked out: Self)\n        requires\n            updates(self.value(), new_value),\n        ensures\n            out.loc() == self.loc(),\n            out.value() == new_value,",
        "ensures": [
          "out.loc() == self.loc()",
          "out.value() == new_value"
        ],
        "requires": [
          "updates(self.value(), new_value)"
        ],
        "body": "{\n        Self::exchange(self, Map::tracked_empty(), new_value, Map::empty()).0\n    }",
        "doc_comment": "\"Normal\" update, no depositing or withdrawing",
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 215,
        "module": "vstd::storage_protocol",
        "keywords": [],
        "callees": [
          "exchange",
          "tracked_empty",
          "empty"
        ]
      },
      "exchange_nondeterministic": {
        "name": "exchange_nondeterministic",
        "type": "proof",
        "signature": "pub proof fn exchange_nondeterministic(\n        tracked p: Self,\n        tracked s: Map<K, V>,\n        new_values: Set<(P, Map<K, V>)>,\n    ) -> (tracked out: (Self, Map<K, V>))\n        requires\n            exchanges_nondeterministic(p.value(), s, new_values),\n        ensures\n            (",
        "ensures": [
          "("
        ],
        "requires": [
          "exchanges_nondeterministic(p.value(), s, new_values)"
        ],
        "body": "{\n                let (new_p, new_s) = out;\n                new_p.loc() == p.loc() && new_values.contains((new_p.value(), new_s))\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 226,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map",
          "Set"
        ],
        "callees": [
          "value",
          "loc",
          "contains"
        ]
      },
      "guard": {
        "name": "guard",
        "type": "axiom",
        "signature": "pub axiom fn guard(tracked p: &Self, s_value: Map<K, V>) -> (tracked s: &Map<K, V>)\n        requires\n            guards(p.value(), s_value),\n        ensures\n            s == s_value,",
        "ensures": [
          "s == s_value",
          "out.loc() == self.loc()",
          "incl(self.value(), out.value())",
          "incl(other.value(), out.value())",
          "out.loc() == self.loc()",
          "out.value() == target",
          "*self == *old(self)",
          "("
        ],
        "requires": [
          "guards(p.value(), s_value)",
          "self.loc() == other.loc()",
          "incl(target, self.value())",
          "old(self).loc() == x.loc()"
        ],
        "body": "{\n                let (q, t) = res;\n                { P::rel(P::op(P::op(self.value(), x.value()), q), t) }\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 256,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "vstd::storage_protocol::join_shared": {
        "name": "vstd::storage_protocol::join_shared",
        "type": "axiom",
        "signature": "pub axiom fn join_shared<'a>(tracked &'a self, tracked other: &'a Self) -> (tracked out:\n        &'a Self)\n        requires\n            self.loc() == other.loc(),\n        ensures\n            out.loc() == self.loc(),\n            incl(self.value(), out.value()),\n            incl(other.value(), out.value()),",
        "ensures": [
          "out.loc() == self.loc()",
          "incl(self.value(), out.value())",
          "incl(other.value(), out.value())",
          "out.loc() == self.loc()",
          "out.value() == target",
          "*self == *old(self)",
          "("
        ],
        "requires": [
          "self.loc() == other.loc()",
          "incl(target, self.value())",
          "old(self).loc() == x.loc()"
        ],
        "body": "{\n                let (q, t) = res;\n                { P::rel(P::op(P::op(self.value(), x.value()), q), t) }\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 265,
        "module": "vstd::storage_protocol",
        "keywords": [],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "vstd::storage_protocol::weaken": {
        "name": "vstd::storage_protocol::weaken",
        "type": "axiom",
        "signature": "pub axiom fn weaken<'a>(tracked &'a self, target: P) -> (tracked out: &'a Self)\n        requires\n            incl(target, self.value()),\n        ensures\n            out.loc() == self.loc(),\n            out.value() == target,",
        "ensures": [
          "out.loc() == self.loc()",
          "out.value() == target",
          "*self == *old(self)",
          "("
        ],
        "requires": [
          "incl(target, self.value())",
          "old(self).loc() == x.loc()"
        ],
        "body": "{\n                let (q, t) = res;\n                { P::rel(P::op(P::op(self.value(), x.value()), q), t) }\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 274,
        "module": "vstd::storage_protocol",
        "keywords": [],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "validate_with_shared": {
        "name": "validate_with_shared",
        "type": "axiom",
        "signature": "pub axiom fn validate_with_shared(tracked self: &mut Self, tracked x: &Self) -> (res: (\n        P,\n        Map<K, V>,\n    ))\n        requires\n            old(self).loc() == x.loc(),\n        ensures\n            *self == *old(self),\n            (",
        "ensures": [
          "*self == *old(self)",
          "("
        ],
        "requires": [
          "old(self).loc() == x.loc()"
        ],
        "body": "{\n                let (q, t) = res;\n                { P::rel(P::op(P::op(self.value(), x.value()), q), t) }\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 282,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ],
        "callees": [
          "value",
          "rel",
          "op"
        ]
      },
      "exchange_with_shared": {
        "name": "exchange_with_shared",
        "type": "proof",
        "signature": "pub proof fn exchange_with_shared(\n        tracked p: Self,\n        tracked x: &Self,\n        tracked s: Map<K, V>,\n        new_p_value: P,\n        new_s_value: Map<K, V>,\n    ) -> (tracked out: (Self, Map<K, V>))\n        requires\n            p.loc() == x.loc(),\n            exchanges(P::op(p.value(), x.value()), s, P::op(new_p_value, x.value()), new_s_value),\n        ensures\n            out.0.loc() == p.loc(),\n            out.0.value() == new_p_value,\n            out.1 == new_s_value,",
        "ensures": [
          "out.0.loc() == p.loc()",
          "out.0.value() == new_p_value",
          "out.1 == new_s_value"
        ],
        "requires": [
          "p.loc() == x.loc()",
          "exchanges(P::op(p.value(), x.value()), s, P::op(new_p_value, x.value()), new_s_value)"
        ],
        "body": "{\n        let se = set![(new_p_value, new_s_value)];\n        Self::exchange_nondeterministic_with_shared(p, x, s, se)\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 299,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ],
        "callees": [
          "exchange_nondeterministic_with_shared"
        ]
      },
      "exchange_nondeterministic_with_shared": {
        "name": "exchange_nondeterministic_with_shared",
        "type": "axiom",
        "signature": "pub axiom fn exchange_nondeterministic_with_shared(\n        tracked p: Self,\n        tracked x: &Self,\n        tracked s: Map<K, V>,\n        new_values: Set<(P, Map<K, V>)>,\n    ) -> (tracked out: (Self, Map<K, V>))\n        requires\n            p.loc() == x.loc(),\n            exchanges_nondeterministic(\n                P::op(p.value(), x.value()),\n                s,\n                set_op(new_values, x.value()),\n            ),\n        ensures\n            (",
        "ensures": [
          "("
        ],
        "requires": [
          "p.loc() == x.loc()",
          "exchanges_nondeterministic(\n                P::op(p.value(), x.value())",
          "s",
          "set_op(new_values, x.value())",
          ")"
        ],
        "body": "{\n                let (new_p, new_s) = out;\n                new_p.loc() == p.loc() && new_values.contains((new_p.value(), new_s))\n            }",
        "doc_comment": "Most general kind of update, potentially depositing and withdrawing",
        "triggers": [],
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 320,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map",
          "Set"
        ],
        "callees": [
          "value",
          "loc",
          "contains"
        ]
      },
      "str_slice_is_ascii": {
        "name": "str_slice_is_ascii",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn str_slice_is_ascii(s: &str) -> bool",
        "ensures": [
          "b == str_slice_is_ascii(s)"
        ],
        "requires": [],
        "body": "{\n    s\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/string.rs",
        "line_number": 29,
        "module": "vstd::string",
        "keywords": [],
        "callees": []
      },
      "to_string_from_display_ensures": {
        "name": "to_string_from_display_ensures",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn to_string_from_display_ensures<T: core::fmt::Display + ?Sized>(\n    t: &T,\n    s: String,\n) -> bool",
        "ensures": [
          "#[trigger] to_string_from_display_"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "to_string_from_display_"
        ],
        "file_path": "verus/source/vstd/string.rs",
        "line_number": 51,
        "module": "vstd::string",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "to_string_from_display_ensures_for_str": {
        "name": "to_string_from_display_ensures_for_str",
        "type": "broadcast_proof",
        "signature": "pub broadcast proof fn to_string_from_display_ensures_for_str(t: &str, res: String)\n    ensures\n        #[trigger] to_string_from_display_ensures::<str>(t, res) <==> (t@ == res@ && t.is_ascii()\n            == res.is_ascii()),",
        "ensures": [
          "#[trigger] to_string_from_display_"
        ],
        "requires": [],
        "body": "{\n    admit();\n}",
        "doc_comment": null,
        "triggers": [
          "to_string_from_display_"
        ],
        "file_path": "verus/source/vstd/string.rs",
        "line_number": 57,
        "module": "vstd::string",
        "keywords": [
          "trigger"
        ],
        "callees": [
          "admit"
        ]
      },
      "axiom_str_literal_is_ascii": {
        "name": "axiom_str_literal_is_ascii",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_str_literal_is_ascii<'a>(s: &'a str)\n    ensures\n        #[trigger] s.is_ascii() == strslice_is_ascii(s),",
        "ensures": [
          "#[trigger] s.is_ascii() == strslice_is_ascii(s)",
          "#[trigger] s@.len() == strslice_len(s)",
          "#[trigger] s@.index(i) == strslice_get_char(s, i)"
        ],
        "requires": [],
        "body": "{\n    axiom_str_literal_is_ascii,\n    axiom_str_literal_len,\n    axiom_str_literal_get_char,\n}",
        "doc_comment": null,
        "triggers": [
          "s.is_ascii(",
          "s@.len(",
          "s@.index(i"
        ],
        "file_path": "verus/source/vstd/string.rs",
        "line_number": 191,
        "module": "vstd::string",
        "keywords": [
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_str_literal_len": {
        "name": "axiom_str_literal_len",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_str_literal_len<'a>(s: &'a str)\n    ensures\n        #[trigger] s@.len() == strslice_len(s),",
        "ensures": [
          "#[trigger] s@.len() == strslice_len(s)",
          "#[trigger] s@.index(i) == strslice_get_char(s, i)"
        ],
        "requires": [],
        "body": "{\n    axiom_str_literal_is_ascii,\n    axiom_str_literal_len,\n    axiom_str_literal_get_char,\n}",
        "doc_comment": null,
        "triggers": [
          "s@.len(",
          "s@.index(i"
        ],
        "file_path": "verus/source/vstd/string.rs",
        "line_number": 196,
        "module": "vstd::string",
        "keywords": [
          "len",
          "trigger"
        ],
        "callees": []
      },
      "axiom_str_literal_get_char": {
        "name": "axiom_str_literal_get_char",
        "type": "broadcast_axiom",
        "signature": "pub broadcast axiom fn axiom_str_literal_get_char<'a>(s: &'a str, i: int)\n    ensures\n        #[trigger] s@.index(i) == strslice_get_char(s, i),",
        "ensures": [
          "#[trigger] s@.index(i) == strslice_get_char(s, i)"
        ],
        "requires": [],
        "body": "{\n    axiom_str_literal_is_ascii,\n    axiom_str_literal_len,\n    axiom_str_literal_get_char,\n}",
        "doc_comment": null,
        "triggers": [
          "s@.index(i"
        ],
        "file_path": "verus/source/vstd/string.rs",
        "line_number": 201,
        "module": "vstd::string",
        "keywords": [
          "trigger"
        ],
        "callees": []
      },
      "string_is_ascii": {
        "name": "string_is_ascii",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn string_is_ascii(s: &String) -> bool",
        "ensures": [
          "b == string_is_ascii(s)",
          "res@ == s@",
          "s.is_ascii() == res.is_ascii()",
          "res == s",
          "res == (s@ == other@)"
        ],
        "requires": [],
        "body": "{\n    fn is_ascii(&self) -> bool;\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/string.rs",
        "line_number": 242,
        "module": "vstd::string",
        "keywords": [],
        "callees": [
          "is_ascii"
        ]
      },
      "predicate": {
        "name": "predicate",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn predicate(&self, ret: Ret) -> bool",
        "ensures": [
          "match r_result"
        ],
        "requires": [],
        "body": "{\n                Result::Ok(r) => self.predicate(r),\n                Result::Err(_) => true,\n            }",
        "doc_comment": "Predicate restricting the possible return values. This is determined by the\npostcondition of the closure provided when calling `spawn()`.",
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 20,
        "module": "vstd::thread",
        "keywords": [],
        "callees": [
          "predicate",
          "rr",
          "k"
        ]
      },
      "vstd::thread::view": {
        "name": "vstd::thread::view",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn view(&self) -> V",
        "ensures": [
          "res == self@",
          "*res == self@",
          "res == self@"
        ],
        "requires": [
          "self.id() == is_thread@",
          "self.id() == is_thread@"
        ],
        "body": "{\n    /// Recover the inner value.\n    /// Unlike `into`, this has no thread requirement, but it does\n    /// require the inner type to be `Send`.\n    pub axiom fn send_into(tracked self) -> (tracked res: V)\n        ensures\n            res == self@,\n    ;\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 231,
        "module": "vstd::thread",
        "keywords": [],
        "callees": [
          "send_into"
        ]
      },
      "agrees": {
        "name": "agrees",
        "type": "axiom",
        "signature": "pub axiom fn agrees(tracked self, tracked other: IsThread)\n        ensures\n            self@ == other@,",
        "ensures": [
          "self@ == other@"
        ],
        "requires": [],
        "body": "{\n    #[cfg(verus_keep_ghost)]\n    fn clone(&self) -> Self {\n        IsThread {  }\n    }\n\n    #[cfg(not(verus_keep_ghost))]\n    fn clone(&self) -> Self {\n        IsThread { _no_send_sync: Default::default() }\n    }\n}",
        "doc_comment": "Guarantees that any two `IsThread` objects on the same thread\nwill have the same ID.",
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 170,
        "module": "vstd::thread",
        "keywords": [],
        "callees": [
          "cfg",
          "default"
        ]
      },
      "ghost_thread_id": {
        "name": "ghost_thread_id",
        "type": "axiom",
        "signature": "pub axiom fn ghost_thread_id() -> (tracked res: IsThread)",
        "ensures": [],
        "requires": [],
        "body": "{\n    phantom: marker::PhantomData<V>,\n}",
        "doc_comment": "Returns _just_ the ghost object, without physically obtaining the thread ID.",
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 207,
        "module": "vstd::thread",
        "keywords": [],
        "callees": []
      },
      "vstd::thread::id": {
        "name": "vstd::thread::id",
        "type": "uninterp_spec",
        "signature": "pub uninterp spec fn id(&self) -> ThreadId",
        "ensures": [
          "res == self@",
          "*res == self@",
          "res == self@"
        ],
        "requires": [
          "self.id() == is_thread@",
          "self.id() == is_thread@"
        ],
        "body": "{\n    /// Recover the inner value.\n    /// Unlike `into`, this has no thread requirement, but it does\n    /// require the inner type to be `Send`.\n    pub axiom fn send_into(tracked self) -> (tracked res: V)\n        ensures\n            res == self@,\n    ;\n}",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 232,
        "module": "vstd::thread",
        "keywords": [],
        "callees": [
          "send_into"
        ]
      },
      "into": {
        "name": "into",
        "type": "axiom",
        "signature": "pub axiom fn into(tracked self, tracked is_thread: IsThread) -> (tracked res: V)\n        requires\n            self.id() == is_thread@,\n        ensures\n            res == self@,",
        "ensures": [
          "res == self@",
          "*res == self@",
          "res == self@"
        ],
        "requires": [
          "self.id() == is_thread@",
          "self.id() == is_thread@"
        ],
        "body": "{\n    /// Recover the inner value.\n    /// Unlike `into`, this has no thread requirement, but it does\n    /// require the inner type to be `Send`.\n    pub axiom fn send_into(tracked self) -> (tracked res: V)\n        ensures\n            res == self@,\n    ;\n}",
        "doc_comment": "Recover the inner value provide we are on the same thread.",
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 234,
        "module": "vstd::thread",
        "keywords": [],
        "callees": [
          "send_into"
        ]
      },
      "vstd::thread::borrow": {
        "name": "vstd::thread::borrow",
        "type": "axiom",
        "signature": "pub axiom fn borrow(tracked &self, tracked is_thread: IsThread) -> (tracked res: &V)\n        requires\n            self.id() == is_thread@,\n        ensures\n            *res == self@,",
        "ensures": [
          "*res == self@",
          "res == self@"
        ],
        "requires": [
          "self.id() == is_thread@"
        ],
        "body": "{\n    /// Recover the inner value.\n    /// Unlike `into`, this has no thread requirement, but it does\n    /// require the inner type to be `Send`.\n    pub axiom fn send_into(tracked self) -> (tracked res: V)\n        ensures\n            res == self@,\n    ;\n}",
        "doc_comment": "Borrow the inner value provide we are on the same thread.",
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 242,
        "module": "vstd::thread",
        "keywords": [],
        "callees": [
          "send_into"
        ]
      },
      "send_into": {
        "name": "send_into",
        "type": "axiom",
        "signature": "pub axiom fn send_into(tracked self) -> (tracked res: V)\n        ensures\n            res == self@,",
        "ensures": [
          "res == self@",
          "*res == self@"
        ],
        "requires": [],
        "body": "{\n    /// Borrow the inner value.\n    /// Unlike `borrow`, this has no thread requirement, but it does\n    /// require the inner type to be `Sync`.\n    pub axiom fn sync_borrow(tracked &self) -> (tracked res: &V)\n        ensures\n            *res == self@,\n    ;\n}",
        "doc_comment": "Recover the inner value.\nUnlike `into`, this has no thread requirement, but it does\nrequire the inner type to be `Send`.",
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 253,
        "module": "vstd::thread",
        "keywords": [],
        "callees": [
          "sync_borrow"
        ]
      },
      "sync_borrow": {
        "name": "sync_borrow",
        "type": "axiom",
        "signature": "pub axiom fn sync_borrow(tracked &self) -> (tracked res: &V)\n        ensures\n            *res == self@,",
        "ensures": [
          "*res == self@"
        ],
        "requires": [],
        "body": null,
        "doc_comment": "Borrow the inner value.\nUnlike `borrow`, this has no thread requirement, but it does\nrequire the inner type to be `Sync`.",
        "triggers": [],
        "file_path": "verus/source/vstd/thread.rs",
        "line_number": 263,
        "module": "vstd::thread",
        "keywords": [],
        "callees": []
      },
      "vstd::tokens::frac::id": {
        "name": "vstd::tokens::frac::id",
        "type": "closed_spec",
        "signature": "pub closed spec fn id(self) -> Loc",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.r.loc()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 680,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "loc"
        ]
      },
      "vstd::tokens::frac::view": {
        "name": "vstd::tokens::frac::view",
        "type": "closed_spec",
        "signature": "pub closed spec fn view(self) -> T",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.frac.view()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 361,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "view"
        ]
      },
      "frac": {
        "name": "vstd::tokens::frac::frac",
        "type": "closed_spec",
        "signature": "pub closed spec fn frac(self) -> int",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.r.value()->n\n    }",
        "doc_comment": "The fractional quantity of this permission. The \"fraction\" is represented as an integer,\nout of `TOTAL`.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 139,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "value"
        ]
      },
      "vstd::tokens::frac::new": {
        "name": "vstd::tokens::frac::new",
        "type": "proof",
        "signature": "pub proof fn new(tracked v: T) -> (tracked result: Self)\n        requires\n            TOTAL > 0,",
        "ensures": [],
        "requires": [
          "TOTAL > 0"
        ],
        "body": "{\n        let f = FractionalCarrierOpt::<T, TOTAL>::Value { v: None, n: TOTAL as int };\n        let tracked mut m = Map::<(), T>::tracked_empty();\n        let tracked r = StorageResource::alloc(f, m);\n        Self { r }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 684,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "tracked_empty",
          "alloc"
        ]
      },
      "agree": {
        "name": "vstd::tokens::frac::agree",
        "type": "proof",
        "signature": "pub proof fn agree(tracked self: &Self, tracked other: &Self)\n        requires\n            self.id() == other.id(),\n        ensures\n            self@ == other@,",
        "ensures": [
          "self@ == other@"
        ],
        "requires": [
          "self.id() == other.id()"
        ],
        "body": "{\n        use_type_invariant(self);\n        use_type_invariant(other);\n        let tracked joined = self.r.join_shared(&other.r);\n        joined.validate()\n    }",
        "doc_comment": "Two tokens agree on their values.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 164,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "validate",
          "join_shared",
          "use_type_invariant"
        ]
      },
      "take": {
        "name": "vstd::tokens::frac::take",
        "type": "proof",
        "signature": "pub proof fn take(tracked &mut self) -> (tracked result: Self)\n        ensures\n            result == *old(self),",
        "ensures": [
          "result == *old(self)"
        ],
        "requires": [],
        "body": "{\n        self.bounded();\n        let tracked mut mself = Self::dummy();\n        tracked_swap(self, &mut mself);\n        mself\n    }",
        "doc_comment": "Take a token out of a mutable reference, leaving a meaningless token behind.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 177,
        "module": "vstd::tokens::frac",
        "keywords": [
          "take"
        ],
        "callees": [
          "bounded",
          "tracked_swap",
          "dummy"
        ]
      },
      "vstd::tokens::frac::split": {
        "name": "vstd::tokens::frac::split",
        "type": "proof",
        "signature": "pub proof fn split(tracked &mut self, n: int) -> (tracked result: Self)\n        requires\n            0 < n < old(self).frac(),\n        ensures\n            result.id() == self.id() == old(self).id(),\n            self.resource() == old(self).resource(),\n            result.resource() == old(self).resource(),\n            self.frac() + result.frac() == old(self).frac(),\n            result.frac() == n,",
        "ensures": [
          "result.id() == self.id() == old(self).id()",
          "self.resource() == old(self).resource()",
          "result.resource() == old(self).resource()",
          "self.frac() + result.frac() == old(self).frac()",
          "result.frac() == n"
        ],
        "requires": [
          "0 < n < old(self).frac()"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        Self::split_helper(&mut self.r, n)\n    }",
        "doc_comment": "Split one token into two tokens whose quantities sum to the original.\nThe returned token has quantity `n`; the new value of the input token has\nquantity `old(self).frac() - n`.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 533,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "split_helper",
          "use_type_invariant"
        ]
      },
      "combine": {
        "name": "vstd::tokens::frac::combine",
        "type": "proof",
        "signature": "pub proof fn combine(tracked &mut self, tracked other: Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n            self.frac() == old(self).frac() + other.frac(),",
        "ensures": [
          "self.id() == old(self).id()",
          "self@ == old(self)@",
          "self@ == other@",
          "self.frac() == old(self).frac() + other.frac()"
        ],
        "requires": [
          "old(self).id() == other.id()"
        ],
        "body": "{\n        self.bounded();\n        let tracked mut mself = Self::dummy();\n        tracked_swap(self, &mut mself);\n        use_type_invariant(&mself);\n        use_type_invariant(&other);\n        let tracked mut r = mself.r;\n        r.validate_2(&other.r);\n        *self = Self { r: r.join(other.r) };\n    }",
        "doc_comment": "Combine two tokens, summing their quantities.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 213,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "tracked_swap",
          "validate_2",
          "use_type_invariant",
          "join",
          "dummy",
          "bounded"
        ]
      },
      "vstd::tokens::frac::update": {
        "name": "vstd::tokens::frac::update",
        "type": "proof",
        "signature": "pub proof fn update(tracked &mut self, tracked v: &mut GhostVar<T>, new_val: T)\n        requires\n            old(self).id() == old(v).id(),\n        ensures\n            self.id() == old(self).id(),\n            v.id() == old(v).id(),\n            old(self)@ == old(v)@,\n            self@ == new_val,\n            v@ == new_val,",
        "ensures": [
          "self.id() == old(self).id()",
          "v.id() == old(v).id()",
          "old(self)@ == old(v)@",
          "self@ == new_val",
          "v@ == new_val"
        ],
        "requires": [
          "old(self).id() == old(v).id()"
        ],
        "body": "{\n        let tracked (mut ms, mut mv) = Self::new(new_val);\n        tracked_swap(self, &mut ms);\n        tracked_swap(v, &mut mv);\n        use_type_invariant(&ms);\n        use_type_invariant(&mv);\n        let tracked mut msfrac = ms.frac;\n        msfrac.combine(mv.frac);\n        msfrac.update(new_val);\n        let tracked mut nv = GhostVar::<T> { frac: msfrac.split(1) };\n        let tracked mut ns = Self { frac: msfrac };\n        tracked_swap(self, &mut ns);\n        tracked_swap(v, &mut nv);\n    }",
        "doc_comment": "Update the value on each token.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 388,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "tracked_swap",
          "use_type_invariant",
          "update",
          "combine",
          "split",
          "tracked",
          "new"
        ]
      },
      "update_with": {
        "name": "update_with",
        "type": "proof",
        "signature": "pub proof fn update_with(tracked &mut self, tracked other: &mut Self, v: T)\n        requires\n            old(self).id() == old(other).id(),\n            old(self).frac() + old(other).frac() == TOTAL,\n        ensures\n            self.id() == old(self).id(),\n            other.id() == old(other).id(),\n            self.frac() == old(self).frac(),\n            other.frac() == old(other).frac(),\n            old(self)@ == old(other)@,\n            self@ == v,\n            other@ == v,",
        "ensures": [
          "self.id() == old(self).id()",
          "other.id() == old(other).id()",
          "self.frac() == old(self).frac()",
          "other.frac() == old(other).frac()",
          "old(self)@ == old(other)@",
          "self@ == v",
          "other@ == v"
        ],
        "requires": [
          "having ALL the permissions",
          "/// i.e., the tokens together must have a quantity total of `TOTAL`.\n    pub proof fn update_with(tracked &mut self, tracked other: &mut Self, v: T)",
          "old(self).id() == old(other).id()",
          "old(self).frac() + old(other).frac() == TOTAL"
        ],
        "body": "{\n        let ghost other_frac = other.frac();\n        other.bounded();\n\n        let tracked mut xother = Self::dummy();\n        tracked_swap(other, &mut xother);\n        self.bounded();\n        self.combine(xother);\n        self.update(v);\n\n        let tracked mut xother = self.split(other_frac);\n        tracked_swap(other, &mut xother);\n    }",
        "doc_comment": "Update the value of the token. This requires having ALL the permissions,\ni.e., the tokens together must have a quantity total of `TOTAL`.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 252,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "tracked_swap",
          "frac",
          "update",
          "dummy",
          "combine",
          "split",
          "bounded"
        ]
      },
      "bounded": {
        "name": "vstd::tokens::frac::bounded",
        "type": "proof",
        "signature": "pub proof fn bounded(tracked &self)\n        ensures\n            0 < self.frac() <= TOTAL,",
        "ensures": [
          "0 < self.frac() <= TOTAL"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(self);\n        self.r.validate()\n    }",
        "doc_comment": "Allowed values for a token's quantity.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 280,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "validate",
          "use_type_invariant"
        ]
      },
      "dummy": {
        "name": "vstd::tokens::frac::dummy",
        "type": "proof",
        "signature": "pub proof fn dummy() -> (tracked result: Self)\n        requires\n            TOTAL > 0,",
        "ensures": [],
        "requires": [
          "TOTAL > 0"
        ],
        "body": "{\n        Self::new(arbitrary())\n    }",
        "doc_comment": "Obtain an arbitrary token with no information about it.\nUseful if you need a well-typed placeholder.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 289,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "arbitrary",
          "new"
        ]
      },
      "vstd::tokens::frac::agree": {
        "name": "vstd::tokens::frac::agree",
        "type": "proof",
        "signature": "pub proof fn agree(tracked self: &Self, tracked other: &Self)\n        requires\n            self.id() == other.id(),\n        ensures\n            self.resource() == other.resource(),",
        "ensures": [
          "self.resource() == other.resource()"
        ],
        "requires": [
          "self.id() == other.id()"
        ],
        "body": "{\n        use_type_invariant(self);\n        use_type_invariant(other);\n        let tracked joined = self.r.join_shared(&other.r);\n        joined.validate();\n    }",
        "doc_comment": "Two tokens agree on values of the underlying resource.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 520,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "validate",
          "join_shared",
          "use_type_invariant"
        ]
      },
      "resource": {
        "name": "resource",
        "type": "closed_spec",
        "signature": "pub closed spec fn resource(self) -> T",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.r.value()->v.unwrap()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 492,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "value"
        ]
      },
      "vstd::tokens::frac::frac": {
        "name": "vstd::tokens::frac::frac",
        "type": "closed_spec",
        "signature": "pub closed spec fn frac(self) -> int",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.r.value()->n\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 496,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "value"
        ]
      },
      "vstd::tokens::frac::combine": {
        "name": "vstd::tokens::frac::combine",
        "type": "proof",
        "signature": "pub proof fn combine(tracked &mut self, tracked other: Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self.resource() == old(self).resource(),\n            self.resource() == other.resource(),\n            self.frac() == old(self).frac() + other.frac(),",
        "ensures": [
          "self.id() == old(self).id()",
          "self.resource() == old(self).resource()",
          "self.resource() == other.resource()",
          "self.frac() == old(self).frac() + other.frac()"
        ],
        "requires": [
          "old(self).id() == other.id()"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        Self::combine_helper(&mut self.r, other)\n    }",
        "doc_comment": "Combine two tokens, summing their quantities.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 579,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "combine_helper",
          "use_type_invariant"
        ]
      },
      "vstd::tokens::frac::bounded": {
        "name": "vstd::tokens::frac::bounded",
        "type": "proof",
        "signature": "pub proof fn bounded(tracked &self)\n        ensures\n            0 < self.frac() <= TOTAL,",
        "ensures": [
          "0 < self.frac() <= TOTAL"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(self);\n        let (x, _) = self.r.validate();\n    }",
        "doc_comment": "Allowed values for a token's quantity.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 618,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "validate",
          "use_type_invariant"
        ]
      },
      "vstd::tokens::frac::borrow": {
        "name": "vstd::tokens::frac::borrow",
        "type": "proof",
        "signature": "pub proof fn borrow(tracked &self) -> (tracked ret: &T)\n        ensures\n            ret == self.resource(),",
        "ensures": [
          "ret == self.resource()"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(self);\n        StorageResource::guard(&self.r, map![() => self.resource()]).tracked_borrow(())\n    }",
        "doc_comment": "Obtain shared access to the underlying resource.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 627,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "guard",
          "tracked_borrow",
          "resource",
          "use_type_invariant"
        ]
      },
      "take_resource": {
        "name": "take_resource",
        "type": "proof",
        "signature": "pub proof fn take_resource(tracked self) -> (tracked pair: (T, Empty<T, TOTAL>))\n        requires\n            self.frac() == TOTAL,\n        ensures\n            pair.0 == self.resource(),\n            pair.1.id() == self.id(),",
        "ensures": [
          "pair.0 == self.resource()",
          "pair.1.id() == self.id()"
        ],
        "requires": [
          "self.frac() == TOTAL"
        ],
        "body": "{\n        use_type_invariant(&self);\n        self.r.validate();\n\n        let p1 = self.r.value();\n        let p2 = FractionalCarrierOpt::Value { v: None, n: TOTAL as int };\n        let b2 = map![() => self.resource()];\n        assert forall|q: FractionalCarrierOpt<T, TOTAL>, t1: Map<(), T>|\n            #![all_triggers]\n            FractionalCarrierOpt::rel(FractionalCarrierOpt::op(p1, q), t1) implies exists|\n            t2: Map<(), T>,\n        |\n            #![all_triggers]\n            FractionalCarrierOpt::rel(FractionalCarrierOpt::op(p2, q), t2) && t2.dom().disjoint(\n                b2.dom(),\n            ) && t1 =~= t2.union_prefer_right(b2) by {\n            let t2 = map![];\n            assert(FractionalCarrierOpt::rel(FractionalCarrierOpt::op(p2, q), t2));\n            assert(t2.dom().disjoint(b2.dom()));\n            assert(t1 =~= t2.union_prefer_right(b2));\n        }\n\n        let tracked Self { r } = self;\n        let tracked (new_r, mut m) = r.withdraw(p2, b2);\n        let tracked emp = Empty { r: new_r };\n        let tracked resource = m.tracked_remove(());\n        (resource, emp)\n    }",
        "doc_comment": "Reclaim full ownership of the underlying resource.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 636,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "withdraw",
          "rel",
          "resource",
          "use_type_invariant",
          "disjoint",
          "validate",
          "value",
          "op",
          "tracked_remove",
          "tracked",
          "dom",
          "union_prefer_right"
        ]
      },
      "put_resource": {
        "name": "put_resource",
        "type": "proof",
        "signature": "pub proof fn put_resource(tracked self, tracked resource: T) -> (tracked frac: Frac<T, TOTAL>)\n        ensures\n            frac.id() == self.id(),\n            frac.resource() == resource,\n            frac.frac() == TOTAL,",
        "ensures": [
          "frac.id() == self.id()",
          "frac.resource() == resource",
          "frac.frac() == TOTAL"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(&self);\n        self.r.validate();\n\n        let p1 = self.r.value();\n        let b1 = map![() => resource];\n        let p2 = FractionalCarrierOpt::Value { v: Some(resource), n: TOTAL as int };\n\n        assert forall|q: FractionalCarrierOpt<T, TOTAL>, t1: Map<(), T>|\n            #![all_triggers]\n            FractionalCarrierOpt::rel(FractionalCarrierOpt::op(p1, q), t1) implies exists|\n            t2: Map<(), T>,\n        |\n            #![all_triggers]\n            FractionalCarrierOpt::rel(FractionalCarrierOpt::op(p2, q), t2) && t1.dom().disjoint(\n                b1.dom(),\n            ) && t1.union_prefer_right(b1) =~= t2 by {\n            let t2 = map![() => resource];\n            assert(FractionalCarrierOpt::rel(FractionalCarrierOpt::op(p2, q), t2)\n                && t1.dom().disjoint(b1.dom()) && t1.union_prefer_right(b1) =~= t2);\n        }\n\n        let tracked mut m = Map::tracked_empty();\n        m.tracked_insert((), resource);\n        let tracked Self { r } = self;\n        let tracked new_r = r.deposit(m, p2);\n        let tracked f = Frac { r: new_r };\n        f\n    }",
        "doc_comment": "Give up ownership of a resource and obtain a [`Frac`] token.",
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 694,
        "module": "vstd::tokens::frac",
        "keywords": [],
        "callees": [
          "rel",
          "use_type_invariant",
          "disjoint",
          "deposit",
          "validate",
          "value",
          "op",
          "tracked_insert",
          "ome",
          "dom",
          "tracked_empty",
          "union_prefer_right"
        ]
      },
      "vstd::tokens::map::id": {
        "name": "vstd::tokens::map::id",
        "type": "closed_spec",
        "signature": "pub closed spec fn id(self) -> Loc",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.r.loc()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 299,
        "module": "vstd::tokens::map",
        "keywords": [],
        "callees": [
          "loc"
        ]
      },
      "vstd::tokens::map::view": {
        "name": "vstd::tokens::map::view",
        "type": "closed_spec",
        "signature": "pub closed spec fn view(self) -> Map<K, V>",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.r.value().frac.unwrap()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 303,
        "module": "vstd::tokens::map",
        "keywords": [
          "Map"
        ],
        "callees": [
          "value"
        ]
      },
      "vstd::tokens::map::dummy": {
        "name": "vstd::tokens::map::dummy",
        "type": "proof",
        "signature": "pub proof fn dummy() -> (tracked result: GhostSubmap<K, V>)",
        "ensures": [],
        "requires": [],
        "body": "{\n        let tracked (auth, submap) = GhostMapAuth::<K, V>::new(Map::empty());\n        submap\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 318,
        "module": "vstd::tokens::map",
        "keywords": [],
        "callees": [
          "tracked",
          "new",
          "empty"
        ]
      },
      "vstd::tokens::map::take": {
        "name": "vstd::tokens::map::take",
        "type": "proof",
        "signature": "pub proof fn take(tracked &mut self) -> (tracked result: GhostSubmap<K, V>)\n        ensures\n            result == *old(self),",
        "ensures": [
          "result == *old(self)"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(&*self);\n\n        let tracked mut r = Self::dummy();\n        tracked_swap(self, &mut r);\n        r\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 332,
        "module": "vstd::tokens::map",
        "keywords": [
          "take"
        ],
        "callees": [
          "tracked_swap",
          "dummy",
          "use_type_invariant"
        ]
      },
      "vstd::tokens::map::empty": {
        "name": "vstd::tokens::map::empty",
        "type": "proof",
        "signature": "pub proof fn empty(id: int) -> (tracked result: GhostSubmap<K, V>)\n        ensures\n            result.id() == id,\n            result@ == Map::<K, V>::empty(),",
        "ensures": [
          "result.id() == id",
          "result@ == Map::<K, V>::empty()"
        ],
        "requires": [],
        "body": "{\n        let tracked r = Resource::create_unit(id);\n        GhostSubmap { r }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 323,
        "module": "vstd::tokens::map",
        "keywords": [
          "Map",
          "empty"
        ],
        "callees": [
          "create_unit"
        ]
      },
      "vstd::tokens::map::insert": {
        "name": "vstd::tokens::map::insert",
        "type": "proof",
        "signature": "pub proof fn insert(tracked &mut self, m: Map<K, V>) -> (tracked result: GhostSubmap<K, V>)\n        requires\n            old(self)@.dom().disjoint(m.dom()),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@.union_prefer_right(m),\n            result.id() == self.id(),\n            result@ == m,",
        "ensures": [
          "self.id() == old(self).id()",
          "self@ == old(self)@.union_prefer_right(m)",
          "result.id() == self.id()",
          "result@ == m"
        ],
        "requires": [
          "old(self)@.dom().disjoint(m.dom())"
        ],
        "body": "{\n        broadcast use lemma_submap_of_trans;\n        broadcast use lemma_op_frac_submap_of;\n\n        let tracked mut mself = Self::dummy();\n        tracked_swap(self, &mut mself);\n\n        use_type_invariant(&mself);\n        assert(mself.inv());\n        let tracked mut r = mself.r;\n\n        let rr = MapCarrier {\n            auth: Some(Some(r.value().auth.unwrap().unwrap().union_prefer_right(m))),\n            frac: Some(m),\n        };\n\n        let tracked r_upd = r.update(rr);\n\n        let arr = MapCarrier { auth: r_upd.value().auth, frac: Some(Map::empty()) };\n\n        let frr = MapCarrier { auth: None, frac: r_upd.value().frac };\n\n        assert(r_upd.value() == MapCarrier::op(arr, frr));\n        let tracked (ar, fr) = r_upd.split(arr, frr);\n        self.r = ar;\n        GhostSubmap { r: fr }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 211,
        "module": "vstd::tokens::map",
        "keywords": [
          "Map",
          "insert"
        ],
        "callees": [
          "tracked_swap",
          "use_type_invariant",
          "update",
          "dummy",
          "value",
          "op",
          "ome",
          "inv",
          "empty",
          "tracked",
          "split",
          "union_prefer_right"
        ]
      },
      "delete": {
        "name": "delete",
        "type": "proof",
        "signature": "pub proof fn delete(tracked &mut self, tracked f: GhostSubmap<K, V>)\n        requires\n            f.id() == old(self).id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@.remove_keys(f@.dom()),",
        "ensures": [
          "self.id() == old(self).id()",
          "self@ == old(self)@.remove_keys(f@.dom())"
        ],
        "requires": [
          "f.id() == old(self).id()"
        ],
        "body": "{\n        broadcast use lemma_submap_of_trans;\n        broadcast use lemma_op_frac_submap_of;\n\n        use_type_invariant(&*self);\n        use_type_invariant(&f);\n\n        let tracked mut mself = Self::dummy();\n        tracked_swap(self, &mut mself);\n        let tracked mut r = mself.r;\n\n        r = r.join(f.r);\n\n        let ra = r.value().auth.unwrap().unwrap();\n        let ra_new = ra.remove_keys(f@.dom());\n\n        let rnew = MapCarrier { auth: Some(Some(ra_new)), frac: Some(Map::empty()) };\n\n        self.r = r.update(rnew);\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 247,
        "module": "vstd::tokens::map",
        "keywords": [],
        "callees": [
          "tracked_swap",
          "join",
          "use_type_invariant",
          "update",
          "value",
          "dummy",
          "remove_keys",
          "ome",
          "empty",
          "dom"
        ]
      },
      "vstd::tokens::map::new": {
        "name": "vstd::tokens::map::new",
        "type": "proof",
        "signature": "pub proof fn new(m: Map<K, V>) -> (tracked result: (GhostMapAuth<K, V>, GhostSubmap<K, V>))\n        ensures\n            result.0.id() == result.1.id(),\n            result.0@ == m,\n            result.1@ == m,",
        "ensures": [
          "result.0.id() == result.1.id()",
          "result.0@ == m",
          "result.1@ == m"
        ],
        "requires": [],
        "body": "{\n        let tracked rr = Resource::alloc(MapCarrier { auth: Some(Some(m)), frac: Some(m) });\n\n        let arr = MapCarrier { auth: Some(Some(m)), frac: Some(Map::empty()) };\n\n        let frr = MapCarrier { auth: None, frac: Some(m) };\n\n        assert(rr.value() == MapCarrier::op(arr, frr));\n        let tracked (ar, fr) = rr.split(arr, frr);\n        (GhostMapAuth { r: ar }, GhostSubmap { r: fr })\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 274,
        "module": "vstd::tokens::map",
        "keywords": [
          "Map"
        ],
        "callees": [
          "alloc",
          "value",
          "op",
          "ome",
          "empty",
          "split",
          "tracked"
        ]
      },
      "vstd::tokens::map::agree": {
        "name": "vstd::tokens::map::agree",
        "type": "proof",
        "signature": "pub proof fn agree(tracked self: &GhostSubmap<K, V>, tracked auth: &GhostMapAuth<K, V>)\n        requires\n            self.id() == auth.id(),\n        ensures\n            self@ <= auth@,",
        "ensures": [
          "self@ <= auth@"
        ],
        "requires": [
          "self.id() == auth.id()"
        ],
        "body": "{\n        broadcast use lemma_submap_of_trans;\n\n        use_type_invariant(self);\n        use_type_invariant(auth);\n\n        let tracked joined = self.r.join_shared(&auth.r);\n        joined.validate();\n        assert(self.r.value().frac.unwrap() <= joined.value().frac.unwrap());\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 343,
        "module": "vstd::tokens::map",
        "keywords": [
          "Map"
        ],
        "callees": [
          "validate",
          "join_shared",
          "value",
          "use_type_invariant"
        ]
      },
      "vstd::tokens::map::combine": {
        "name": "vstd::tokens::map::combine",
        "type": "proof",
        "signature": "pub proof fn combine(tracked &mut self, tracked other: GhostSubmap<K, V>)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@.union_prefer_right(other@),\n            old(self)@.dom().disjoint(other@.dom()),",
        "ensures": [
          "self.id() == old(self).id()",
          "self@ == old(self)@.union_prefer_right(other@)",
          "old(self)@.dom().disjoint(other@.dom())"
        ],
        "requires": [
          "old(self).id() == other.id()"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        use_type_invariant(&other);\n\n        let tracked mut r = Resource::alloc(MapCarrier::unit());\n        tracked_swap(&mut self.r, &mut r);\n        r.validate_2(&other.r);\n        self.r = r.join(other.r);\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 359,
        "module": "vstd::tokens::map",
        "keywords": [],
        "callees": [
          "tracked_swap",
          "validate_2",
          "use_type_invariant",
          "alloc",
          "join",
          "unit"
        ]
      },
      "disjoint": {
        "name": "vstd::tokens::map::disjoint",
        "type": "proof",
        "signature": "pub proof fn disjoint(tracked &mut self, tracked other: &GhostSubmap<K, V>)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@.dom().disjoint(other@.dom()),",
        "ensures": [
          "self.id() == old(self).id()",
          "self@ == old(self)@",
          "self@.dom().disjoint(other@.dom())"
        ],
        "requires": [
          "old(self).id() == other.id()"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        use_type_invariant(other);\n        self.r.validate_2(&other.r);\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 376,
        "module": "vstd::tokens::map",
        "keywords": [],
        "callees": [
          "validate_2",
          "use_type_invariant"
        ]
      },
      "vstd::tokens::map::split": {
        "name": "vstd::tokens::map::split",
        "type": "proof",
        "signature": "pub proof fn split(tracked &mut self, s: Set<K>) -> (tracked result: GhostSubmap<K, V>)\n        requires\n            s <= old(self)@.dom(),\n        ensures\n            self.id() == old(self).id(),\n            result.id() == self.id(),\n            old(self)@ == self@.union_prefer_right(result@),\n            result@.dom() =~= s,\n            self@.dom() =~= old(self)@.dom() - s,",
        "ensures": [
          "self.id() == old(self).id()",
          "result.id() == self.id()",
          "old(self)@ == self@.union_prefer_right(result@)",
          "result@.dom() =~= s",
          "self@.dom() =~= old(self)@.dom() - s"
        ],
        "requires": [
          "s <= old(self)@.dom()"
        ],
        "body": "{\n        use_type_invariant(&*self);\n\n        let tracked mut r = Resource::alloc(MapCarrier::<K, V>::unit());\n        tracked_swap(&mut self.r, &mut r);\n\n        let rr1 = MapCarrier { auth: None, frac: Some(r.value().frac.unwrap().remove_keys(s)) };\n\n        let rr2 = MapCarrier { auth: None, frac: Some(r.value().frac.unwrap().restrict(s)) };\n\n        assert(r.value().frac == MapCarrier::op(rr1, rr2).frac);\n        let tracked (r1, r2) = r.split(rr1, rr2);\n        self.r = r1;\n        GhostSubmap { r: r2 }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 389,
        "module": "vstd::tokens::map",
        "keywords": [
          "Set"
        ],
        "callees": [
          "tracked_swap",
          "use_type_invariant",
          "alloc",
          "value",
          "op",
          "restrict",
          "remove_keys",
          "ome",
          "split",
          "tracked",
          "unit"
        ]
      },
      "vstd::tokens::map::update": {
        "name": "vstd::tokens::map::update",
        "type": "proof",
        "signature": "pub proof fn update(tracked &mut self, tracked auth: &mut GhostMapAuth<K, V>, m: Map<K, V>)\n        requires\n            m.dom() <= old(self)@.dom(),\n            old(self).id() == old(auth).id(),\n        ensures\n            self.id() == old(self).id(),\n            auth.id() == old(auth).id(),\n            self@ == old(self)@.union_prefer_right(m),\n            auth@ == old(auth)@.union_prefer_right(m),",
        "ensures": [
          "self.id() == old(self).id()",
          "auth.id() == old(auth).id()",
          "self@ == old(self)@.union_prefer_right(m)",
          "auth@ == old(auth)@.union_prefer_right(m)"
        ],
        "requires": [
          "m.dom() <= old(self)@.dom()",
          "old(self).id() == old(auth).id()"
        ],
        "body": "{\n        broadcast use lemma_submap_of_trans;\n        broadcast use lemma_op_frac_submap_of;\n\n        use_type_invariant(&*self);\n        use_type_invariant(&*auth);\n\n        let tracked mut mself = Self::dummy();\n        tracked_swap(self, &mut mself);\n        let tracked mut fr = mself.r;\n\n        let tracked mut mauth = GhostMapAuth::<K, V>::dummy();\n        tracked_swap(auth, &mut mauth);\n        let tracked mut ar = mauth.r;\n\n        fr.validate_2(&ar);\n        let tracked mut r = fr.join(ar);\n\n        assert(r.value().frac == fr.value().frac);\n\n        let rr = MapCarrier {\n            auth: Some(Some(r.value().auth.unwrap().unwrap().union_prefer_right(m))),\n            frac: Some(r.value().frac.unwrap().union_prefer_right(m)),\n        };\n\n        let tracked r_upd = r.update(rr);\n\n        let arr = MapCarrier { auth: r_upd.value().auth, frac: Some(Map::empty()) };\n\n        let frr = MapCarrier { auth: None, frac: r_upd.value().frac };\n\n        assert(r_upd.value().frac == MapCarrier::op(arr, frr).frac);\n        let tracked (ar, fr) = r_upd.split(arr, frr);\n        auth.r = ar;\n        self.r = fr;\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 414,
        "module": "vstd::tokens::map",
        "keywords": [
          "Map"
        ],
        "callees": [
          "tracked_swap",
          "validate_2",
          "join",
          "use_type_invariant",
          "update",
          "dummy",
          "value",
          "op",
          "ome",
          "empty",
          "split",
          "tracked",
          "union_prefer_right"
        ]
      },
      "vstd::tokens::seq::id": {
        "name": "vstd::tokens::seq::id",
        "type": "closed_spec",
        "signature": "pub closed spec fn id(self) -> int",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.frac.id()\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 204,
        "module": "vstd::tokens::seq",
        "keywords": [],
        "callees": [
          "id"
        ]
      },
      "vstd::tokens::seq::view": {
        "name": "vstd::tokens::seq::view",
        "type": "closed_spec",
        "signature": "pub closed spec fn view(self) -> Seq<V>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Seq::new(self.len, |i: int| self.frac@[self.off + i])\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 178,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Seq"
        ],
        "callees": [
          "new"
        ]
      },
      "off": {
        "name": "vstd::tokens::seq::off",
        "type": "closed_spec",
        "signature": "pub closed spec fn off(self) -> nat",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.off\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 99,
        "module": "vstd::tokens::seq",
        "keywords": [],
        "callees": []
      },
      "vstd::tokens::seq::new": {
        "name": "vstd::tokens::seq::new",
        "type": "proof",
        "signature": "pub proof fn new(off: nat, len: nat, tracked f: GhostSubmap<int, V>) -> (tracked result:\n        GhostSubseq<V>)\n        requires\n            f@.dom() == Set::new(|i: int| off <= i < off + len),\n        ensures\n            result.id() == f.id(),\n            result.off() == off,\n            result@ == Seq::new(len, |i| f@[off + i]),",
        "ensures": [
          "result.id() == f.id()",
          "result.off() == off",
          "result@ == Seq::new(len, |i| f@[off + i])"
        ],
        "requires": [
          "f@.dom() == Set::new(|i: int| off <= i < off + len)"
        ],
        "body": "{\n        GhostSubseq { off: off, len: len, frac: f }\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 391,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Seq",
          "Set",
          "len"
        ],
        "callees": []
      },
      "vstd::tokens::seq::dummy": {
        "name": "vstd::tokens::seq::dummy",
        "type": "proof",
        "signature": "pub proof fn dummy() -> (tracked result: Self)",
        "ensures": [],
        "requires": [],
        "body": "{\n        let tracked (auth, subseq) = GhostSeqAuth::<V>::new(Seq::empty(), 0);\n        subseq\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 384,
        "module": "vstd::tokens::seq",
        "keywords": [],
        "callees": [
          "tracked",
          "new",
          "empty"
        ]
      },
      "vstd::tokens::seq::agree": {
        "name": "vstd::tokens::seq::agree",
        "type": "proof",
        "signature": "pub proof fn agree(tracked self: &GhostSubseq<V>, tracked auth: &GhostSeqAuth<V>)\n        requires\n            self.id() == auth.id(),\n        ensures\n            self@.len() > 0 ==>",
        "ensures": [
          "self@.len() > 0 ==>"
        ],
        "requires": [
          "self.id() == auth.id()"
        ],
        "body": "{\n                &&& self@ =~= auth@.subrange(\n                    self.off() as int - auth.off(),\n                    self.off() - auth.off() + self@.len() as int,\n                )\n                &&& self.off() >= auth.off()\n                &&& self.off() + self@.len() <= auth.off() + auth@.len()\n            }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 208,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": [
          "len",
          "off",
          "subrange"
        ]
      },
      "update_subrange_with": {
        "name": "update_subrange_with",
        "type": "proof",
        "signature": "pub proof fn update_subrange_with(\n        tracked self: &mut GhostSeqAuth<V>,\n        tracked frac: &mut GhostSubseq<V>,\n        off: int,\n        v: Seq<V>,\n    )\n        requires\n            old(self).id() == old(frac).id(),\n            old(frac).off() <= off,\n            off + v.len() <= old(frac).off() + old(frac)@.len(),\n        ensures\n            self.id() == old(self).id(),\n            frac.id() == old(frac).id(),\n            frac.off() == old(frac).off(),\n            self@ =~= old(self)@.update_subrange_with(off - self.off(), v),\n            frac@ =~= old(frac)@.update_subrange_with(off - frac.off(), v),\n            self.off() == old(self).off(),\n            frac.off() == old(frac).off(),",
        "ensures": [
          "self.id() == old(self).id()",
          "frac.id() == old(frac).id()",
          "frac.off() == old(frac).off()",
          "self@ =~= old(self)@.update_subrange_with(off - self.off(), v)",
          "frac@ =~= old(frac)@.update_subrange_with(off - frac.off(), v)",
          "self.off() == old(self).off()",
          "frac.off() == old(frac).off()"
        ],
        "requires": [
          "old(self).id() == old(frac).id()",
          "old(frac).off() <= off",
          "off + v.len() <= old(frac).off() + old(frac)@.len()"
        ],
        "body": "{\n        let tracked mut mid = frac.split(off - frac.off());\n        let tracked mut end = mid.split(v.len() as int);\n        mid.update(self, v);\n        frac.combine(mid);\n        frac.combine(end);\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 145,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": [
          "update",
          "combine",
          "len",
          "off",
          "split"
        ]
      },
      "vstd::tokens::seq::off": {
        "name": "vstd::tokens::seq::off",
        "type": "closed_spec",
        "signature": "pub closed spec fn off(self) -> nat",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.off\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 200,
        "module": "vstd::tokens::seq",
        "keywords": [],
        "callees": []
      },
      "agree_map": {
        "name": "agree_map",
        "type": "proof",
        "signature": "pub proof fn agree_map(tracked self: &GhostSubseq<V>, tracked auth: &GhostMapAuth<int, V>)\n        requires\n            self.id() == auth.id(),\n        ensures\n            forall|i|\n                0 <= i < self@.len() ==> #[trigger] auth@.contains_key(self.off() + i)\n                    && auth@[self.off() + i] == self@[i],",
        "ensures": [
          "forall|i|\n                0 <= i < self@.len() ==> #[trigger] auth@.contains_key(self.off() + i)\n                    && auth@[self.off() + i] == self@[i]"
        ],
        "requires": [
          "self.id() == auth.id()"
        ],
        "body": "{\n        use_type_invariant(self);\n\n        self.frac.agree(&auth);\n\n        assert forall|i: int| 0 <= i < self.len implies #[trigger] auth@.contains_key(self.off + i)\n            && self.frac@[self.off + i] == auth@[self.off + i] by {\n            assert(self.frac@.contains_key(self.off + i));\n        };\n    }",
        "doc_comment": null,
        "triggers": [
          "auth@.contains_key(self.off("
        ],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 242,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Map",
          "forall",
          "len",
          "trigger"
        ],
        "callees": [
          "agree",
          "use_type_invariant",
          "contains_key"
        ]
      },
      "vstd::tokens::seq::update": {
        "name": "vstd::tokens::seq::update",
        "type": "proof",
        "signature": "pub proof fn update(\n        tracked self: &mut GhostSubseq<V>,\n        tracked auth: &mut GhostSeqAuth<V>,\n        v: Seq<V>,\n    )\n        requires\n            old(self).id() == old(auth).id(),\n            v.len() == old(self)@.len(),\n        ensures\n            self.id() == auth.id(),\n            self.off() == old(self).off(),\n            auth.id() == old(auth).id(),\n            self@ =~= v,\n            auth@ =~= old(auth)@.update_subrange_with(self.off() - auth.off(), v),\n            self.off() == old(self).off(),\n            auth.off() == old(auth).off(),",
        "ensures": [
          "self.id() == auth.id()",
          "self.off() == old(self).off()",
          "auth.id() == old(auth).id()",
          "self@ =~= v",
          "auth@ =~= old(auth)@.update_subrange_with(self.off() - auth.off(), v)",
          "self.off() == old(self).off()",
          "auth.off() == old(auth).off()"
        ],
        "requires": [
          "old(self).id() == old(auth).id()",
          "v.len() == old(self)@.len()"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        use_type_invariant(&*auth);\n\n        self.update_map(&mut auth.auth, v);\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 260,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Seq",
          "len"
        ],
        "callees": [
          "update_map",
          "use_type_invariant"
        ]
      },
      "update_map": {
        "name": "update_map",
        "type": "proof",
        "signature": "pub proof fn update_map(\n        tracked self: &mut GhostSubseq<V>,\n        tracked auth: &mut GhostMapAuth<int, V>,\n        v: Seq<V>,\n    )\n        requires\n            old(self).id() == old(auth).id(),\n            v.len() == old(self)@.len(),\n        ensures\n            self.id() == auth.id(),\n            self.off() == old(self).off(),\n            auth.id() == old(auth).id(),\n            self@ =~= v,\n            auth@ =~= Map::new(\n                |i: int| old(auth)@.contains_key(i),\n                |i: int|\n                    if self.off() <= i < self.off() + v.len()",
        "ensures": [
          "self.id() == auth.id()",
          "self.off() == old(self).off()",
          "auth.id() == old(auth).id()",
          "self@ =~= v",
          "auth@ =~= Map::new(\n                |i: int| old(auth)@.contains_key(i)",
          "|i: int|\n                    if self.off() <= i < self.off() + v.len()"
        ],
        "requires": [
          "old(self).id() == old(auth).id()",
          "v.len() == old(self)@.len()"
        ],
        "body": "{\n                        v[i - self.off()]\n                    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 283,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Map",
          "Seq",
          "len"
        ],
        "callees": [
          "off"
        ]
      },
      "vstd::tokens::seq::split": {
        "name": "vstd::tokens::seq::split",
        "type": "proof",
        "signature": "pub proof fn split(tracked self: &mut GhostSubseq<V>, n: int) -> (tracked result: GhostSubseq<\n        V,\n    >)\n        requires\n            0 <= n <= old(self)@.len(),\n        ensures\n            self.id() == old(self).id(),\n            self.off() == old(self).off(),\n            result.id() == self.id(),\n            result.off() == old(self).off() + n,\n            self@ =~= old(self)@.subrange(0, n),\n            result@ =~= old(self)@.subrange(n, old(self)@.len() as int),",
        "ensures": [
          "self.id() == old(self).id()",
          "self.off() == old(self).off()",
          "result.id() == self.id()",
          "result.off() == old(self).off() + n",
          "self@ =~= old(self)@.subrange(0, n)",
          "result@ =~= old(self)@.subrange(n, old(self)@.len() as int)"
        ],
        "requires": [
          "0 <= n <= old(self)@.len()"
        ],
        "body": "{\n        let tracked mut mself = Self::dummy();\n        tracked_swap(self, &mut mself);\n\n        use_type_invariant(&mself);\n        let tracked mut mselffrac = mself.frac;\n\n        let tracked mfrac = mselffrac.split(\n            Set::new(|i: int| mself.off + n <= i < mself.off + mself.len),\n        );\n        let tracked result = GhostSubseq {\n            off: (mself.off + n) as nat,\n            len: (mself.len - n) as nat,\n            frac: mfrac,\n        };\n\n        *self = Self { off: mself.off, len: n as nat, frac: mselffrac };\n        result\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 314,
        "module": "vstd::tokens::seq",
        "keywords": [
          "len",
          "subrange"
        ],
        "callees": [
          "tracked_swap",
          "use_type_invariant",
          "dummy",
          "split",
          "new"
        ]
      },
      "vstd::tokens::seq::combine": {
        "name": "vstd::tokens::seq::combine",
        "type": "proof",
        "signature": "pub proof fn combine(tracked self: &mut GhostSubseq<V>, tracked r: GhostSubseq<V>)\n        requires\n            r.id() == old(self).id(),\n            r.off() == old(self).off() + old(self)@.len(),\n        ensures\n            self.id() == old(self).id(),\n            self@ =~= old(self)@ + r@,\n            self.off() == old(self).off(),",
        "ensures": [
          "self.id() == old(self).id()",
          "self@ =~= old(self)@ + r@",
          "self.off() == old(self).off()"
        ],
        "requires": [
          "r.id() == old(self).id()",
          "r.off() == old(self).off() + old(self)@.len()"
        ],
        "body": "{\n        let tracked mut mself = Self::dummy();\n        tracked_swap(self, &mut mself);\n\n        use_type_invariant(&mself);\n        use_type_invariant(&r);\n        let tracked mut mselffrac = mself.frac;\n\n        mselffrac.combine(r.frac);\n        *self = Self { frac: mselffrac, off: mself.off, len: mself.len + r.len };\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 346,
        "module": "vstd::tokens::seq",
        "keywords": [
          "len"
        ],
        "callees": [
          "tracked_swap",
          "dummy",
          "use_type_invariant",
          "combine"
        ]
      },
      "vstd::tokens::seq::disjoint": {
        "name": "vstd::tokens::seq::disjoint",
        "type": "proof",
        "signature": "pub proof fn disjoint(tracked &mut self, tracked other: &GhostSubseq<V>)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self.off() == old(self).off(),\n            self@ == old(self)@,\n            self@.len() == 0 || other@.len() == 0 || self.off() + self@.len() <= other.off()\n                || other.off() + other@.len() <= self.off(),",
        "ensures": [
          "self.id() == old(self).id()",
          "self.off() == old(self).off()",
          "self@ == old(self)@",
          "self@.len() == 0 || other@.len() == 0 || self.off() + self@.len() <= other.off()\n                || other.off() + other@.len() <= self.off()"
        ],
        "requires": [
          "old(self).id() == other.id()"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        use_type_invariant(other);\n\n        self.frac.disjoint(&other.frac);\n        assert(self@.len() == 0 || self.frac@.contains_key(self.off() as int));\n        assert(other@.len() == 0 || other.frac@.contains_key(other.off() as int));\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 366,
        "module": "vstd::tokens::seq",
        "keywords": [
          "len"
        ],
        "callees": [
          "use_type_invariant",
          "disjoint",
          "len",
          "off",
          "contains_key"
        ]
      },
      "instance_id": {
        "name": "vstd::tokens::instance_id",
        "type": "closed_spec",
        "signature": "pub closed spec fn instance_id(self) -> InstanceId",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.inst\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 265,
        "module": "vstd::tokens",
        "keywords": [],
        "callees": []
      },
      "map": {
        "name": "map",
        "type": "closed_spec",
        "signature": "pub closed spec fn map(self) -> Map<Key, Value>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Map::new(\n            |k: Key| self.m.dom().contains(k),\n            |k: Key| self.m[k].value(),\n        )\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 269,
        "module": "vstd::tokens",
        "keywords": [
          "Map",
          "map"
        ],
        "callees": [
          "value",
          "dom",
          "new",
          "contains"
        ]
      },
      "vstd::tokens::empty": {
        "name": "vstd::tokens::empty",
        "type": "proof",
        "signature": "pub proof fn empty(instance_id: InstanceId) -> (tracked s: Self)\n        ensures\n            s.instance_id() == instance_id,\n            s.multiset() === Multiset::empty(),",
        "ensures": [
          "s.instance_id() == instance_id",
          "s.multiset() === Multiset::empty()"
        ],
        "requires": [],
        "body": "{\n        let tracked s = Self { inst: instance_id, m: Map::tracked_empty(), _v: PhantomData, };\n        broadcast use super::set::fold::lemma_fold_empty;\n        assert(Self::map_elems(Map::empty()) =~= Map::empty());\n        return s;\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 535,
        "module": "vstd::tokens",
        "keywords": [
          "Multiset",
          "empty"
        ],
        "callees": [
          "map_elems",
          "tracked_empty",
          "empty"
        ]
      },
      "vstd::tokens::insert": {
        "name": "vstd::tokens::insert",
        "type": "proof",
        "signature": "pub proof fn insert(tracked &mut self, tracked token: Token)\n        requires\n            old(self).instance_id() == token.instance_id(),\n        ensures\n            self.instance_id() == old(self).instance_id(),\n            self.multiset() == old(self).multiset().insert(token.element()),",
        "ensures": [
          "self.instance_id() == old(self).instance_id()",
          "self.multiset() == old(self).multiset().insert(token.element())"
        ],
        "requires": [
          "old(self).instance_id() == token.instance_id()"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        let f = fresh(self.m.dom());\n        fresh_is_fresh(self.m.dom());\n        map_values_insert_not_in(\n            Self::map_elems(self.m),\n            f,\n            token.element());\n        self.m.tracked_insert(f, token);\n        assert(Self::map_elems(self.m) =~= Self::map_elems(old(self).m).insert(\n            f, token.element()));\n        assert(self.multiset() =~= old(self).multiset().insert(token.element()));\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 546,
        "module": "vstd::tokens",
        "keywords": [
          "insert"
        ],
        "callees": [
          "multiset",
          "use_type_invariant",
          "fresh",
          "map_values_insert_not_in",
          "element",
          "tracked_insert",
          "insert",
          "fresh_is_fresh",
          "map_elems",
          "dom"
        ]
      },
      "vstd::tokens::remove": {
        "name": "vstd::tokens::remove",
        "type": "proof",
        "signature": "pub proof fn remove(tracked &mut self, element: Element) -> (tracked token: Token)\n        requires\n            old(self).multiset().contains(element)\n        ensures\n            self.instance_id() == old(self).instance_id(),\n            self.multiset() == old(self).multiset().remove(element),\n            token.instance_id() == self.instance_id(),\n            token.element() == element,",
        "ensures": [
          "self.instance_id() == old(self).instance_id()",
          "self.multiset() == old(self).multiset().remove(element)",
          "token.instance_id() == self.instance_id()",
          "token.element() == element"
        ],
        "requires": [
          "old(self).multiset().contains(element)"
        ],
        "body": "{\n        use_type_invariant(&*self);\n        assert(Self::map_elems(self.m).dom() =~= self.m.dom());\n        let k = get_key_for_value(Self::map_elems(self.m), element);\n        map_values_remove(Self::map_elems(self.m), k);\n        let tracked t = self.m.tracked_remove(k);\n        assert(Self::map_elems(self.m) =~= Self::map_elems(old(self).m).remove(k));\n        assert(self.multiset() =~= old(self).multiset().remove(element));\n        t\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 566,
        "module": "vstd::tokens",
        "keywords": [
          "contains",
          "remove"
        ],
        "callees": [
          "multiset",
          "remove",
          "use_type_invariant",
          "tracked_remove",
          "map_elems",
          "dom",
          "map_values_remove",
          "get_key_for_value"
        ]
      },
      "into_map": {
        "name": "vstd::tokens::into_map",
        "type": "proof",
        "signature": "pub proof fn into_map(tracked self) -> (tracked map: Map<Key, Token>)\n        ensures\n            map.dom() == self.map().dom(),\n            forall |key|\n                #![trigger(map.dom().contains(key))]\n                #![trigger(map.index(key))]\n              map.dom().contains(key)\n                ==> map[key].instance_id() == self.instance_id()\n                 && map[key].key() == key\n                 && map[key].value() == self.map()[key]",
        "ensures": [
          "map.dom() == self.map().dom()",
          "forall |key|\n                #![trigger(map.dom().contains(key))]\n                #![trigger(map.index(key))]\n              map.dom().contains(key)\n                ==> map[key].instance_id() == self.instance_id()\n                 && map[key].key() == key\n                 && map[key].value() == self.map()[key]"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(&self);\n        let tracked MapToken { inst, m, _v } = self;\n        assert(m.dom() =~= self.map().dom());\n        return m;\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 329,
        "module": "vstd::tokens",
        "keywords": [
          "Map",
          "contains",
          "forall",
          "map",
          "trigger"
        ],
        "callees": [
          "dom",
          "use_type_invariant",
          "map"
        ]
      },
      "vstd::tokens::from_map": {
        "name": "vstd::tokens::from_map",
        "type": "proof",
        "signature": "pub proof fn from_map(instance_id: InstanceId, tracked map: Map<Element, Token>) -> (tracked s: Self)\n        requires\n            forall |key| #[trigger] map.dom().contains(key) ==> map[key].instance_id() == instance_id,\n            forall |key| #[trigger] map.dom().contains(key) ==> map[key].element() == key,\n        ensures\n            s.instance_id() == instance_id,\n            s.set() == map.dom(),",
        "ensures": [
          "s.instance_id() == instance_id",
          "s.set() == map.dom()"
        ],
        "requires": [
          "forall |key| #[trigger] map.dom().contains(key) ==> map[key].instance_id() == instance_id",
          "forall |key| #[trigger] map.dom().contains(key) ==> map[key].element() == key"
        ],
        "body": "{\n        let tracked s = SetToken { inst: instance_id, m: map };\n        assert(s.set() =~= map.dom());\n        s\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 447,
        "module": "vstd::tokens",
        "keywords": [
          "Map",
          "contains",
          "forall",
          "map",
          "trigger"
        ],
        "callees": [
          "dom",
          "set"
        ]
      },
      "vstd::tokens::instance_id": {
        "name": "vstd::tokens::instance_id",
        "type": "closed_spec",
        "signature": "pub closed spec fn instance_id(self) -> InstanceId",
        "ensures": [],
        "requires": [],
        "body": "{\n        self.inst\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 523,
        "module": "vstd::tokens",
        "keywords": [],
        "callees": []
      },
      "set": {
        "name": "set",
        "type": "closed_spec",
        "signature": "pub closed spec fn set(self) -> Set<Element>",
        "ensures": [],
        "requires": [],
        "body": "{\n        Set::new(\n            |e: Element| self.m.dom().contains(e),\n        )\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 383,
        "module": "vstd::tokens",
        "keywords": [
          "Set"
        ],
        "callees": [
          "dom",
          "new",
          "contains"
        ]
      },
      "vstd::tokens::into_map": {
        "name": "vstd::tokens::into_map",
        "type": "proof",
        "signature": "pub proof fn into_map(tracked self) -> (tracked map: Map<Element, Token>)\n        ensures\n            map.dom() == self.set(),\n            forall |key|\n                #![trigger(map.dom().contains(key))]\n                #![trigger(map.index(key))]\n                map.dom().contains(key)\n                    ==> map[key].instance_id() == self.instance_id()\n                     && map[key].element() == key",
        "ensures": [
          "map.dom() == self.set()",
          "forall |key|\n                #![trigger(map.dom().contains(key))]\n                #![trigger(map.index(key))]\n                map.dom().contains(key)\n                    ==> map[key].instance_id() == self.instance_id()\n                     && map[key].element() == key"
        ],
        "requires": [],
        "body": "{\n        use_type_invariant(&self);\n        let tracked SetToken { inst, m } = self;\n        assert(m.dom() =~= self.set());\n        return m;\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 431,
        "module": "vstd::tokens",
        "keywords": [
          "Map",
          "contains",
          "forall",
          "map",
          "trigger"
        ],
        "callees": [
          "dom",
          "use_type_invariant",
          "set"
        ]
      },
      "multiset": {
        "name": "multiset",
        "type": "closed_spec",
        "signature": "pub closed spec fn multiset(self) -> Multiset<Element>",
        "ensures": [],
        "requires": [],
        "body": "{\n        map_values(Self::map_elems(self.m))\n    }",
        "doc_comment": null,
        "triggers": [],
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 531,
        "module": "vstd::tokens",
        "keywords": [
          "Multiset"
        ],
        "callees": [
          "map_values",
          "map_elems"
        ]
      }
    },
    "open_specs": {
      "is_mod_equivalent": {
        "name": "is_mod_equivalent",
        "signature": "pub open spec fn is_mod_equivalent(x: int, y: int, m: int) -> bool\n    recommends\n        m > 0,",
        "body": "{\n    x % m == y % m <==> (x - y) % m == 0\n}",
        "file_path": "verus/source/vstd/arithmetic/div_mod.rs",
        "line_number": 1450,
        "module": "vstd::arithmetic::div_mod",
        "keywords": []
      },
      "div_pos": {
        "name": "div_pos",
        "signature": "pub open spec fn div_pos(x: int, d: int) -> int\n    recommends\n        d > 0,\n    decreases\n            (if x < 0",
        "body": "{\n                d - x\n            }",
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 39,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": [
          "decreases"
        ]
      },
      "div_recursive": {
        "name": "div_recursive",
        "signature": "pub open spec fn div_recursive(x: int, d: int) -> int\n    recommends\n        d != 0,",
        "body": "{\n    // reveal(div_pos);\n    if d > 0 {\n        div_pos(x, d)\n    } else {\n        -1 * div_pos(x, -1 * d)\n    }\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 63,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": []
      },
      "div_auto_plus": {
        "name": "div_auto_plus",
        "signature": "pub open spec fn div_auto_plus(n: int) -> bool",
        "body": "{\n    forall|x: int, y: int|\n        #![trigger ((x + y) / n)]\n        {\n            let z = (x % n) + (y % n);\n            ((0 <= z < n && ((x + y) / n) == x / n + y / n) || (n <= z < n + n && ((x + y) / n) == x\n                / n + y / n + 1))\n        }\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 99,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": []
      },
      "div_auto_minus": {
        "name": "div_auto_minus",
        "signature": "pub open spec fn div_auto_minus(n: int) -> bool",
        "body": "{\n    forall|x: int, y: int|\n        #![trigger ((x - y) / n)]\n        {\n            let z = (x % n) - (y % n);\n            ((0 <= z < n && ((x - y) / n) == x / n - y / n) || (-n <= z < 0 && ((x - y) / n) == x\n                / n - y / n - 1))\n        }\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 113,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": []
      },
      "div_auto": {
        "name": "div_auto",
        "signature": "pub open spec fn div_auto(n: int) -> bool\n    recommends\n        n > 0,",
        "body": "{\n    &&& mod_auto(n)\n    &&& (n / n == -((-n) / n) == 1)\n    &&& forall|x: int| 0 <= x < n <==> #[trigger] (x / n) == 0\n    &&& div_auto_plus(n)\n    &&& div_auto_minus(n)\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/div_internals.rs",
        "line_number": 127,
        "module": "vstd::arithmetic::internals::div_internals",
        "keywords": []
      },
      "is_le": {
        "name": "is_le",
        "signature": "pub open spec fn is_le(x: int, y: int) -> bool",
        "body": "{\n    x <= y\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/general_internals.rs",
        "line_number": 25,
        "module": "vstd::arithmetic::internals::general_internals",
        "keywords": []
      },
      "mod_recursive": {
        "name": "mod_recursive",
        "signature": "pub open spec fn mod_recursive(x: int, d: int) -> int\n    recommends\n        d > 0,\n    decreases\n            (if x < 0",
        "body": "{\n                (d - x)\n            }",
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 38,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": [
          "decreases"
        ]
      },
      "mod_auto_plus": {
        "name": "mod_auto_plus",
        "signature": "pub open spec fn mod_auto_plus(n: int) -> bool\n    recommends\n        n > 0,",
        "body": "{\n    forall|x: int, y: int|\n        {\n            let z = (x % n) + (y % n);\n            ((0 <= z < n && #[trigger] ((x + y) % n) == z) || (n <= z < n + n && ((x + y) % n) == z\n                - n))\n        }\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 346,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": []
      },
      "mod_auto_minus": {
        "name": "mod_auto_minus",
        "signature": "pub open spec fn mod_auto_minus(n: int) -> bool\n    recommends\n        n > 0,",
        "body": "{\n    forall|x: int, y: int|\n        {\n            let z = (x % n) - (y % n);\n            ((0 <= z < n && #[trigger] ((x - y) % n) == z) || (-n <= z < 0 && ((x - y) % n) == z\n                + n))\n        }\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 362,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": []
      },
      "mod_auto": {
        "name": "mod_auto",
        "signature": "pub open spec fn mod_auto(n: int) -> bool\n    recommends\n        n > 0,",
        "body": "{\n    &&& (n % n == 0 && (-n) % n == 0)\n    &&& (forall|x: int| #[trigger] ((x % n) % n) == x % n)\n    &&& (forall|x: int| 0 <= x < n <==> #[trigger] (x % n) == x)\n    &&& mod_auto_plus(n)\n    &&& mod_auto_minus(n)\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals.rs",
        "line_number": 376,
        "module": "vstd::arithmetic::internals::mod_internals",
        "keywords": []
      },
      "modulus": {
        "name": "modulus",
        "signature": "pub open spec fn modulus(x: int, y: int) -> int",
        "body": "{\n    x % y\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/mod_internals_nonlinear.rs",
        "line_number": 24,
        "module": "vstd::arithmetic::internals::mod_internals_nonlinear",
        "keywords": []
      },
      "mul_pos": {
        "name": "mul_pos",
        "signature": "pub open spec fn mul_pos(x: int, y: int) -> int\n    recommends\n        x >= 0,\n    decreases x,",
        "body": "{\n    if x <= 0 {\n        0\n    } else {\n        y + mul_pos(x - 1, y)\n    }\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 30,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": [
          "decreases"
        ]
      },
      "mul_recursive": {
        "name": "mul_recursive",
        "signature": "pub open spec fn mul_recursive(x: int, y: int) -> int",
        "body": "{\n    if x >= 0 {\n        mul_pos(x, y)\n    } else {\n        -1 * mul_pos(-1 * x, y)\n    }\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 43,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": []
      },
      "mul_auto": {
        "name": "mul_auto",
        "signature": "pub open spec fn mul_auto() -> bool",
        "body": "{\n    &&& forall|x: int, y: int| #[trigger] (x * y) == (y * x)\n    &&& forall|x: int, y: int, z: int| #[trigger] ((x + y) * z) == (x * z + y * z)\n    &&& forall|x: int, y: int, z: int| #[trigger] ((x - y) * z) == (x * z - y * z)\n}",
        "file_path": "verus/source/vstd/arithmetic/internals/mul_internals.rs",
        "line_number": 148,
        "module": "vstd::arithmetic::internals::mul_internals",
        "keywords": []
      },
      "log": {
        "name": "log",
        "signature": "pub open spec fn log(base: int, pow: int) -> int\n    recommends\n        base > 1,\n        pow >= 0,\n    decreases pow,",
        "body": "{\n    // In Dafny, we can invoke lemmas in functions to establish\n    // termination. Here in Verus, instead, we add the second\n    // conditions `pow / base >= pow` and `pow / base < 0` to show\n    // termination.\n    if pow < base || pow / base >= pow || pow / base < 0 {\n        0\n    } else {\n        1 + log(base, pow / base)\n    }\n}",
        "file_path": "verus/source/vstd/arithmetic/logarithm.rs",
        "line_number": 38,
        "module": "vstd::arithmetic::logarithm",
        "keywords": [
          "decreases"
        ]
      },
      "spec_is_overflowed": {
        "name": "spec_is_overflowed",
        "signature": "pub open spec fn spec_is_overflowed(&self) -> bool",
        "body": "{\n                    self@ > $uty::MAX\n                }",
        "file_path": "verus/source/vstd/arithmetic/overflow.rs",
        "line_number": 140,
        "module": "vstd::arithmetic::overflow",
        "keywords": []
      },
      "pow": {
        "name": "pow",
        "signature": "pub open spec fn pow(b: int, e: nat) -> int\n    decreases e,",
        "body": "{\n    if e == 0 {\n        1\n    } else {\n        b * pow(b, (e - 1) as nat)\n    }\n}",
        "file_path": "verus/source/vstd/arithmetic/power.rs",
        "line_number": 43,
        "module": "vstd::arithmetic::power",
        "keywords": [
          "decreases"
        ]
      },
      "pow2": {
        "name": "pow2",
        "signature": "pub open spec fn pow2(e: nat) -> nat\n    decreases\n            e  // ensures pow2(e) > 0\n            // cannot have ensurs clause in spec functions\n            // a workaround is the lemma_pow2_pos below\n            ,",
        "body": "{\n    // you cannot reveal in a spec function, which cause more reveals clauses\n    // for the proof\n    // reveal(pow);\n    pow(2, e) as nat\n}",
        "file_path": "verus/source/vstd/arithmetic/power2.rs",
        "line_number": 32,
        "module": "vstd::arithmetic::power2",
        "keywords": [
          "decreases"
        ]
      },
      "array_view": {
        "name": "array_view",
        "signature": "pub open spec fn array_view<T, const N: usize>(a: [T; N]) -> Seq<T>",
        "body": "{\n    Seq::new(N as nat, |i: int| array_index(a, i))\n}",
        "file_path": "verus/source/vstd/array.rs",
        "line_number": 9,
        "module": "vstd::array",
        "keywords": [
          "Seq"
        ]
      },
      "is_for": {
        "name": "is_for",
        "signature": "pub open spec fn is_for(&self, patomic: $at_ident) -> bool",
        "body": "{\n                self.view().patomic == patomic.id()\n            }",
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 117,
        "module": "vstd::atomic",
        "keywords": []
      },
      "points_to": {
        "name": "points_to",
        "signature": "pub open spec fn points_to(&self, v: $value_ty) -> bool",
        "body": "{\n                self.view().value == v\n            }",
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 121,
        "module": "vstd::atomic",
        "keywords": []
      },
      "value": {
        "name": "value",
        "signature": "pub open spec fn value(&self) -> $value_ty",
        "body": "{\n                self.view().value\n            }",
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 126,
        "module": "vstd::atomic",
        "keywords": []
      },
      "id": {
        "name": "id",
        "signature": "pub open spec fn id(&self) -> AtomicCellId",
        "body": "{\n                self.view().patomic\n            }",
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 131,
        "module": "vstd::atomic",
        "keywords": []
      },
      "vstd::atomic::is_for": {
        "name": "vstd::atomic::is_for",
        "signature": "pub open spec fn is_for(&self, patomic: $at_ident <T>) -> bool",
        "body": "{\n                self.view().patomic == patomic.id()\n            }",
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 167,
        "module": "vstd::atomic",
        "keywords": []
      },
      "vstd::atomic::points_to": {
        "name": "vstd::atomic::points_to",
        "signature": "pub open spec fn points_to(&self, v: $value_ty) -> bool",
        "body": "{\n                self.view().value == v\n            }",
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 171,
        "module": "vstd::atomic",
        "keywords": []
      },
      "vstd::atomic::value": {
        "name": "vstd::atomic::value",
        "signature": "pub open spec fn value(&self) -> $value_ty",
        "body": "{\n                self.view().value\n            }",
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 176,
        "module": "vstd::atomic",
        "keywords": []
      },
      "vstd::atomic::id": {
        "name": "vstd::atomic::id",
        "signature": "pub open spec fn id(&self) -> AtomicCellId",
        "body": "{\n                self.view().patomic\n            }",
        "file_path": "verus/source/vstd/atomic.rs",
        "line_number": 181,
        "module": "vstd::atomic",
        "keywords": []
      },
      "well_formed": {
        "name": "well_formed",
        "signature": "pub open spec fn well_formed(&self) -> bool",
        "body": "{\n                self.atomic_inv@.constant().1 == self.patomic.id()\n            }",
        "file_path": "verus/source/vstd/atomic_ghost.rs",
        "line_number": 56,
        "module": "vstd::atomic_ghost",
        "keywords": []
      },
      "constant": {
        "name": "constant",
        "signature": "pub open spec fn constant(&self) -> K",
        "body": "{\n                self.atomic_inv@.constant().0\n            }",
        "file_path": "verus/source/vstd/atomic_ghost.rs",
        "line_number": 60,
        "module": "vstd::atomic_ghost",
        "keywords": []
      },
      "vstd::atomic_ghost::well_formed": {
        "name": "vstd::atomic_ghost::well_formed",
        "signature": "pub open spec fn well_formed(&self) -> bool",
        "body": "{\n                self.atomic_inv@.constant().1 == self.patomic.id()\n            }",
        "file_path": "verus/source/vstd/atomic_ghost.rs",
        "line_number": 145,
        "module": "vstd::atomic_ghost",
        "keywords": []
      },
      "vstd::atomic_ghost::constant": {
        "name": "vstd::atomic_ghost::constant",
        "signature": "pub open spec fn constant(&self) -> K",
        "body": "{\n                self.atomic_inv@.constant().0\n            }",
        "file_path": "verus/source/vstd/atomic_ghost.rs",
        "line_number": 149,
        "module": "vstd::atomic_ghost",
        "keywords": []
      },
      "low_bits_mask": {
        "name": "low_bits_mask",
        "signature": "pub open spec fn low_bits_mask(n: nat) -> nat",
        "body": "{\n    (pow2(n) - 1) as nat\n}",
        "file_path": "verus/source/vstd/bits.rs",
        "line_number": 236,
        "module": "vstd::bits",
        "keywords": []
      },
      "spec_u64_to_le_bytes_open": {
        "name": "spec_u64_to_le_bytes_open",
        "signature": "pub open spec fn spec_u64_to_le_bytes_open(x: u64) -> Seq<u8>",
        "body": "{\n    #[verusfmt::skip]\n    seq![\n        (x & 0xff) as u8,\n        ((x >> 8) & 0xff) as u8,\n        ((x >> 16) & 0xff) as u8,\n        ((x >> 24) & 0xff) as u8,\n        ((x >> 32) & 0xff) as u8,\n        ((x >> 40) & 0xff) as u8,\n        ((x >> 48) & 0xff) as u8,\n        ((x >> 56) & 0xff) as u8,\n    ]\n}",
        "file_path": "verus/source/vstd/bytes.rs",
        "line_number": 216,
        "module": "vstd::bytes",
        "keywords": [
          "Seq"
        ]
      },
      "option_from_mem_contents": {
        "name": "option_from_mem_contents",
        "signature": "pub open spec fn option_from_mem_contents<V>(val: MemContents<V>) -> Option<V>",
        "body": "{\n    match val {\n        MemContents::Init(v) => Some(v),\n        MemContents::Uninit => None,\n    }\n}",
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 95,
        "module": "vstd::cell",
        "keywords": []
      },
      "view": {
        "name": "view",
        "signature": "pub open spec fn view(self) -> PointsToData<V>",
        "body": "{\n        PointsToData { pcell: self.id(), value: option_from_mem_contents(self.mem_contents()) }\n    }",
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 161,
        "module": "vstd::cell",
        "keywords": []
      },
      "opt_value": {
        "name": "opt_value",
        "signature": "pub open spec fn opt_value(&self) -> Option<V>",
        "body": "{\n        match self.mem_contents() {\n            MemContents::Init(value) => Some(value),\n            MemContents::Uninit => None,\n        }\n    }",
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 166,
        "module": "vstd::cell",
        "keywords": []
      },
      "is_init": {
        "name": "is_init",
        "signature": "pub open spec fn is_init(&self) -> bool",
        "body": "{\n        self.mem_contents().is_init()\n    }",
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 175,
        "module": "vstd::cell",
        "keywords": []
      },
      "is_uninit": {
        "name": "is_uninit",
        "signature": "pub open spec fn is_uninit(&self) -> bool",
        "body": "{\n        self.mem_contents().is_uninit()\n    }",
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 181,
        "module": "vstd::cell",
        "keywords": []
      },
      "vstd::cell::value": {
        "name": "vstd::cell::value",
        "signature": "pub open spec fn value(&self) -> V\n        recommends\n            self.is_init(),",
        "body": "{\n        self.mem_contents().value()\n    }",
        "file_path": "verus/source/vstd/cell.rs",
        "line_number": 187,
        "module": "vstd::cell",
        "keywords": []
      },
      "range_all_spec_rec": {
        "name": "range_all_spec_rec",
        "signature": "pub open spec fn range_all_spec_rec(r: Range<int>, p: spec_fn(int) -> bool) -> bool\n    decreases r.end - r.start,",
        "body": "{\n    if r.start >= r.end {\n        true\n    } else {\n        p(r.start) && range_all_spec_rec(r.start + 1..r.end, p)\n    }\n}",
        "file_path": "verus/source/vstd/compute.rs",
        "line_number": 13,
        "module": "vstd::compute",
        "keywords": [
          "decreases"
        ]
      },
      "inv": {
        "name": "inv",
        "signature": "pub open spec fn inv(&self, v: V) -> bool",
        "body": "{\n                Pred::inv(self.constant(), v)\n            }",
        "file_path": "verus/source/vstd/invariant.rs",
        "line_number": 195,
        "module": "vstd::invariant",
        "keywords": []
      },
      "obeys_partial_cmp_spec_properties": {
        "name": "obeys_partial_cmp_spec_properties",
        "signature": "pub open spec fn obeys_partial_cmp_spec_properties<T: PartialOrd>() -> bool",
        "body": "{\n    &&& forall|x: T, y: T| #[trigger]\n        x.partial_cmp_spec(&y) == Some(Ordering::Equal) <==> x.eq_spec(&y)\n    &&& forall|x: T, y: T| #[trigger]\n        x.partial_cmp_spec(&y) == Some(Ordering::Less) <==> y.partial_cmp_spec(&x) == Some(\n            Ordering::Greater,\n        )\n    &&& forall|x: T, y: T, z: T|\n        x.partial_cmp_spec(&y) == Some(Ordering::Less) && #[trigger] y.partial_cmp_spec(&z) == Some(\n            Ordering::Less,\n        ) ==> #[trigger] x.partial_cmp_spec(&z) == Some(Ordering::Less)\n    &&& forall|x: T, y: T, z: T|\n        x.partial_cmp_spec(&y) == Some(Ordering::Greater) && #[trigger] y.partial_cmp_spec(&z)\n            == Some(Ordering::Greater) ==> #[trigger] x.partial_cmp_spec(&z) == Some(\n            Ordering::Greater,\n        )\n    &&& obeys_eq_spec_properties::<T>()\n}",
        "file_path": "verus/source/vstd/laws_cmp.rs",
        "line_number": 12,
        "module": "vstd::laws_cmp",
        "keywords": []
      },
      "obeys_cmp_partial_ord": {
        "name": "obeys_cmp_partial_ord",
        "signature": "pub open spec fn obeys_cmp_partial_ord<T: PartialOrd>() -> bool",
        "body": "{\n    &&& T::obeys_eq_spec()\n    &&& T::obeys_partial_cmp_spec()\n    &&& forall|x: T, y: T| x.eq_spec(&y) <==> x.partial_cmp_spec(&y) == Some(Ordering::Equal)\n}",
        "file_path": "verus/source/vstd/laws_cmp.rs",
        "line_number": 32,
        "module": "vstd::laws_cmp",
        "keywords": []
      },
      "obeys_cmp_ord": {
        "name": "obeys_cmp_ord",
        "signature": "pub open spec fn obeys_cmp_ord<T: Ord>() -> bool",
        "body": "{\n    &&& T::obeys_cmp_spec()\n    &&& forall|x: T, y: T|\n        #![trigger x.partial_cmp_spec(&y)]\n        #![trigger x.cmp_spec(&y)]\n        x.partial_cmp_spec(&y) == Some(x.cmp_spec(&y))\n}",
        "file_path": "verus/source/vstd/laws_cmp.rs",
        "line_number": 39,
        "module": "vstd::laws_cmp",
        "keywords": []
      },
      "obeys_cmp_spec": {
        "name": "obeys_cmp_spec",
        "signature": "pub open spec fn obeys_cmp_spec<T: Ord>() -> bool",
        "body": "{\n    &&& obeys_eq_spec::<T>()\n    &&& obeys_cmp_partial_ord::<T>()\n    &&& obeys_cmp_ord::<T>()\n    &&& obeys_partial_cmp_spec_properties::<T>()\n}",
        "file_path": "verus/source/vstd/laws_cmp.rs",
        "line_number": 47,
        "module": "vstd::laws_cmp",
        "keywords": []
      },
      "obeys_eq_spec_properties": {
        "name": "obeys_eq_spec_properties",
        "signature": "pub open spec fn obeys_eq_spec_properties<T: PartialEq>() -> bool",
        "body": "{\n    &&& forall|x: T, y: T| #[trigger] x.eq_spec(&y) <==> y.eq_spec(&x)\n    &&& forall|x: T, y: T, z: T|\n        x.eq_spec(&y) && #[trigger] y.eq_spec(&z) ==> #[trigger] x.eq_spec(&z)\n}",
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 11,
        "module": "vstd::laws_eq",
        "keywords": []
      },
      "obeys_eq_spec": {
        "name": "obeys_eq_spec",
        "signature": "pub open spec fn obeys_eq_spec<T: PartialEq>() -> bool",
        "body": "{\n    &&& T::obeys_eq_spec()\n    &&& obeys_eq_spec_properties::<T>()\n}",
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 17,
        "module": "vstd::laws_eq",
        "keywords": []
      },
      "obeys_concrete_eq": {
        "name": "obeys_concrete_eq",
        "signature": "pub open spec fn obeys_concrete_eq<T: PartialEq>() -> bool",
        "body": "{\n    &&& T::obeys_eq_spec()\n    &&& forall|x: T, y: T| x.eq_spec(&y) <==> x == y\n}",
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 23,
        "module": "vstd::laws_eq",
        "keywords": []
      },
      "obeys_view_eq": {
        "name": "obeys_view_eq",
        "signature": "pub open spec fn obeys_view_eq<T: PartialEq + View>() -> bool",
        "body": "{\n    &&& T::obeys_eq_spec()\n    &&& forall|x: T, y: T| x.eq_spec(&y) <==> x@ == y@\n}",
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 29,
        "module": "vstd::laws_eq",
        "keywords": []
      },
      "obeys_deep_eq": {
        "name": "obeys_deep_eq",
        "signature": "pub open spec fn obeys_deep_eq<T: PartialEq + DeepView>() -> bool",
        "body": "{\n    &&& T::obeys_eq_spec()\n    &&& forall|x: T, y: T| x.eq_spec(&y) <==> x.deep_view() == y.deep_view()\n}",
        "file_path": "verus/source/vstd/laws_eq.rs",
        "line_number": 35,
        "module": "vstd::laws_eq",
        "keywords": []
      },
      "is_power_2": {
        "name": "is_power_2",
        "signature": "pub open spec fn is_power_2(n: int) -> bool\n    decreases n,",
        "body": "{\n    if n <= 0 {\n        false\n    } else if n == 1 {\n        true\n    } else {\n        n % 2 == 0 && is_power_2(n / 2)\n    }\n}",
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 9,
        "module": "vstd::layout",
        "keywords": [
          "decreases"
        ]
      },
      "valid_layout": {
        "name": "valid_layout",
        "signature": "pub open spec fn valid_layout(size: usize, align: usize) -> bool",
        "body": "{\n    is_power_2(align as int) && size <= isize::MAX as int - (isize::MAX as int % align as int)\n}",
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 22,
        "module": "vstd::layout",
        "keywords": []
      },
      "size_of_as_usize": {
        "name": "size_of_as_usize",
        "signature": "pub open spec fn size_of_as_usize<V>() -> usize\n    recommends\n        size_of::<V>() as usize as int == size_of::<V>(),",
        "body": "{\n    size_of::<V>() as usize\n}",
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 47,
        "module": "vstd::layout",
        "keywords": []
      },
      "align_of_as_usize": {
        "name": "align_of_as_usize",
        "signature": "pub open spec fn align_of_as_usize<V>() -> usize\n    recommends\n        align_of::<V>() as usize as int == align_of::<V>(),",
        "body": "{\n    align_of::<V>() as usize\n}",
        "file_path": "verus/source/vstd/layout.rs",
        "line_number": 55,
        "module": "vstd::layout",
        "keywords": []
      },
      "total": {
        "name": "total",
        "signature": "pub open spec fn total(fv: spec_fn(K) -> V) -> Map<K, V>",
        "body": "{\n        Set::full().mk_map(fv)\n    }",
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 44,
        "module": "vstd::map",
        "keywords": [
          "Map"
        ]
      },
      "new": {
        "name": "new",
        "signature": "pub open spec fn new(fk: spec_fn(K) -> bool, fv: spec_fn(K) -> V) -> Map<K, V>",
        "body": "{\n        Set::new(fk).mk_map(fv)\n    }",
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 50,
        "module": "vstd::map",
        "keywords": [
          "Map"
        ]
      },
      "spec_index": {
        "name": "spec_index",
        "signature": "pub open spec fn spec_index(self, key: K) -> V\n        recommends\n            self.dom().contains(key),",
        "body": "{\n        self.index(key)\n    }",
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 70,
        "module": "vstd::map",
        "keywords": [
          "contains"
        ]
      },
      "len": {
        "name": "len",
        "signature": "pub open spec fn len(self) -> nat",
        "body": "{\n        self.dom().len()\n    }",
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 107,
        "module": "vstd::map",
        "keywords": [
          "len"
        ]
      },
      "check_argument_is_map": {
        "name": "check_argument_is_map",
        "signature": "pub open spec fn check_argument_is_map<K, V>(m: Map<K, V>) -> Map<K, V>",
        "body": "{\n    m\n}",
        "file_path": "verus/source/vstd/map.rs",
        "line_number": 336,
        "module": "vstd::map",
        "keywords": [
          "Map"
        ]
      },
      "is_full": {
        "name": "is_full",
        "signature": "pub open spec fn is_full(self) -> bool",
        "body": "{\n        self.dom().is_full()\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 18,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "is_empty": {
        "name": "is_empty",
        "signature": "pub open spec fn is_empty(self) -> (b: bool)",
        "body": "{\n        self.dom().is_empty()\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 24,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "contains_key": {
        "name": "contains_key",
        "signature": "pub open spec fn contains_key(self, k: K) -> bool",
        "body": "{\n        self.dom().contains(k)\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 30,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "contains_value": {
        "name": "contains_value",
        "signature": "pub open spec fn contains_value(self, v: V) -> bool",
        "body": "{\n        exists|i: K| #[trigger] self.dom().contains(i) && self[i] == v\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 35,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "index_opt": {
        "name": "index_opt",
        "signature": "pub open spec fn index_opt(self, k: K) -> Option<V>",
        "body": "{\n        if self.contains_key(k) {\n            Some(self[k])\n        } else {\n            None\n        }\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 41,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "values": {
        "name": "values",
        "signature": "pub open spec fn values(self) -> Set<V>",
        "body": "{\n        Set::<V>::new(|v: V| self.contains_value(v))\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 62,
        "module": "vstd::map_lib",
        "keywords": [
          "Set"
        ]
      },
      "kv_pairs": {
        "name": "kv_pairs",
        "signature": "pub open spec fn kv_pairs(self) -> Set<(K, V)>",
        "body": "{\n        Set::<(K, V)>::new(|kv: (K, V)| self.dom().contains(kv.0) && self[kv.0] == kv.1)\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 79,
        "module": "vstd::map_lib",
        "keywords": [
          "Set"
        ]
      },
      "contains_pair": {
        "name": "contains_pair",
        "signature": "pub open spec fn contains_pair(self, k: K, v: V) -> bool",
        "body": "{\n        self.dom().contains(k) && self[k] == v\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 84,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "submap_of": {
        "name": "submap_of",
        "signature": "pub open spec fn submap_of(self, m2: Self) -> bool",
        "body": "{\n        forall|k: K| #[trigger]\n            self.dom().contains(k) ==> #[trigger] m2.dom().contains(k) && self[k] == m2[k]\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 98,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "spec_le": {
        "name": "spec_le",
        "signature": "pub open spec fn spec_le(self, m2: Self) -> bool",
        "body": "{\n        self.submap_of(m2)\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 104,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "union_prefer_right": {
        "name": "union_prefer_right",
        "signature": "pub open spec fn union_prefer_right(self, m2: Self) -> Self",
        "body": "{\n        Self::new(\n            |k: K| self.dom().contains(k) || m2.dom().contains(k),\n            |k: K|\n                if m2.dom().contains(k) {\n                    m2[k]\n                } else {\n                    self[k]\n                },\n        )\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 121,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "remove_keys": {
        "name": "remove_keys",
        "signature": "pub open spec fn remove_keys(self, keys: Set<K>) -> Self",
        "body": "{\n        Self::new(|k: K| self.dom().contains(k) && !keys.contains(k), |k: K| self[k])\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 144,
        "module": "vstd::map_lib",
        "keywords": [
          "Set"
        ]
      },
      "restrict": {
        "name": "restrict",
        "signature": "pub open spec fn restrict(self, keys: Set<K>) -> Self",
        "body": "{\n        Self::new(|k: K| self.dom().contains(k) && keys.contains(k), |k: K| self[k])\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 159,
        "module": "vstd::map_lib",
        "keywords": [
          "Set"
        ]
      },
      "is_equal_on_key": {
        "name": "is_equal_on_key",
        "signature": "pub open spec fn is_equal_on_key(self, m2: Self, key: K) -> bool",
        "body": "{\n        ||| (!self.dom().contains(key) && !m2.dom().contains(key))\n        ||| (self.dom().contains(key) && m2.dom().contains(key) && self[key] == m2[key])\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 164,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "agrees": {
        "name": "agrees",
        "signature": "pub open spec fn agrees(self, m2: Self) -> bool",
        "body": "{\n        forall|k| #![auto] self.dom().contains(k) && m2.dom().contains(k) ==> self[k] == m2[k]\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 170,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "map_entries": {
        "name": "map_entries",
        "signature": "pub open spec fn map_entries<W>(self, f: spec_fn(K, V) -> W) -> Map<K, W>",
        "body": "{\n        Map::new(|k: K| self.contains_key(k), |k: K| f(k, self[k]))\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 175,
        "module": "vstd::map_lib",
        "keywords": [
          "Map"
        ]
      },
      "map_values": {
        "name": "map_values",
        "signature": "pub open spec fn map_values<W>(self, f: spec_fn(V) -> W) -> Map<K, W>",
        "body": "{\n        Map::new(|k: K| self.contains_key(k), |k: K| f(self[k]))\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 180,
        "module": "vstd::map_lib",
        "keywords": [
          "Map"
        ]
      },
      "is_injective": {
        "name": "is_injective",
        "signature": "pub open spec fn is_injective(self) -> bool",
        "body": "{\n        forall|x: K, y: K|\n            x != y && self.dom().contains(x) && self.dom().contains(y) ==> #[trigger] self[x]\n                != #[trigger] self[y]\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 185,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "invert": {
        "name": "invert",
        "signature": "pub open spec fn invert(self) -> Map<V, K>",
        "body": "{\n        Map::<V, K>::new(\n            |v: V| self.contains_value(v),\n            |v: V| choose|k: K| self.contains_pair(k, v),\n        )\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 193,
        "module": "vstd::map_lib",
        "keywords": [
          "Map"
        ]
      },
      "filter_keys": {
        "name": "filter_keys",
        "signature": "pub open spec fn filter_keys(self, p: spec_fn(K) -> bool) -> Self",
        "body": "{\n        self.restrict(self.dom().filter(p))\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 271,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "get": {
        "name": "get",
        "signature": "pub open spec fn get(self, k: K) -> Option<V>",
        "body": "{\n        if self.dom().contains(k) {\n            Some(self[k])\n        } else {\n            None\n        }\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 290,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "prefixed_entries": {
        "name": "prefixed_entries",
        "signature": "pub open spec fn prefixed_entries(self, prefix: Seq<K>) -> Self",
        "body": "{\n        Map::new(|k: Seq<K>| self.contains_key(prefix + k), |k: Seq<K>| self[prefix + k])\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 437,
        "module": "vstd::map_lib",
        "keywords": [
          "Seq"
        ]
      },
      "is_monotonic": {
        "name": "is_monotonic",
        "signature": "pub open spec fn is_monotonic(self) -> bool",
        "body": "{\n        forall|x: int, y: int|\n            self.dom().contains(x) && self.dom().contains(y) && x <= y ==> #[trigger] self[x]\n                <= #[trigger] self[y]\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 569,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "is_monotonic_from": {
        "name": "is_monotonic_from",
        "signature": "pub open spec fn is_monotonic_from(self, start: int) -> bool",
        "body": "{\n        forall|x: int, y: int|\n            self.dom().contains(x) && self.dom().contains(y) && start <= x <= y\n                ==> #[trigger] self[x] <= #[trigger] self[y]\n    }",
        "file_path": "verus/source/vstd/map_lib.rs",
        "line_number": 577,
        "module": "vstd::map_lib",
        "keywords": []
      },
      "min": {
        "name": "min",
        "signature": "pub open spec fn min(x: int, y: int) -> int",
        "body": "{\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}",
        "file_path": "verus/source/vstd/math.rs",
        "line_number": 7,
        "module": "vstd::math",
        "keywords": []
      },
      "max": {
        "name": "max",
        "signature": "pub open spec fn max(x: int, y: int) -> int",
        "body": "{\n    if x >= y {\n        x\n    } else {\n        y\n    }\n}",
        "file_path": "verus/source/vstd/math.rs",
        "line_number": 16,
        "module": "vstd::math",
        "keywords": []
      },
      "max3": {
        "name": "max3",
        "signature": "pub open spec fn max3(x: int, y: int, z: int) -> int",
        "body": "{\n    if x < y {\n        max(y, z)\n    } else {\n        max(x, z)\n    }\n}",
        "file_path": "verus/source/vstd/math.rs",
        "line_number": 25,
        "module": "vstd::math",
        "keywords": []
      },
      "clip": {
        "name": "clip",
        "signature": "pub open spec fn clip(x: int) -> nat",
        "body": "{\n    if x < 0 {\n        0\n    } else {\n        x as nat\n    }\n}",
        "file_path": "verus/source/vstd/math.rs",
        "line_number": 35,
        "module": "vstd::math",
        "keywords": []
      },
      "abs": {
        "name": "abs",
        "signature": "pub open spec fn abs(x: int) -> nat",
        "body": "{\n    if x < 0 {\n        -x as nat\n    } else {\n        x as nat\n    }\n}",
        "file_path": "verus/source/vstd/math.rs",
        "line_number": 44,
        "module": "vstd::math",
        "keywords": []
      },
      "add": {
        "name": "add",
        "signature": "pub open spec fn add(x: int, y: int) -> int",
        "body": "{\n    x + y\n}",
        "file_path": "verus/source/vstd/math.rs",
        "line_number": 56,
        "module": "vstd::math",
        "keywords": []
      },
      "sub": {
        "name": "sub",
        "signature": "pub open spec fn sub(x: int, y: int) -> int",
        "body": "{\n    x - y\n}",
        "file_path": "verus/source/vstd/math.rs",
        "line_number": 64,
        "module": "vstd::math",
        "keywords": []
      },
      "div": {
        "name": "div",
        "signature": "pub open spec fn div(x: int, y: int) -> int",
        "body": "{\n    x / y\n}",
        "file_path": "verus/source/vstd/math.rs",
        "line_number": 72,
        "module": "vstd::math",
        "keywords": []
      },
      "from_set": {
        "name": "from_set",
        "signature": "pub open spec fn from_set(m: Set<V>) -> Self",
        "body": "{\n        Self::from_map(Map::new(|k| m.contains(k), |v| 1))\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 65,
        "module": "vstd::multiset",
        "keywords": [
          "Set"
        ]
      },
      "insert": {
        "name": "insert",
        "signature": "pub open spec fn insert(self, v: V) -> Self",
        "body": "{\n        self.add(Self::singleton(v))\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 88,
        "module": "vstd::multiset",
        "keywords": [
          "insert"
        ]
      },
      "remove": {
        "name": "remove",
        "signature": "pub open spec fn remove(self, v: V) -> Self",
        "body": "{\n        self.sub(Self::singleton(v))\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 95,
        "module": "vstd::multiset",
        "keywords": [
          "remove"
        ]
      },
      "update": {
        "name": "update",
        "signature": "pub open spec fn update(self, v: V, mult: nat) -> Self",
        "body": "{\n        let map = Map::new(\n            |key: V| (self.contains(key) || key == v),\n            |key: V|\n                if key == v {\n                    mult\n                } else {\n                    self.count(key)\n                },\n        );\n        Self::from_map(map)\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 100,
        "module": "vstd::multiset",
        "keywords": []
      },
      "subset_of": {
        "name": "subset_of",
        "signature": "pub open spec fn subset_of(self, m2: Self) -> bool",
        "body": "{\n        forall|v: V| self.count(v) <= m2.count(v)\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 116,
        "module": "vstd::multiset",
        "keywords": []
      },
      "vstd::multiset::spec_le": {
        "name": "vstd::multiset::spec_le",
        "signature": "pub open spec fn spec_le(self, m2: Self) -> bool",
        "body": "{\n        self.subset_of(m2)\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 121,
        "module": "vstd::multiset",
        "keywords": []
      },
      "choose": {
        "name": "choose",
        "signature": "pub open spec fn choose(self) -> V",
        "body": "{\n        choose|v: V| self.count(v) > 0\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 134,
        "module": "vstd::multiset",
        "keywords": []
      },
      "contains": {
        "name": "contains",
        "signature": "pub open spec fn contains(self, v: V) -> bool",
        "body": "{\n        self.count(v) > 0\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 139,
        "module": "vstd::multiset",
        "keywords": [
          "contains"
        ]
      },
      "spec_has": {
        "name": "spec_has",
        "signature": "pub open spec fn spec_has(self, v: V) -> bool",
        "body": "{\n        self.contains(v)\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 145,
        "module": "vstd::multiset",
        "keywords": []
      },
      "intersection_with": {
        "name": "intersection_with",
        "signature": "pub open spec fn intersection_with(self, other: Self) -> Self",
        "body": "{\n        let m = Map::<V, nat>::new(\n            |v: V| self.contains(v),\n            |v: V| min(self.count(v) as int, other.count(v) as int) as nat,\n        );\n        Self::from_map(m)\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 152,
        "module": "vstd::multiset",
        "keywords": []
      },
      "difference_with": {
        "name": "difference_with",
        "signature": "pub open spec fn difference_with(self, other: Self) -> Self",
        "body": "{\n        let m = Map::<V, nat>::new(\n            |v: V| self.contains(v),\n            |v: V| clip(self.count(v) - other.count(v)),\n        );\n        Self::from_map(m)\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 162,
        "module": "vstd::multiset",
        "keywords": []
      },
      "is_disjoint_from": {
        "name": "is_disjoint_from",
        "signature": "pub open spec fn is_disjoint_from(self, other: Self) -> bool",
        "body": "{\n        forall|x: V| self.count(x) == 0 || other.count(x) == 0\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 173,
        "module": "vstd::multiset",
        "keywords": []
      },
      "dom": {
        "name": "dom",
        "signature": "pub open spec fn dom(self) -> Set<V>",
        "body": "{\n        Set::new(|v: V| self.count(v) > 0)\n    }",
        "file_path": "verus/source/vstd/multiset.rs",
        "line_number": 178,
        "module": "vstd::multiset",
        "keywords": [
          "Set"
        ]
      },
      "vstd::multiset_lib::is_empty": {
        "name": "vstd::multiset_lib::is_empty",
        "signature": "pub open spec fn is_empty(self) -> (b: bool)",
        "body": "{\n        self.len() == 0\n    }",
        "file_path": "verus/source/vstd/multiset_lib.rs",
        "line_number": 12,
        "module": "vstd::multiset_lib",
        "keywords": []
      },
      "is_singleton": {
        "name": "is_singleton",
        "signature": "pub open spec fn is_singleton(self) -> bool",
        "body": "{\n        &&& self.len() > 0\n        &&& (forall|x: A| self.contains(x) ==> self.count(x) == 1)\n        &&& (forall|x: A, y: A| self.contains(x) && self.contains(y) ==> x == y)\n    }",
        "file_path": "verus/source/vstd/multiset_lib.rs",
        "line_number": 17,
        "module": "vstd::multiset_lib",
        "keywords": []
      },
      "incl": {
        "name": "incl",
        "signature": "pub open spec fn incl<P: PCM>(a: P, b: P) -> bool",
        "body": "{\n    exists|c| P::op(a, c) == b\n}",
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 90,
        "module": "vstd::pcm",
        "keywords": []
      },
      "conjunct_shared": {
        "name": "conjunct_shared",
        "signature": "pub open spec fn conjunct_shared<P: PCM>(a: P, b: P, c: P) -> bool",
        "body": "{\n    forall|p: P| p.valid() && incl(a, p) && incl(b, p) ==> #[trigger] incl(c, p)\n}",
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 94,
        "module": "vstd::pcm",
        "keywords": []
      },
      "frame_preserving_update": {
        "name": "frame_preserving_update",
        "signature": "pub open spec fn frame_preserving_update<P: PCM>(a: P, b: P) -> bool",
        "body": "{\n    forall|c| #![trigger P::op(a, c), P::op(b, c)] P::op(a, c).valid() ==> P::op(b, c).valid()\n}",
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 98,
        "module": "vstd::pcm",
        "keywords": []
      },
      "frame_preserving_update_nondeterministic": {
        "name": "frame_preserving_update_nondeterministic",
        "signature": "pub open spec fn frame_preserving_update_nondeterministic<P: PCM>(a: P, bs: Set<P>) -> bool",
        "body": "{\n    forall|c|\n        #![trigger P::op(a, c)]\n        P::op(a, c).valid() ==> exists|b| #[trigger] bs.contains(b) && P::op(b, c).valid()\n}",
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 102,
        "module": "vstd::pcm",
        "keywords": [
          "Set"
        ]
      },
      "set_op": {
        "name": "set_op",
        "signature": "pub open spec fn set_op<P: PCM>(s: Set<P>, t: P) -> Set<P>",
        "body": "{\n    Set::new(|v| exists|q| s.contains(q) && v == P::op(q, t))\n}",
        "file_path": "verus/source/vstd/pcm.rs",
        "line_number": 108,
        "module": "vstd::pcm",
        "keywords": [
          "Set"
        ]
      },
      "combine_values": {
        "name": "combine_values",
        "signature": "pub open spec fn combine_values<P: PCM>(values: Seq<P>) -> P\n    decreases values.len(),",
        "body": "{\n    if values.len() == 0 {\n        P::unit()\n    } else {\n        P::op(values[0], combine_values(values.skip(1)))\n    }\n}",
        "file_path": "verus/source/vstd/pcm_lib.rs",
        "line_number": 13,
        "module": "vstd::pcm_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ]
      },
      "trigger": {
        "name": "trigger",
        "signature": "pub open spec fn trigger<A>(a: A) -> bool",
        "body": "{\n    true\n}",
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 37,
        "module": "vstd::pervasive",
        "keywords": [
          "trigger"
        ]
      },
      "strictly_cloned": {
        "name": "strictly_cloned",
        "signature": "pub open spec fn strictly_cloned<T: Clone>(a: T, b: T) -> bool",
        "body": "{\n    call_ensures(T::clone, (&a,), b)\n}",
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 415,
        "module": "vstd::pervasive",
        "keywords": []
      },
      "cloned": {
        "name": "cloned",
        "signature": "pub open spec fn cloned<T: Clone>(a: T, b: T) -> bool",
        "body": "{\n    strictly_cloned(a, b) || a == b\n}",
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 425,
        "module": "vstd::pervasive",
        "keywords": []
      },
      "allow_panic": {
        "name": "allow_panic",
        "signature": "pub open spec fn allow_panic() -> bool",
        "body": "{\n    cfg!(feature = \"allow_panic\")\n}",
        "file_path": "verus/source/vstd/pervasive.rs",
        "line_number": 436,
        "module": "vstd::pervasive",
        "keywords": []
      },
      "ptr": {
        "name": "ptr",
        "signature": "pub open spec fn ptr(&self) -> *mut T",
        "body": "{\n        self.view().ptr\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 200,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "vstd::raw_ptr::opt_value": {
        "name": "vstd::raw_ptr::opt_value",
        "signature": "pub open spec fn opt_value(&self) -> MemContents<T>",
        "body": "{\n        self.view().opt_value\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 206,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "vstd::raw_ptr::is_init": {
        "name": "vstd::raw_ptr::is_init",
        "signature": "pub open spec fn is_init(&self) -> bool",
        "body": "{\n        self is Init\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 271,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "vstd::raw_ptr::is_uninit": {
        "name": "vstd::raw_ptr::is_uninit",
        "signature": "pub open spec fn is_uninit(&self) -> bool",
        "body": "{\n        self is Uninit\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 277,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "vstd::raw_ptr::value": {
        "name": "vstd::raw_ptr::value",
        "signature": "pub open spec fn value(&self) -> T\n        recommends\n            self is Init,",
        "body": "{\n        self->0\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 284,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "ptr_from_data": {
        "name": "ptr_from_data",
        "signature": "pub open spec fn ptr_from_data<T: ?Sized>(data: PtrData<T>) -> *const T",
        "body": "{\n    ptr_mut_from_data(data) as *const T\n}",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 302,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "ptr_null": {
        "name": "ptr_null",
        "signature": "pub open spec fn ptr_null<T: ?Sized + core::ptr::Pointee<Metadata = ()>>() -> *const T",
        "body": "{\n    ptr_from_data(PtrData::<T> { addr: 0, provenance: Provenance::null(), metadata: () })\n}",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 345,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "ptr_null_mut": {
        "name": "ptr_null_mut",
        "signature": "pub open spec fn ptr_null_mut<T: ?Sized + core::ptr::Pointee<Metadata = ()>>() -> *mut T",
        "body": "{\n    ptr_mut_from_data(PtrData::<T> { addr: 0, provenance: Provenance::null(), metadata: () })\n}",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 364,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "spec_cast_ptr_to_thin_ptr": {
        "name": "spec_cast_ptr_to_thin_ptr",
        "signature": "pub open spec fn spec_cast_ptr_to_thin_ptr<T: ?Sized, U: Sized>(ptr: *mut T) -> *mut U",
        "body": "{\n    ptr_mut_from_data(PtrData::<U> { addr: ptr@.addr, provenance: ptr@.provenance, metadata: () })\n}",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 384,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "spec_cast_array_ptr_to_slice_ptr": {
        "name": "spec_cast_array_ptr_to_slice_ptr",
        "signature": "pub open spec fn spec_cast_array_ptr_to_slice_ptr<T, const N: usize>(ptr: *mut [T; N]) -> *mut [T]",
        "body": "{\n    ptr_mut_from_data(PtrData::<[T]> { addr: ptr@.addr, provenance: ptr@.provenance, metadata: N })\n}",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 405,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "spec_cast_ptr_to_usize": {
        "name": "spec_cast_ptr_to_usize",
        "signature": "pub open spec fn spec_cast_ptr_to_usize<T: Sized>(ptr: *mut T) -> usize",
        "body": "{\n    ptr@.addr\n}",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 426,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "spec_addr": {
        "name": "spec_addr",
        "signature": "pub open spec fn spec_addr<T: ?Sized>(p: *$mu T) -> usize",
        "body": "{ p@.addr }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 536,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "spec_with_addr": {
        "name": "spec_with_addr",
        "signature": "pub open spec fn spec_with_addr<T: ?Sized>(p: *$mu T, addr: usize) -> *$mu T",
        "body": "{\n                $ptr_from_data(PtrData::<T> { addr: addr, .. p@ })\n            }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 544,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "vstd::raw_ptr::view": {
        "name": "vstd::raw_ptr::view",
        "signature": "pub open spec fn view(self) -> Provenance",
        "body": "{\n        self.provenance()\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 589,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "is_range": {
        "name": "is_range",
        "signature": "pub open spec fn is_range(self, start: int, len: int) -> bool",
        "body": "{\n        super::set_lib::set_int_range(start, start + len) =~= self.dom()\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 655,
        "module": "vstd::raw_ptr",
        "keywords": [
          "len"
        ]
      },
      "contains_range": {
        "name": "contains_range",
        "signature": "pub open spec fn contains_range(self, start: int, len: int) -> bool",
        "body": "{\n        super::set_lib::set_int_range(start, start + len) <= self.dom()\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 660,
        "module": "vstd::raw_ptr",
        "keywords": [
          "len"
        ]
      },
      "addr": {
        "name": "addr",
        "signature": "pub open spec fn addr(self) -> usize",
        "body": "{\n        self.view().addr\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 752,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "size": {
        "name": "size",
        "signature": "pub open spec fn size(self) -> nat",
        "body": "{\n        self.view().size\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 758,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "align": {
        "name": "align",
        "signature": "pub open spec fn align(self) -> nat",
        "body": "{\n        self.view().align\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 764,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "provenance": {
        "name": "provenance",
        "signature": "pub open spec fn provenance(self) -> Provenance",
        "body": "{\n        self.view().provenance\n    }",
        "file_path": "verus/source/vstd/raw_ptr.rs",
        "line_number": 770,
        "module": "vstd::raw_ptr",
        "keywords": []
      },
      "injective": {
        "name": "injective",
        "signature": "pub open spec fn injective<X, Y>(r: spec_fn(X) -> Y) -> bool",
        "body": "{\n    forall|x1: X, x2: X| #[trigger] r(x1) == #[trigger] r(x2) ==> x1 == x2\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 13,
        "module": "vstd::relations",
        "keywords": []
      },
      "commutative": {
        "name": "commutative",
        "signature": "pub open spec fn commutative<T, U>(r: spec_fn(T, T) -> U) -> bool",
        "body": "{\n    forall|x: T, y: T| #[trigger] r(x, y) == #[trigger] r(y, x)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 17,
        "module": "vstd::relations",
        "keywords": []
      },
      "associative": {
        "name": "associative",
        "signature": "pub open spec fn associative<T>(r: spec_fn(T, T) -> T) -> bool",
        "body": "{\n    forall|x: T, y: T, z: T| #[trigger] r(x, r(y, z)) == #[trigger] r(r(x, y), z)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 21,
        "module": "vstd::relations",
        "keywords": []
      },
      "reflexive": {
        "name": "reflexive",
        "signature": "pub open spec fn reflexive<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|x: T| #[trigger] r(x, x)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 25,
        "module": "vstd::relations",
        "keywords": []
      },
      "irreflexive": {
        "name": "irreflexive",
        "signature": "pub open spec fn irreflexive<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|x: T| #[trigger] r(x, x) == false\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 29,
        "module": "vstd::relations",
        "keywords": []
      },
      "antisymmetric": {
        "name": "antisymmetric",
        "signature": "pub open spec fn antisymmetric<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|x: T, y: T| #[trigger] r(x, y) && #[trigger] r(y, x) ==> x == y\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 33,
        "module": "vstd::relations",
        "keywords": []
      },
      "asymmetric": {
        "name": "asymmetric",
        "signature": "pub open spec fn asymmetric<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|x: T, y: T| #[trigger] r(x, y) ==> #[trigger] r(y, x) == false\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 37,
        "module": "vstd::relations",
        "keywords": []
      },
      "symmetric": {
        "name": "symmetric",
        "signature": "pub open spec fn symmetric<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|x: T, y: T| #[trigger] r(x, y) <==> #[trigger] r(y, x)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 41,
        "module": "vstd::relations",
        "keywords": []
      },
      "connected": {
        "name": "connected",
        "signature": "pub open spec fn connected<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|x: T, y: T| x != y ==> #[trigger] r(x, y) || #[trigger] r(y, x)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 45,
        "module": "vstd::relations",
        "keywords": []
      },
      "strongly_connected": {
        "name": "strongly_connected",
        "signature": "pub open spec fn strongly_connected<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|x: T, y: T| #[trigger] r(x, y) || #[trigger] r(y, x)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 49,
        "module": "vstd::relations",
        "keywords": []
      },
      "transitive": {
        "name": "transitive",
        "signature": "pub open spec fn transitive<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|x: T, y: T, z: T| #[trigger] r(x, y) && #[trigger] r(y, z) ==> r(x, z)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 53,
        "module": "vstd::relations",
        "keywords": []
      },
      "total_ordering": {
        "name": "total_ordering",
        "signature": "pub open spec fn total_ordering<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    &&& reflexive(r)\n    &&& antisymmetric(r)\n    &&& transitive(r)\n    &&& strongly_connected(r)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 57,
        "module": "vstd::relations",
        "keywords": []
      },
      "strict_total_ordering": {
        "name": "strict_total_ordering",
        "signature": "pub open spec fn strict_total_ordering<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    &&& irreflexive(r)\n    &&& antisymmetric(r)\n    &&& transitive(r)\n    &&& connected(r)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 64,
        "module": "vstd::relations",
        "keywords": []
      },
      "pre_ordering": {
        "name": "pre_ordering",
        "signature": "pub open spec fn pre_ordering<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    &&& reflexive(r)\n    &&& transitive(r)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 71,
        "module": "vstd::relations",
        "keywords": []
      },
      "partial_ordering": {
        "name": "partial_ordering",
        "signature": "pub open spec fn partial_ordering<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    &&& reflexive(r)\n    &&& transitive(r)\n    &&& antisymmetric(r)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 76,
        "module": "vstd::relations",
        "keywords": []
      },
      "equivalence_relation": {
        "name": "equivalence_relation",
        "signature": "pub open spec fn equivalence_relation<T>(r: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    &&& reflexive(r)\n    &&& symmetric(r)\n    &&& transitive(r)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 82,
        "module": "vstd::relations",
        "keywords": []
      },
      "sorted_by": {
        "name": "sorted_by",
        "signature": "pub open spec fn sorted_by<T>(a: Seq<T>, less_than: spec_fn(T, T) -> bool) -> bool",
        "body": "{\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> #[trigger] less_than(a[i], a[j])\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 90,
        "module": "vstd::relations",
        "keywords": [
          "Seq"
        ]
      },
      "is_least": {
        "name": "is_least",
        "signature": "pub open spec fn is_least<T>(leq: spec_fn(T, T) -> bool, min: T, s: Set<T>) -> bool",
        "body": "{\n    s.contains(min) && forall|x: T| s.contains(x) ==> #[trigger] leq(min, x)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 98,
        "module": "vstd::relations",
        "keywords": [
          "Set"
        ]
      },
      "is_minimal": {
        "name": "is_minimal",
        "signature": "pub open spec fn is_minimal<T>(leq: spec_fn(T, T) -> bool, min: T, s: Set<T>) -> bool",
        "body": "{\n    s.contains(min) && forall|x: T|\n        s.contains(x) && #[trigger] leq(x, min) ==> #[trigger] leq(min, x)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 103,
        "module": "vstd::relations",
        "keywords": [
          "Set"
        ]
      },
      "is_greatest": {
        "name": "is_greatest",
        "signature": "pub open spec fn is_greatest<T>(leq: spec_fn(T, T) -> bool, max: T, s: Set<T>) -> bool",
        "body": "{\n    s.contains(max) && forall|x: T| s.contains(x) ==> #[trigger] leq(x, max)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 110,
        "module": "vstd::relations",
        "keywords": [
          "Set"
        ]
      },
      "is_maximal": {
        "name": "is_maximal",
        "signature": "pub open spec fn is_maximal<T>(leq: spec_fn(T, T) -> bool, max: T, s: Set<T>) -> bool",
        "body": "{\n    s.contains(max) && forall|x: T|\n        s.contains(x) && #[trigger] leq(max, x) ==> #[trigger] leq(x, max)\n}",
        "file_path": "verus/source/vstd/relations.rs",
        "line_number": 115,
        "module": "vstd::relations",
        "keywords": [
          "Set"
        ]
      },
      "vstd::rwlock::inv": {
        "name": "vstd::rwlock::inv",
        "signature": "pub open spec fn inv(&self, val: V) -> bool",
        "body": "{\n        self.pred().inv(val)\n    }",
        "file_path": "verus/source/vstd/rwlock.rs",
        "line_number": 497,
        "module": "vstd::rwlock",
        "keywords": []
      },
      "vstd::seq::spec_index": {
        "name": "vstd::seq::spec_index",
        "signature": "pub open spec fn spec_index(self, i: int) -> A\n        recommends\n            0 <= i < self.len(),",
        "body": "{\n        self.index(i)\n    }",
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 60,
        "module": "vstd::seq",
        "keywords": [
          "len"
        ]
      },
      "take": {
        "name": "take",
        "signature": "pub open spec fn take(self, n: int) -> Seq<A>",
        "body": "{\n        self.subrange(0, n)\n    }",
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 121,
        "module": "vstd::seq",
        "keywords": [
          "Seq",
          "take"
        ]
      },
      "skip": {
        "name": "skip",
        "signature": "pub open spec fn skip(self, n: int) -> Seq<A>",
        "body": "{\n        self.subrange(n, self.len() as int)\n    }",
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 127,
        "module": "vstd::seq",
        "keywords": [
          "Seq"
        ]
      },
      "spec_add": {
        "name": "spec_add",
        "signature": "pub open spec fn spec_add(self, rhs: Seq<A>) -> Seq<A>",
        "body": "{\n        self.add(rhs)\n    }",
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 146,
        "module": "vstd::seq",
        "keywords": [
          "Seq"
        ]
      },
      "last": {
        "name": "last",
        "signature": "pub open spec fn last(self) -> A\n        recommends\n            0 < self.len(),",
        "body": "{\n        self[self.len() as int - 1]\n    }",
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 152,
        "module": "vstd::seq",
        "keywords": [
          "len"
        ]
      },
      "first": {
        "name": "first",
        "signature": "pub open spec fn first(self) -> A\n        recommends\n            0 < self.len(),",
        "body": "{\n        self[0]\n    }",
        "file_path": "verus/source/vstd/seq.rs",
        "line_number": 161,
        "module": "vstd::seq",
        "keywords": [
          "len"
        ]
      },
      "map": {
        "name": "map",
        "signature": "pub open spec fn map<B>(self, f: spec_fn(int, A) -> B) -> Seq<B>",
        "body": "{\n        Seq::new(self.len(), |i: int| f(i, self[i]))\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 25,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "map"
        ]
      },
      "vstd::seq_lib::map_values": {
        "name": "vstd::seq_lib::map_values",
        "signature": "pub open spec fn map_values<B>(self, f: spec_fn(A) -> B) -> Seq<B>",
        "body": "{\n        Seq::new(self.len(), |i: int| f(self[i]))\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 32,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ]
      },
      "flat_map": {
        "name": "flat_map",
        "signature": "pub open spec fn flat_map<B>(self, f: spec_fn(A) -> Seq<B>) -> Seq<B>",
        "body": "{\n        self.map_values(f).flatten()\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 49,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ]
      },
      "is_prefix_of": {
        "name": "is_prefix_of",
        "signature": "pub open spec fn is_prefix_of(self, other: Self) -> bool",
        "body": "{\n        self.len() <= other.len() && self =~= other.subrange(0, self.len() as int)\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 64,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "is_suffix_of": {
        "name": "is_suffix_of",
        "signature": "pub open spec fn is_suffix_of(self, other: Self) -> bool",
        "body": "{\n        self.len() <= other.len() && self =~= other.subrange(\n            (other.len() - self.len()) as int,\n            other.len() as int,\n        )\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 79,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "all": {
        "name": "all",
        "signature": "pub open spec fn all(self, pred: spec_fn(A) -> bool) -> bool",
        "body": "{\n        forall|i: int| 0 <= i < self.len() ==> #[trigger] pred(self[i])\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 120,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "any": {
        "name": "any",
        "signature": "pub open spec fn any(self, pred: spec_fn(A) -> bool) -> bool",
        "body": "{\n        exists|i: int| 0 <= i < self.len() && #[trigger] pred(self[i])\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 134,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "exactly_one": {
        "name": "exactly_one",
        "signature": "pub open spec fn exactly_one(self, pred: spec_fn(A) -> bool) -> bool",
        "body": "{\n        self.filter(pred).len() == 1\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 147,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "filter": {
        "name": "filter",
        "signature": "pub open spec fn filter(self, pred: spec_fn(A) -> bool) -> Self\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            self\n        } else {\n            let subseq = self.drop_last().filter(pred);\n            if pred(self.last()) {\n                subseq.push(self.last())\n            } else {\n                subseq\n            }\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 197,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "filter",
          "len"
        ]
      },
      "max_via": {
        "name": "max_via",
        "signature": "pub open spec fn max_via(self, leq: spec_fn(A, A) -> bool) -> A\n        recommends\n            self.len() > 0,\n        decreases self.len(),",
        "body": "{\n        if self.len() > 1 {\n            if leq(self[0], self.subrange(1, self.len() as int).max_via(leq)) {\n                self.subrange(1, self.len() as int).max_via(leq)\n            } else {\n                self[0]\n            }\n        } else {\n            self[0]\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 340,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ]
      },
      "min_via": {
        "name": "min_via",
        "signature": "pub open spec fn min_via(self, leq: spec_fn(A, A) -> bool) -> A\n        recommends\n            self.len() > 0,\n        decreases self.len(),",
        "body": "{\n        if self.len() > 1 {\n            let subseq = self.subrange(1, self.len() as int);\n            let elt = subseq.min_via(leq);\n            if leq(elt, self[0]) {\n                elt\n            } else {\n                self[0]\n            }\n        } else {\n            self[0]\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 357,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ]
      },
      "vstd::seq_lib::contains": {
        "name": "vstd::seq_lib::contains",
        "signature": "pub open spec fn contains(self, needle: A) -> bool",
        "body": "{\n        exists|i: int| 0 <= i < self.len() && self[i] == needle\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 376,
        "module": "vstd::seq_lib",
        "keywords": [
          "contains"
        ]
      },
      "index_of": {
        "name": "index_of",
        "signature": "pub open spec fn index_of(self, needle: A) -> int",
        "body": "{\n        choose|i: int| 0 <= i < self.len() && self[i] == needle\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 382,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "drop_last": {
        "name": "drop_last",
        "signature": "pub open spec fn drop_last(self) -> Seq<A>\n        recommends\n            self.len() >= 1,",
        "body": "{\n        self.subrange(0, self.len() as int - 1)\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 490,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len"
        ]
      },
      "drop_first": {
        "name": "drop_first",
        "signature": "pub open spec fn drop_first(self) -> Seq<A>\n        recommends\n            self.len() >= 1,",
        "body": "{\n        self.subrange(1, self.len() as int)\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 508,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len"
        ]
      },
      "no_duplicates": {
        "name": "no_duplicates",
        "signature": "pub open spec fn no_duplicates(self) -> bool",
        "body": "{\n        forall|i, j| (0 <= i < self.len() && 0 <= j < self.len() && i != j) ==> self[i] != self[j]\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 516,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "disjoint": {
        "name": "disjoint",
        "signature": "pub open spec fn disjoint(self, other: Self) -> bool",
        "body": "{\n        forall|i: int, j: int| 0 <= i < self.len() && 0 <= j < other.len() ==> self[i] != other[j]\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 521,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "to_set": {
        "name": "to_set",
        "signature": "pub open spec fn to_set(self) -> Set<A>",
        "body": "{\n        Set::new(|a: A| self.contains(a))\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 526,
        "module": "vstd::seq_lib",
        "keywords": [
          "Set"
        ]
      },
      "vstd::seq_lib::insert": {
        "name": "vstd::seq_lib::insert",
        "signature": "pub open spec fn insert(self, i: int, a: A) -> Seq<A>\n        recommends\n            0 <= i <= self.len(),",
        "body": "{\n        self.subrange(0, i).push(a) + self.subrange(i, self.len() as int)\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 560,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "insert",
          "len"
        ]
      },
      "vstd::seq_lib::remove": {
        "name": "vstd::seq_lib::remove",
        "signature": "pub open spec fn remove(self, i: int) -> Seq<A>\n        recommends\n            0 <= i < self.len(),",
        "body": "{\n        self.subrange(0, i) + self.subrange(i + 1, self.len() as int)\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 580,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "len",
          "remove"
        ]
      },
      "remove_value": {
        "name": "remove_value",
        "signature": "pub open spec fn remove_value(self, val: A) -> Seq<A>",
        "body": "{\n        let index = self.index_of_first(val);\n        match index {\n            Some(i) => self.remove(i),\n            None => self,\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 601,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ]
      },
      "reverse": {
        "name": "reverse",
        "signature": "pub open spec fn reverse(self) -> Seq<A>\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            Seq::empty()\n        } else {\n            Seq::new(self.len(), |i: int| self[self.len() - 1 - i])\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 610,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ]
      },
      "zip_with": {
        "name": "zip_with",
        "signature": "pub open spec fn zip_with<B>(self, other: Seq<B>) -> Seq<(A, B)>\n        recommends\n            self.len() == other.len(),\n        decreases self.len(),",
        "body": "{\n        if self.len() != other.len() {\n            Seq::empty()\n        } else if self.len() == 0 {\n            Seq::empty()\n        } else {\n            Seq::new(self.len(), |i: int| (self[i], other[i]))\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 622,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ]
      },
      "fold_left": {
        "name": "fold_left",
        "signature": "pub open spec fn fold_left<B>(self, b: B, f: spec_fn(B, A) -> B) -> (res: B)\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            b\n        } else {\n            f(self.drop_last().fold_left(b, f), self.last())\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 642,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ]
      },
      "fold_left_alt": {
        "name": "fold_left_alt",
        "signature": "pub open spec fn fold_left_alt<B>(self, b: B, f: spec_fn(B, A) -> B) -> (res: B)\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            b\n        } else {\n            self.subrange(1, self.len() as int).fold_left_alt(f(b, self[0]), f)\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 655,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ]
      },
      "fold_right": {
        "name": "fold_right",
        "signature": "pub open spec fn fold_right<B>(self, f: spec_fn(A, B) -> B, b: B) -> (res: B)\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            b\n        } else {\n            self.drop_last().fold_right(f, f(self.last(), b))\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 766,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ]
      },
      "fold_right_alt": {
        "name": "fold_right_alt",
        "signature": "pub open spec fn fold_right_alt<B>(self, f: spec_fn(A, B) -> B, b: B) -> (res: B)\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            b\n        } else {\n            f(self[0], self.subrange(1, self.len() as int).fold_right_alt(f, b))\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 779,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ]
      },
      "update_subrange_with": {
        "name": "update_subrange_with",
        "signature": "pub open spec fn update_subrange_with(self, off: int, vs: Self) -> Self\n        recommends\n            0 <= off,\n            off + vs.len() <= self.len(),",
        "body": "{\n        Seq::new(\n            self.len(),\n            |i: int|\n                if off <= i < off + vs.len() {\n                    vs[i - off]\n                } else {\n                    self[i]\n                },\n        )\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1164,
        "module": "vstd::seq_lib",
        "keywords": [
          "len"
        ]
      },
      "remove_duplicates": {
        "name": "remove_duplicates",
        "signature": "pub open spec fn remove_duplicates(self, seen: Seq<A>) -> Seq<A>\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            seen\n        } else if seen.contains(self[0]) {\n            self.skip(1).remove_duplicates(seen)\n        } else {\n            self.skip(1).remove_duplicates(seen + seq![self[0]])\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1297,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ]
      },
      "filter_map": {
        "name": "filter_map",
        "signature": "pub open spec fn filter_map<B>(self, f: spec_fn(A) -> Option<B>) -> Seq<B>\n        decreases self.len(),",
        "body": "{\n        // We're defining this by starting at the end of the list since it makes it\n        // easier to reason about in the common case of looping over a vector in the\n        // implementation.\n        if self.len() == 0 {\n            Seq::empty()\n        } else {\n            let rest = self.drop_last();\n            match f(self.last()) {\n                Option::Some(s) => rest.filter_map(f) + seq![s],\n                Option::None => rest.filter_map(f),\n            }\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1497,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ]
      },
      "filter_alt": {
        "name": "filter_alt",
        "signature": "pub open spec fn filter_alt(self, p: spec_fn(A) -> bool) -> Seq<A>",
        "body": "{\n        if self.len() == 0 {\n            Seq::empty()\n        } else {\n            let rest = self.drop_first().filter(p);\n            let first = self.first();\n            if p(first) {\n                seq![first] + rest\n            } else {\n                rest\n            }\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 1627,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ]
      },
      "flatten": {
        "name": "flatten",
        "signature": "pub open spec fn flatten(self) -> Seq<A>\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            Seq::empty()\n        } else {\n            self.first().add(self.drop_first().flatten())\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2395,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ]
      },
      "flatten_alt": {
        "name": "flatten_alt",
        "signature": "pub open spec fn flatten_alt(self) -> Seq<A>\n        decreases self.len(),",
        "body": "{\n        if self.len() == 0 {\n            Seq::empty()\n        } else {\n            self.drop_last().flatten_alt().add(self.last())\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2409,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq",
          "decreases",
          "len"
        ]
      },
      "vstd::seq_lib::max": {
        "name": "vstd::seq_lib::max",
        "signature": "pub open spec fn max(self) -> int\n        recommends\n            0 < self.len(),\n        decreases self.len(),",
        "body": "{\n        if self.len() == 1 {\n            self[0]\n        } else if self.len() == 0 {\n            0\n        } else {\n            let later_max = self.drop_first().max();\n            if self[0] >= later_max {\n                self[0]\n            } else {\n                later_max\n            }\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2539,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ]
      },
      "vstd::seq_lib::min": {
        "name": "vstd::seq_lib::min",
        "signature": "pub open spec fn min(self) -> int\n        recommends\n            0 < self.len(),\n        decreases self.len(),",
        "body": "{\n        if self.len() == 1 {\n            self[0]\n        } else if self.len() == 0 {\n            0\n        } else {\n            let later_min = self.drop_first().min();\n            if self[0] <= later_min {\n                self[0]\n            } else {\n                later_min\n            }\n        }\n    }",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 2580,
        "module": "vstd::seq_lib",
        "keywords": [
          "decreases",
          "len"
        ]
      },
      "commutative_foldr": {
        "name": "commutative_foldr",
        "signature": "pub open spec fn commutative_foldr<A, B>(f: spec_fn(A, B) -> B) -> bool",
        "body": "{\n    forall|x: A, y: A, v: B| #[trigger] f(x, f(y, v)) == f(y, f(x, v))\n}",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3273,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "commutative_foldl": {
        "name": "commutative_foldl",
        "signature": "pub open spec fn commutative_foldl<A, B>(f: spec_fn(B, A) -> B) -> bool",
        "body": "{\n    forall|x: A, y: A, v: B| #[trigger] f(f(v, x), y) == f(f(v, y), x)\n}",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3278,
        "module": "vstd::seq_lib",
        "keywords": []
      },
      "check_argument_is_seq": {
        "name": "check_argument_is_seq",
        "signature": "pub open spec fn check_argument_is_seq<A>(s: Seq<A>) -> Seq<A>",
        "body": "{\n    s\n}",
        "file_path": "verus/source/vstd/seq_lib.rs",
        "line_number": 3600,
        "module": "vstd::seq_lib",
        "keywords": [
          "Seq"
        ]
      },
      "full": {
        "name": "full",
        "signature": "pub open spec fn full() -> Set<A>",
        "body": "{\n        Set::empty().complement()\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 78,
        "module": "vstd::set",
        "keywords": [
          "Set"
        ]
      },
      "vstd::set::spec_has": {
        "name": "vstd::set::spec_has",
        "signature": "pub open spec fn spec_has(self, a: A) -> bool",
        "body": "{\n        self.contains(a)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 90,
        "module": "vstd::set",
        "keywords": []
      },
      "vstd::set::subset_of": {
        "name": "vstd::set::subset_of",
        "signature": "pub open spec fn subset_of(self, s2: Set<A>) -> bool",
        "body": "{\n        forall|a: A| self.contains(a) ==> s2.contains(a)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 96,
        "module": "vstd::set",
        "keywords": [
          "Set"
        ]
      },
      "vstd::set::spec_le": {
        "name": "vstd::set::spec_le",
        "signature": "pub open spec fn spec_le(self, s2: Set<A>) -> bool",
        "body": "{\n        self.subset_of(s2)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 101,
        "module": "vstd::set",
        "keywords": [
          "Set"
        ]
      },
      "vstd::set::spec_add": {
        "name": "vstd::set::spec_add",
        "signature": "pub open spec fn spec_add(self, s2: Set<A>) -> Set<A>",
        "body": "{\n        self.union(s2)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 140,
        "module": "vstd::set",
        "keywords": [
          "Set"
        ]
      },
      "spec_mul": {
        "name": "spec_mul",
        "signature": "pub open spec fn spec_mul(self, s2: Set<A>) -> Set<A>",
        "body": "{\n        self.intersect(s2)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 151,
        "module": "vstd::set",
        "keywords": [
          "Set"
        ]
      },
      "spec_sub": {
        "name": "spec_sub",
        "signature": "pub open spec fn spec_sub(self, s2: Set<A>) -> Set<A>",
        "body": "{\n        self.difference(s2)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 162,
        "module": "vstd::set",
        "keywords": [
          "Set"
        ]
      },
      "vstd::set::filter": {
        "name": "vstd::set::filter",
        "signature": "pub open spec fn filter(self, f: spec_fn(A) -> bool) -> Set<A>",
        "body": "{\n        self.intersect(Self::new(f))\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 172,
        "module": "vstd::set",
        "keywords": [
          "Set",
          "filter"
        ]
      },
      "vstd::set::choose": {
        "name": "vstd::set::choose",
        "signature": "pub open spec fn choose(self) -> A",
        "body": "{\n        choose|a: A| self.contains(a)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 197,
        "module": "vstd::set",
        "keywords": []
      },
      "vstd::set::disjoint": {
        "name": "vstd::set::disjoint",
        "signature": "pub open spec fn disjoint(self, s2: Self) -> bool",
        "body": "{\n        forall|a: A| self.contains(a) ==> !s2.contains(a)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 207,
        "module": "vstd::set",
        "keywords": []
      },
      "is_fun_commutative": {
        "name": "is_fun_commutative",
        "signature": "pub open spec fn is_fun_commutative<A, B>(f: spec_fn(B, A) -> B) -> bool",
        "body": "{\n        forall|a1, a2, b| #[trigger] f(f(b, a2), a1) == f(f(b, a1), a2)\n    }",
        "file_path": "verus/source/vstd/set.rs",
        "line_number": 267,
        "module": "vstd::set",
        "keywords": []
      },
      "vstd::set_lib::is_full": {
        "name": "vstd::set_lib::is_full",
        "signature": "pub open spec fn is_full(self) -> bool",
        "body": "{\n        self == Set::<A>::full()\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 19,
        "module": "vstd::set_lib",
        "keywords": []
      },
      "vstd::set_lib::is_empty": {
        "name": "vstd::set_lib::is_empty",
        "signature": "pub open spec fn is_empty(self) -> (b: bool)",
        "body": "{\n        self =~= Set::<A>::empty()\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 24,
        "module": "vstd::set_lib",
        "keywords": []
      },
      "vstd::set_lib::map": {
        "name": "vstd::set_lib::map",
        "signature": "pub open spec fn map<B>(self, f: spec_fn(A) -> B) -> Set<B>",
        "body": "{\n        Set::new(|a: B| exists|x: A| self.contains(x) && a == f(x))\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 29,
        "module": "vstd::set_lib",
        "keywords": [
          "Set",
          "map"
        ]
      },
      "to_seq": {
        "name": "to_seq",
        "signature": "pub open spec fn to_seq(self) -> Seq<A>\n        recommends\n            self.finite(),\n        decreases self.len(),\n        when self.finite()",
        "body": "{\n        if self.len() == 0 {\n            Seq::<A>::empty()\n        } else {\n            let x = self.choose();\n            Seq::<A>::empty().push(x) + self.remove(x).to_seq()\n        }\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 34,
        "module": "vstd::set_lib",
        "keywords": [
          "Seq",
          "decreases",
          "finite",
          "len"
        ]
      },
      "to_sorted_seq": {
        "name": "to_sorted_seq",
        "signature": "pub open spec fn to_sorted_seq(self, leq: spec_fn(A, A) -> bool) -> Seq<A>",
        "body": "{\n        self.to_seq().sort_by(leq)\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 49,
        "module": "vstd::set_lib",
        "keywords": [
          "Seq"
        ]
      },
      "vstd::set_lib::is_singleton": {
        "name": "vstd::set_lib::is_singleton",
        "signature": "pub open spec fn is_singleton(self) -> bool",
        "body": "{\n        &&& self.len() > 0\n        &&& (forall|x: A, y: A| self.contains(x) && self.contains(y) ==> x == y)\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 54,
        "module": "vstd::set_lib",
        "keywords": []
      },
      "to_multiset": {
        "name": "to_multiset",
        "signature": "pub open spec fn to_multiset(self) -> Multiset<A>\n        decreases self.len(),\n        when self.finite()",
        "body": "{\n        if self.len() == 0 {\n            Multiset::<A>::empty()\n        } else {\n            Multiset::<A>::empty().insert(self.choose()).add(\n                self.remove(self.choose()).to_multiset(),\n            )\n        }\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 230,
        "module": "vstd::set_lib",
        "keywords": [
          "Multiset",
          "decreases",
          "finite",
          "len"
        ]
      },
      "vstd::set_lib::all": {
        "name": "vstd::set_lib::all",
        "signature": "pub open spec fn all(&self, pred: spec_fn(A) -> bool) -> bool",
        "body": "{\n        forall|x: A| self.contains(x) ==> pred(x)\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 477,
        "module": "vstd::set_lib",
        "keywords": []
      },
      "vstd::set_lib::any": {
        "name": "vstd::set_lib::any",
        "signature": "pub open spec fn any(&self, pred: spec_fn(A) -> bool) -> bool",
        "body": "{\n        exists|x: A| self.contains(x) && pred(x)\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 482,
        "module": "vstd::set_lib",
        "keywords": []
      },
      "vstd::set_lib::filter_map": {
        "name": "vstd::set_lib::filter_map",
        "signature": "pub open spec fn filter_map<B>(self, f: spec_fn(A) -> Option<B>) -> Set<B>",
        "body": "{\n        self.map(\n            |elem: A|\n                match f(elem) {\n                    Option::Some(r) => set!{r},\n                    Option::None => set!{},\n                },\n        ).flatten()\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 504,
        "module": "vstd::set_lib",
        "keywords": [
          "Set"
        ]
      },
      "vstd::set_lib::flatten": {
        "name": "vstd::set_lib::flatten",
        "signature": "pub open spec fn flatten(self) -> Set<A>",
        "body": "{\n        Set::new(\n            |elem| exists|elem_s: Set<A>| #[trigger] self.contains(elem_s) && elem_s.contains(elem),\n        )\n    }",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 682,
        "module": "vstd::set_lib",
        "keywords": [
          "Set"
        ]
      },
      "set_int_range": {
        "name": "set_int_range",
        "signature": "pub open spec fn set_int_range(lo: int, hi: int) -> Set<int>",
        "body": "{\n    Set::new(|i: int| lo <= i && i < hi)\n}",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 909,
        "module": "vstd::set_lib",
        "keywords": [
          "Set"
        ]
      },
      "check_argument_is_set": {
        "name": "check_argument_is_set",
        "signature": "pub open spec fn check_argument_is_set<A>(s: Set<A>) -> Set<A>",
        "body": "{\n    s\n}",
        "file_path": "verus/source/vstd/set_lib.rs",
        "line_number": 1222,
        "module": "vstd::set_lib",
        "keywords": [
          "Set"
        ]
      },
      "vstd::simple_pptr::spec_addr": {
        "name": "vstd::simple_pptr::spec_addr",
        "signature": "pub open spec fn spec_addr(p: PPtr<V>) -> usize",
        "body": "{\n        p.0\n    }",
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 177,
        "module": "vstd::simple_pptr",
        "keywords": []
      },
      "pptr": {
        "name": "pptr",
        "signature": "pub open spec fn pptr(&self) -> PPtr<V>",
        "body": "{\n        PPtr(self.addr(), PhantomData)\n    }",
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 222,
        "module": "vstd::simple_pptr",
        "keywords": []
      },
      "vstd::simple_pptr::opt_value": {
        "name": "vstd::simple_pptr::opt_value",
        "signature": "pub open spec fn opt_value(&self) -> MemContents<V>",
        "body": "{\n        self.mem_contents()\n    }",
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 252,
        "module": "vstd::simple_pptr",
        "keywords": []
      },
      "vstd::simple_pptr::is_init": {
        "name": "vstd::simple_pptr::is_init",
        "signature": "pub open spec fn is_init(&self) -> bool",
        "body": "{\n        self.mem_contents().is_init()\n    }",
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 257,
        "module": "vstd::simple_pptr",
        "keywords": []
      },
      "vstd::simple_pptr::is_uninit": {
        "name": "vstd::simple_pptr::is_uninit",
        "signature": "pub open spec fn is_uninit(&self) -> bool",
        "body": "{\n        self.mem_contents().is_uninit()\n    }",
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 262,
        "module": "vstd::simple_pptr",
        "keywords": []
      },
      "vstd::simple_pptr::value": {
        "name": "vstd::simple_pptr::value",
        "signature": "pub open spec fn value(&self) -> V\n        recommends\n            self.is_init(),",
        "body": "{\n        self.mem_contents().value()\n    }",
        "file_path": "verus/source/vstd/simple_pptr.rs",
        "line_number": 267,
        "module": "vstd::simple_pptr",
        "keywords": []
      },
      "nat_max": {
        "name": "nat_max",
        "signature": "pub open spec fn nat_max(a: nat, b: nat) -> nat",
        "body": "{\n    if a > b {\n        a\n    } else {\n        b\n    }\n}",
        "file_path": "verus/source/vstd/state_machine_internal.rs",
        "line_number": 259,
        "module": "vstd::state_machine_internal",
        "keywords": []
      },
      "update_at_index": {
        "name": "update_at_index",
        "signature": "pub open spec fn update_at_index(self, i: int, a: A) -> Self\n        recommends\n            0 <= i < self.len(),",
        "body": "{\n        self.update(i, a)\n    }",
        "file_path": "verus/source/vstd/state_machine_internal.rs",
        "line_number": 270,
        "module": "vstd::state_machine_internal",
        "keywords": [
          "len"
        ]
      },
      "vstd::state_machine_internal::update_at_index": {
        "name": "vstd::state_machine_internal::update_at_index",
        "signature": "pub open spec fn update_at_index(self, k: K, v: V) -> Self",
        "body": "{\n        self.insert(k, v)\n    }",
        "file_path": "verus/source/vstd/state_machine_internal.rs",
        "line_number": 282,
        "module": "vstd::state_machine_internal",
        "keywords": []
      },
      "opt_is_none": {
        "name": "opt_is_none",
        "signature": "pub open spec fn opt_is_none<V>(a: Option<V>) -> bool",
        "body": "{\n    a is None\n}",
        "file_path": "verus/source/vstd/state_machine_internal.rs",
        "line_number": 289,
        "module": "vstd::state_machine_internal",
        "keywords": []
      },
      "opt_ge": {
        "name": "opt_ge",
        "signature": "pub open spec fn opt_ge<V>(a: Option<V>, b: Option<V>) -> bool",
        "body": "{\n    b is Some ==> a === b\n}",
        "file_path": "verus/source/vstd/state_machine_internal.rs",
        "line_number": 295,
        "module": "vstd::state_machine_internal",
        "keywords": []
      },
      "opt_add": {
        "name": "opt_add",
        "signature": "pub open spec fn opt_add<V>(a: Option<V>, b: Option<V>) -> Option<V>",
        "body": "{\n    if b is Some {\n        b\n    } else {\n        a\n    }\n}",
        "file_path": "verus/source/vstd/state_machine_internal.rs",
        "line_number": 301,
        "module": "vstd::state_machine_internal",
        "keywords": []
      },
      "opt_agree": {
        "name": "opt_agree",
        "signature": "pub open spec fn opt_agree<V>(a: Option<V>, b: Option<V>) -> bool",
        "body": "{\n    a is Some && b is Some ==> a->0 === b->0\n}",
        "file_path": "verus/source/vstd/state_machine_internal.rs",
        "line_number": 311,
        "module": "vstd::state_machine_internal",
        "keywords": []
      },
      "opt_sub": {
        "name": "opt_sub",
        "signature": "pub open spec fn opt_sub<V>(a: Option<V>, b: Option<V>) -> Option<V>",
        "body": "{\n    if b is Some {\n        Option::None\n    } else {\n        a\n    }\n}",
        "file_path": "verus/source/vstd/state_machine_internal.rs",
        "line_number": 317,
        "module": "vstd::state_machine_internal",
        "keywords": []
      },
      "u8_trailing_ones": {
        "name": "u8_trailing_ones",
        "signature": "pub open spec fn u8_trailing_ones(i: u8) -> u32",
        "body": "{\n    u8_trailing_zeros(!i)\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 37,
        "module": "vstd::std_specs::bits",
        "keywords": []
      },
      "u8_leading_ones": {
        "name": "u8_leading_ones",
        "signature": "pub open spec fn u8_leading_ones(i: u8) -> u32",
        "body": "{\n    u8_leading_zeros(!i)\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 43,
        "module": "vstd::std_specs::bits",
        "keywords": []
      },
      "u16_trailing_ones": {
        "name": "u16_trailing_ones",
        "signature": "pub open spec fn u16_trailing_ones(i: u16) -> u32",
        "body": "{\n    u16_trailing_zeros(!i)\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 207,
        "module": "vstd::std_specs::bits",
        "keywords": []
      },
      "u16_leading_ones": {
        "name": "u16_leading_ones",
        "signature": "pub open spec fn u16_leading_ones(i: u16) -> u32",
        "body": "{\n    u16_leading_zeros(!i)\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 213,
        "module": "vstd::std_specs::bits",
        "keywords": []
      },
      "u32_trailing_ones": {
        "name": "u32_trailing_ones",
        "signature": "pub open spec fn u32_trailing_ones(i: u32) -> u32",
        "body": "{\n    u32_trailing_zeros(!i)\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 383,
        "module": "vstd::std_specs::bits",
        "keywords": []
      },
      "u32_leading_ones": {
        "name": "u32_leading_ones",
        "signature": "pub open spec fn u32_leading_ones(i: u32) -> u32",
        "body": "{\n    u32_leading_zeros(!i)\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 389,
        "module": "vstd::std_specs::bits",
        "keywords": []
      },
      "u64_leading_zeros": {
        "name": "u64_leading_zeros",
        "signature": "pub open spec fn u64_leading_zeros(i: u64) -> int\n    decreases i,",
        "body": "{\n    if i == 0 {\n        64\n    } else {\n        u64_leading_zeros(i / 2) - 1\n    }\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 548,
        "module": "vstd::std_specs::bits",
        "keywords": [
          "decreases"
        ]
      },
      "u64_trailing_ones": {
        "name": "u64_trailing_ones",
        "signature": "pub open spec fn u64_trailing_ones(i: u64) -> u32",
        "body": "{\n    u64_trailing_zeros(!i) as u32\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 560,
        "module": "vstd::std_specs::bits",
        "keywords": []
      },
      "u64_leading_ones": {
        "name": "u64_leading_ones",
        "signature": "pub open spec fn u64_leading_ones(i: u64) -> u32",
        "body": "{\n    u64_leading_zeros(!i) as u32\n}",
        "file_path": "verus/source/vstd/std_specs/bits.rs",
        "line_number": 566,
        "module": "vstd::std_specs::bits",
        "keywords": []
      },
      "iter_into_iter_spec": {
        "name": "iter_into_iter_spec",
        "signature": "pub open spec fn iter_into_iter_spec<I: Iterator>(i: I) -> I",
        "body": "{\n    i\n}",
        "file_path": "verus/source/vstd/std_specs/core.rs",
        "line_number": 140,
        "module": "vstd::std_specs::core",
        "keywords": []
      },
      "hash_map_deep_view_impl": {
        "name": "hash_map_deep_view_impl",
        "signature": "pub open spec fn hash_map_deep_view_impl<Key: DeepView, Value: DeepView, S>(\n    m: HashMap<Key, Value, S>,\n) -> Map<Key::V, Value::V>",
        "body": "{\n    Map::new(\n        |k: Key::V|\n            exists|orig_k: Key| #[trigger] m@.contains_key(orig_k) && k == orig_k.deep_view(),\n        |dk: Key::V|\n            {\n                let k = choose|k: Key| m@.contains_key(k) && #[trigger] k.deep_view() == dk;\n                m@[k].deep_view()\n            },\n    )\n}",
        "file_path": "verus/source/vstd/std_specs/hash.rs",
        "line_number": 691,
        "module": "vstd::std_specs::hash",
        "keywords": [
          "Map"
        ]
      },
      "checked_div": {
        "name": "checked_div",
        "signature": "pub open spec fn checked_div(x: $uN, y: $uN) -> Option<$uN>",
        "body": "{\n                if y == 0 {\n                    None\n                } else {\n                    Some(x / y)\n                }\n            }",
        "file_path": "verus/source/vstd/std_specs/num.rs",
        "line_number": 154,
        "module": "vstd::std_specs::num",
        "keywords": []
      },
      "signed_crop": {
        "name": "signed_crop",
        "signature": "pub open spec fn signed_crop(x: int) -> $iN",
        "body": "{\n                if (x % ($range as int)) > (<$iN>::MAX as int) {\n                    ((x % ($range as int)) - $range) as $iN\n                } else {\n                    (x % ($range as int)) as $iN\n                }\n            }",
        "file_path": "verus/source/vstd/std_specs/num.rs",
        "line_number": 274,
        "module": "vstd::std_specs::num",
        "keywords": []
      },
      "is_some": {
        "name": "is_some",
        "signature": "pub open spec fn is_some<T>(option: &Option<T>) -> bool",
        "body": "{\n    is_variant(option, \"Some\")\n}",
        "file_path": "verus/source/vstd/std_specs/option.rs",
        "line_number": 125,
        "module": "vstd::std_specs::option",
        "keywords": []
      },
      "is_none": {
        "name": "is_none",
        "signature": "pub open spec fn is_none<T>(option: &Option<T>) -> bool",
        "body": "{\n    is_variant(option, \"None\")\n}",
        "file_path": "verus/source/vstd/std_specs/option.rs",
        "line_number": 137,
        "module": "vstd::std_specs::option",
        "keywords": []
      },
      "spec_unwrap": {
        "name": "spec_unwrap",
        "signature": "pub open spec fn spec_unwrap<T>(option: Option<T>) -> T\n    recommends\n        option is Some,",
        "body": "{\n    option->0\n}",
        "file_path": "verus/source/vstd/std_specs/option.rs",
        "line_number": 156,
        "module": "vstd::std_specs::option",
        "keywords": []
      },
      "spec_unwrap_or": {
        "name": "spec_unwrap_or",
        "signature": "pub open spec fn spec_unwrap_or<T>(option: Option<T>, default: T) -> T",
        "body": "{\n    match option {\n        Some(t) => t,\n        None => default,\n    }\n}",
        "file_path": "verus/source/vstd/std_specs/option.rs",
        "line_number": 173,
        "module": "vstd::std_specs::option",
        "keywords": []
      },
      "spec_expect": {
        "name": "spec_expect",
        "signature": "pub open spec fn spec_expect<T>(option: Option<T>, msg: &str) -> T\n    recommends\n        option is Some,",
        "body": "{\n    option->0\n}",
        "file_path": "verus/source/vstd/std_specs/option.rs",
        "line_number": 188,
        "module": "vstd::std_specs::option",
        "keywords": []
      },
      "spec_ok_or": {
        "name": "spec_ok_or",
        "signature": "pub open spec fn spec_ok_or<T, E>(option: Option<T>, err: E) -> Result<T, E>",
        "body": "{\n    match option {\n        Some(t) => Ok(t),\n        None => Err(err),\n    }\n}",
        "file_path": "verus/source/vstd/std_specs/option.rs",
        "line_number": 293,
        "module": "vstd::std_specs::option",
        "keywords": []
      },
      "is_ok": {
        "name": "is_ok",
        "signature": "pub open spec fn is_ok<T, E>(result: &Result<T, E>) -> bool",
        "body": "{\n    is_variant(result, \"Ok\")\n}",
        "file_path": "verus/source/vstd/std_specs/result.rs",
        "line_number": 74,
        "module": "vstd::std_specs::result",
        "keywords": []
      },
      "is_err": {
        "name": "is_err",
        "signature": "pub open spec fn is_err<T, E>(result: &Result<T, E>) -> bool",
        "body": "{\n    is_variant(result, \"Err\")\n}",
        "file_path": "verus/source/vstd/std_specs/result.rs",
        "line_number": 86,
        "module": "vstd::std_specs::result",
        "keywords": []
      },
      "vstd::std_specs::result::spec_unwrap": {
        "name": "vstd::std_specs::result::spec_unwrap",
        "signature": "pub open spec fn spec_unwrap<T, E: core::fmt::Debug>(result: Result<T, E>) -> T\n    recommends\n        result is Ok,",
        "body": "{\n    result->Ok_0\n}",
        "file_path": "verus/source/vstd/std_specs/result.rs",
        "line_number": 110,
        "module": "vstd::std_specs::result",
        "keywords": []
      },
      "spec_unwrap_err": {
        "name": "spec_unwrap_err",
        "signature": "pub open spec fn spec_unwrap_err<T: core::fmt::Debug, E>(result: Result<T, E>) -> E\n    recommends\n        result is Err,",
        "body": "{\n    result->Err_0\n}",
        "file_path": "verus/source/vstd/std_specs/result.rs",
        "line_number": 129,
        "module": "vstd::std_specs::result",
        "keywords": []
      },
      "vstd::std_specs::result::spec_expect": {
        "name": "vstd::std_specs::result::spec_expect",
        "signature": "pub open spec fn spec_expect<T, E: core::fmt::Debug>(result: Result<T, E>, msg: &str) -> T\n    recommends\n        result is Ok,",
        "body": "{\n    result->Ok_0\n}",
        "file_path": "verus/source/vstd/std_specs/result.rs",
        "line_number": 148,
        "module": "vstd::std_specs::result",
        "keywords": []
      },
      "ok": {
        "name": "ok",
        "signature": "pub open spec fn ok<T, E>(result: Result<T, E>) -> Option<T>",
        "body": "{\n    match result {\n        Ok(t) => Some(t),\n        Err(_) => None,\n    }\n}",
        "file_path": "verus/source/vstd/std_specs/result.rs",
        "line_number": 195,
        "module": "vstd::std_specs::result",
        "keywords": []
      },
      "err": {
        "name": "err",
        "signature": "pub open spec fn err<T, E>(result: Result<T, E>) -> Option<E>",
        "body": "{\n    match result {\n        Ok(_) => None,\n        Err(e) => Some(e),\n    }\n}",
        "file_path": "verus/source/vstd/std_specs/result.rs",
        "line_number": 210,
        "module": "vstd::std_specs::result",
        "keywords": []
      },
      "vec_clone_trigger": {
        "name": "vec_clone_trigger",
        "signature": "pub open spec fn vec_clone_trigger<T, A: Allocator>(v1: Vec<T, A>, v2: Vec<T, A>) -> bool",
        "body": "{\n    true\n}",
        "file_path": "verus/source/vstd/std_specs/vec.rs",
        "line_number": 205,
        "module": "vstd::std_specs::vec",
        "keywords": [
          "Vec",
          "trigger"
        ]
      },
      "vec_dequeue_clone_trigger": {
        "name": "vec_dequeue_clone_trigger",
        "signature": "pub open spec fn vec_dequeue_clone_trigger<T, A: Allocator>(\n    v1: VecDeque<T, A>,\n    v2: VecDeque<T, A>,\n) -> bool",
        "body": "{\n    true\n}",
        "file_path": "verus/source/vstd/std_specs/vecdeque.rs",
        "line_number": 201,
        "module": "vstd::std_specs::vecdeque",
        "keywords": [
          "Vec",
          "trigger"
        ]
      },
      "vstd::storage_protocol::incl": {
        "name": "vstd::storage_protocol::incl",
        "signature": "pub open spec fn incl<K, V, P: Protocol<K, V>>(a: P, b: P) -> bool",
        "body": "{\n    exists|c| P::op(a, c) == b\n}",
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 64,
        "module": "vstd::storage_protocol",
        "keywords": []
      },
      "guards": {
        "name": "guards",
        "signature": "pub open spec fn guards<K, V, P: Protocol<K, V>>(p: P, b: Map<K, V>) -> bool",
        "body": "{\n    forall|q: P, t: Map<K, V>| #![all_triggers] P::rel(P::op(p, q), t) ==> b.submap_of(t)\n}",
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 68,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ]
      },
      "exchanges": {
        "name": "exchanges",
        "signature": "pub open spec fn exchanges<K, V, P: Protocol<K, V>>(\n    p1: P,\n    b1: Map<K, V>,\n    p2: P,\n    b2: Map<K, V>,\n) -> bool",
        "body": "{\n    forall|q: P, t1: Map<K, V>|\n        #![all_triggers]\n        P::rel(P::op(p1, q), t1) ==> exists|t2: Map<K, V>|\n            #![all_triggers]\n            P::rel(P::op(p2, q), t2) && t1.dom().disjoint(b1.dom()) && t2.dom().disjoint(b2.dom())\n                && t1.union_prefer_right(b1) =~= t2.union_prefer_right(b2)\n}",
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 72,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ]
      },
      "exchanges_nondeterministic": {
        "name": "exchanges_nondeterministic",
        "signature": "pub open spec fn exchanges_nondeterministic<K, V, P: Protocol<K, V>>(\n    p1: P,\n    s1: Map<K, V>,\n    new_values: Set<(P, Map<K, V>)>,\n) -> bool",
        "body": "{\n    forall|q: P, t1: Map<K, V>|\n        #![all_triggers]\n        P::rel(P::op(p1, q), t1) ==> exists|p2: P, s2: Map<K, V>, t2: Map<K, V>|\n            #![all_triggers]\n            new_values.contains((p2, s2)) && P::rel(P::op(p2, q), t2) && t1.dom().disjoint(s1.dom())\n                && t2.dom().disjoint(s2.dom()) && t1.union_prefer_right(s1)\n                =~= t2.union_prefer_right(s2)\n}",
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 86,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map",
          "Set"
        ]
      },
      "deposits": {
        "name": "deposits",
        "signature": "pub open spec fn deposits<K, V, P: Protocol<K, V>>(p1: P, b1: Map<K, V>, p2: P) -> bool",
        "body": "{\n    forall|q: P, t1: Map<K, V>|\n        #![all_triggers]\n        P::rel(P::op(p1, q), t1) ==> exists|t2: Map<K, V>|\n            #![all_triggers]\n            P::rel(P::op(p2, q), t2) && t1.dom().disjoint(b1.dom()) && t1.union_prefer_right(b1)\n                =~= t2\n}",
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 100,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ]
      },
      "withdraws": {
        "name": "withdraws",
        "signature": "pub open spec fn withdraws<K, V, P: Protocol<K, V>>(p1: P, p2: P, b2: Map<K, V>) -> bool",
        "body": "{\n    forall|q: P, t1: Map<K, V>|\n        #![all_triggers]\n        P::rel(P::op(p1, q), t1) ==> exists|t2: Map<K, V>|\n            #![all_triggers]\n            P::rel(P::op(p2, q), t2) && t2.dom().disjoint(b2.dom()) && t1 =~= t2.union_prefer_right(\n                b2,\n            )\n}",
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 109,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map"
        ]
      },
      "updates": {
        "name": "updates",
        "signature": "pub open spec fn updates<K, V, P: Protocol<K, V>>(p1: P, p2: P) -> bool",
        "body": "{\n    forall|q: P, t1: Map<K, V>|\n        #![all_triggers]\n        P::rel(P::op(p1, q), t1) ==> P::rel(P::op(p2, q), t1)\n}",
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 119,
        "module": "vstd::storage_protocol",
        "keywords": []
      },
      "vstd::storage_protocol::set_op": {
        "name": "vstd::storage_protocol::set_op",
        "signature": "pub open spec fn set_op<K, V, P: Protocol<K, V>>(s: Set<(P, Map<K, V>)>, t: P) -> Set<\n    (P, Map<K, V>),\n>",
        "body": "{\n    Set::new(|v: (P, Map<K, V>)| exists|q| s.contains((q, v.1)) && v.0 == #[trigger] P::op(q, t))\n}",
        "file_path": "verus/source/vstd/storage_protocol.rs",
        "line_number": 125,
        "module": "vstd::storage_protocol",
        "keywords": [
          "Map",
          "Set"
        ]
      },
      "new_strlit_spec": {
        "name": "new_strlit_spec",
        "signature": "pub open spec fn new_strlit_spec(s: &str) -> &str",
        "body": "{\n    s\n}",
        "file_path": "verus/source/vstd/string.rs",
        "line_number": 39,
        "module": "vstd::string",
        "keywords": []
      },
      "valid": {
        "name": "valid",
        "signature": "pub open spec fn valid(self, id: Loc, frac: int) -> bool",
        "body": "{\n        &&& self.id() == id\n        &&& self.frac() == frac\n    }",
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 147,
        "module": "vstd::tokens::frac",
        "keywords": []
      },
      "vstd::tokens::frac::valid": {
        "name": "vstd::tokens::frac::valid",
        "signature": "pub open spec fn valid(self, id: Loc, frac: int) -> bool",
        "body": "{\n        &&& self.id() == id\n        &&& self.frac() == frac\n    }",
        "file_path": "verus/source/vstd/tokens/frac.rs",
        "line_number": 502,
        "module": "vstd::tokens::frac",
        "keywords": []
      },
      "vstd::tokens::map::dom": {
        "name": "vstd::tokens::map::dom",
        "signature": "pub open spec fn dom(self) -> Set<K>",
        "body": "{\n        self@.dom()\n    }",
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 309,
        "module": "vstd::tokens::map",
        "keywords": [
          "Set"
        ]
      },
      "vstd::tokens::map::spec_index": {
        "name": "vstd::tokens::map::spec_index",
        "signature": "pub open spec fn spec_index(self, key: K) -> V\n        recommends\n            self.dom().contains(key),",
        "body": "{\n        self@[key]\n    }",
        "file_path": "verus/source/vstd/tokens/map.rs",
        "line_number": 313,
        "module": "vstd::tokens::map",
        "keywords": [
          "contains"
        ]
      },
      "seq_to_map": {
        "name": "seq_to_map",
        "signature": "pub open spec fn seq_to_map<V>(s: Seq<V>, off: int) -> Map<int, V>",
        "body": "{\n    Map::new(|i: int| off <= i < off + s.len(), |i: int| s[i - off])\n}",
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 9,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Map",
          "Seq"
        ]
      },
      "vstd::tokens::seq::len": {
        "name": "vstd::tokens::seq::len",
        "signature": "pub open spec fn len(self) -> nat",
        "body": "{\n        self@.len()\n    }",
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 184,
        "module": "vstd::tokens::seq",
        "keywords": [
          "len"
        ]
      },
      "vstd::tokens::seq::spec_index": {
        "name": "vstd::tokens::seq::spec_index",
        "signature": "pub open spec fn spec_index(self, idx: int) -> V\n        recommends\n            0 <= idx < self.len(),",
        "body": "{\n        self@[idx]\n    }",
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 188,
        "module": "vstd::tokens::seq",
        "keywords": [
          "len"
        ]
      },
      "subrange_abs": {
        "name": "subrange_abs",
        "signature": "pub open spec fn subrange_abs(self, start_inclusive: int, end_exclusive: int) -> Seq<V>\n        recommends\n            self.off() <= start_inclusive <= end_exclusive <= self.off() + self@.len(),",
        "body": "{\n        self@.subrange(start_inclusive - self.off(), end_exclusive - self.off())\n    }",
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 105,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Seq",
          "len"
        ]
      },
      "vstd::tokens::seq::subrange_abs": {
        "name": "vstd::tokens::seq::subrange_abs",
        "signature": "pub open spec fn subrange_abs(self, start_inclusive: int, end_exclusive: int) -> Seq<V>\n        recommends\n            self.off() <= start_inclusive <= end_exclusive <= self.off() + self@.len(),",
        "body": "{\n        self@.subrange(start_inclusive - self.off(), end_exclusive - self.off())\n    }",
        "file_path": "verus/source/vstd/tokens/seq.rs",
        "line_number": 195,
        "module": "vstd::tokens::seq",
        "keywords": [
          "Seq",
          "len"
        ]
      },
      "vstd::tokens::dom": {
        "name": "vstd::tokens::dom",
        "signature": "pub open spec fn dom(self) -> Set<Key>",
        "body": "{\n        self.map().dom()\n    }",
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 279,
        "module": "vstd::tokens",
        "keywords": [
          "Set"
        ]
      },
      "vstd::tokens::spec_index": {
        "name": "vstd::tokens::spec_index",
        "signature": "pub open spec fn spec_index(self, k: Key) -> Value",
        "body": "{\n        self.map()[k]\n    }",
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 284,
        "module": "vstd::tokens",
        "keywords": []
      },
      "index": {
        "name": "index",
        "signature": "pub open spec fn index(self, k: Key) -> Value",
        "body": "{\n        self.map()[k]\n    }",
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 289,
        "module": "vstd::tokens",
        "keywords": []
      },
      "vstd::tokens::contains": {
        "name": "vstd::tokens::contains",
        "signature": "pub open spec fn contains(self, element: Element) -> bool",
        "body": "{\n        self.set().contains(element)\n    }",
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 392,
        "module": "vstd::tokens",
        "keywords": [
          "contains"
        ]
      },
      "option_value_eq_option_token": {
        "name": "option_value_eq_option_token",
        "signature": "pub open spec fn option_value_eq_option_token<Value, Token: ValueToken<Value>>(\n    opt_value: Option<Value>,\n    opt_token: Option<Token>,\n    instance_id: InstanceId,\n) -> bool",
        "body": "{\n    match opt_value {\n        Some(val) => opt_token.is_some()\n            && opt_token.unwrap().value() == val\n            && opt_token.unwrap().instance_id() == instance_id,\n        None => opt_token.is_none(),\n    }\n}",
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 588,
        "module": "vstd::tokens",
        "keywords": []
      },
      "option_value_le_option_token": {
        "name": "option_value_le_option_token",
        "signature": "pub open spec fn option_value_le_option_token<Value, Token: ValueToken<Value>>(\n    opt_value: Option<Value>,\n    opt_token: Option<Token>,\n    instance_id: InstanceId,\n) -> bool",
        "body": "{\n    match opt_value {\n        Some(val) => opt_token.is_some()\n            && opt_token.unwrap().value() == val\n            && opt_token.unwrap().instance_id() == instance_id,\n        None => true,\n    }\n}",
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 601,
        "module": "vstd::tokens",
        "keywords": []
      },
      "bool_value_eq_option_token": {
        "name": "bool_value_eq_option_token",
        "signature": "pub open spec fn bool_value_eq_option_token<Token: SimpleToken>(\n    b: bool,\n    opt_token: Option<Token>,\n    instance_id: InstanceId,\n) -> bool",
        "body": "{\n    if b {\n        opt_token.is_some() && opt_token.unwrap().instance_id() == instance_id\n    } else {\n        opt_token.is_none()\n    }\n}",
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 614,
        "module": "vstd::tokens",
        "keywords": []
      },
      "bool_value_le_option_token": {
        "name": "bool_value_le_option_token",
        "signature": "pub open spec fn bool_value_le_option_token<Token: SimpleToken>(\n    b: bool,\n    opt_token: Option<Token>,\n    instance_id: InstanceId,\n) -> bool",
        "body": "{\n    b ==>\n        opt_token.is_some() && opt_token.unwrap().instance_id() == instance_id\n}",
        "file_path": "verus/source/vstd/tokens.rs",
        "line_number": 626,
        "module": "vstd::tokens",
        "keywords": []
      }
    },
    "by_module": {
      "vstd::arithmetic::div_mod": {
        "functions": [
          "lemma_div_is_div_recursive",
          "lemma_div_by_self",
          "lemma_div_of0",
          "lemma_div_basics",
          "lemma_div_basics_1",
          "lemma_div_basics_2",
          "lemma_div_basics_3",
          "lemma_div_basics_4",
          "lemma_div_basics_5",
          "lemma_small_div_converse",
          "lemma_div_non_zero",
          "lemma_div_is_ordered_by_denominator",
          "lemma_div_is_strictly_smaller",
          "lemma_dividing_sums",
          "lemma_div_pos_is_pos",
          "lemma_div_plus_one",
          "lemma_div_minus_one",
          "lemma_basic_div_specific_divisor",
          "lemma_basic_div",
          "lemma_div_is_ordered",
          "lemma_div_decreases",
          "lemma_div_nonincreasing",
          "lemma_small_mod",
          "lemma_breakdown",
          "lemma_remainder_upper",
          "lemma_remainder_lower",
          "lemma_remainder",
          "lemma_fundamental_div_mod",
          "lemma_div_denominator",
          "lemma_mul_hoist_inequality",
          "lemma_indistinguishable_quotients",
          "lemma_truncate_middle",
          "lemma_div_multiples_vanish_quotient",
          "lemma_round_down",
          "lemma_div_multiples_vanish_fancy",
          "lemma_div_multiples_vanish",
          "lemma_div_by_multiple",
          "lemma_div_by_multiple_is_strongly_ordered",
          "lemma_multiply_divide_le",
          "lemma_multiply_divide_lt",
          "lemma_hoist_over_denominator",
          "lemma_part_bound1",
          "lemma_mod_is_mod_recursive",
          "lemma_mod_self_0",
          "lemma_mod_twice",
          "lemma_mod_division_less_than_divisor",
          "lemma_mod_decreases",
          "lemma_mod_is_zero",
          "lemma_mod_multiples_basic",
          "lemma_mod_add_multiples_vanish",
          "lemma_mod_sub_multiples_vanish",
          "lemma_mod_multiples_vanish",
          "lemma_mod_subtraction",
          "lemma_add_mod_noop",
          "lemma_add_mod_noop_right",
          "lemma_sub_mod_noop",
          "lemma_sub_mod_noop_right",
          "lemma_mod_adds",
          "lemma_mod_neg_neg",
          "lemma_fundamental_div_mod_converse_mod",
          "lemma_fundamental_div_mod_converse_div",
          "lemma_fundamental_div_mod_converse",
          "lemma_mod_pos_bound",
          "lemma_mod_bound",
          "lemma_mul_mod_noop_left",
          "lemma_mul_mod_noop_right",
          "lemma_mul_mod_noop_general",
          "lemma_mul_mod_noop",
          "lemma_mod_equivalence",
          "lemma_mod_mul_equivalent",
          "lemma_mod_ordering",
          "lemma_mod_mod",
          "lemma_part_bound2",
          "lemma_mod_breakdown"
        ],
        "open_specs": [
          "is_mod_equivalent"
        ]
      },
      "vstd::arithmetic::internals::div_internals": {
        "functions": [
          "lemma_div_basics",
          "lemma_div_auto",
          "lemma_div_induction_auto",
          "lemma_div_induction_auto_forall"
        ],
        "open_specs": [
          "div_pos",
          "div_recursive",
          "div_auto_plus",
          "div_auto_minus",
          "div_auto"
        ]
      },
      "vstd::arithmetic::internals::div_internals_nonlinear": {
        "functions": [
          "lemma_div_of0",
          "lemma_div_by_self",
          "lemma_small_div"
        ],
        "open_specs": []
      },
      "vstd::arithmetic::internals::general_internals": {
        "functions": [
          "lemma_induction_helper"
        ],
        "open_specs": [
          "is_le"
        ]
      },
      "vstd::arithmetic::internals::mod_internals": {
        "functions": [
          "lemma_mod_induction_forall",
          "lemma_mod_induction_forall2",
          "lemma_div_add_denominator",
          "lemma_div_sub_denominator",
          "lemma_mod_add_denominator",
          "lemma_mod_sub_denominator",
          "lemma_mod_below_denominator",
          "lemma_mod_basics",
          "lemma_quotient_and_remainder",
          "lemma_mod_auto",
          "lemma_mod_induction_auto",
          "lemma_mod_induction_auto_forall"
        ],
        "open_specs": [
          "mod_recursive",
          "mod_auto_plus",
          "mod_auto_minus",
          "mod_auto"
        ]
      },
      "vstd::arithmetic::internals::mod_internals_nonlinear": {
        "functions": [
          "lemma_fundamental_div_mod",
          "lemma_small_mod",
          "lemma_mod_range"
        ],
        "open_specs": [
          "modulus"
        ]
      },
      "vstd::arithmetic::internals::mul_internals": {
        "functions": [
          "lemma_mul_induction",
          "lemma_mul_commutes",
          "lemma_mul_distributes_plus",
          "lemma_mul_distributes_minus",
          "lemma_mul_induction_auto",
          "lemma_mul_induction_auto_forall"
        ],
        "open_specs": [
          "mul_pos",
          "mul_recursive",
          "mul_auto"
        ]
      },
      "vstd::arithmetic::internals::mul_internals_nonlinear": {
        "functions": [
          "lemma_mul_strictly_positive",
          "lemma_mul_nonzero",
          "lemma_mul_is_associative",
          "lemma_mul_is_distributive_add",
          "lemma_mul_ordering",
          "lemma_mul_strict_inequality"
        ],
        "open_specs": []
      },
      "vstd::arithmetic::logarithm": {
        "functions": [
          "lemma_log0",
          "lemma_log_s",
          "lemma_log_nonnegative",
          "lemma_log_is_ordered",
          "lemma_log_pow"
        ],
        "open_specs": [
          "log"
        ]
      },
      "vstd::arithmetic::mul": {
        "functions": [
          "lemma_mul_is_mul_recursive",
          "lemma_mul_is_mul_pos",
          "lemma_mul_basics",
          "lemma_mul_basics_1",
          "lemma_mul_basics_2",
          "lemma_mul_basics_3",
          "lemma_mul_basics_4",
          "lemma_mul_nonzero",
          "lemma_mul_by_zero_is_zero",
          "lemma_mul_is_associative",
          "lemma_mul_is_commutative",
          "lemma_mul_ordering",
          "lemma_mul_inequality",
          "lemma_mul_strict_inequality",
          "lemma_mul_upper_bound",
          "lemma_mul_strict_upper_bound",
          "lemma_mul_left_inequality",
          "lemma_mul_equality_converse",
          "lemma_mul_inequality_converse",
          "lemma_mul_strict_inequality_converse",
          "lemma_mul_is_distributive_add",
          "lemma_mul_is_distributive_add_other_way",
          "lemma_mul_is_distributive_sub",
          "lemma_mul_is_distributive_sub_other_way",
          "lemma_mul_strictly_positive",
          "lemma_mul_strictly_increases",
          "lemma_mul_increases",
          "lemma_mul_nonnegative",
          "lemma_mul_unary_negation",
          "lemma_mul_cancels_negatives"
        ],
        "open_specs": []
      },
      "vstd::arithmetic::overflow": {
        "functions": [
          "spec_new",
          "new",
          "new_overflowed",
          "is_overflowed",
          "unwrap",
          "to_option",
          "add_value",
          "add_checked",
          "mul_value",
          "mul_checked"
        ],
        "open_specs": [
          "spec_is_overflowed"
        ]
      },
      "vstd::arithmetic::power": {
        "functions": [
          "lemma_pow0",
          "lemma_pow1",
          "lemma0_pow",
          "lemma1_pow",
          "lemma_square_is_pow2",
          "lemma_pow_positive",
          "lemma_pow_adds",
          "lemma_pow_sub_add_cancel",
          "lemma_pow_subtracts",
          "lemma_pow_multiplies",
          "lemma_pow_distributes",
          "lemma_pow_strictly_increases",
          "lemma_pow_increases",
          "lemma_pow_strictly_increases_converse",
          "lemma_pow_increases_converse",
          "lemma_pull_out_pows",
          "lemma_pow_division_inequality",
          "lemma_pow_mod",
          "lemma_pow_mod_noop"
        ],
        "open_specs": [
          "pow"
        ]
      },
      "vstd::arithmetic::power2": {
        "functions": [
          "lemma_pow2_pos",
          "lemma_pow2",
          "lemma_pow2_unfold",
          "lemma_pow2_adds",
          "lemma_pow2_subtracts",
          "lemma_pow2_strictly_increases",
          "lemma2_to64",
          "lemma2_to64_rest"
        ],
        "open_specs": [
          "pow2"
        ]
      },
      "vstd::array": {
        "functions": [
          "lemma_array_index",
          "array_index_get",
          "array_len_matches_n",
          "spec_array_as_slice",
          "axiom_spec_array_as_slice",
          "spec_array_fill_for_copy_type",
          "axiom_spec_array_fill_for_copy_type",
          "axiom_array_ext_equal"
        ],
        "open_specs": [
          "array_view"
        ]
      },
      "vstd::atomic": {
        "functions": [
          "view",
          "view",
          "id"
        ],
        "open_specs": [
          "is_for",
          "points_to",
          "value",
          "id",
          "is_for",
          "points_to",
          "value",
          "id"
        ]
      },
      "vstd::atomic_ghost": {
        "functions": [],
        "open_specs": [
          "well_formed",
          "constant",
          "well_formed",
          "constant"
        ]
      },
      "vstd::bits": {
        "functions": [
          "lemma_low_bits_mask_unfold",
          "lemma_low_bits_mask_is_odd",
          "lemma_low_bits_mask_div2",
          "lemma_low_bits_mask_values"
        ],
        "open_specs": [
          "low_bits_mask"
        ]
      },
      "vstd::bytes": {
        "functions": [
          "spec_u16_to_le_bytes",
          "spec_u16_from_le_bytes",
          "lemma_auto_spec_u16_to_from_le_bytes",
          "u16_from_le_bytes",
          "u16_to_le_bytes",
          "spec_u32_to_le_bytes",
          "spec_u32_from_le_bytes",
          "lemma_auto_spec_u32_to_from_le_bytes",
          "u32_from_le_bytes",
          "u32_to_le_bytes",
          "spec_u64_to_le_bytes",
          "spec_u64_from_le_bytes",
          "lemma_auto_spec_u64_to_from_le_bytes",
          "spec_u64_to_le_bytes_to_open",
          "u64_from_le_bytes",
          "u64_to_le_bytes",
          "spec_u128_to_le_bytes",
          "spec_u128_from_le_bytes",
          "lemma_auto_spec_u128_to_from_le_bytes",
          "u128_from_le_bytes",
          "u128_to_le_bytes"
        ],
        "open_specs": [
          "spec_u64_to_le_bytes_open"
        ]
      },
      "vstd::cell": {
        "functions": [
          "id",
          "mem_contents",
          "id",
          "inv"
        ],
        "open_specs": [
          "option_from_mem_contents",
          "view",
          "opt_value",
          "is_init",
          "is_uninit",
          "value"
        ]
      },
      "vstd::compute": {
        "functions": [
          "all_spec_ensures"
        ],
        "open_specs": [
          "range_all_spec_rec"
        ]
      },
      "vstd::function": {
        "functions": [
          "axiom_proof_fn_requires",
          "axiom_proof_fn_ensures",
          "proof_fn_as_req_ens"
        ],
        "open_specs": []
      },
      "vstd::hash_map": {
        "functions": [
          "spec_len",
          "axiom_hash_map_with_view_spec_len",
          "spec_len",
          "axiom_string_hash_map_spec_len"
        ],
        "open_specs": []
      },
      "vstd::hash_set": {
        "functions": [
          "spec_len",
          "axiom_hash_set_with_view_spec_len",
          "spec_len",
          "axiom_string_hash_set_spec_len"
        ],
        "open_specs": []
      },
      "vstd::invariant": {
        "functions": [
          "constant",
          "namespace",
          "new",
          "into_inner",
          "spend_open_invariant_credit_in_proof"
        ],
        "open_specs": [
          "inv"
        ]
      },
      "vstd::laws_cmp": {
        "functions": [
          "lemma_obeys_cmp_spec",
          "lemma_option_obeys_cmp_spec"
        ],
        "open_specs": [
          "obeys_partial_cmp_spec_properties",
          "obeys_cmp_partial_ord",
          "obeys_cmp_ord",
          "obeys_cmp_spec"
        ]
      },
      "vstd::laws_eq": {
        "functions": [
          "axiom_structural_obeys_concrete_eq",
          "lemma_obeys_eq_spec",
          "lemma_obeys_concrete_eq",
          "lemma_obeys_view_eq",
          "lemma_obeys_deep_eq",
          "lemma_option_obeys_eq_spec",
          "lemma_option_obeys_concrete_eq",
          "lemma_option_obeys_view_eq",
          "lemma_option_obeys_deep_eq"
        ],
        "open_specs": [
          "obeys_eq_spec_properties",
          "obeys_eq_spec",
          "obeys_concrete_eq",
          "obeys_view_eq",
          "obeys_deep_eq"
        ]
      },
      "vstd::layout": {
        "functions": [
          "is_sized",
          "size_of",
          "align_of",
          "layout_for_type_is_valid",
          "layout_of_primitives",
          "layout_of_unit_tuple",
          "layout_of_references_and_pointers",
          "layout_of_references_and_pointers_for_sized_types"
        ],
        "open_specs": [
          "is_power_2",
          "valid_layout",
          "size_of_as_usize",
          "align_of_as_usize"
        ]
      },
      "vstd::map": {
        "functions": [
          "empty",
          "dom",
          "index",
          "insert",
          "remove",
          "tracked_empty",
          "tracked_insert",
          "tracked_remove",
          "tracked_borrow",
          "tracked_map_keys",
          "tracked_remove_keys",
          "tracked_union_prefer_right",
          "axiom_map_index_decreases",
          "axiom_map_index_decreases_finite",
          "axiom_map_index_decreases_infinite",
          "axiom_map_empty",
          "axiom_map_insert_domain",
          "axiom_map_insert_same",
          "axiom_map_insert_different",
          "axiom_map_remove_domain",
          "axiom_map_remove_different",
          "axiom_map_ext_equal",
          "axiom_map_ext_equal_deep",
          "tracked_map_keys_in_place"
        ],
        "open_specs": [
          "total",
          "new",
          "spec_index",
          "len",
          "check_argument_is_map"
        ]
      },
      "vstd::map_lib": {
        "functions": [
          "lemma_remove_key_len",
          "lemma_remove_equivalency",
          "lemma_remove_keys_len",
          "lemma_invert_is_injective",
          "lemma_union_insert_left",
          "lemma_union_insert_right",
          "lemma_union_remove_left",
          "lemma_union_remove_right",
          "lemma_union_dom",
          "lemma_disjoint_union_size",
          "lemma_submap_of_trans",
          "lemma_map_new_domain",
          "lemma_map_new_values",
          "lemma_map_properties",
          "lemma_values_finite"
        ],
        "open_specs": [
          "is_full",
          "is_empty",
          "contains_key",
          "contains_value",
          "index_opt",
          "values",
          "kv_pairs",
          "contains_pair",
          "submap_of",
          "spec_le",
          "union_prefer_right",
          "remove_keys",
          "restrict",
          "is_equal_on_key",
          "agrees",
          "map_entries",
          "map_values",
          "is_injective",
          "invert",
          "filter_keys",
          "get",
          "prefixed_entries",
          "is_monotonic",
          "is_monotonic_from"
        ]
      },
      "vstd::math": {
        "functions": [],
        "open_specs": [
          "min",
          "max",
          "max3",
          "clip",
          "abs",
          "add",
          "sub",
          "div"
        ]
      },
      "vstd::modes": {
        "functions": [
          "tracked_swap",
          "tracked_static_ref"
        ],
        "open_specs": []
      },
      "vstd::multiset": {
        "functions": [
          "count",
          "len",
          "empty",
          "from_map",
          "singleton",
          "add",
          "sub",
          "filter",
          "axiom_multiset_empty",
          "lemma_multiset_empty_len",
          "axiom_multiset_contained",
          "axiom_multiset_new_not_contained",
          "axiom_multiset_singleton",
          "axiom_multiset_singleton_different",
          "axiom_multiset_add",
          "axiom_multiset_sub",
          "axiom_multiset_ext_equal",
          "axiom_multiset_ext_equal_deep",
          "axiom_len_empty",
          "axiom_len_singleton",
          "axiom_len_add",
          "axiom_len_sub",
          "axiom_count_le_len",
          "axiom_filter_count",
          "axiom_choose_count",
          "axiom_multiset_always_finite",
          "lemma_update_same",
          "lemma_update_different",
          "lemma_insert_containment",
          "lemma_insert_increases_count_by_1",
          "lemma_insert_non_decreasing",
          "lemma_insert_other_elements_unchanged",
          "lemma_insert_len",
          "lemma_intersection_count",
          "lemma_left_pseudo_idempotence",
          "lemma_right_pseudo_idempotence",
          "lemma_difference_count",
          "lemma_difference_bottoms_out",
          "lemma_multiset_properties"
        ],
        "open_specs": [
          "from_set",
          "insert",
          "remove",
          "update",
          "subset_of",
          "spec_le",
          "choose",
          "contains",
          "spec_has",
          "intersection_with",
          "difference_with",
          "is_disjoint_from",
          "dom"
        ]
      },
      "vstd::multiset_lib": {
        "functions": [
          "lemma_is_singleton_contains_elem_equal_singleton",
          "lemma_singleton_size",
          "lemma_is_singleton"
        ],
        "open_specs": [
          "is_empty",
          "is_singleton"
        ]
      },
      "vstd::pcm": {
        "functions": [
          "value",
          "loc",
          "alloc",
          "join",
          "split",
          "create_unit",
          "validate",
          "update",
          "update_nondeterministic",
          "join_shared",
          "join_shared_to_target",
          "weaken",
          "validate_2",
          "update_with_shared",
          "update_nondeterministic_with_shared"
        ],
        "open_specs": [
          "incl",
          "conjunct_shared",
          "frame_preserving_update",
          "frame_preserving_update_nondeterministic",
          "set_op"
        ]
      },
      "vstd::pcm_lib": {
        "functions": [
          "lemma_pcm_properties",
          "copy_duplicable_part",
          "duplicate",
          "incorporate",
          "split_mut",
          "extract",
          "update_mut",
          "redistribute",
          "update_and_redistribute",
          "validate_3",
          "validate_multiple",
          "validate_4",
          "validate_5"
        ],
        "open_specs": [
          "combine_values"
        ]
      },
      "vstd::pervasive": {
        "functions": [
          "assume",
          "assert",
          "affirm",
          "arbitrary",
          "proof_from_false"
        ],
        "open_specs": [
          "trigger",
          "strictly_cloned",
          "cloned",
          "allow_panic"
        ]
      },
      "vstd::proph": {
        "functions": [
          "view",
          "new",
          "resolve"
        ],
        "open_specs": []
      },
      "vstd::raw_ptr": {
        "functions": [
          "null",
          "is_nonnull",
          "leak_contents",
          "is_disjoint",
          "ptr_mut_from_data",
          "axiom_ptr_mut_from_data",
          "view_reverse_for_eq",
          "ptrs_mut_eq",
          "view_reverse_for_eq_sized",
          "ptrs_mut_eq_sized",
          "provenance",
          "null",
          "provenance",
          "dom",
          "empty",
          "split",
          "join",
          "into_typed",
          "into_raw",
          "view",
          "value",
          "ptr",
          "points_to"
        ],
        "open_specs": [
          "ptr",
          "opt_value",
          "is_init",
          "is_uninit",
          "value",
          "is_init",
          "is_uninit",
          "value",
          "ptr_from_data",
          "ptr_null",
          "ptr_null_mut",
          "spec_cast_ptr_to_thin_ptr",
          "spec_cast_array_ptr_to_slice_ptr",
          "spec_cast_ptr_to_usize",
          "spec_addr",
          "spec_with_addr",
          "view",
          "is_range",
          "contains_range",
          "addr",
          "size",
          "align",
          "provenance"
        ]
      },
      "vstd::relations": {
        "functions": [
          "lemma_new_first_element_still_sorted_by"
        ],
        "open_specs": [
          "injective",
          "commutative",
          "associative",
          "reflexive",
          "irreflexive",
          "antisymmetric",
          "asymmetric",
          "symmetric",
          "connected",
          "strongly_connected",
          "transitive",
          "total_ordering",
          "strict_total_ordering",
          "pre_ordering",
          "partial_ordering",
          "equivalence_relation",
          "sorted_by",
          "is_least",
          "is_minimal",
          "is_greatest",
          "is_maximal"
        ]
      },
      "vstd::rwlock": {
        "functions": [
          "rwlock",
          "view",
          "rwlock",
          "lemma_readers_match",
          "pred"
        ],
        "open_specs": [
          "inv"
        ]
      },
      "vstd::seq": {
        "functions": [
          "empty",
          "new",
          "len",
          "index",
          "tracked_empty",
          "tracked_remove",
          "tracked_insert",
          "tracked_borrow",
          "tracked_push",
          "tracked_pop",
          "tracked_pop_front",
          "axiom_seq_index_decreases",
          "axiom_seq_len_decreases",
          "axiom_seq_subrange_decreases",
          "axiom_seq_empty",
          "axiom_seq_new_len",
          "axiom_seq_new_index",
          "axiom_seq_push_len",
          "axiom_seq_push_index_same",
          "axiom_seq_push_index_different",
          "axiom_seq_update_len",
          "axiom_seq_update_same",
          "axiom_seq_update_different",
          "axiom_seq_ext_equal",
          "axiom_seq_ext_equal_deep",
          "axiom_seq_subrange_len",
          "axiom_seq_subrange_index",
          "axiom_seq_add_len",
          "axiom_seq_add_index1",
          "axiom_seq_add_index2"
        ],
        "open_specs": [
          "spec_index",
          "take",
          "skip",
          "spec_add",
          "last",
          "first"
        ]
      },
      "vstd::seq_lib": {
        "functions": [
          "lemma_sort_by_ensures",
          "lemma_filter_len",
          "lemma_filter_pred",
          "lemma_filter_contains",
          "filter_lemma",
          "filter_distributes_over_add",
          "add_empty_left",
          "add_empty_right",
          "push_distributes_over_add",
          "index_of_first",
          "index_of_first_ensures",
          "index_of_last",
          "index_of_last_ensures",
          "drop_last_distributes_over_add",
          "to_multiset",
          "to_multiset_ensures",
          "insert_ensures",
          "remove_ensures",
          "lemma_fold_left_split",
          "lemma_fold_left_alt",
          "lemma_reverse_fold_left",
          "lemma_fold_right_split",
          "lemma_fold_right_commute_one",
          "lemma_fold_right_alt",
          "lemma_reverse_fold_right",
          "lemma_multiset_has_no_duplicates",
          "lemma_multiset_has_no_duplicates_conv",
          "lemma_reverse_to_multiset",
          "lemma_add_last_back",
          "lemma_indexing_implies_membership",
          "lemma_membership_implies_indexing",
          "lemma_split_at",
          "lemma_element_from_slice",
          "lemma_slice_of_slice",
          "unique_seq_to_set",
          "lemma_cardinality_of_set",
          "lemma_cardinality_of_empty_set_is_0",
          "lemma_no_dup_set_cardinality",
          "lemma_to_set_map_commutes",
          "lemma_to_set_insert_commutes",
          "lemma_filter_contains_rev",
          "lemma_filter_map_contains",
          "lemma_take_succ",
          "lemma_filter_map_singleton",
          "lemma_filter_eq_filter_alt",
          "lemma_index_contains",
          "lemma_take_succ_push",
          "lemma_take_len",
          "lemma_flat_map_singleton",
          "lemma_prefix_append_unique",
          "lemma_concat_injective",
          "unzip",
          "unzip_ensures",
          "lemma_zip_of_unzip",
          "lemma_flatten_one_element",
          "lemma_flatten_length_ge_single_element_length",
          "lemma_flatten_length_le_mul",
          "lemma_flatten_and_flatten_alt_are_equivalent",
          "lemma_flatten_push",
          "lemma_flatten_singleton",
          "max_ensures",
          "min_ensures",
          "sort",
          "lemma_sort_ensures",
          "lemma_subrange_max",
          "lemma_subrange_min",
          "lemma_max_of_concat",
          "lemma_min_of_concat",
          "to_multiset_build",
          "to_multiset_remove",
          "to_multiset_insert",
          "to_multiset_len",
          "to_multiset_contains",
          "to_multiset_update",
          "lemma_update_is_remove_insert",
          "lemma_append_last",
          "lemma_concat_associative",
          "seq_to_set_is_finite",
          "seq_to_set_distributes_over_add",
          "lemma_no_dup_in_concat",
          "lemma_flatten_concat",
          "lemma_flatten_alt_concat",
          "lemma_seq_union_to_multiset_commutative",
          "lemma_multiset_commutative",
          "lemma_sorted_unique",
          "lemma_seq_contains",
          "lemma_seq_empty_contains_nothing",
          "lemma_seq_empty_equality",
          "lemma_seq_concat_contains_all_elements",
          "lemma_seq_contains_after_push",
          "lemma_seq_subrange_elements",
          "lemma_fold_right_permutation",
          "lemma_fold_left_permutation",
          "lemma_seq_take_len",
          "lemma_seq_take_contains",
          "lemma_seq_take_index",
          "subrange_of_matching_take",
          "lemma_seq_skip_len",
          "lemma_seq_skip_contains",
          "lemma_seq_skip_index",
          "lemma_seq_skip_index2",
          "lemma_seq_append_take_skip",
          "lemma_seq_take_update_commut1",
          "lemma_seq_take_update_commut2",
          "lemma_seq_skip_update_commut1",
          "lemma_seq_skip_update_commut2",
          "lemma_seq_skip_build_commut",
          "lemma_seq_skip_nothing",
          "lemma_seq_take_nothing",
          "lemma_seq_skip_of_skip",
          "lemma_seq_properties"
        ],
        "open_specs": [
          "map",
          "map_values",
          "flat_map",
          "is_prefix_of",
          "is_suffix_of",
          "all",
          "any",
          "exactly_one",
          "filter",
          "max_via",
          "min_via",
          "contains",
          "index_of",
          "drop_last",
          "drop_first",
          "no_duplicates",
          "disjoint",
          "to_set",
          "insert",
          "remove",
          "remove_value",
          "reverse",
          "zip_with",
          "fold_left",
          "fold_left_alt",
          "fold_right",
          "fold_right_alt",
          "update_subrange_with",
          "remove_duplicates",
          "filter_map",
          "filter_alt",
          "flatten",
          "flatten_alt",
          "max",
          "min",
          "commutative_foldr",
          "commutative_foldl",
          "check_argument_is_seq"
        ]
      },
      "vstd::set": {
        "functions": [
          "empty",
          "new",
          "contains",
          "insert",
          "remove",
          "union",
          "intersect",
          "difference",
          "complement",
          "finite",
          "len",
          "mk_map",
          "lemma_finite_set_induct",
          "lemma_fold_insert",
          "lemma_fold_empty",
          "axiom_set_empty",
          "axiom_set_new",
          "axiom_set_insert_same",
          "axiom_set_insert_different",
          "axiom_set_remove_same",
          "axiom_set_remove_insert",
          "axiom_set_remove_different",
          "axiom_set_union",
          "axiom_set_intersect",
          "axiom_set_difference",
          "axiom_set_complement",
          "axiom_set_ext_equal",
          "axiom_set_ext_equal_deep",
          "axiom_mk_map_domain",
          "axiom_mk_map_index",
          "axiom_set_empty_finite",
          "axiom_set_insert_finite",
          "axiom_set_remove_finite",
          "axiom_set_union_finite",
          "axiom_set_intersect_finite",
          "axiom_set_difference_finite",
          "axiom_set_choose_infinite",
          "axiom_set_empty_len",
          "axiom_set_insert_len",
          "axiom_set_remove_len",
          "axiom_set_contains_len",
          "axiom_set_choose_len"
        ],
        "open_specs": [
          "full",
          "spec_has",
          "subset_of",
          "spec_le",
          "spec_add",
          "spec_mul",
          "spec_sub",
          "filter",
          "choose",
          "disjoint",
          "is_fun_commutative"
        ]
      },
      "vstd::set_lib": {
        "functions": [
          "find_unique_minimal",
          "find_unique_minimal_ensures",
          "find_unique_maximal",
          "find_unique_maximal_ensures",
          "lemma_len0_is_empty",
          "lemma_singleton_size",
          "lemma_is_singleton",
          "lemma_len_filter",
          "lemma_greatest_implies_maximal",
          "lemma_least_implies_minimal",
          "lemma_maximal_equivalent_greatest",
          "lemma_minimal_equivalent_least",
          "lemma_least_is_unique",
          "lemma_greatest_is_unique",
          "lemma_minimal_is_unique",
          "lemma_maximal_is_unique",
          "lemma_set_insert_diff_decreases",
          "lemma_subset_not_in_lt",
          "lemma_set_map_insert_commute",
          "lemma_map_union_commute",
          "lemma_any_map_preserved_pred",
          "lemma_filter_map_insert",
          "lemma_filter_map_union",
          "lemma_map_finite",
          "lemma_set_all_subset",
          "lemma_filter_map_finite",
          "lemma_to_seq_to_set_id",
          "flatten_insert_union_commute",
          "lemma_sets_eq_iff_injective_map_eq",
          "lemma_set_insert_finite_iff",
          "lemma_set_remove_finite_iff",
          "lemma_set_union_finite_iff",
          "lemma_set_union_finite_implies_sets_finite",
          "lemma_len_union",
          "lemma_len_union_ind",
          "lemma_len_intersect",
          "lemma_len_subset",
          "lemma_set_subset_finite",
          "lemma_len_difference",
          "lemma_int_range",
          "lemma_subset_equality",
          "lemma_map_size",
          "lemma_set_union_again1",
          "lemma_set_union_again2",
          "lemma_set_intersect_again1",
          "lemma_set_intersect_again2",
          "lemma_set_difference2",
          "lemma_set_disjoint",
          "lemma_set_empty_equivalency_len",
          "lemma_set_disjoint_lens",
          "lemma_set_intersect_union_lens",
          "lemma_set_difference_len",
          "lemma_set_properties",
          "axiom_is_empty",
          "axiom_is_empty_len0"
        ],
        "open_specs": [
          "is_full",
          "is_empty",
          "map",
          "to_seq",
          "to_sorted_seq",
          "is_singleton",
          "to_multiset",
          "all",
          "any",
          "filter_map",
          "flatten",
          "set_int_range",
          "check_argument_is_set"
        ]
      },
      "vstd::shared": {
        "functions": [
          "view",
          "new",
          "clone",
          "borrow"
        ],
        "open_specs": []
      },
      "vstd::simple_pptr": {
        "functions": [
          "addr",
          "mem_contents",
          "is_nonnull",
          "leak_contents",
          "is_disjoint",
          "is_distinct"
        ],
        "open_specs": [
          "spec_addr",
          "pptr",
          "opt_value",
          "is_init",
          "is_uninit",
          "value"
        ]
      },
      "vstd::slice": {
        "functions": [
          "slice_index_get",
          "spec_slice_len",
          "axiom_spec_len",
          "slice_to_vec",
          "slice_subrange",
          "spec_slice_get",
          "axiom_slice_get_usize",
          "axiom_slice_ext_equal"
        ],
        "open_specs": []
      },
      "vstd::state_machine_internal": {
        "functions": [],
        "open_specs": [
          "nat_max",
          "update_at_index",
          "update_at_index",
          "opt_is_none",
          "opt_ge",
          "opt_add",
          "opt_agree",
          "opt_sub"
        ]
      },
      "vstd::std_specs::bits": {
        "functions": [
          "u8_trailing_zeros",
          "u8_leading_zeros",
          "axiom_u8_trailing_zeros",
          "axiom_u8_trailing_ones",
          "axiom_u8_leading_zeros",
          "axiom_u8_leading_ones",
          "u16_trailing_zeros",
          "u16_leading_zeros",
          "axiom_u16_trailing_zeros",
          "axiom_u16_trailing_ones",
          "axiom_u16_leading_zeros",
          "axiom_u16_leading_ones",
          "u32_trailing_zeros",
          "u32_leading_zeros",
          "axiom_u32_trailing_zeros",
          "axiom_u32_trailing_ones",
          "axiom_u32_leading_zeros",
          "axiom_u32_leading_ones",
          "u64_trailing_zeros",
          "axiom_u64_trailing_zeros",
          "axiom_u64_trailing_ones",
          "axiom_u64_leading_zeros",
          "axiom_u64_leading_ones"
        ],
        "open_specs": [
          "u8_trailing_ones",
          "u8_leading_ones",
          "u16_trailing_ones",
          "u16_leading_ones",
          "u32_trailing_ones",
          "u32_leading_ones",
          "u64_leading_zeros",
          "u64_trailing_ones",
          "u64_leading_ones"
        ]
      },
      "vstd::std_specs::cmp": {
        "functions": [
          "eq_ensures",
          "ne_ensures",
          "partial_cmp_ensures",
          "lt_ensures",
          "le_ensures",
          "gt_ensures",
          "ge_ensures"
        ],
        "open_specs": []
      },
      "vstd::std_specs::control_flow": {
        "functions": [
          "spec_from",
          "spec_from_blanket_identity"
        ],
        "open_specs": []
      },
      "vstd::std_specs::core": {
        "functions": [],
        "open_specs": [
          "iter_into_iter_spec"
        ]
      },
      "vstd::std_specs::hash": {
        "functions": [
          "obeys_key_model",
          "axiom_bool_obeys_hash_table_key_model",
          "axiom_u8_obeys_hash_table_key_model",
          "axiom_u16_obeys_hash_table_key_model",
          "axiom_u32_obeys_hash_table_key_model",
          "axiom_u64_obeys_hash_table_key_model",
          "axiom_u128_obeys_hash_table_key_model",
          "axiom_usize_obeys_hash_table_key_model",
          "axiom_i8_obeys_hash_table_key_model",
          "axiom_i16_obeys_hash_table_key_model",
          "axiom_i32_obeys_hash_table_key_model",
          "axiom_i164_obeys_hash_table_key_model",
          "axiom_i128_obeys_hash_table_key_model",
          "axiom_isize_obeys_hash_table_key_model",
          "axiom_box_bool_obeys_hash_table_key_model",
          "axiom_box_integer_type_obeys_hash_table_key_model",
          "builds_valid_hashers",
          "axiom_random_state_builds_valid_hashers",
          "spec_hash_map_iter",
          "axiom_spec_hash_map_iter",
          "lemma_hashmap_deepview_dom",
          "lemma_hashmap_deepview_properties",
          "lemma_hashmap_deepview_values",
          "axiom_hashmap_deepview_borrow",
          "axiom_hashmap_view_finite_dom",
          "spec_hash_map_len",
          "axiom_spec_hash_map_len",
          "contains_borrowed_key",
          "axiom_contains_deref_key",
          "axiom_contains_box",
          "maps_borrowed_key_to_value",
          "axiom_maps_deref_key_to_value",
          "axiom_maps_box_key_to_value",
          "borrowed_key_removed",
          "axiom_deref_key_removed",
          "axiom_box_key_removed",
          "axiom_hashmap_decreases",
          "spec_hash_set_len",
          "axiom_spec_hash_set_len",
          "set_contains_borrowed_key",
          "axiom_set_contains_deref_key",
          "axiom_set_contains_box",
          "sets_borrowed_key_to_key",
          "axiom_set_deref_key_to_value",
          "axiom_set_box_key_to_value",
          "sets_differ_by_borrowed_key",
          "axiom_set_deref_key_removed",
          "axiom_set_box_key_removed",
          "axiom_hashset_decreases"
        ],
        "open_specs": [
          "hash_map_deep_view_impl"
        ]
      },
      "vstd::std_specs::num": {
        "functions": [],
        "open_specs": [
          "checked_div",
          "signed_crop"
        ]
      },
      "vstd::std_specs::ops": {
        "functions": [
          "neg_ensures",
          "add_ensures",
          "sub_ensures",
          "mul_ensures",
          "div_ensures"
        ],
        "open_specs": []
      },
      "vstd::std_specs::option": {
        "functions": [],
        "open_specs": [
          "is_some",
          "is_none",
          "spec_unwrap",
          "spec_unwrap_or",
          "spec_expect",
          "spec_ok_or"
        ]
      },
      "vstd::std_specs::range": {
        "functions": [
          "spec_range_next"
        ],
        "open_specs": []
      },
      "vstd::std_specs::result": {
        "functions": [],
        "open_specs": [
          "is_ok",
          "is_err",
          "spec_unwrap",
          "spec_unwrap_err",
          "spec_expect",
          "ok",
          "err"
        ]
      },
      "vstd::std_specs::slice": {
        "functions": [
          "spec_slice_iter",
          "axiom_spec_slice_iter"
        ],
        "open_specs": []
      },
      "vstd::std_specs::vec": {
        "functions": [
          "spec_vec_len",
          "axiom_spec_len",
          "vec_clone_deep_view_proof",
          "axiom_vec_index_decreases",
          "spec_into_iter",
          "axiom_spec_into_iter"
        ],
        "open_specs": [
          "vec_clone_trigger"
        ]
      },
      "vstd::std_specs::vecdeque": {
        "functions": [
          "spec_vec_dequeue_len",
          "axiom_spec_len",
          "axiom_vec_dequeue_index_decreases",
          "spec_iter",
          "axiom_spec_iter"
        ],
        "open_specs": [
          "vec_dequeue_clone_trigger"
        ]
      },
      "vstd::storage_protocol": {
        "functions": [
          "value",
          "loc",
          "alloc",
          "join",
          "split",
          "validate",
          "exchange",
          "deposit",
          "withdraw",
          "update",
          "exchange_nondeterministic",
          "guard",
          "join_shared",
          "weaken",
          "validate_with_shared",
          "exchange_with_shared",
          "exchange_nondeterministic_with_shared"
        ],
        "open_specs": [
          "incl",
          "guards",
          "exchanges",
          "exchanges_nondeterministic",
          "deposits",
          "withdraws",
          "updates",
          "set_op"
        ]
      },
      "vstd::string": {
        "functions": [
          "str_slice_is_ascii",
          "to_string_from_display_ensures",
          "to_string_from_display_ensures_for_str",
          "axiom_str_literal_is_ascii",
          "axiom_str_literal_len",
          "axiom_str_literal_get_char",
          "string_is_ascii"
        ],
        "open_specs": [
          "new_strlit_spec"
        ]
      },
      "vstd::thread": {
        "functions": [
          "predicate",
          "view",
          "agrees",
          "ghost_thread_id",
          "view",
          "id",
          "into",
          "borrow",
          "send_into",
          "sync_borrow"
        ],
        "open_specs": []
      },
      "vstd::tokens::frac": {
        "functions": [
          "id",
          "view",
          "frac",
          "new",
          "agree",
          "take",
          "split",
          "combine",
          "update",
          "update_with",
          "bounded",
          "dummy",
          "id",
          "view",
          "id",
          "view",
          "new",
          "agree",
          "update",
          "id",
          "resource",
          "frac",
          "new",
          "agree",
          "split",
          "combine",
          "bounded",
          "borrow",
          "take_resource",
          "id",
          "new",
          "put_resource"
        ],
        "open_specs": [
          "valid",
          "valid"
        ]
      },
      "vstd::tokens::map": {
        "functions": [
          "id",
          "view",
          "dummy",
          "take",
          "empty",
          "insert",
          "delete",
          "new",
          "id",
          "view",
          "dummy",
          "empty",
          "take",
          "agree",
          "combine",
          "disjoint",
          "split",
          "update"
        ],
        "open_specs": [
          "dom",
          "spec_index",
          "dom",
          "spec_index"
        ]
      },
      "vstd::tokens::seq": {
        "functions": [
          "id",
          "view",
          "off",
          "new",
          "dummy",
          "agree",
          "update_subrange_with",
          "view",
          "off",
          "id",
          "agree",
          "agree_map",
          "update",
          "update_map",
          "split",
          "combine",
          "disjoint",
          "dummy",
          "new"
        ],
        "open_specs": [
          "seq_to_map",
          "len",
          "spec_index",
          "subrange_abs",
          "len",
          "spec_index",
          "subrange_abs"
        ]
      },
      "vstd::tokens": {
        "functions": [
          "instance_id",
          "map",
          "empty",
          "insert",
          "remove",
          "into_map",
          "from_map",
          "instance_id",
          "set",
          "empty",
          "insert",
          "remove",
          "into_map",
          "from_map",
          "instance_id",
          "multiset",
          "empty",
          "insert",
          "remove"
        ],
        "open_specs": [
          "dom",
          "spec_index",
          "index",
          "contains",
          "option_value_eq_option_token",
          "option_value_le_option_token",
          "bool_value_eq_option_token",
          "bool_value_le_option_token"
        ]
      }
    },
    "by_keyword": {
      "trigger": [
        "lemma_div_is_div_recursive",
        "lemma_div_basics_1",
        "lemma_div_basics_2",
        "lemma_div_basics_3",
        "lemma_div_basics_4",
        "lemma_div_basics_5",
        "lemma_small_div_converse",
        "lemma_div_non_zero",
        "lemma_div_is_ordered_by_denominator",
        "lemma_div_is_strictly_smaller",
        "lemma_dividing_sums",
        "lemma_div_pos_is_pos",
        "lemma_div_plus_one",
        "lemma_div_minus_one",
        "lemma_basic_div_specific_divisor",
        "lemma_basic_div",
        "lemma_div_is_ordered",
        "lemma_div_decreases",
        "lemma_div_nonincreasing",
        "lemma_breakdown",
        "lemma_remainder_upper",
        "lemma_remainder_lower",
        "lemma_remainder",
        "lemma_fundamental_div_mod",
        "lemma_div_denominator",
        "lemma_mul_hoist_inequality",
        "lemma_indistinguishable_quotients",
        "lemma_truncate_middle",
        "lemma_div_multiples_vanish_quotient",
        "lemma_round_down",
        "lemma_div_multiples_vanish_fancy",
        "lemma_div_multiples_vanish",
        "lemma_div_by_multiple",
        "lemma_div_by_multiple_is_strongly_ordered",
        "lemma_multiply_divide_le",
        "lemma_multiply_divide_lt",
        "lemma_hoist_over_denominator",
        "lemma_part_bound1",
        "lemma_mod_is_mod_recursive",
        "lemma_mod_self_0",
        "lemma_mod_twice",
        "lemma_mod_division_less_than_divisor",
        "lemma_mod_decreases",
        "lemma_mod_is_zero",
        "lemma_mod_multiples_basic",
        "lemma_mod_add_multiples_vanish",
        "lemma_mod_sub_multiples_vanish",
        "lemma_mod_multiples_vanish",
        "lemma_mod_subtraction",
        "lemma_add_mod_noop",
        "lemma_add_mod_noop_right",
        "lemma_sub_mod_noop",
        "lemma_sub_mod_noop_right",
        "lemma_mod_adds",
        "lemma_fundamental_div_mod_converse_mod",
        "lemma_fundamental_div_mod_converse_div",
        "lemma_mod_pos_bound",
        "lemma_mod_bound",
        "lemma_mul_mod_noop_left",
        "lemma_mul_mod_noop_right",
        "lemma_mul_mod_noop_general",
        "lemma_mul_mod_noop",
        "lemma_mod_equivalence",
        "lemma_mod_mul_equivalent",
        "lemma_mod_ordering",
        "lemma_mod_mod",
        "lemma_part_bound2",
        "lemma_mod_breakdown",
        "lemma_div_basics",
        "lemma_small_div",
        "lemma_induction_helper",
        "lemma_mod_induction_forall",
        "lemma_mod_induction_forall2",
        "lemma_mod_basics",
        "lemma_small_mod",
        "lemma_mod_range",
        "lemma_mul_induction",
        "lemma_mul_commutes",
        "lemma_mul_distributes_plus",
        "lemma_mul_distributes_minus",
        "lemma_log_s",
        "lemma_mul_is_mul_recursive",
        "lemma_mul_basics_1",
        "lemma_mul_basics_2",
        "lemma_mul_basics_3",
        "lemma_mul_basics_4",
        "lemma_mul_nonzero",
        "lemma_mul_by_zero_is_zero",
        "lemma_mul_is_associative",
        "lemma_mul_is_commutative",
        "lemma_mul_ordering",
        "lemma_mul_inequality",
        "lemma_mul_strict_inequality",
        "lemma_mul_upper_bound",
        "lemma_mul_strict_upper_bound",
        "lemma_mul_left_inequality",
        "lemma_mul_equality_converse",
        "lemma_mul_inequality_converse",
        "lemma_mul_strict_inequality_converse",
        "lemma_mul_is_distributive_add",
        "lemma_mul_is_distributive_add_other_way",
        "lemma_mul_is_distributive_sub",
        "lemma_mul_is_distributive_sub_other_way",
        "lemma_mul_strictly_positive",
        "lemma_mul_strictly_increases",
        "lemma_mul_increases",
        "lemma_mul_nonnegative",
        "lemma_mul_unary_negation",
        "lemma_mul_cancels_negatives",
        "lemma_pow0",
        "lemma_pow1",
        "lemma0_pow",
        "lemma1_pow",
        "lemma_square_is_pow2",
        "lemma_pow_positive",
        "lemma_pow_adds",
        "lemma_pow_sub_add_cancel",
        "lemma_pow_subtracts",
        "lemma_pow_multiplies",
        "lemma_pow_distributes",
        "lemma_pow_strictly_increases",
        "lemma_pow_increases",
        "lemma_pow_strictly_increases_converse",
        "lemma_pow_increases_converse",
        "lemma_pull_out_pows",
        "lemma_pow_division_inequality",
        "lemma_pow_mod",
        "lemma_pow_mod_noop",
        "lemma_pow2_pos",
        "lemma_pow2",
        "lemma_pow2_unfold",
        "lemma_pow2_adds",
        "lemma_pow2_subtracts",
        "lemma_pow2_strictly_increases",
        "lemma_array_index",
        "array_len_matches_n",
        "spec_array_as_slice",
        "axiom_spec_array_as_slice",
        "spec_array_fill_for_copy_type",
        "axiom_spec_array_fill_for_copy_type",
        "axiom_array_ext_equal",
        "lemma_low_bits_mask_unfold",
        "lemma_low_bits_mask_is_odd",
        "lemma_low_bits_mask_div2",
        "lemma_auto_spec_u64_to_from_le_bytes",
        "all_spec_ensures",
        "axiom_proof_fn_requires",
        "axiom_proof_fn_ensures",
        "proof_fn_as_req_ens",
        "axiom_hash_map_with_view_spec_len",
        "axiom_string_hash_map_spec_len",
        "axiom_hash_set_with_view_spec_len",
        "axiom_string_hash_set_spec_len",
        "lemma_obeys_cmp_spec",
        "lemma_option_obeys_cmp_spec",
        "axiom_structural_obeys_concrete_eq",
        "lemma_obeys_eq_spec",
        "lemma_obeys_concrete_eq",
        "lemma_obeys_view_eq",
        "lemma_obeys_deep_eq",
        "lemma_option_obeys_eq_spec",
        "lemma_option_obeys_concrete_eq",
        "lemma_option_obeys_view_eq",
        "lemma_option_obeys_deep_eq",
        "layout_of_primitives",
        "layout_of_unit_tuple",
        "layout_of_references_and_pointers",
        "layout_of_references_and_pointers_for_sized_types",
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_remove_keys",
        "tracked_union_prefer_right",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "axiom_map_index_decreases_infinite",
        "axiom_map_empty",
        "axiom_map_insert_domain",
        "axiom_map_insert_same",
        "axiom_map_insert_different",
        "axiom_map_remove_domain",
        "axiom_map_remove_different",
        "axiom_map_ext_equal",
        "axiom_map_ext_equal_deep",
        "tracked_map_keys_in_place",
        "lemma_remove_keys_len",
        "lemma_union_insert_left",
        "lemma_union_insert_right",
        "lemma_union_remove_left",
        "lemma_union_remove_right",
        "lemma_union_dom",
        "lemma_disjoint_union_size",
        "lemma_submap_of_trans",
        "lemma_map_new_domain",
        "lemma_map_new_values",
        "lemma_map_properties",
        "axiom_multiset_empty",
        "lemma_multiset_empty_len",
        "axiom_multiset_contained",
        "axiom_multiset_new_not_contained",
        "axiom_multiset_singleton",
        "axiom_multiset_singleton_different",
        "axiom_multiset_add",
        "axiom_multiset_sub",
        "axiom_multiset_ext_equal",
        "axiom_multiset_ext_equal_deep",
        "axiom_len_empty",
        "axiom_len_singleton",
        "axiom_len_add",
        "axiom_len_sub",
        "axiom_count_le_len",
        "axiom_filter_count",
        "axiom_choose_count",
        "axiom_multiset_always_finite",
        "lemma_update_same",
        "lemma_update_different",
        "lemma_insert_containment",
        "lemma_insert_increases_count_by_1",
        "lemma_insert_non_decreasing",
        "lemma_insert_other_elements_unchanged",
        "lemma_insert_len",
        "lemma_intersection_count",
        "lemma_left_pseudo_idempotence",
        "lemma_right_pseudo_idempotence",
        "lemma_difference_count",
        "lemma_difference_bottoms_out",
        "lemma_multiset_properties",
        "lemma_pcm_properties",
        "validate_multiple",
        "trigger",
        "axiom_ptr_mut_from_data",
        "view_reverse_for_eq",
        "ptrs_mut_eq",
        "ptrs_mut_eq_sized",
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "axiom_seq_subrange_decreases",
        "axiom_seq_empty",
        "axiom_seq_new_len",
        "axiom_seq_new_index",
        "axiom_seq_push_len",
        "axiom_seq_push_index_same",
        "axiom_seq_push_index_different",
        "axiom_seq_update_len",
        "axiom_seq_update_same",
        "axiom_seq_update_different",
        "axiom_seq_ext_equal",
        "axiom_seq_ext_equal_deep",
        "axiom_seq_subrange_len",
        "axiom_seq_subrange_index",
        "axiom_seq_add_len",
        "axiom_seq_add_index1",
        "axiom_seq_add_index2",
        "lemma_sort_by_ensures",
        "lemma_filter_len",
        "lemma_filter_pred",
        "lemma_filter_contains",
        "filter_lemma",
        "filter_distributes_over_add",
        "add_empty_left",
        "add_empty_right",
        "push_distributes_over_add",
        "to_multiset_ensures",
        "insert_ensures",
        "remove_ensures",
        "lemma_fold_left_split",
        "lemma_fold_right_split",
        "lemma_add_last_back",
        "lemma_indexing_implies_membership",
        "lemma_membership_implies_indexing",
        "lemma_to_set_map_commutes",
        "lemma_to_set_insert_commutes",
        "lemma_filter_contains_rev",
        "lemma_filter_map_contains",
        "lemma_index_contains",
        "lemma_take_succ_push",
        "lemma_take_len",
        "lemma_flat_map_singleton",
        "lemma_prefix_append_unique",
        "unzip_ensures",
        "lemma_flatten_length_le_mul",
        "lemma_flatten_push",
        "lemma_flatten_singleton",
        "to_multiset_build",
        "to_multiset_remove",
        "to_multiset_insert",
        "to_multiset_len",
        "to_multiset_contains",
        "to_multiset_update",
        "lemma_update_is_remove_insert",
        "seq_to_set_is_finite",
        "lemma_no_dup_in_concat",
        "lemma_seq_union_to_multiset_commutative",
        "lemma_multiset_commutative",
        "lemma_seq_contains",
        "lemma_seq_empty_contains_nothing",
        "lemma_seq_empty_equality",
        "lemma_seq_concat_contains_all_elements",
        "lemma_seq_contains_after_push",
        "lemma_seq_subrange_elements",
        "lemma_seq_take_len",
        "lemma_seq_take_contains",
        "lemma_seq_take_index",
        "lemma_seq_skip_len",
        "lemma_seq_skip_contains",
        "lemma_seq_skip_index",
        "lemma_seq_skip_index2",
        "lemma_seq_append_take_skip",
        "lemma_seq_take_update_commut1",
        "lemma_seq_take_update_commut2",
        "lemma_seq_skip_update_commut1",
        "lemma_seq_skip_update_commut2",
        "lemma_seq_skip_build_commut",
        "lemma_seq_skip_nothing",
        "lemma_seq_take_nothing",
        "lemma_seq_skip_of_skip",
        "lemma_seq_properties",
        "lemma_finite_set_induct",
        "lemma_fold_insert",
        "lemma_fold_empty",
        "axiom_set_empty",
        "axiom_set_new",
        "axiom_set_insert_same",
        "axiom_set_insert_different",
        "axiom_set_remove_same",
        "axiom_set_remove_insert",
        "axiom_set_remove_different",
        "axiom_set_union",
        "axiom_set_intersect",
        "axiom_set_difference",
        "axiom_set_complement",
        "axiom_set_ext_equal",
        "axiom_set_ext_equal_deep",
        "axiom_mk_map_domain",
        "axiom_mk_map_index",
        "axiom_set_empty_finite",
        "axiom_set_insert_finite",
        "axiom_set_remove_finite",
        "axiom_set_union_finite",
        "axiom_set_intersect_finite",
        "axiom_set_difference_finite",
        "axiom_set_choose_infinite",
        "axiom_set_empty_len",
        "axiom_set_insert_len",
        "axiom_set_remove_len",
        "axiom_set_contains_len",
        "axiom_set_choose_len",
        "lemma_set_insert_diff_decreases",
        "lemma_set_map_insert_commute",
        "lemma_any_map_preserved_pred",
        "lemma_filter_map_insert",
        "lemma_filter_map_union",
        "lemma_set_all_subset",
        "lemma_filter_map_finite",
        "lemma_to_seq_to_set_id",
        "flatten_insert_union_commute",
        "lemma_set_insert_finite_iff",
        "lemma_set_remove_finite_iff",
        "lemma_set_union_finite_iff",
        "lemma_set_subset_finite",
        "lemma_map_size",
        "lemma_set_union_again1",
        "lemma_set_union_again2",
        "lemma_set_intersect_again1",
        "lemma_set_intersect_again2",
        "lemma_set_difference2",
        "lemma_set_disjoint",
        "lemma_set_empty_equivalency_len",
        "lemma_set_disjoint_lens",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "lemma_set_properties",
        "axiom_is_empty",
        "axiom_is_empty_len0",
        "spec_slice_len",
        "axiom_spec_len",
        "spec_slice_get",
        "axiom_slice_get_usize",
        "axiom_slice_ext_equal",
        "axiom_u8_trailing_zeros",
        "axiom_u8_trailing_ones",
        "axiom_u8_leading_zeros",
        "axiom_u8_leading_ones",
        "axiom_u16_trailing_zeros",
        "axiom_u16_trailing_ones",
        "axiom_u16_leading_zeros",
        "axiom_u16_leading_ones",
        "axiom_u32_trailing_zeros",
        "axiom_u32_trailing_ones",
        "axiom_u32_leading_zeros",
        "axiom_u32_leading_ones",
        "axiom_u64_trailing_zeros",
        "axiom_u64_trailing_ones",
        "axiom_u64_leading_zeros",
        "axiom_u64_leading_ones",
        "spec_from",
        "spec_from_blanket_identity",
        "obeys_key_model",
        "axiom_bool_obeys_hash_table_key_model",
        "axiom_u8_obeys_hash_table_key_model",
        "axiom_u16_obeys_hash_table_key_model",
        "axiom_u32_obeys_hash_table_key_model",
        "axiom_u64_obeys_hash_table_key_model",
        "axiom_u128_obeys_hash_table_key_model",
        "axiom_usize_obeys_hash_table_key_model",
        "axiom_i8_obeys_hash_table_key_model",
        "axiom_i16_obeys_hash_table_key_model",
        "axiom_i32_obeys_hash_table_key_model",
        "axiom_i164_obeys_hash_table_key_model",
        "axiom_i128_obeys_hash_table_key_model",
        "axiom_isize_obeys_hash_table_key_model",
        "axiom_box_bool_obeys_hash_table_key_model",
        "axiom_box_integer_type_obeys_hash_table_key_model",
        "builds_valid_hashers",
        "axiom_random_state_builds_valid_hashers",
        "lemma_hashmap_deepview_dom",
        "lemma_hashmap_deepview_properties",
        "lemma_hashmap_deepview_values",
        "axiom_hashmap_deepview_borrow",
        "axiom_hashmap_view_finite_dom",
        "spec_hash_map_len",
        "axiom_spec_hash_map_len",
        "contains_borrowed_key",
        "axiom_contains_deref_key",
        "axiom_contains_box",
        "maps_borrowed_key_to_value",
        "axiom_maps_deref_key_to_value",
        "axiom_maps_box_key_to_value",
        "borrowed_key_removed",
        "axiom_deref_key_removed",
        "axiom_box_key_removed",
        "axiom_hashmap_decreases",
        "spec_hash_set_len",
        "axiom_spec_hash_set_len",
        "set_contains_borrowed_key",
        "axiom_set_contains_deref_key",
        "axiom_set_contains_box",
        "sets_borrowed_key_to_key",
        "axiom_set_deref_key_to_value",
        "axiom_set_box_key_to_value",
        "sets_differ_by_borrowed_key",
        "axiom_set_deref_key_removed",
        "axiom_set_box_key_removed",
        "axiom_hashset_decreases",
        "spec_slice_iter",
        "axiom_spec_slice_iter",
        "spec_vec_len",
        "axiom_spec_len",
        "vec_clone_deep_view_proof",
        "axiom_vec_index_decreases",
        "spec_into_iter",
        "axiom_spec_into_iter",
        "vec_clone_trigger",
        "spec_vec_dequeue_len",
        "axiom_spec_len",
        "axiom_vec_dequeue_index_decreases",
        "spec_iter",
        "axiom_spec_iter",
        "vec_dequeue_clone_trigger",
        "to_string_from_display_ensures",
        "to_string_from_display_ensures_for_str",
        "axiom_str_literal_is_ascii",
        "axiom_str_literal_len",
        "axiom_str_literal_get_char",
        "agree_map",
        "into_map",
        "from_map",
        "into_map",
        "from_map"
      ],
      "decreases": [
        "lemma_div_is_ordered_by_denominator",
        "lemma_div_is_strictly_smaller",
        "lemma_div_decreases",
        "lemma_mod_is_mod_recursive",
        "lemma_mod_decreases",
        "lemma_mod_multiples_vanish",
        "div_pos",
        "lemma_quotient_and_remainder",
        "mod_recursive",
        "mul_pos",
        "lemma_log_nonnegative",
        "lemma_log_is_ordered",
        "lemma_log_pow",
        "log",
        "lemma0_pow",
        "lemma1_pow",
        "lemma_pow_adds",
        "lemma_pow_sub_add_cancel",
        "lemma_pow_multiplies",
        "lemma_pow_distributes",
        "lemma_pow_mod_noop",
        "pow",
        "lemma_pow2",
        "pow2",
        "all_spec_ensures",
        "range_all_spec_rec",
        "is_power_2",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "axiom_map_index_decreases_infinite",
        "lemma_remove_keys_len",
        "lemma_values_finite",
        "combine_values",
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "axiom_seq_subrange_decreases",
        "lemma_sort_by_ensures",
        "lemma_filter_len",
        "filter_lemma",
        "filter_distributes_over_add",
        "to_multiset",
        "lemma_fold_left_split",
        "lemma_fold_left_alt",
        "lemma_fold_right_split",
        "lemma_fold_right_commute_one",
        "lemma_fold_right_alt",
        "lemma_reverse_fold_right",
        "lemma_multiset_has_no_duplicates",
        "lemma_reverse_to_multiset",
        "unique_seq_to_set",
        "lemma_cardinality_of_set",
        "lemma_no_dup_set_cardinality",
        "lemma_filter_contains_rev",
        "lemma_filter_map_contains",
        "lemma_filter_eq_filter_alt",
        "unzip_ensures",
        "lemma_flatten_length_ge_single_element_length",
        "lemma_flatten_length_le_mul",
        "lemma_flatten_and_flatten_alt_are_equivalent",
        "lemma_flatten_push",
        "max_ensures",
        "min_ensures",
        "lemma_max_of_concat",
        "lemma_min_of_concat",
        "to_multiset_build",
        "to_multiset_insert",
        "to_multiset_len",
        "to_multiset_contains",
        "to_multiset_update",
        "lemma_update_is_remove_insert",
        "lemma_flatten_concat",
        "lemma_flatten_alt_concat",
        "lemma_multiset_commutative",
        "lemma_sorted_unique",
        "lemma_seq_concat_contains_all_elements",
        "lemma_fold_right_permutation",
        "filter",
        "max_via",
        "min_via",
        "reverse",
        "zip_with",
        "fold_left",
        "fold_left_alt",
        "fold_right",
        "fold_right_alt",
        "remove_duplicates",
        "filter_map",
        "flatten",
        "flatten_alt",
        "max",
        "min",
        "find_unique_minimal",
        "find_unique_minimal_ensures",
        "find_unique_maximal",
        "find_unique_maximal_ensures",
        "lemma_len_filter",
        "lemma_set_insert_diff_decreases",
        "lemma_map_finite",
        "lemma_filter_map_finite",
        "lemma_to_seq_to_set_id",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_len_union",
        "lemma_len_union_ind",
        "lemma_len_intersect",
        "lemma_len_difference",
        "lemma_int_range",
        "lemma_subset_equality",
        "lemma_map_size",
        "lemma_set_disjoint_lens",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "to_seq",
        "to_multiset",
        "u8_trailing_zeros",
        "u8_leading_zeros",
        "axiom_u8_trailing_zeros",
        "axiom_u8_leading_zeros",
        "u16_trailing_zeros",
        "u16_leading_zeros",
        "axiom_u16_trailing_zeros",
        "axiom_u16_leading_zeros",
        "u32_trailing_zeros",
        "u32_leading_zeros",
        "axiom_u32_trailing_zeros",
        "axiom_u32_leading_zeros",
        "u64_trailing_zeros",
        "axiom_u64_trailing_zeros",
        "axiom_u64_leading_zeros",
        "u64_leading_zeros",
        "axiom_hashmap_decreases",
        "axiom_hashset_decreases",
        "axiom_vec_index_decreases",
        "axiom_vec_dequeue_index_decreases"
      ],
      "forall": [
        "lemma_basic_div_specific_divisor",
        "lemma_div_basics",
        "lemma_div_induction_auto_forall",
        "lemma_small_div",
        "lemma_induction_helper",
        "lemma_mod_induction_forall",
        "lemma_mod_induction_forall2",
        "lemma_mod_basics",
        "lemma_mod_induction_auto_forall",
        "lemma_mul_induction",
        "lemma_mul_induction_auto_forall",
        "spec_array_fill_for_copy_type",
        "axiom_spec_array_fill_for_copy_type",
        "axiom_array_ext_equal",
        "lemma_auto_spec_u16_to_from_le_bytes",
        "lemma_auto_spec_u32_to_from_le_bytes",
        "lemma_auto_spec_u64_to_from_le_bytes",
        "lemma_auto_spec_u128_to_from_le_bytes",
        "all_spec_ensures",
        "axiom_proof_fn_requires",
        "axiom_proof_fn_ensures",
        "proof_fn_as_req_ens",
        "axiom_structural_obeys_concrete_eq",
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_map_keys_in_place",
        "lemma_remove_keys_len",
        "lemma_map_properties",
        "axiom_multiset_ext_equal",
        "lemma_multiset_properties",
        "lemma_pcm_properties",
        "validate_multiple",
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "lemma_sort_by_ensures",
        "filter_lemma",
        "to_multiset_ensures",
        "insert_ensures",
        "remove_ensures",
        "lemma_multiset_has_no_duplicates",
        "lemma_multiset_has_no_duplicates_conv",
        "lemma_indexing_implies_membership",
        "lemma_membership_implies_indexing",
        "unzip_ensures",
        "lemma_flatten_length_le_mul",
        "max_ensures",
        "min_ensures",
        "lemma_max_of_concat",
        "lemma_min_of_concat",
        "lemma_no_dup_in_concat",
        "lemma_seq_properties",
        "lemma_finite_set_induct",
        "axiom_set_ext_equal",
        "find_unique_minimal_ensures",
        "find_unique_maximal_ensures",
        "lemma_least_is_unique",
        "lemma_greatest_is_unique",
        "lemma_minimal_is_unique",
        "lemma_maximal_is_unique",
        "lemma_any_map_preserved_pred",
        "lemma_map_size",
        "lemma_set_properties",
        "spec_slice_get",
        "axiom_slice_get_usize",
        "axiom_slice_ext_equal",
        "axiom_u8_trailing_zeros",
        "axiom_u8_trailing_ones",
        "axiom_u8_leading_zeros",
        "axiom_u8_leading_ones",
        "axiom_u16_trailing_zeros",
        "axiom_u16_trailing_ones",
        "axiom_u16_leading_zeros",
        "axiom_u16_leading_ones",
        "axiom_u32_trailing_zeros",
        "axiom_u32_trailing_ones",
        "axiom_u32_leading_zeros",
        "axiom_u32_leading_ones",
        "axiom_u64_trailing_zeros",
        "axiom_u64_trailing_ones",
        "axiom_u64_leading_zeros",
        "axiom_u64_leading_ones",
        "lemma_hashmap_deepview_properties",
        "agree_map",
        "into_map",
        "from_map",
        "into_map",
        "from_map"
      ],
      "len": [
        "array_len_matches_n",
        "spec_u16_from_le_bytes",
        "u16_from_le_bytes",
        "u16_to_le_bytes",
        "spec_u32_from_le_bytes",
        "u32_from_le_bytes",
        "u32_to_le_bytes",
        "spec_u64_from_le_bytes",
        "u64_from_le_bytes",
        "u64_to_le_bytes",
        "spec_u128_from_le_bytes",
        "u128_from_le_bytes",
        "u128_to_le_bytes",
        "spec_len",
        "axiom_hash_map_with_view_spec_len",
        "spec_len",
        "axiom_string_hash_map_spec_len",
        "spec_len",
        "axiom_hash_set_with_view_spec_len",
        "spec_len",
        "axiom_string_hash_set_spec_len",
        "len",
        "lemma_remove_key_len",
        "lemma_remove_keys_len",
        "lemma_disjoint_union_size",
        "lemma_values_finite",
        "len",
        "axiom_multiset_empty",
        "lemma_multiset_empty_len",
        "axiom_multiset_ext_equal",
        "axiom_multiset_ext_equal_deep",
        "axiom_len_empty",
        "axiom_len_singleton",
        "axiom_len_add",
        "axiom_len_sub",
        "axiom_count_le_len",
        "axiom_choose_count",
        "lemma_insert_len",
        "lemma_multiset_properties",
        "lemma_singleton_size",
        "lemma_is_singleton",
        "validate_multiple",
        "combine_values",
        "is_range",
        "contains_range",
        "lemma_new_first_element_still_sorted_by",
        "new",
        "len",
        "index",
        "tracked_remove",
        "tracked_insert",
        "tracked_borrow",
        "tracked_push",
        "tracked_pop",
        "tracked_pop_front",
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "axiom_seq_subrange_decreases",
        "axiom_seq_empty",
        "axiom_seq_new_len",
        "axiom_seq_new_index",
        "axiom_seq_push_len",
        "axiom_seq_push_index_same",
        "axiom_seq_push_index_different",
        "axiom_seq_update_len",
        "axiom_seq_update_same",
        "axiom_seq_update_different",
        "axiom_seq_subrange_len",
        "axiom_seq_subrange_index",
        "axiom_seq_add_len",
        "axiom_seq_add_index1",
        "axiom_seq_add_index2",
        "spec_index",
        "last",
        "first",
        "lemma_sort_by_ensures",
        "lemma_filter_len",
        "lemma_filter_pred",
        "lemma_filter_contains",
        "filter_lemma",
        "filter_distributes_over_add",
        "add_empty_left",
        "add_empty_right",
        "drop_last_distributes_over_add",
        "to_multiset",
        "to_multiset_ensures",
        "insert_ensures",
        "remove_ensures",
        "lemma_fold_left_split",
        "lemma_fold_left_alt",
        "lemma_fold_right_split",
        "lemma_fold_right_commute_one",
        "lemma_fold_right_alt",
        "lemma_reverse_fold_right",
        "lemma_multiset_has_no_duplicates",
        "lemma_reverse_to_multiset",
        "lemma_add_last_back",
        "lemma_indexing_implies_membership",
        "lemma_membership_implies_indexing",
        "lemma_split_at",
        "lemma_element_from_slice",
        "lemma_slice_of_slice",
        "unique_seq_to_set",
        "lemma_cardinality_of_set",
        "lemma_cardinality_of_empty_set_is_0",
        "lemma_no_dup_set_cardinality",
        "lemma_filter_contains_rev",
        "lemma_filter_map_contains",
        "lemma_take_succ",
        "lemma_filter_eq_filter_alt",
        "lemma_index_contains",
        "lemma_take_succ_push",
        "lemma_take_len",
        "lemma_flat_map_singleton",
        "unzip_ensures",
        "lemma_flatten_one_element",
        "lemma_flatten_length_ge_single_element_length",
        "lemma_flatten_length_le_mul",
        "lemma_flatten_and_flatten_alt_are_equivalent",
        "lemma_flatten_push",
        "lemma_flatten_singleton",
        "max_ensures",
        "min_ensures",
        "lemma_subrange_max",
        "lemma_subrange_min",
        "lemma_max_of_concat",
        "lemma_min_of_concat",
        "to_multiset_build",
        "to_multiset_remove",
        "to_multiset_insert",
        "to_multiset_len",
        "to_multiset_contains",
        "to_multiset_update",
        "lemma_update_is_remove_insert",
        "lemma_append_last",
        "lemma_no_dup_in_concat",
        "lemma_flatten_concat",
        "lemma_flatten_alt_concat",
        "lemma_multiset_commutative",
        "lemma_sorted_unique",
        "lemma_seq_contains",
        "lemma_seq_empty_equality",
        "lemma_seq_concat_contains_all_elements",
        "lemma_seq_subrange_elements",
        "lemma_fold_right_permutation",
        "lemma_seq_take_len",
        "lemma_seq_take_contains",
        "lemma_seq_take_index",
        "subrange_of_matching_take",
        "lemma_seq_skip_len",
        "lemma_seq_skip_contains",
        "lemma_seq_skip_index",
        "lemma_seq_skip_index2",
        "lemma_seq_append_take_skip",
        "lemma_seq_take_update_commut1",
        "lemma_seq_take_update_commut2",
        "lemma_seq_skip_update_commut1",
        "lemma_seq_skip_update_commut2",
        "lemma_seq_skip_build_commut",
        "lemma_seq_skip_of_skip",
        "lemma_seq_properties",
        "filter",
        "max_via",
        "min_via",
        "drop_last",
        "drop_first",
        "insert",
        "remove",
        "reverse",
        "zip_with",
        "fold_left",
        "fold_left_alt",
        "fold_right",
        "fold_right_alt",
        "update_subrange_with",
        "remove_duplicates",
        "filter_map",
        "flatten",
        "flatten_alt",
        "max",
        "min",
        "len",
        "axiom_set_empty_len",
        "axiom_set_insert_len",
        "axiom_set_remove_len",
        "axiom_set_contains_len",
        "axiom_set_choose_len",
        "find_unique_minimal",
        "find_unique_minimal_ensures",
        "find_unique_maximal",
        "find_unique_maximal_ensures",
        "lemma_len0_is_empty",
        "lemma_singleton_size",
        "lemma_is_singleton",
        "lemma_len_filter",
        "lemma_set_insert_diff_decreases",
        "lemma_subset_not_in_lt",
        "lemma_map_finite",
        "lemma_filter_map_finite",
        "lemma_to_seq_to_set_id",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_len_union",
        "lemma_len_union_ind",
        "lemma_len_intersect",
        "lemma_len_subset",
        "lemma_len_difference",
        "lemma_int_range",
        "lemma_subset_equality",
        "lemma_map_size",
        "lemma_set_empty_equivalency_len",
        "lemma_set_disjoint_lens",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "lemma_set_properties",
        "axiom_is_empty_len0",
        "to_seq",
        "to_multiset",
        "slice_index_get",
        "spec_slice_len",
        "axiom_spec_len",
        "slice_subrange",
        "spec_slice_get",
        "axiom_slice_get_usize",
        "axiom_slice_ext_equal",
        "update_at_index",
        "spec_hash_map_len",
        "axiom_spec_hash_map_len",
        "spec_hash_set_len",
        "axiom_spec_hash_set_len",
        "spec_vec_len",
        "axiom_spec_len",
        "axiom_vec_index_decreases",
        "spec_vec_dequeue_len",
        "axiom_spec_len",
        "axiom_vec_dequeue_index_decreases",
        "axiom_str_literal_is_ascii",
        "axiom_str_literal_len",
        "agree",
        "update_subrange_with",
        "agree",
        "agree_map",
        "update",
        "update_map",
        "split",
        "combine",
        "disjoint",
        "new",
        "len",
        "spec_index",
        "subrange_abs",
        "len",
        "spec_index",
        "subrange_abs"
      ],
      "Seq": [
        "array_view",
        "spec_u16_to_le_bytes",
        "spec_u16_from_le_bytes",
        "spec_u32_to_le_bytes",
        "spec_u32_from_le_bytes",
        "spec_u64_to_le_bytes",
        "spec_u64_from_le_bytes",
        "spec_u128_to_le_bytes",
        "spec_u128_from_le_bytes",
        "spec_u64_to_le_bytes_open",
        "prefixed_entries",
        "validate_multiple",
        "combine_values",
        "lemma_new_first_element_still_sorted_by",
        "sorted_by",
        "empty",
        "new",
        "tracked_empty",
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "axiom_seq_subrange_decreases",
        "axiom_seq_empty",
        "axiom_seq_new_len",
        "axiom_seq_new_index",
        "axiom_seq_push_len",
        "axiom_seq_push_index_same",
        "axiom_seq_push_index_different",
        "axiom_seq_update_len",
        "axiom_seq_update_same",
        "axiom_seq_update_different",
        "axiom_seq_ext_equal",
        "axiom_seq_ext_equal_deep",
        "axiom_seq_subrange_len",
        "axiom_seq_subrange_index",
        "axiom_seq_add_len",
        "axiom_seq_add_index1",
        "axiom_seq_add_index2",
        "take",
        "skip",
        "spec_add",
        "lemma_element_from_slice",
        "lemma_to_set_insert_commutes",
        "lemma_take_succ",
        "lemma_flat_map_singleton",
        "lemma_prefix_append_unique",
        "lemma_concat_injective",
        "unzip",
        "lemma_flatten_push",
        "lemma_max_of_concat",
        "lemma_min_of_concat",
        "to_multiset_build",
        "to_multiset_remove",
        "to_multiset_insert",
        "to_multiset_len",
        "to_multiset_contains",
        "to_multiset_update",
        "lemma_update_is_remove_insert",
        "lemma_append_last",
        "lemma_concat_associative",
        "seq_to_set_is_finite",
        "seq_to_set_distributes_over_add",
        "lemma_no_dup_in_concat",
        "lemma_flatten_concat",
        "lemma_flatten_alt_concat",
        "lemma_seq_union_to_multiset_commutative",
        "lemma_multiset_commutative",
        "lemma_sorted_unique",
        "lemma_seq_contains",
        "lemma_seq_empty_contains_nothing",
        "lemma_seq_empty_equality",
        "lemma_seq_concat_contains_all_elements",
        "lemma_seq_contains_after_push",
        "lemma_seq_subrange_elements",
        "lemma_fold_right_permutation",
        "lemma_fold_left_permutation",
        "lemma_seq_take_len",
        "lemma_seq_take_contains",
        "lemma_seq_take_index",
        "subrange_of_matching_take",
        "lemma_seq_skip_len",
        "lemma_seq_skip_contains",
        "lemma_seq_skip_index",
        "lemma_seq_skip_index2",
        "lemma_seq_append_take_skip",
        "lemma_seq_take_update_commut1",
        "lemma_seq_take_update_commut2",
        "lemma_seq_skip_update_commut1",
        "lemma_seq_skip_update_commut2",
        "lemma_seq_skip_build_commut",
        "lemma_seq_skip_nothing",
        "lemma_seq_take_nothing",
        "lemma_seq_skip_of_skip",
        "lemma_seq_properties",
        "map",
        "map_values",
        "flat_map",
        "drop_last",
        "drop_first",
        "insert",
        "remove",
        "remove_value",
        "reverse",
        "zip_with",
        "remove_duplicates",
        "filter_map",
        "filter_alt",
        "flatten",
        "flatten_alt",
        "check_argument_is_seq",
        "to_seq",
        "to_sorted_seq",
        "view",
        "new",
        "agree",
        "update_subrange_with",
        "view",
        "agree",
        "update",
        "update_map",
        "new",
        "seq_to_map",
        "subrange_abs",
        "subrange_abs"
      ],
      "Vec": [
        "u16_to_le_bytes",
        "u32_to_le_bytes",
        "u64_to_le_bytes",
        "u128_to_le_bytes",
        "slice_to_vec",
        "spec_vec_len",
        "axiom_spec_len",
        "vec_clone_deep_view_proof",
        "axiom_vec_index_decreases",
        "spec_into_iter",
        "axiom_spec_into_iter",
        "vec_clone_trigger",
        "spec_vec_dequeue_len",
        "axiom_spec_len",
        "axiom_vec_dequeue_index_decreases",
        "spec_iter",
        "axiom_spec_iter",
        "vec_dequeue_clone_trigger"
      ],
      "Map": [
        "axiom_hash_map_with_view_spec_len",
        "axiom_string_hash_map_spec_len",
        "empty",
        "insert",
        "remove",
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_remove_keys",
        "tracked_union_prefer_right",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "axiom_map_index_decreases_infinite",
        "axiom_map_empty",
        "axiom_map_insert_domain",
        "axiom_map_insert_same",
        "axiom_map_insert_different",
        "axiom_map_remove_domain",
        "axiom_map_remove_different",
        "axiom_map_ext_equal",
        "axiom_map_ext_equal_deep",
        "tracked_map_keys_in_place",
        "total",
        "new",
        "check_argument_is_map",
        "lemma_union_insert_left",
        "lemma_union_insert_right",
        "lemma_union_remove_left",
        "lemma_union_remove_right",
        "lemma_union_dom",
        "lemma_disjoint_union_size",
        "lemma_submap_of_trans",
        "lemma_map_new_domain",
        "lemma_map_new_values",
        "lemma_map_properties",
        "lemma_values_finite",
        "map_entries",
        "map_values",
        "invert",
        "from_map",
        "axiom_multiset_contained",
        "axiom_multiset_new_not_contained",
        "validate_multiple",
        "mk_map",
        "builds_valid_hashers",
        "spec_hash_map_iter",
        "axiom_spec_hash_map_iter",
        "lemma_hashmap_deepview_dom",
        "lemma_hashmap_deepview_properties",
        "lemma_hashmap_deepview_values",
        "axiom_hashmap_deepview_borrow",
        "axiom_hashmap_view_finite_dom",
        "spec_hash_map_len",
        "axiom_spec_hash_map_len",
        "contains_borrowed_key",
        "axiom_contains_deref_key",
        "axiom_contains_box",
        "maps_borrowed_key_to_value",
        "axiom_maps_deref_key_to_value",
        "axiom_maps_box_key_to_value",
        "borrowed_key_removed",
        "axiom_deref_key_removed",
        "axiom_box_key_removed",
        "axiom_hashmap_decreases",
        "hash_map_deep_view_impl",
        "alloc",
        "validate",
        "exchange",
        "deposit",
        "withdraw",
        "exchange_nondeterministic",
        "guard",
        "validate_with_shared",
        "exchange_with_shared",
        "exchange_nondeterministic_with_shared",
        "guards",
        "exchanges",
        "exchanges_nondeterministic",
        "deposits",
        "withdraws",
        "set_op",
        "view",
        "dummy",
        "take",
        "empty",
        "insert",
        "new",
        "view",
        "empty",
        "agree",
        "update",
        "agree_map",
        "update_map",
        "seq_to_map",
        "map",
        "empty",
        "into_map",
        "from_map",
        "into_map",
        "from_map"
      ],
      "Set": [
        "axiom_hash_set_with_view_spec_len",
        "axiom_string_hash_set_spec_len",
        "dom",
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_remove_keys",
        "tracked_union_prefer_right",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "axiom_map_index_decreases_infinite",
        "axiom_map_empty",
        "lemma_remove_keys_len",
        "lemma_map_new_domain",
        "lemma_map_new_values",
        "lemma_map_properties",
        "values",
        "kv_pairs",
        "remove_keys",
        "restrict",
        "from_set",
        "dom",
        "update_nondeterministic",
        "update_nondeterministic_with_shared",
        "frame_preserving_update_nondeterministic",
        "set_op",
        "dom",
        "empty",
        "split",
        "is_least",
        "is_minimal",
        "is_greatest",
        "is_maximal",
        "to_set",
        "empty",
        "new",
        "insert",
        "remove",
        "union",
        "intersect",
        "difference",
        "complement",
        "lemma_finite_set_induct",
        "lemma_fold_insert",
        "lemma_fold_empty",
        "axiom_set_empty",
        "axiom_set_new",
        "axiom_set_insert_same",
        "axiom_set_insert_different",
        "axiom_set_remove_same",
        "axiom_set_remove_insert",
        "axiom_set_remove_different",
        "axiom_set_union",
        "axiom_set_intersect",
        "axiom_set_difference",
        "axiom_set_complement",
        "axiom_set_ext_equal",
        "axiom_set_ext_equal_deep",
        "axiom_mk_map_domain",
        "axiom_mk_map_index",
        "axiom_set_empty_finite",
        "axiom_set_insert_finite",
        "axiom_set_remove_finite",
        "axiom_set_union_finite",
        "axiom_set_intersect_finite",
        "axiom_set_difference_finite",
        "axiom_set_choose_infinite",
        "axiom_set_empty_len",
        "axiom_set_insert_len",
        "axiom_set_remove_len",
        "axiom_set_contains_len",
        "axiom_set_choose_len",
        "full",
        "subset_of",
        "spec_le",
        "spec_add",
        "spec_mul",
        "spec_sub",
        "filter",
        "lemma_len0_is_empty",
        "lemma_is_singleton",
        "lemma_set_insert_diff_decreases",
        "lemma_subset_not_in_lt",
        "lemma_map_union_commute",
        "lemma_filter_map_insert",
        "lemma_filter_map_union",
        "lemma_set_all_subset",
        "flatten_insert_union_commute",
        "lemma_sets_eq_iff_injective_map_eq",
        "lemma_set_insert_finite_iff",
        "lemma_set_remove_finite_iff",
        "lemma_set_union_finite_iff",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_len_union",
        "lemma_len_union_ind",
        "lemma_len_intersect",
        "lemma_len_subset",
        "lemma_set_subset_finite",
        "lemma_len_difference",
        "lemma_subset_equality",
        "lemma_map_size",
        "lemma_set_union_again1",
        "lemma_set_union_again2",
        "lemma_set_intersect_again1",
        "lemma_set_intersect_again2",
        "lemma_set_difference2",
        "lemma_set_disjoint",
        "lemma_set_empty_equivalency_len",
        "lemma_set_disjoint_lens",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "lemma_set_properties",
        "axiom_is_empty",
        "axiom_is_empty_len0",
        "map",
        "filter_map",
        "flatten",
        "set_int_range",
        "check_argument_is_set",
        "builds_valid_hashers",
        "spec_hash_set_len",
        "axiom_spec_hash_set_len",
        "set_contains_borrowed_key",
        "axiom_set_contains_deref_key",
        "axiom_set_contains_box",
        "sets_borrowed_key_to_key",
        "axiom_set_deref_key_to_value",
        "axiom_set_box_key_to_value",
        "sets_differ_by_borrowed_key",
        "axiom_set_deref_key_removed",
        "axiom_set_box_key_removed",
        "axiom_hashset_decreases",
        "exchange_nondeterministic",
        "exchange_nondeterministic_with_shared",
        "exchanges_nondeterministic",
        "set_op",
        "split",
        "dom",
        "dom",
        "new",
        "set",
        "empty",
        "dom"
      ],
      "invariant": [
        "new",
        "into_inner",
        "spend_open_invariant_credit_in_proof",
        "layout_for_type_is_valid",
        "provenance",
        "null",
        "points_to"
      ],
      "empty": [
        "empty",
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_remove_keys",
        "tracked_union_prefer_right",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "axiom_map_index_decreases_infinite",
        "axiom_map_empty",
        "empty",
        "axiom_multiset_empty",
        "lemma_multiset_empty_len",
        "axiom_multiset_ext_equal",
        "axiom_multiset_ext_equal_deep",
        "axiom_len_empty",
        "lemma_multiset_properties",
        "empty",
        "empty",
        "tracked_empty",
        "axiom_seq_empty",
        "lemma_seq_empty_contains_nothing",
        "lemma_seq_empty_equality",
        "lemma_seq_take_nothing",
        "lemma_seq_properties",
        "empty",
        "lemma_finite_set_induct",
        "lemma_fold_empty",
        "axiom_set_empty",
        "axiom_mk_map_domain",
        "axiom_mk_map_index",
        "axiom_set_empty_finite",
        "axiom_set_empty_len",
        "lemma_len0_is_empty",
        "lemma_set_empty_equivalency_len",
        "empty",
        "empty",
        "empty",
        "empty",
        "empty"
      ],
      "contains": [
        "index",
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_remove_keys",
        "tracked_union_prefer_right",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "axiom_map_index_decreases_infinite",
        "tracked_map_keys_in_place",
        "spec_index",
        "lemma_remove_key_len",
        "lemma_remove_keys_len",
        "axiom_multiset_contained",
        "axiom_multiset_new_not_contained",
        "contains",
        "lemma_is_singleton_contains_elem_equal_singleton",
        "update_nondeterministic",
        "update_nondeterministic_with_shared",
        "validate_multiple",
        "lemma_sort_by_ensures",
        "lemma_filter_contains",
        "filter_lemma",
        "to_multiset_ensures",
        "lemma_multiset_has_no_duplicates",
        "lemma_multiset_has_no_duplicates_conv",
        "lemma_indexing_implies_membership",
        "lemma_membership_implies_indexing",
        "lemma_filter_contains_rev",
        "lemma_filter_map_contains",
        "lemma_index_contains",
        "lemma_prefix_append_unique",
        "max_ensures",
        "min_ensures",
        "lemma_max_of_concat",
        "lemma_min_of_concat",
        "to_multiset_contains",
        "lemma_seq_contains",
        "lemma_seq_empty_contains_nothing",
        "lemma_seq_concat_contains_all_elements",
        "lemma_seq_contains_after_push",
        "lemma_seq_subrange_elements",
        "lemma_seq_take_contains",
        "lemma_seq_skip_contains",
        "lemma_seq_properties",
        "contains",
        "contains",
        "lemma_finite_set_induct",
        "lemma_fold_insert",
        "axiom_set_empty",
        "axiom_set_new",
        "axiom_set_insert_same",
        "axiom_set_insert_different",
        "axiom_set_remove_same",
        "axiom_set_remove_insert",
        "axiom_set_remove_different",
        "axiom_set_union",
        "axiom_set_intersect",
        "axiom_set_difference",
        "axiom_set_complement",
        "axiom_set_ext_equal",
        "axiom_mk_map_domain",
        "axiom_mk_map_index",
        "axiom_set_choose_infinite",
        "axiom_set_insert_len",
        "axiom_set_remove_len",
        "axiom_set_contains_len",
        "axiom_set_choose_len",
        "lemma_set_insert_diff_decreases",
        "lemma_subset_not_in_lt",
        "lemma_map_size",
        "lemma_set_difference2",
        "lemma_set_empty_equivalency_len",
        "lemma_set_properties",
        "axiom_is_empty",
        "set_contains_borrowed_key",
        "axiom_set_contains_deref_key",
        "axiom_set_contains_box",
        "sets_borrowed_key_to_key",
        "axiom_set_deref_key_to_value",
        "axiom_set_box_key_to_value",
        "spec_index",
        "spec_index",
        "remove",
        "into_map",
        "from_map",
        "remove",
        "into_map",
        "from_map",
        "remove",
        "contains"
      ],
      "insert": [
        "insert",
        "tracked_empty",
        "tracked_insert",
        "axiom_map_insert_domain",
        "axiom_map_insert_same",
        "axiom_map_insert_different",
        "lemma_union_insert_left",
        "lemma_union_insert_right",
        "lemma_insert_containment",
        "lemma_insert_increases_count_by_1",
        "lemma_insert_non_decreasing",
        "lemma_insert_other_elements_unchanged",
        "lemma_insert_len",
        "lemma_multiset_properties",
        "insert",
        "tracked_insert",
        "to_multiset_ensures",
        "insert_ensures",
        "lemma_to_set_insert_commutes",
        "to_multiset_build",
        "to_multiset_insert",
        "to_multiset_update",
        "lemma_update_is_remove_insert",
        "lemma_seq_properties",
        "insert",
        "insert",
        "lemma_finite_set_induct",
        "lemma_fold_insert",
        "axiom_set_insert_same",
        "axiom_set_insert_different",
        "axiom_set_remove_insert",
        "axiom_set_insert_finite",
        "axiom_set_insert_len",
        "lemma_set_insert_diff_decreases",
        "lemma_set_map_insert_commute",
        "lemma_filter_map_insert",
        "flatten_insert_union_commute",
        "lemma_set_insert_finite_iff",
        "insert",
        "insert",
        "insert",
        "insert"
      ],
      "remove": [
        "remove",
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "axiom_map_remove_domain",
        "axiom_map_remove_different",
        "lemma_remove_key_len",
        "lemma_remove_equivalency",
        "lemma_union_remove_left",
        "lemma_union_remove_right",
        "remove",
        "tracked_remove",
        "to_multiset_ensures",
        "remove_ensures",
        "to_multiset_remove",
        "to_multiset_update",
        "lemma_update_is_remove_insert",
        "remove",
        "remove",
        "axiom_set_remove_same",
        "axiom_set_remove_insert",
        "axiom_set_remove_different",
        "axiom_set_remove_finite",
        "axiom_set_remove_len",
        "lemma_set_remove_finite_iff",
        "borrowed_key_removed",
        "axiom_deref_key_removed",
        "axiom_box_key_removed",
        "sets_differ_by_borrowed_key",
        "axiom_set_deref_key_removed",
        "axiom_set_box_key_removed",
        "remove",
        "remove",
        "remove"
      ],
      "finite": [
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_remove_keys",
        "tracked_union_prefer_right",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "lemma_remove_key_len",
        "lemma_remove_keys_len",
        "lemma_disjoint_union_size",
        "lemma_values_finite",
        "axiom_multiset_contained",
        "axiom_multiset_new_not_contained",
        "axiom_choose_count",
        "axiom_multiset_always_finite",
        "seq_to_set_is_finite",
        "finite",
        "lemma_finite_set_induct",
        "lemma_fold_insert",
        "axiom_mk_map_domain",
        "axiom_mk_map_index",
        "axiom_set_empty_finite",
        "axiom_set_insert_finite",
        "axiom_set_remove_finite",
        "axiom_set_union_finite",
        "axiom_set_intersect_finite",
        "axiom_set_difference_finite",
        "axiom_set_choose_infinite",
        "axiom_set_insert_len",
        "axiom_set_remove_len",
        "axiom_set_contains_len",
        "axiom_set_choose_len",
        "find_unique_minimal",
        "find_unique_minimal_ensures",
        "find_unique_maximal",
        "find_unique_maximal_ensures",
        "lemma_len0_is_empty",
        "lemma_is_singleton",
        "lemma_len_filter",
        "lemma_maximal_is_unique",
        "lemma_set_insert_diff_decreases",
        "lemma_subset_not_in_lt",
        "lemma_map_finite",
        "lemma_filter_map_finite",
        "lemma_to_seq_to_set_id",
        "lemma_set_insert_finite_iff",
        "lemma_set_remove_finite_iff",
        "lemma_set_union_finite_iff",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_len_union",
        "lemma_len_union_ind",
        "lemma_len_intersect",
        "lemma_len_subset",
        "lemma_set_subset_finite",
        "lemma_len_difference",
        "lemma_int_range",
        "lemma_subset_equality",
        "lemma_map_size",
        "lemma_set_empty_equivalency_len",
        "lemma_set_disjoint_lens",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "lemma_set_properties",
        "axiom_is_empty_len0",
        "to_seq",
        "to_multiset",
        "axiom_hashmap_view_finite_dom"
      ],
      "union": [
        "lemma_union_dom",
        "union",
        "axiom_set_union",
        "axiom_set_union_finite",
        "lemma_map_union_commute",
        "lemma_filter_map_union",
        "flatten_insert_union_commute",
        "lemma_set_union_finite_iff",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_len_union",
        "lemma_len_union_ind",
        "lemma_set_union_again1",
        "lemma_set_union_again2",
        "lemma_set_properties"
      ],
      "exists": [
        "lemma_map_new_values",
        "lemma_map_properties",
        "axiom_multiset_empty",
        "lemma_multiset_empty_len",
        "lemma_multiset_properties",
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "lemma_filter_map_contains",
        "lemma_seq_contains",
        "lemma_seq_subrange_elements",
        "lemma_seq_take_contains",
        "lemma_seq_skip_contains",
        "lemma_seq_properties",
        "lemma_map_size",
        "lemma_set_empty_equivalency_len",
        "lemma_set_properties",
        "axiom_is_empty",
        "lemma_hashmap_deepview_properties"
      ],
      "filter": [
        "filter",
        "axiom_multiset_ext_equal",
        "axiom_multiset_ext_equal_deep",
        "axiom_len_empty",
        "axiom_len_singleton",
        "axiom_len_add",
        "axiom_len_sub",
        "axiom_count_le_len",
        "axiom_filter_count",
        "lemma_filter_len",
        "lemma_filter_pred",
        "lemma_filter_contains",
        "filter_lemma",
        "filter_distributes_over_add",
        "lemma_filter_contains_rev",
        "lemma_filter_eq_filter_alt",
        "filter",
        "filter",
        "lemma_len_filter"
      ],
      "Multiset": [
        "axiom_multiset_empty",
        "lemma_multiset_empty_len",
        "axiom_multiset_contained",
        "axiom_multiset_new_not_contained",
        "axiom_multiset_singleton",
        "axiom_multiset_singleton_different",
        "axiom_multiset_add",
        "axiom_multiset_sub",
        "axiom_multiset_ext_equal",
        "axiom_multiset_ext_equal_deep",
        "axiom_len_empty",
        "axiom_len_singleton",
        "axiom_len_add",
        "axiom_len_sub",
        "axiom_count_le_len",
        "axiom_filter_count",
        "axiom_choose_count",
        "axiom_multiset_always_finite",
        "lemma_update_same",
        "lemma_update_different",
        "lemma_insert_containment",
        "lemma_insert_increases_count_by_1",
        "lemma_insert_non_decreasing",
        "lemma_insert_other_elements_unchanged",
        "lemma_insert_len",
        "lemma_intersection_count",
        "lemma_left_pseudo_idempotence",
        "lemma_right_pseudo_idempotence",
        "lemma_difference_count",
        "lemma_difference_bottoms_out",
        "lemma_multiset_properties",
        "lemma_is_singleton_contains_elem_equal_singleton",
        "lemma_is_singleton",
        "to_multiset",
        "to_multiset",
        "multiset",
        "empty"
      ],
      "difference": [
        "empty",
        "split",
        "difference",
        "axiom_set_difference",
        "axiom_set_difference_finite",
        "lemma_set_insert_diff_decreases",
        "lemma_len_difference",
        "lemma_set_difference2",
        "lemma_set_disjoint",
        "lemma_set_difference_len",
        "lemma_set_properties"
      ],
      "push": [
        "tracked_push",
        "axiom_seq_empty",
        "axiom_seq_new_len",
        "axiom_seq_new_index",
        "axiom_seq_push_len",
        "axiom_seq_push_index_same",
        "axiom_seq_push_index_different",
        "push_distributes_over_add",
        "to_multiset_ensures",
        "lemma_add_last_back",
        "lemma_take_succ_push",
        "lemma_flatten_push",
        "to_multiset_build",
        "lemma_seq_contains_after_push",
        "lemma_seq_skip_build_commut",
        "lemma_seq_properties"
      ],
      "take": [
        "tracked_pop",
        "take",
        "lemma_take_succ",
        "lemma_take_succ_push",
        "lemma_take_len",
        "lemma_seq_take_len",
        "lemma_seq_take_contains",
        "lemma_seq_take_index",
        "subrange_of_matching_take",
        "lemma_seq_append_take_skip",
        "lemma_seq_take_update_commut1",
        "lemma_seq_take_update_commut2",
        "lemma_seq_take_nothing",
        "lemma_seq_properties",
        "take",
        "take",
        "take"
      ],
      "subrange": [
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "axiom_seq_subrange_decreases",
        "axiom_seq_subrange_len",
        "axiom_seq_subrange_index",
        "lemma_fold_left_split",
        "lemma_fold_right_split",
        "lemma_split_at",
        "lemma_element_from_slice",
        "lemma_slice_of_slice",
        "lemma_subrange_max",
        "lemma_subrange_min",
        "lemma_seq_subrange_elements",
        "subrange_of_matching_take",
        "lemma_seq_properties",
        "slice_subrange",
        "split"
      ],
      "map": [
        "lemma_to_set_map_commutes",
        "map",
        "lemma_set_map_insert_commute",
        "lemma_map_union_commute",
        "lemma_any_map_preserved_pred",
        "lemma_map_finite",
        "lemma_sets_eq_iff_injective_map_eq",
        "map",
        "lemma_hashmap_deepview_dom",
        "lemma_hashmap_deepview_values",
        "map",
        "empty",
        "insert",
        "remove",
        "into_map",
        "from_map",
        "into_map",
        "from_map"
      ],
      "intersect": [
        "intersect",
        "axiom_set_intersect",
        "axiom_set_intersect_finite",
        "lemma_len_intersect",
        "lemma_set_intersect_again1",
        "lemma_set_intersect_again2",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "lemma_set_properties"
      ],
      "fold": [
        "lemma_fold_insert",
        "lemma_fold_empty"
      ]
    },
    "by_type": {
      "Seq": {
        "functions": [
          "spec_u16_to_le_bytes",
          "spec_u16_from_le_bytes",
          "spec_u32_to_le_bytes",
          "spec_u32_from_le_bytes",
          "spec_u64_to_le_bytes",
          "spec_u64_from_le_bytes",
          "spec_u128_to_le_bytes",
          "spec_u128_from_le_bytes",
          "validate_multiple",
          "lemma_new_first_element_still_sorted_by",
          "empty",
          "new",
          "tracked_empty",
          "axiom_seq_index_decreases",
          "axiom_seq_len_decreases",
          "axiom_seq_subrange_decreases",
          "axiom_seq_empty",
          "axiom_seq_new_len",
          "axiom_seq_new_index",
          "axiom_seq_push_len",
          "axiom_seq_push_index_same",
          "axiom_seq_push_index_different",
          "axiom_seq_update_len",
          "axiom_seq_update_same",
          "axiom_seq_update_different",
          "axiom_seq_ext_equal",
          "axiom_seq_ext_equal_deep",
          "axiom_seq_subrange_len",
          "axiom_seq_subrange_index",
          "axiom_seq_add_len",
          "axiom_seq_add_index1",
          "axiom_seq_add_index2",
          "lemma_element_from_slice",
          "lemma_to_set_insert_commutes",
          "lemma_take_succ",
          "lemma_flat_map_singleton",
          "lemma_prefix_append_unique",
          "lemma_concat_injective",
          "unzip",
          "lemma_flatten_push",
          "lemma_max_of_concat",
          "lemma_min_of_concat",
          "to_multiset_build",
          "to_multiset_remove",
          "to_multiset_insert",
          "to_multiset_len",
          "to_multiset_contains",
          "to_multiset_update",
          "lemma_update_is_remove_insert",
          "lemma_append_last",
          "lemma_concat_associative",
          "seq_to_set_is_finite",
          "seq_to_set_distributes_over_add",
          "lemma_no_dup_in_concat",
          "lemma_flatten_concat",
          "lemma_flatten_alt_concat",
          "lemma_seq_union_to_multiset_commutative",
          "lemma_multiset_commutative",
          "lemma_sorted_unique",
          "lemma_seq_contains",
          "lemma_seq_empty_contains_nothing",
          "lemma_seq_empty_equality",
          "lemma_seq_concat_contains_all_elements",
          "lemma_seq_contains_after_push",
          "lemma_seq_subrange_elements",
          "lemma_fold_right_permutation",
          "lemma_fold_left_permutation",
          "lemma_seq_take_len",
          "lemma_seq_take_contains",
          "lemma_seq_take_index",
          "subrange_of_matching_take",
          "lemma_seq_skip_len",
          "lemma_seq_skip_contains",
          "lemma_seq_skip_index",
          "lemma_seq_skip_index2",
          "lemma_seq_append_take_skip",
          "lemma_seq_take_update_commut1",
          "lemma_seq_take_update_commut2",
          "lemma_seq_skip_update_commut1",
          "lemma_seq_skip_update_commut2",
          "lemma_seq_skip_build_commut",
          "lemma_seq_skip_nothing",
          "lemma_seq_take_nothing",
          "lemma_seq_skip_of_skip",
          "lemma_seq_properties",
          "view",
          "new",
          "agree",
          "update_subrange_with",
          "view",
          "agree",
          "update",
          "update_map",
          "new"
        ],
        "open_specs": [
          "array_view",
          "spec_u64_to_le_bytes_open",
          "prefixed_entries",
          "combine_values",
          "sorted_by",
          "take",
          "skip",
          "spec_add",
          "map",
          "map_values",
          "flat_map",
          "drop_last",
          "drop_first",
          "insert",
          "remove",
          "remove_value",
          "reverse",
          "zip_with",
          "remove_duplicates",
          "filter_map",
          "filter_alt",
          "flatten",
          "flatten_alt",
          "check_argument_is_seq",
          "to_seq",
          "to_sorted_seq",
          "seq_to_map",
          "subrange_abs",
          "subrange_abs"
        ]
      },
      "Vec": {
        "functions": [
          "u16_to_le_bytes",
          "u32_to_le_bytes",
          "u64_to_le_bytes",
          "u128_to_le_bytes",
          "slice_to_vec",
          "spec_vec_len",
          "axiom_spec_len",
          "vec_clone_deep_view_proof",
          "axiom_vec_index_decreases",
          "spec_into_iter",
          "axiom_spec_into_iter",
          "spec_vec_dequeue_len",
          "axiom_spec_len",
          "axiom_vec_dequeue_index_decreases",
          "spec_iter",
          "axiom_spec_iter"
        ],
        "open_specs": [
          "vec_clone_trigger",
          "vec_dequeue_clone_trigger"
        ]
      },
      "Map": {
        "functions": [
          "axiom_hash_map_with_view_spec_len",
          "axiom_string_hash_map_spec_len",
          "empty",
          "insert",
          "remove",
          "tracked_empty",
          "tracked_insert",
          "tracked_remove",
          "tracked_borrow",
          "tracked_map_keys",
          "tracked_remove_keys",
          "tracked_union_prefer_right",
          "axiom_map_index_decreases",
          "axiom_map_index_decreases_finite",
          "axiom_map_index_decreases_infinite",
          "axiom_map_empty",
          "axiom_map_insert_domain",
          "axiom_map_insert_same",
          "axiom_map_insert_different",
          "axiom_map_remove_domain",
          "axiom_map_remove_different",
          "axiom_map_ext_equal",
          "axiom_map_ext_equal_deep",
          "tracked_map_keys_in_place",
          "lemma_union_insert_left",
          "lemma_union_insert_right",
          "lemma_union_remove_left",
          "lemma_union_remove_right",
          "lemma_union_dom",
          "lemma_disjoint_union_size",
          "lemma_submap_of_trans",
          "lemma_map_new_domain",
          "lemma_map_new_values",
          "lemma_map_properties",
          "lemma_values_finite",
          "from_map",
          "axiom_multiset_contained",
          "axiom_multiset_new_not_contained",
          "validate_multiple",
          "mk_map",
          "builds_valid_hashers",
          "spec_hash_map_iter",
          "axiom_spec_hash_map_iter",
          "lemma_hashmap_deepview_dom",
          "lemma_hashmap_deepview_properties",
          "lemma_hashmap_deepview_values",
          "axiom_hashmap_deepview_borrow",
          "axiom_hashmap_view_finite_dom",
          "spec_hash_map_len",
          "axiom_spec_hash_map_len",
          "contains_borrowed_key",
          "axiom_contains_deref_key",
          "axiom_contains_box",
          "maps_borrowed_key_to_value",
          "axiom_maps_deref_key_to_value",
          "axiom_maps_box_key_to_value",
          "borrowed_key_removed",
          "axiom_deref_key_removed",
          "axiom_box_key_removed",
          "axiom_hashmap_decreases",
          "alloc",
          "validate",
          "exchange",
          "deposit",
          "withdraw",
          "exchange_nondeterministic",
          "guard",
          "validate_with_shared",
          "exchange_with_shared",
          "exchange_nondeterministic_with_shared",
          "view",
          "dummy",
          "take",
          "empty",
          "insert",
          "new",
          "view",
          "empty",
          "agree",
          "update",
          "agree_map",
          "update_map",
          "map",
          "empty",
          "into_map",
          "from_map",
          "into_map",
          "from_map"
        ],
        "open_specs": [
          "total",
          "new",
          "check_argument_is_map",
          "map_entries",
          "map_values",
          "invert",
          "hash_map_deep_view_impl",
          "guards",
          "exchanges",
          "exchanges_nondeterministic",
          "deposits",
          "withdraws",
          "set_op",
          "seq_to_map"
        ]
      },
      "Set": {
        "functions": [
          "axiom_hash_set_with_view_spec_len",
          "axiom_string_hash_set_spec_len",
          "dom",
          "tracked_empty",
          "tracked_insert",
          "tracked_remove",
          "tracked_borrow",
          "tracked_map_keys",
          "tracked_remove_keys",
          "tracked_union_prefer_right",
          "axiom_map_index_decreases",
          "axiom_map_index_decreases_finite",
          "axiom_map_index_decreases_infinite",
          "axiom_map_empty",
          "lemma_remove_keys_len",
          "lemma_map_new_domain",
          "lemma_map_new_values",
          "lemma_map_properties",
          "update_nondeterministic",
          "update_nondeterministic_with_shared",
          "dom",
          "empty",
          "split",
          "empty",
          "new",
          "insert",
          "remove",
          "union",
          "intersect",
          "difference",
          "complement",
          "lemma_finite_set_induct",
          "lemma_fold_insert",
          "lemma_fold_empty",
          "axiom_set_empty",
          "axiom_set_new",
          "axiom_set_insert_same",
          "axiom_set_insert_different",
          "axiom_set_remove_same",
          "axiom_set_remove_insert",
          "axiom_set_remove_different",
          "axiom_set_union",
          "axiom_set_intersect",
          "axiom_set_difference",
          "axiom_set_complement",
          "axiom_set_ext_equal",
          "axiom_set_ext_equal_deep",
          "axiom_mk_map_domain",
          "axiom_mk_map_index",
          "axiom_set_empty_finite",
          "axiom_set_insert_finite",
          "axiom_set_remove_finite",
          "axiom_set_union_finite",
          "axiom_set_intersect_finite",
          "axiom_set_difference_finite",
          "axiom_set_choose_infinite",
          "axiom_set_empty_len",
          "axiom_set_insert_len",
          "axiom_set_remove_len",
          "axiom_set_contains_len",
          "axiom_set_choose_len",
          "lemma_len0_is_empty",
          "lemma_is_singleton",
          "lemma_set_insert_diff_decreases",
          "lemma_subset_not_in_lt",
          "lemma_map_union_commute",
          "lemma_filter_map_insert",
          "lemma_filter_map_union",
          "lemma_set_all_subset",
          "flatten_insert_union_commute",
          "lemma_sets_eq_iff_injective_map_eq",
          "lemma_set_insert_finite_iff",
          "lemma_set_remove_finite_iff",
          "lemma_set_union_finite_iff",
          "lemma_set_union_finite_implies_sets_finite",
          "lemma_len_union",
          "lemma_len_union_ind",
          "lemma_len_intersect",
          "lemma_len_subset",
          "lemma_set_subset_finite",
          "lemma_len_difference",
          "lemma_subset_equality",
          "lemma_map_size",
          "lemma_set_union_again1",
          "lemma_set_union_again2",
          "lemma_set_intersect_again1",
          "lemma_set_intersect_again2",
          "lemma_set_difference2",
          "lemma_set_disjoint",
          "lemma_set_empty_equivalency_len",
          "lemma_set_disjoint_lens",
          "lemma_set_intersect_union_lens",
          "lemma_set_difference_len",
          "lemma_set_properties",
          "axiom_is_empty",
          "axiom_is_empty_len0",
          "builds_valid_hashers",
          "spec_hash_set_len",
          "axiom_spec_hash_set_len",
          "set_contains_borrowed_key",
          "axiom_set_contains_deref_key",
          "axiom_set_contains_box",
          "sets_borrowed_key_to_key",
          "axiom_set_deref_key_to_value",
          "axiom_set_box_key_to_value",
          "sets_differ_by_borrowed_key",
          "axiom_set_deref_key_removed",
          "axiom_set_box_key_removed",
          "axiom_hashset_decreases",
          "exchange_nondeterministic",
          "exchange_nondeterministic_with_shared",
          "split",
          "new",
          "set",
          "empty"
        ],
        "open_specs": [
          "values",
          "kv_pairs",
          "remove_keys",
          "restrict",
          "from_set",
          "dom",
          "frame_preserving_update_nondeterministic",
          "set_op",
          "is_least",
          "is_minimal",
          "is_greatest",
          "is_maximal",
          "to_set",
          "full",
          "subset_of",
          "spec_le",
          "spec_add",
          "spec_mul",
          "spec_sub",
          "filter",
          "map",
          "filter_map",
          "flatten",
          "set_int_range",
          "check_argument_is_set",
          "exchanges_nondeterministic",
          "set_op",
          "dom",
          "dom",
          "dom"
        ]
      },
      "Multiset": {
        "functions": [
          "axiom_multiset_empty",
          "lemma_multiset_empty_len",
          "axiom_multiset_contained",
          "axiom_multiset_new_not_contained",
          "axiom_multiset_singleton",
          "axiom_multiset_singleton_different",
          "axiom_multiset_add",
          "axiom_multiset_sub",
          "axiom_multiset_ext_equal",
          "axiom_multiset_ext_equal_deep",
          "axiom_len_empty",
          "axiom_len_singleton",
          "axiom_len_add",
          "axiom_len_sub",
          "axiom_count_le_len",
          "axiom_filter_count",
          "axiom_choose_count",
          "axiom_multiset_always_finite",
          "lemma_update_same",
          "lemma_update_different",
          "lemma_insert_containment",
          "lemma_insert_increases_count_by_1",
          "lemma_insert_non_decreasing",
          "lemma_insert_other_elements_unchanged",
          "lemma_insert_len",
          "lemma_intersection_count",
          "lemma_left_pseudo_idempotence",
          "lemma_right_pseudo_idempotence",
          "lemma_difference_count",
          "lemma_difference_bottoms_out",
          "lemma_multiset_properties",
          "lemma_is_singleton_contains_elem_equal_singleton",
          "lemma_is_singleton",
          "to_multiset",
          "multiset",
          "empty"
        ],
        "open_specs": [
          "to_multiset"
        ]
      }
    },
    "callers": {
      "lemma_div_is_div_recursive": [],
      "lemma_div_by_self": [
        "lemma_div_by_self",
        "lemma_div_basics",
        "vstd::arithmetic::internals::div_internals::lemma_div_basics"
      ],
      "lemma_div_of0": [
        "lemma_div_of0",
        "lemma_div_basics"
      ],
      "lemma_div_basics": [
        "lemma_div_basics_1",
        "lemma_div_basics_2",
        "lemma_div_basics_3",
        "lemma_div_multiples_vanish_fancy",
        "lemma_div_auto"
      ],
      "lemma_div_basics_1": [],
      "lemma_div_basics_2": [],
      "lemma_div_basics_3": [],
      "lemma_div_basics_4": [],
      "lemma_div_basics_5": [],
      "lemma_small_div_converse": [],
      "lemma_div_non_zero": [],
      "lemma_div_is_ordered_by_denominator": [
        "lemma_div_basics_5",
        "lemma_div_is_ordered_by_denominator"
      ],
      "lemma_div_is_strictly_smaller": [],
      "lemma_dividing_sums": [],
      "lemma_div_pos_is_pos": [
        "lemma_div_basics_5",
        "lemma_breakdown",
        "lemma_mod_breakdown"
      ],
      "lemma_div_plus_one": [],
      "lemma_div_minus_one": [],
      "lemma_basic_div_specific_divisor": [
        "lemma_basic_div"
      ],
      "lemma_basic_div": [],
      "lemma_div_is_ordered": [
        "lemma_div_is_ordered_by_denominator",
        "lemma_mul_hoist_inequality"
      ],
      "lemma_div_decreases": [],
      "lemma_div_nonincreasing": [],
      "lemma_small_mod": [
        "lemma_small_mod",
        "lemma_breakdown",
        "lemma_mod_is_zero",
        "lemma_part_bound2",
        "lemma_mod_breakdown",
        "lemma_mod_below_denominator"
      ],
      "lemma_breakdown": [],
      "lemma_remainder_upper": [],
      "lemma_remainder_lower": [],
      "lemma_remainder": [],
      "lemma_fundamental_div_mod": [
        "lemma_dividing_sums",
        "lemma_breakdown",
        "lemma_fundamental_div_mod",
        "lemma_mul_hoist_inequality",
        "lemma_truncate_middle",
        "lemma_hoist_over_denominator",
        "lemma_part_bound1",
        "lemma_mod_ordering",
        "lemma_mod_mod",
        "lemma_mod_breakdown",
        "vstd::arithmetic::internals::div_internals::lemma_div_basics",
        "lemma_div_add_denominator",
        "lemma_div_sub_denominator",
        "lemma_mod_add_denominator",
        "lemma_mod_sub_denominator",
        "lemma_mod_auto",
        "lemma_pow_division_inequality"
      ],
      "lemma_div_denominator": [
        "lemma_truncate_middle",
        "lemma_div_multiples_vanish_quotient"
      ],
      "lemma_mul_hoist_inequality": [],
      "lemma_indistinguishable_quotients": [],
      "lemma_truncate_middle": [
        "lemma_breakdown",
        "lemma_mod_breakdown"
      ],
      "lemma_div_multiples_vanish_quotient": [],
      "lemma_round_down": [],
      "lemma_div_multiples_vanish_fancy": [
        "lemma_div_multiples_vanish"
      ],
      "lemma_div_multiples_vanish": [
        "lemma_mul_hoist_inequality",
        "lemma_div_multiples_vanish_quotient",
        "lemma_div_by_multiple",
        "lemma_multiply_divide_le",
        "lemma_multiply_divide_lt",
        "lemma_log_pow"
      ],
      "lemma_div_by_multiple": [
        "lemma_truncate_middle",
        "lemma_pow_subtracts"
      ],
      "lemma_div_by_multiple_is_strongly_ordered": [],
      "lemma_multiply_divide_le": [],
      "lemma_multiply_divide_lt": [],
      "lemma_hoist_over_denominator": [],
      "lemma_part_bound1": [
        "lemma_breakdown",
        "lemma_mod_breakdown"
      ],
      "lemma_mod_is_mod_recursive": [],
      "lemma_mod_self_0": [],
      "lemma_mod_twice": [],
      "lemma_mod_division_less_than_divisor": [],
      "lemma_mod_decreases": [
        "lemma_mod_ordering"
      ],
      "lemma_mod_is_zero": [],
      "lemma_mod_multiples_basic": [
        "lemma_div_by_multiple_is_strongly_ordered",
        "lemma_multiply_divide_le",
        "lemma_multiply_divide_lt",
        "lemma_pow_mod"
      ],
      "lemma_mod_add_multiples_vanish": [],
      "lemma_mod_sub_multiples_vanish": [],
      "lemma_mod_multiples_vanish": [
        "lemma_mod_ordering",
        "lemma_low_bits_mask_is_odd"
      ],
      "lemma_mod_subtraction": [],
      "lemma_add_mod_noop": [],
      "lemma_add_mod_noop_right": [],
      "lemma_sub_mod_noop": [],
      "lemma_sub_mod_noop_right": [],
      "lemma_mod_adds": [
        "lemma_breakdown",
        "lemma_mod_breakdown"
      ],
      "lemma_mod_neg_neg": [],
      "lemma_fundamental_div_mod_converse_mod": [
        "lemma_fundamental_div_mod_converse"
      ],
      "lemma_fundamental_div_mod_converse_div": [
        "lemma_fundamental_div_mod_converse"
      ],
      "lemma_fundamental_div_mod_converse": [
        "lemma_hoist_over_denominator",
        "lemma_mod_mod"
      ],
      "lemma_mod_pos_bound": [],
      "lemma_mod_bound": [],
      "lemma_mul_mod_noop_left": [
        "lemma_mul_mod_noop_general",
        "lemma_mod_mul_equivalent"
      ],
      "lemma_mul_mod_noop_right": [
        "lemma_mul_mod_noop_general"
      ],
      "lemma_mul_mod_noop_general": [
        "lemma_mul_mod_noop",
        "lemma_pow_mod_noop"
      ],
      "lemma_mul_mod_noop": [],
      "lemma_mod_equivalence": [
        "lemma_mod_mul_equivalent"
      ],
      "lemma_mod_mul_equivalent": [],
      "lemma_mod_ordering": [],
      "lemma_mod_mod": [],
      "lemma_part_bound2": [
        "lemma_breakdown",
        "lemma_mod_breakdown"
      ],
      "lemma_mod_breakdown": [],
      "vstd::arithmetic::internals::div_internals::lemma_div_basics": [],
      "lemma_div_auto": [
        "lemma_div_pos_is_pos",
        "lemma_div_plus_one",
        "lemma_div_minus_one",
        "lemma_basic_div_specific_divisor",
        "lemma_div_is_ordered",
        "lemma_div_multiples_vanish_fancy",
        "lemma_mod_adds"
      ],
      "lemma_div_induction_auto": [
        "lemma_div_is_div_recursive",
        "lemma_small_div_converse",
        "lemma_div_is_strictly_smaller",
        "lemma_div_pos_is_pos",
        "lemma_div_is_ordered",
        "lemma_div_decreases",
        "lemma_div_nonincreasing",
        "lemma_remainder_upper",
        "lemma_remainder_lower",
        "lemma_remainder",
        "lemma_indistinguishable_quotients",
        "lemma_round_down",
        "lemma_div_by_multiple_is_strongly_ordered",
        "lemma_multiply_divide_le",
        "lemma_multiply_divide_lt"
      ],
      "lemma_div_induction_auto_forall": [],
      "vstd::arithmetic::internals::div_internals_nonlinear::lemma_div_of0": [],
      "vstd::arithmetic::internals::div_internals_nonlinear::lemma_div_by_self": [],
      "lemma_small_div": [
        "vstd::arithmetic::internals::div_internals::lemma_div_basics"
      ],
      "lemma_induction_helper": [
        "lemma_mod_induction_forall",
        "lemma_mul_induction"
      ],
      "lemma_mod_induction_forall": [
        "lemma_mod_induction_forall2"
      ],
      "lemma_mod_induction_forall2": [],
      "lemma_div_add_denominator": [
        "lemma_mod_basics"
      ],
      "lemma_div_sub_denominator": [
        "lemma_mod_basics"
      ],
      "lemma_mod_add_denominator": [
        "lemma_mod_basics"
      ],
      "lemma_mod_sub_denominator": [
        "lemma_mod_basics"
      ],
      "lemma_mod_below_denominator": [
        "lemma_mod_basics"
      ],
      "lemma_mod_basics": [
        "vstd::arithmetic::internals::div_internals::lemma_div_basics",
        "lemma_mod_auto"
      ],
      "lemma_quotient_and_remainder": [
        "lemma_mod_auto"
      ],
      "lemma_mod_auto": [
        "lemma_mod_self_0",
        "lemma_mod_twice",
        "lemma_mod_division_less_than_divisor",
        "lemma_mod_decreases",
        "lemma_mod_multiples_basic",
        "lemma_mod_add_multiples_vanish",
        "lemma_mod_sub_multiples_vanish",
        "lemma_mod_subtraction",
        "lemma_add_mod_noop",
        "lemma_add_mod_noop_right",
        "lemma_sub_mod_noop",
        "lemma_sub_mod_noop_right",
        "lemma_mod_neg_neg",
        "lemma_mod_pos_bound",
        "lemma_mul_mod_noop_left",
        "lemma_mul_mod_noop_right",
        "lemma_mod_equivalence",
        "vstd::arithmetic::internals::div_internals::lemma_div_basics",
        "lemma_div_auto"
      ],
      "lemma_mod_induction_auto": [],
      "lemma_mod_induction_auto_forall": [],
      "vstd::arithmetic::internals::mod_internals_nonlinear::lemma_fundamental_div_mod": [],
      "vstd::arithmetic::internals::mod_internals_nonlinear::lemma_small_mod": [],
      "lemma_mod_range": [
        "lemma_mod_bound",
        "lemma_mod_below_denominator"
      ],
      "lemma_mul_induction": [
        "lemma_div_multiples_vanish_fancy",
        "lemma_mod_multiples_basic",
        "lemma_mod_neg_neg",
        "lemma_mul_distributes_plus",
        "lemma_mul_distributes_minus"
      ],
      "lemma_mul_commutes": [],
      "lemma_mul_distributes_plus": [],
      "lemma_mul_distributes_minus": [],
      "lemma_mul_induction_auto": [
        "lemma_mul_mod_noop_left",
        "lemma_mul_mod_noop_right",
        "lemma_mul_is_mul_pos",
        "lemma_mul_inequality",
        "lemma_mul_left_inequality",
        "lemma_mul_equality_converse",
        "lemma_mul_inequality_converse",
        "lemma_mul_strict_inequality_converse",
        "lemma_mul_strictly_increases",
        "lemma_mul_increases",
        "lemma_mul_nonnegative",
        "lemma_mul_unary_negation",
        "lemma_mul_cancels_negatives",
        "lemma_pow_positive",
        "lemma_pow_strictly_increases"
      ],
      "lemma_mul_induction_auto_forall": [],
      "lemma_mul_strictly_positive": [
        "lemma_div_multiples_vanish_quotient",
        "lemma_part_bound1",
        "vstd::arithmetic::mul::lemma_mul_strictly_positive"
      ],
      "lemma_mul_nonzero": [
        "vstd::arithmetic::mul::lemma_mul_nonzero"
      ],
      "lemma_mul_is_associative": [
        "lemma_mul_is_mul_recursive",
        "vstd::arithmetic::mul::lemma_mul_is_associative"
      ],
      "lemma_mul_is_distributive_add": [
        "lemma_div_multiples_vanish_fancy",
        "lemma_hoist_over_denominator",
        "vstd::arithmetic::mul::lemma_mul_is_distributive_add"
      ],
      "lemma_mul_ordering": [
        "vstd::arithmetic::mul::lemma_mul_ordering"
      ],
      "lemma_mul_strict_inequality": [
        "vstd::arithmetic::mul::lemma_mul_strict_inequality"
      ],
      "lemma_log0": [],
      "lemma_log_s": [
        "lemma_log_pow"
      ],
      "lemma_log_nonnegative": [
        "lemma_log_nonnegative",
        "lemma_log_is_ordered"
      ],
      "lemma_log_is_ordered": [
        "lemma_log_is_ordered"
      ],
      "lemma_log_pow": [
        "lemma_log_pow"
      ],
      "lemma_mul_is_mul_recursive": [],
      "lemma_mul_is_mul_pos": [
        "lemma_mul_is_mul_recursive"
      ],
      "lemma_mul_basics": [
        "lemma_div_multiples_vanish_fancy",
        "lemma_mul_by_zero_is_zero"
      ],
      "lemma_mul_basics_1": [],
      "lemma_mul_basics_2": [],
      "lemma_mul_basics_3": [],
      "lemma_mul_basics_4": [],
      "vstd::arithmetic::mul::lemma_mul_nonzero": [],
      "lemma_mul_by_zero_is_zero": [
        "mul_value",
        "mul_checked"
      ],
      "vstd::arithmetic::mul::lemma_mul_is_associative": [],
      "lemma_mul_is_commutative": [
        "lemma_multiply_divide_lt",
        "lemma_hoist_over_denominator",
        "lemma_log_pow",
        "lemma_mul_is_distributive_sub_other_way",
        "mul_value"
      ],
      "vstd::arithmetic::mul::lemma_mul_ordering": [],
      "lemma_mul_inequality": [
        "lemma_div_add_denominator",
        "lemma_div_sub_denominator",
        "lemma_mod_add_denominator",
        "lemma_mod_sub_denominator",
        "lemma_mul_upper_bound",
        "lemma_mul_strict_upper_bound",
        "mul_value",
        "mul_checked",
        "lemma_pow_division_inequality"
      ],
      "vstd::arithmetic::mul::lemma_mul_strict_inequality": [],
      "lemma_mul_upper_bound": [],
      "lemma_mul_strict_upper_bound": [],
      "lemma_mul_left_inequality": [
        "lemma_pow_strictly_increases"
      ],
      "lemma_mul_equality_converse": [],
      "lemma_mul_inequality_converse": [],
      "lemma_mul_strict_inequality_converse": [],
      "vstd::arithmetic::mul::lemma_mul_is_distributive_add": [],
      "lemma_mul_is_distributive_add_other_way": [],
      "lemma_mul_is_distributive_sub": [
        "lemma_div_multiples_vanish_fancy",
        "lemma_mul_is_distributive_sub_other_way"
      ],
      "lemma_mul_is_distributive_sub_other_way": [],
      "vstd::arithmetic::mul::lemma_mul_strictly_positive": [],
      "lemma_mul_strictly_increases": [
        "lemma_mod_ordering",
        "lemma_pow_strictly_increases"
      ],
      "lemma_mul_increases": [
        "lemma_breakdown",
        "lemma_mod_breakdown",
        "lemma_log_pow"
      ],
      "lemma_mul_nonnegative": [
        "lemma_breakdown",
        "lemma_mul_hoist_inequality",
        "lemma_div_multiples_vanish_quotient",
        "lemma_mod_breakdown",
        "lemma_pow_multiplies",
        "lemma_pull_out_pows"
      ],
      "lemma_mul_unary_negation": [],
      "lemma_mul_cancels_negatives": [],
      "spec_new": [],
      "new": [
        "vstd::cell::id",
        "dom",
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_remove_keys",
        "tracked_union_prefer_right",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "axiom_map_index_decreases_infinite",
        "axiom_map_empty",
        "lemma_map_new_domain",
        "lemma_map_new_values",
        "count",
        "len",
        "vstd::multiset::empty",
        "from_map",
        "lemma_update_same",
        "lemma_update_different",
        "lemma_intersection_count",
        "lemma_difference_count",
        "unzip",
        "lemma_len_filter",
        "axiom_maps_box_key_to_value",
        "vstd::tokens::frac::update",
        "dummy",
        "vstd::tokens::map::dummy",
        "vstd::tokens::seq::view",
        "vstd::tokens::seq::dummy",
        "vstd::tokens::seq::split",
        "map",
        "set"
      ],
      "new_overflowed": [],
      "is_overflowed": [],
      "unwrap": [],
      "to_option": [],
      "add_value": [
        "add_checked"
      ],
      "add_checked": [],
      "mul_value": [
        "mul_checked"
      ],
      "mul_checked": [],
      "lemma_pow0": [
        "lemma_pow1",
        "lemma_pow_adds",
        "lemma_pow_multiplies"
      ],
      "lemma_pow1": [
        "lemma_pow_strictly_increases"
      ],
      "lemma0_pow": [
        "lemma0_pow"
      ],
      "lemma1_pow": [
        "lemma1_pow",
        "lemma_pow_increases"
      ],
      "lemma_square_is_pow2": [],
      "lemma_pow_positive": [
        "lemma_log_pow",
        "lemma_pow_strictly_increases",
        "lemma_pull_out_pows",
        "lemma_pow2_pos"
      ],
      "lemma_pow_adds": [
        "lemma_pow_adds",
        "lemma_pow_sub_add_cancel",
        "lemma_pow_multiplies",
        "lemma_pow_strictly_increases",
        "lemma_pow_division_inequality",
        "lemma_pow2_adds"
      ],
      "lemma_pow_sub_add_cancel": [
        "lemma_pow_subtracts"
      ],
      "lemma_pow_subtracts": [
        "lemma_pow2_subtracts"
      ],
      "lemma_pow_multiplies": [
        "lemma_pow_multiplies",
        "lemma_pull_out_pows"
      ],
      "lemma_pow_distributes": [
        "lemma_pow_distributes"
      ],
      "lemma_pow_strictly_increases": [
        "lemma_pow_increases",
        "lemma_pow_increases_converse",
        "lemma_pow2_strictly_increases"
      ],
      "lemma_pow_increases": [
        "lemma_pow_strictly_increases_converse"
      ],
      "lemma_pow_strictly_increases_converse": [],
      "lemma_pow_increases_converse": [],
      "lemma_pull_out_pows": [],
      "lemma_pow_division_inequality": [],
      "lemma_pow_mod": [],
      "lemma_pow_mod_noop": [
        "lemma_pow_mod_noop"
      ],
      "lemma_pow2_pos": [
        "lemma_low_bits_mask_unfold"
      ],
      "lemma_pow2": [
        "lemma_pow2",
        "lemma_pow2_unfold",
        "lemma_pow2_adds",
        "lemma_pow2_subtracts",
        "lemma_pow2_strictly_increases"
      ],
      "lemma_pow2_unfold": [
        "lemma_low_bits_mask_unfold"
      ],
      "lemma_pow2_adds": [],
      "lemma_pow2_subtracts": [],
      "lemma_pow2_strictly_increases": [],
      "lemma2_to64": [],
      "lemma2_to64_rest": [],
      "lemma_array_index": [],
      "array_index_get": [],
      "array_len_matches_n": [],
      "spec_array_as_slice": [],
      "axiom_spec_array_as_slice": [],
      "spec_array_fill_for_copy_type": [],
      "axiom_spec_array_fill_for_copy_type": [],
      "axiom_array_ext_equal": [],
      "view": [
        "view",
        "vstd::atomic::view",
        "vstd::raw_ptr::view",
        "vstd::tokens::frac::view"
      ],
      "vstd::atomic::view": [],
      "id": [
        "view",
        "vstd::atomic::view",
        "id",
        "mem_contents",
        "vstd::tokens::seq::id"
      ],
      "lemma_low_bits_mask_unfold": [
        "lemma_low_bits_mask_is_odd",
        "lemma_low_bits_mask_div2"
      ],
      "lemma_low_bits_mask_is_odd": [],
      "lemma_low_bits_mask_div2": [],
      "lemma_low_bits_mask_values": [],
      "spec_u16_to_le_bytes": [
        "lemma_auto_spec_u16_to_from_le_bytes"
      ],
      "spec_u16_from_le_bytes": [
        "lemma_auto_spec_u16_to_from_le_bytes"
      ],
      "lemma_auto_spec_u16_to_from_le_bytes": [],
      "u16_from_le_bytes": [],
      "u16_to_le_bytes": [],
      "spec_u32_to_le_bytes": [
        "lemma_auto_spec_u32_to_from_le_bytes"
      ],
      "spec_u32_from_le_bytes": [
        "lemma_auto_spec_u32_to_from_le_bytes"
      ],
      "lemma_auto_spec_u32_to_from_le_bytes": [],
      "u32_from_le_bytes": [],
      "u32_to_le_bytes": [],
      "spec_u64_to_le_bytes": [
        "lemma_auto_spec_u64_to_from_le_bytes"
      ],
      "spec_u64_from_le_bytes": [
        "lemma_auto_spec_u64_to_from_le_bytes"
      ],
      "lemma_auto_spec_u64_to_from_le_bytes": [],
      "spec_u64_to_le_bytes_to_open": [],
      "u64_from_le_bytes": [],
      "u64_to_le_bytes": [],
      "spec_u128_to_le_bytes": [
        "lemma_auto_spec_u128_to_from_le_bytes"
      ],
      "spec_u128_from_le_bytes": [
        "lemma_auto_spec_u128_to_from_le_bytes"
      ],
      "lemma_auto_spec_u128_to_from_le_bytes": [],
      "u128_from_le_bytes": [],
      "u128_to_le_bytes": [],
      "vstd::cell::id": [],
      "mem_contents": [
        "mem_contents"
      ],
      "inv": [
        "constant",
        "namespace",
        "vstd::tokens::map::insert"
      ],
      "all_spec_ensures": [
        "all_spec_ensures"
      ],
      "axiom_proof_fn_requires": [],
      "axiom_proof_fn_ensures": [],
      "proof_fn_as_req_ens": [],
      "spec_len": [],
      "axiom_hash_map_with_view_spec_len": [],
      "vstd::hash_map::spec_len": [],
      "axiom_string_hash_map_spec_len": [],
      "vstd::hash_set::spec_len": [],
      "axiom_hash_set_with_view_spec_len": [],
      "axiom_string_hash_set_spec_len": [],
      "constant": [
        "constant",
        "namespace"
      ],
      "namespace": [],
      "vstd::invariant::new": [],
      "into_inner": [],
      "spend_open_invariant_credit_in_proof": [],
      "lemma_obeys_cmp_spec": [],
      "lemma_option_obeys_cmp_spec": [],
      "axiom_structural_obeys_concrete_eq": [],
      "lemma_obeys_eq_spec": [],
      "lemma_obeys_concrete_eq": [],
      "lemma_obeys_view_eq": [],
      "lemma_obeys_deep_eq": [],
      "lemma_option_obeys_eq_spec": [],
      "lemma_option_obeys_concrete_eq": [],
      "lemma_option_obeys_view_eq": [],
      "lemma_option_obeys_deep_eq": [],
      "is_sized": [],
      "size_of": [],
      "align_of": [],
      "layout_for_type_is_valid": [],
      "layout_of_primitives": [],
      "layout_of_unit_tuple": [],
      "layout_of_references_and_pointers": [],
      "layout_of_references_and_pointers_for_sized_types": [],
      "empty": [
        "tracked_empty",
        "tracked_insert",
        "tracked_remove",
        "tracked_borrow",
        "tracked_map_keys",
        "tracked_remove_keys",
        "tracked_union_prefer_right",
        "axiom_map_index_decreases",
        "axiom_map_index_decreases_finite",
        "axiom_map_index_decreases_infinite",
        "axiom_map_empty",
        "lemma_values_finite",
        "axiom_multiset_empty",
        "lemma_multiset_empty_len",
        "to_multiset",
        "lemma_no_dup_set_cardinality",
        "lemma_filter_map_singleton",
        "to_multiset_build",
        "to_multiset_len",
        "to_multiset_contains",
        "lemma_sorted_unique",
        "lemma_fold_empty",
        "axiom_set_choose_len",
        "lemma_len0_is_empty",
        "vstd::set_lib::lemma_singleton_size",
        "lemma_map_finite",
        "lemma_filter_map_finite",
        "lemma_to_seq_to_set_id",
        "lemma_int_range",
        "lemma_subset_equality",
        "lemma_set_empty_equivalency_len",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "deposit",
        "vstd::storage_protocol::update",
        "vstd::tokens::map::dummy",
        "vstd::tokens::map::insert",
        "delete",
        "vstd::tokens::map::new",
        "vstd::tokens::map::update",
        "vstd::tokens::seq::dummy",
        "vstd::tokens::empty"
      ],
      "dom": [
        "axiom_map_insert_domain",
        "axiom_map_remove_domain",
        "axiom_map_ext_equal",
        "axiom_map_ext_equal_deep",
        "lemma_invert_is_injective",
        "lemma_union_dom",
        "lemma_disjoint_union_size",
        "lemma_submap_of_trans",
        "lemma_map_new_values",
        "lemma_values_finite",
        "lemma_update_same",
        "lemma_update_different",
        "lemma_intersection_count",
        "lemma_difference_count",
        "vstd::raw_ptr::provenance",
        "vstd::raw_ptr::dom",
        "lemma_hashmap_deepview_dom",
        "lemma_hashmap_deepview_properties",
        "take_resource",
        "put_resource",
        "delete",
        "map",
        "vstd::tokens::insert",
        "vstd::tokens::remove",
        "into_map",
        "vstd::tokens::from_map",
        "set",
        "vstd::tokens::into_map"
      ],
      "index": [
        "vstd::seq::empty",
        "vstd::seq::new",
        "vstd::seq::len",
        "vstd::seq::index"
      ],
      "insert": [
        "axiom_map_insert_domain",
        "lemma_union_insert_left",
        "lemma_union_insert_right",
        "lemma_values_finite",
        "lemma_update_same",
        "lemma_update_different",
        "lemma_is_singleton",
        "tracked_push",
        "to_multiset",
        "lemma_reverse_to_multiset",
        "unique_seq_to_set",
        "lemma_cardinality_of_set",
        "lemma_no_dup_set_cardinality",
        "to_multiset_build",
        "to_multiset_insert",
        "to_multiset_contains",
        "to_multiset_update",
        "lemma_fold_insert",
        "axiom_set_remove_insert",
        "axiom_set_insert_finite",
        "axiom_set_contains_len",
        "vstd::set_lib::lemma_is_singleton",
        "lemma_set_insert_diff_decreases",
        "lemma_set_map_insert_commute",
        "lemma_filter_map_insert",
        "lemma_map_finite",
        "lemma_filter_map_finite",
        "lemma_to_seq_to_set_id",
        "flatten_insert_union_commute",
        "lemma_set_insert_finite_iff",
        "lemma_set_remove_finite_iff",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_int_range",
        "lemma_map_size",
        "vstd::tokens::insert"
      ],
      "remove": [
        "axiom_map_remove_domain",
        "lemma_remove_keys_len",
        "lemma_union_remove_left",
        "lemma_union_remove_right",
        "lemma_values_finite",
        "lemma_is_singleton",
        "tracked_pop",
        "tracked_pop_front",
        "lemma_cardinality_of_empty_set_is_0",
        "to_multiset_remove",
        "to_multiset_update",
        "lemma_sorted_unique",
        "lemma_fold_right_permutation",
        "axiom_set_remove_insert",
        "axiom_set_remove_finite",
        "axiom_set_contains_len",
        "find_unique_minimal",
        "find_unique_maximal",
        "lemma_len0_is_empty",
        "vstd::set_lib::lemma_singleton_size",
        "vstd::set_lib::lemma_is_singleton",
        "lemma_subset_not_in_lt",
        "lemma_map_finite",
        "lemma_filter_map_finite",
        "lemma_to_seq_to_set_id",
        "lemma_set_insert_finite_iff",
        "lemma_set_remove_finite_iff",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_len_union",
        "lemma_len_union_ind",
        "lemma_len_intersect",
        "lemma_len_difference",
        "lemma_subset_equality",
        "lemma_map_size",
        "lemma_set_empty_equivalency_len",
        "lemma_set_disjoint_lens",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "vstd::tokens::remove"
      ],
      "tracked_empty": [
        "tracked_map_keys_in_place",
        "validate_4",
        "validate_5",
        "withdraw",
        "vstd::storage_protocol::update",
        "vstd::tokens::frac::new",
        "put_resource",
        "vstd::tokens::empty"
      ],
      "tracked_insert": [
        "validate_4",
        "validate_5",
        "tracked_push",
        "put_resource",
        "vstd::tokens::insert"
      ],
      "tracked_remove": [
        "validate_4",
        "validate_5",
        "tracked_pop",
        "tracked_pop_front",
        "take_resource",
        "vstd::tokens::remove"
      ],
      "tracked_borrow": [
        "vstd::tokens::frac::borrow"
      ],
      "tracked_map_keys": [
        "tracked_map_keys_in_place"
      ],
      "tracked_remove_keys": [],
      "tracked_union_prefer_right": [],
      "axiom_map_index_decreases": [],
      "axiom_map_index_decreases_finite": [],
      "axiom_map_index_decreases_infinite": [],
      "axiom_map_empty": [],
      "axiom_map_insert_domain": [],
      "axiom_map_insert_same": [],
      "axiom_map_insert_different": [],
      "axiom_map_remove_domain": [],
      "axiom_map_remove_different": [],
      "axiom_map_ext_equal": [],
      "axiom_map_ext_equal_deep": [],
      "tracked_map_keys_in_place": [],
      "lemma_remove_key_len": [],
      "lemma_remove_equivalency": [],
      "lemma_remove_keys_len": [
        "lemma_remove_keys_len",
        "lemma_disjoint_union_size"
      ],
      "lemma_invert_is_injective": [],
      "lemma_union_insert_left": [],
      "lemma_union_insert_right": [],
      "lemma_union_remove_left": [],
      "lemma_union_remove_right": [],
      "lemma_union_dom": [],
      "lemma_disjoint_union_size": [],
      "lemma_submap_of_trans": [],
      "lemma_map_new_domain": [],
      "lemma_map_new_values": [],
      "lemma_map_properties": [],
      "lemma_values_finite": [
        "lemma_values_finite"
      ],
      "tracked_swap": [
        "tracked_map_keys_in_place",
        "incorporate",
        "split_mut",
        "update_mut",
        "take",
        "combine",
        "vstd::tokens::frac::update",
        "update_with",
        "vstd::tokens::map::take",
        "vstd::tokens::map::insert",
        "delete",
        "vstd::tokens::map::combine",
        "vstd::tokens::map::split",
        "vstd::tokens::map::update",
        "vstd::tokens::seq::split",
        "vstd::tokens::seq::combine"
      ],
      "tracked_static_ref": [],
      "count": [
        "filter",
        "axiom_multiset_contained",
        "axiom_multiset_new_not_contained",
        "axiom_multiset_singleton",
        "axiom_multiset_singleton_different",
        "axiom_multiset_add",
        "axiom_multiset_sub",
        "axiom_multiset_ext_equal",
        "axiom_multiset_ext_equal_deep",
        "axiom_len_empty",
        "axiom_len_singleton",
        "axiom_len_add",
        "axiom_len_sub",
        "axiom_count_le_len",
        "axiom_filter_count",
        "lemma_update_same",
        "lemma_update_different",
        "lemma_intersection_count",
        "lemma_left_pseudo_idempotence",
        "lemma_right_pseudo_idempotence",
        "lemma_difference_count",
        "lemma_is_singleton_contains_elem_equal_singleton",
        "lemma_is_singleton",
        "lemma_sort_by_ensures",
        "lemma_multiset_has_no_duplicates",
        "lemma_multiset_has_no_duplicates_conv",
        "to_multiset_contains",
        "lemma_fold_right_permutation"
      ],
      "len": [
        "lemma_auto_spec_u16_to_from_le_bytes",
        "lemma_auto_spec_u32_to_from_le_bytes",
        "lemma_auto_spec_u64_to_from_le_bytes",
        "lemma_auto_spec_u128_to_from_le_bytes",
        "spec_len",
        "vstd::hash_map::spec_len",
        "vstd::hash_set::spec_len",
        "lemma_remove_keys_len",
        "lemma_disjoint_union_size",
        "lemma_values_finite",
        "axiom_multiset_empty",
        "lemma_multiset_empty_len",
        "lemma_is_singleton",
        "validate_multiple",
        "lemma_new_first_element_still_sorted_by",
        "tracked_push",
        "tracked_pop",
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "axiom_seq_subrange_decreases",
        "axiom_seq_empty",
        "axiom_seq_new_len",
        "axiom_seq_new_index",
        "axiom_seq_push_len",
        "axiom_seq_push_index_same",
        "axiom_seq_push_index_different",
        "axiom_seq_update_len",
        "axiom_seq_update_same",
        "axiom_seq_update_different",
        "axiom_seq_ext_equal",
        "axiom_seq_ext_equal_deep",
        "lemma_sort_by_ensures",
        "lemma_filter_len",
        "filter_lemma",
        "filter_distributes_over_add",
        "index_of_first_ensures",
        "index_of_last_ensures",
        "to_multiset",
        "lemma_fold_left_split",
        "lemma_fold_left_alt",
        "lemma_fold_right_split",
        "lemma_fold_right_commute_one",
        "lemma_fold_right_alt",
        "lemma_reverse_fold_right",
        "lemma_multiset_has_no_duplicates",
        "lemma_multiset_has_no_duplicates_conv",
        "lemma_reverse_to_multiset",
        "lemma_indexing_implies_membership",
        "lemma_membership_implies_indexing",
        "unique_seq_to_set",
        "lemma_cardinality_of_set",
        "lemma_cardinality_of_empty_set_is_0",
        "lemma_no_dup_set_cardinality",
        "lemma_to_set_map_commutes",
        "lemma_filter_contains_rev",
        "lemma_filter_map_contains",
        "lemma_filter_eq_filter_alt",
        "lemma_concat_injective",
        "unzip",
        "unzip_ensures",
        "lemma_flatten_one_element",
        "lemma_flatten_length_ge_single_element_length",
        "lemma_flatten_length_le_mul",
        "lemma_flatten_and_flatten_alt_are_equivalent",
        "max_ensures",
        "min_ensures",
        "lemma_max_of_concat",
        "lemma_min_of_concat",
        "to_multiset_build",
        "to_multiset_remove",
        "to_multiset_insert",
        "to_multiset_len",
        "to_multiset_contains",
        "lemma_flatten_concat",
        "lemma_flatten_alt_concat",
        "lemma_multiset_commutative",
        "lemma_sorted_unique",
        "lemma_seq_concat_contains_all_elements",
        "lemma_seq_contains_after_push",
        "lemma_seq_subrange_elements",
        "lemma_fold_right_permutation",
        "lemma_seq_take_contains",
        "lemma_seq_skip_contains",
        "axiom_set_choose_len",
        "find_unique_minimal",
        "find_unique_maximal",
        "lemma_len0_is_empty",
        "vstd::set_lib::lemma_is_singleton",
        "lemma_subset_not_in_lt",
        "lemma_map_finite",
        "lemma_filter_map_finite",
        "lemma_to_seq_to_set_id",
        "lemma_sets_eq_iff_injective_map_eq",
        "lemma_len_union_ind",
        "lemma_map_size",
        "lemma_set_empty_equivalency_len",
        "lemma_set_disjoint_lens",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "lemma_set_properties",
        "spec_hash_map_iter",
        "axiom_spec_hash_map_iter",
        "vstd::tokens::seq::agree",
        "update_subrange_with",
        "vstd::tokens::seq::disjoint"
      ],
      "vstd::multiset::empty": [],
      "from_map": [
        "count",
        "len",
        "vstd::multiset::empty",
        "from_map"
      ],
      "singleton": [
        "singleton",
        "add",
        "sub",
        "lemma_is_singleton_contains_elem_equal_singleton"
      ],
      "add": [],
      "sub": [],
      "filter": [
        "lemma_filter_len",
        "filter_lemma",
        "filter_distributes_over_add"
      ],
      "axiom_multiset_empty": [],
      "lemma_multiset_empty_len": [],
      "axiom_multiset_contained": [],
      "axiom_multiset_new_not_contained": [],
      "axiom_multiset_singleton": [],
      "axiom_multiset_singleton_different": [],
      "axiom_multiset_add": [],
      "axiom_multiset_sub": [],
      "axiom_multiset_ext_equal": [],
      "axiom_multiset_ext_equal_deep": [],
      "axiom_len_empty": [],
      "axiom_len_singleton": [],
      "axiom_len_add": [],
      "axiom_len_sub": [],
      "axiom_count_le_len": [],
      "axiom_filter_count": [],
      "axiom_choose_count": [],
      "axiom_multiset_always_finite": [],
      "lemma_update_same": [],
      "lemma_update_different": [],
      "lemma_insert_containment": [],
      "lemma_insert_increases_count_by_1": [],
      "lemma_insert_non_decreasing": [],
      "lemma_insert_other_elements_unchanged": [],
      "lemma_insert_len": [],
      "lemma_intersection_count": [
        "lemma_left_pseudo_idempotence",
        "lemma_right_pseudo_idempotence"
      ],
      "lemma_left_pseudo_idempotence": [],
      "lemma_right_pseudo_idempotence": [],
      "lemma_difference_count": [
        "lemma_difference_bottoms_out"
      ],
      "lemma_difference_bottoms_out": [],
      "lemma_multiset_properties": [],
      "lemma_is_singleton_contains_elem_equal_singleton": [
        "lemma_singleton_size"
      ],
      "lemma_singleton_size": [
        "lemma_is_singleton",
        "vstd::set_lib::lemma_is_singleton"
      ],
      "lemma_is_singleton": [],
      "value": [
        "weaken",
        "validate_2",
        "update_with_shared",
        "duplicate",
        "extract",
        "validate_3",
        "validate_multiple",
        "validate_4",
        "validate_5",
        "is_nonnull",
        "leak_contents",
        "is_disjoint",
        "vstd::rwlock::view",
        "vstd::storage_protocol::value",
        "vstd::storage_protocol::loc",
        "vstd::storage_protocol::alloc",
        "vstd::storage_protocol::join",
        "vstd::storage_protocol::split",
        "vstd::storage_protocol::validate",
        "exchange",
        "exchange_nondeterministic",
        "guard",
        "vstd::storage_protocol::join_shared",
        "vstd::storage_protocol::weaken",
        "validate_with_shared",
        "exchange_nondeterministic_with_shared",
        "frac",
        "resource",
        "vstd::tokens::frac::frac",
        "take_resource",
        "put_resource",
        "vstd::tokens::map::view",
        "vstd::tokens::map::insert",
        "delete",
        "vstd::tokens::map::new",
        "vstd::tokens::map::agree",
        "vstd::tokens::map::split",
        "vstd::tokens::map::update",
        "map"
      ],
      "loc": [
        "copy_duplicable_part",
        "incorporate",
        "split_mut",
        "update_mut",
        "validate_4",
        "validate_5",
        "exchange",
        "exchange_nondeterministic",
        "exchange_nondeterministic_with_shared",
        "vstd::tokens::frac::id",
        "vstd::tokens::map::id"
      ],
      "alloc": [
        "vstd::tokens::frac::new",
        "vstd::tokens::map::new",
        "vstd::tokens::map::combine",
        "vstd::tokens::map::split"
      ],
      "join": [
        "incorporate",
        "combine",
        "delete",
        "vstd::tokens::map::combine",
        "vstd::tokens::map::update"
      ],
      "split": [
        "split_mut",
        "vstd::tokens::frac::update",
        "update_with",
        "vstd::tokens::map::insert",
        "vstd::tokens::map::new",
        "vstd::tokens::map::split",
        "vstd::tokens::map::update",
        "update_subrange_with",
        "vstd::tokens::seq::split"
      ],
      "create_unit": [
        "copy_duplicable_part",
        "incorporate",
        "split_mut",
        "update_mut",
        "vstd::tokens::map::empty"
      ],
      "validate": [
        "update_nondeterministic",
        "join_shared",
        "join_shared_to_target",
        "validate_3",
        "validate_multiple",
        "agree",
        "bounded",
        "vstd::tokens::frac::agree",
        "vstd::tokens::frac::bounded",
        "take_resource",
        "put_resource",
        "vstd::tokens::map::agree"
      ],
      "update": [
        "update_mut",
        "to_multiset_update",
        "vstd::tokens::frac::update",
        "update_with",
        "vstd::tokens::map::insert",
        "delete",
        "vstd::tokens::map::update",
        "update_subrange_with"
      ],
      "update_nondeterministic": [
        "value",
        "loc",
        "alloc",
        "join",
        "split",
        "create_unit",
        "validate",
        "update"
      ],
      "join_shared": [
        "update_nondeterministic",
        "join_shared",
        "join_shared_to_target",
        "agree",
        "vstd::tokens::frac::agree",
        "vstd::tokens::map::agree"
      ],
      "join_shared_to_target": [],
      "weaken": [
        "update_nondeterministic",
        "join_shared",
        "join_shared_to_target"
      ],
      "validate_2": [
        "validate_3",
        "combine",
        "vstd::tokens::map::combine",
        "disjoint",
        "vstd::tokens::map::update"
      ],
      "update_with_shared": [
        "copy_duplicable_part"
      ],
      "update_nondeterministic_with_shared": [
        "weaken",
        "validate_2",
        "update_with_shared"
      ],
      "lemma_pcm_properties": [],
      "copy_duplicable_part": [
        "duplicate"
      ],
      "duplicate": [],
      "incorporate": [
        "redistribute",
        "update_and_redistribute",
        "validate_3",
        "validate_4",
        "validate_5"
      ],
      "split_mut": [
        "extract",
        "redistribute",
        "update_and_redistribute",
        "validate_3"
      ],
      "extract": [
        "redistribute",
        "update_and_redistribute",
        "validate_3",
        "validate_4",
        "validate_5"
      ],
      "update_mut": [
        "update_and_redistribute"
      ],
      "redistribute": [],
      "update_and_redistribute": [],
      "validate_3": [],
      "validate_multiple": [
        "validate_4",
        "validate_5"
      ],
      "validate_4": [],
      "validate_5": [],
      "assume": [],
      "assert": [],
      "affirm": [],
      "arbitrary": [
        "vstd::proph::new",
        "dummy"
      ],
      "proof_from_false": [],
      "vstd::proph::view": [],
      "vstd::proph::new": [],
      "resolve": [],
      "null": [],
      "is_nonnull": [],
      "leak_contents": [
        "vstd::simple_pptr::leak_contents"
      ],
      "is_disjoint": [
        "vstd::simple_pptr::is_disjoint",
        "is_distinct"
      ],
      "ptr_mut_from_data": [
        "ptr_mut_from_data"
      ],
      "axiom_ptr_mut_from_data": [],
      "view_reverse_for_eq": [
        "axiom_ptr_mut_from_data",
        "view_reverse_for_eq",
        "ptrs_mut_eq",
        "view_reverse_for_eq_sized"
      ],
      "ptrs_mut_eq": [
        "ptrs_mut_eq_sized"
      ],
      "view_reverse_for_eq_sized": [],
      "ptrs_mut_eq_sized": [],
      "provenance": [
        "vstd::raw_ptr::empty",
        "vstd::raw_ptr::split",
        "vstd::raw_ptr::join",
        "into_typed"
      ],
      "vstd::raw_ptr::null": [],
      "vstd::raw_ptr::provenance": [],
      "vstd::raw_ptr::dom": [],
      "vstd::raw_ptr::empty": [],
      "vstd::raw_ptr::split": [],
      "vstd::raw_ptr::join": [],
      "into_typed": [],
      "into_raw": [],
      "vstd::raw_ptr::view": [],
      "vstd::raw_ptr::value": [],
      "ptr": [
        "addr"
      ],
      "points_to": [],
      "lemma_new_first_element_still_sorted_by": [],
      "rwlock": [],
      "vstd::rwlock::view": [],
      "vstd::rwlock::rwlock": [],
      "lemma_readers_match": [],
      "pred": [
        "filter_lemma",
        "filter_distributes_over_add"
      ],
      "vstd::seq::empty": [],
      "vstd::seq::new": [],
      "vstd::seq::len": [],
      "vstd::seq::index": [],
      "vstd::seq::tracked_empty": [],
      "vstd::seq::tracked_remove": [],
      "vstd::seq::tracked_insert": [],
      "vstd::seq::tracked_borrow": [],
      "tracked_push": [],
      "tracked_pop": [],
      "tracked_pop_front": [],
      "axiom_seq_index_decreases": [],
      "axiom_seq_len_decreases": [
        "axiom_seq_index_decreases",
        "axiom_seq_len_decreases",
        "axiom_seq_subrange_decreases"
      ],
      "axiom_seq_subrange_decreases": [],
      "axiom_seq_empty": [],
      "axiom_seq_new_len": [],
      "axiom_seq_new_index": [],
      "axiom_seq_push_len": [],
      "axiom_seq_push_index_same": [],
      "axiom_seq_push_index_different": [],
      "axiom_seq_update_len": [],
      "axiom_seq_update_same": [],
      "axiom_seq_update_different": [],
      "axiom_seq_ext_equal": [],
      "axiom_seq_ext_equal_deep": [],
      "axiom_seq_subrange_len": [],
      "axiom_seq_subrange_index": [],
      "axiom_seq_add_len": [],
      "axiom_seq_add_index1": [],
      "axiom_seq_add_index2": [],
      "lemma_sort_by_ensures": [
        "lemma_sort_by_ensures",
        "lemma_sort_ensures"
      ],
      "lemma_filter_len": [
        "lemma_filter_len"
      ],
      "lemma_filter_pred": [],
      "lemma_filter_contains": [],
      "filter_lemma": [
        "lemma_filter_pred",
        "lemma_filter_contains",
        "filter_lemma"
      ],
      "filter_distributes_over_add": [
        "filter_distributes_over_add"
      ],
      "add_empty_left": [],
      "add_empty_right": [
        "filter_distributes_over_add"
      ],
      "push_distributes_over_add": [
        "filter_distributes_over_add"
      ],
      "index_of_first": [],
      "index_of_first_ensures": [],
      "index_of_last": [],
      "index_of_last_ensures": [],
      "drop_last_distributes_over_add": [
        "filter_distributes_over_add"
      ],
      "to_multiset": [
        "lemma_sort_by_ensures",
        "to_multiset",
        "lemma_multiset_has_no_duplicates",
        "lemma_multiset_has_no_duplicates_conv",
        "lemma_reverse_to_multiset",
        "to_multiset_build",
        "to_multiset_remove",
        "to_multiset_insert",
        "to_multiset_len",
        "to_multiset_contains",
        "to_multiset_update",
        "lemma_sorted_unique",
        "lemma_fold_right_permutation",
        "lemma_fold_left_permutation"
      ],
      "to_multiset_ensures": [],
      "insert_ensures": [],
      "remove_ensures": [],
      "lemma_fold_left_split": [
        "lemma_fold_left_split"
      ],
      "lemma_fold_left_alt": [
        "lemma_fold_left_alt"
      ],
      "lemma_reverse_fold_left": [],
      "lemma_fold_right_split": [
        "lemma_fold_right_split",
        "lemma_fold_right_alt",
        "lemma_fold_right_permutation"
      ],
      "lemma_fold_right_commute_one": [
        "lemma_fold_right_commute_one",
        "lemma_fold_right_permutation"
      ],
      "lemma_fold_right_alt": [
        "lemma_fold_right_alt",
        "lemma_reverse_fold_right"
      ],
      "lemma_reverse_fold_right": [
        "lemma_reverse_fold_left",
        "lemma_reverse_fold_right",
        "lemma_fold_left_permutation"
      ],
      "lemma_multiset_has_no_duplicates": [
        "lemma_multiset_has_no_duplicates"
      ],
      "lemma_multiset_has_no_duplicates_conv": [],
      "lemma_reverse_to_multiset": [
        "lemma_reverse_to_multiset",
        "lemma_fold_left_permutation"
      ],
      "lemma_add_last_back": [],
      "lemma_indexing_implies_membership": [],
      "lemma_membership_implies_indexing": [],
      "lemma_split_at": [],
      "lemma_element_from_slice": [],
      "lemma_slice_of_slice": [],
      "unique_seq_to_set": [
        "unique_seq_to_set"
      ],
      "lemma_cardinality_of_set": [
        "lemma_cardinality_of_set",
        "lemma_cardinality_of_empty_set_is_0",
        "lemma_no_dup_set_cardinality"
      ],
      "lemma_cardinality_of_empty_set_is_0": [],
      "lemma_no_dup_set_cardinality": [
        "lemma_no_dup_set_cardinality"
      ],
      "lemma_to_set_map_commutes": [],
      "lemma_to_set_insert_commutes": [],
      "lemma_filter_contains_rev": [
        "lemma_filter_contains_rev"
      ],
      "lemma_filter_map_contains": [
        "lemma_filter_map_contains"
      ],
      "lemma_take_succ": [],
      "lemma_filter_map_singleton": [],
      "lemma_filter_eq_filter_alt": [
        "lemma_filter_eq_filter_alt"
      ],
      "lemma_index_contains": [],
      "lemma_take_succ_push": [],
      "lemma_take_len": [],
      "lemma_flat_map_singleton": [],
      "lemma_prefix_append_unique": [],
      "lemma_concat_injective": [],
      "unzip": [],
      "unzip_ensures": [
        "unzip_ensures"
      ],
      "lemma_zip_of_unzip": [],
      "lemma_flatten_one_element": [
        "lemma_flatten_length_ge_single_element_length",
        "lemma_flatten_and_flatten_alt_are_equivalent"
      ],
      "lemma_flatten_length_ge_single_element_length": [
        "lemma_flatten_length_ge_single_element_length"
      ],
      "lemma_flatten_length_le_mul": [
        "lemma_flatten_length_le_mul"
      ],
      "lemma_flatten_and_flatten_alt_are_equivalent": [
        "lemma_flatten_length_ge_single_element_length",
        "lemma_flatten_and_flatten_alt_are_equivalent",
        "lemma_flatten_push"
      ],
      "lemma_flatten_push": [],
      "lemma_flatten_singleton": [],
      "max_ensures": [
        "max_ensures",
        "lemma_subrange_max",
        "lemma_max_of_concat"
      ],
      "min_ensures": [
        "min_ensures",
        "lemma_subrange_min",
        "lemma_min_of_concat"
      ],
      "sort": [],
      "lemma_sort_ensures": [],
      "lemma_subrange_max": [],
      "lemma_subrange_min": [],
      "lemma_max_of_concat": [
        "lemma_max_of_concat",
        "lemma_min_of_concat"
      ],
      "lemma_min_of_concat": [],
      "to_multiset_build": [
        "to_multiset_build",
        "to_multiset_contains"
      ],
      "to_multiset_remove": [],
      "to_multiset_insert": [],
      "to_multiset_len": [
        "to_multiset_len"
      ],
      "to_multiset_contains": [
        "to_multiset_contains"
      ],
      "to_multiset_update": [],
      "lemma_update_is_remove_insert": [],
      "lemma_append_last": [],
      "lemma_concat_associative": [],
      "seq_to_set_is_finite": [],
      "seq_to_set_distributes_over_add": [],
      "lemma_no_dup_in_concat": [],
      "lemma_flatten_concat": [
        "lemma_flatten_and_flatten_alt_are_equivalent",
        "lemma_flatten_concat"
      ],
      "lemma_flatten_alt_concat": [
        "lemma_flatten_alt_concat"
      ],
      "lemma_seq_union_to_multiset_commutative": [
        "to_multiset_remove"
      ],
      "lemma_multiset_commutative": [
        "lemma_sort_by_ensures",
        "lemma_multiset_has_no_duplicates_conv",
        "lemma_reverse_to_multiset",
        "lemma_seq_union_to_multiset_commutative",
        "lemma_multiset_commutative"
      ],
      "lemma_sorted_unique": [
        "lemma_sorted_unique"
      ],
      "lemma_seq_contains": [],
      "lemma_seq_empty_contains_nothing": [],
      "lemma_seq_empty_equality": [],
      "lemma_seq_concat_contains_all_elements": [],
      "lemma_seq_contains_after_push": [],
      "lemma_seq_subrange_elements": [],
      "lemma_fold_right_permutation": [
        "lemma_fold_right_permutation",
        "lemma_fold_left_permutation"
      ],
      "lemma_fold_left_permutation": [],
      "lemma_seq_take_len": [],
      "lemma_seq_take_contains": [],
      "lemma_seq_take_index": [],
      "subrange_of_matching_take": [],
      "lemma_seq_skip_len": [],
      "lemma_seq_skip_contains": [
        "to_multiset_contains"
      ],
      "lemma_seq_skip_index": [
        "lemma_seq_skip_contains"
      ],
      "lemma_seq_skip_index2": [],
      "lemma_seq_append_take_skip": [],
      "lemma_seq_take_update_commut1": [],
      "lemma_seq_take_update_commut2": [],
      "lemma_seq_skip_update_commut1": [],
      "lemma_seq_skip_update_commut2": [],
      "lemma_seq_skip_build_commut": [],
      "lemma_seq_skip_nothing": [],
      "lemma_seq_take_nothing": [],
      "lemma_seq_skip_of_skip": [],
      "lemma_seq_properties": [],
      "vstd::set::empty": [],
      "vstd::set::new": [],
      "contains": [
        "inv",
        "axiom_map_ext_equal",
        "axiom_map_ext_equal_deep",
        "lemma_invert_is_injective",
        "lemma_submap_of_trans",
        "lemma_map_new_values",
        "lemma_values_finite",
        "count",
        "len",
        "vstd::multiset::empty",
        "from_map",
        "lemma_update_same",
        "lemma_update_different",
        "lemma_intersection_count",
        "lemma_difference_count",
        "lemma_is_singleton_contains_elem_equal_singleton",
        "lemma_is_singleton",
        "value",
        "loc",
        "alloc",
        "join",
        "split",
        "create_unit",
        "validate",
        "update",
        "weaken",
        "validate_2",
        "update_with_shared",
        "lemma_sort_by_ensures",
        "filter_lemma",
        "index_of_first",
        "index_of_first_ensures",
        "index_of_last",
        "index_of_last_ensures",
        "lemma_multiset_has_no_duplicates",
        "lemma_indexing_implies_membership",
        "lemma_membership_implies_indexing",
        "unique_seq_to_set",
        "lemma_cardinality_of_empty_set_is_0",
        "lemma_no_dup_set_cardinality",
        "lemma_to_set_map_commutes",
        "lemma_filter_map_contains",
        "max_ensures",
        "min_ensures",
        "lemma_max_of_concat",
        "lemma_min_of_concat",
        "to_multiset_contains",
        "lemma_sorted_unique",
        "lemma_seq_concat_contains_all_elements",
        "lemma_seq_contains_after_push",
        "lemma_seq_subrange_elements",
        "lemma_fold_left_permutation",
        "lemma_seq_take_contains",
        "lemma_seq_skip_contains",
        "finite",
        "mk_map",
        "lemma_finite_set_induct",
        "axiom_set_remove_insert",
        "axiom_set_ext_equal",
        "axiom_set_insert_finite",
        "axiom_set_remove_finite",
        "axiom_set_union_finite",
        "axiom_set_intersect_finite",
        "axiom_set_difference_finite",
        "find_unique_minimal",
        "find_unique_maximal",
        "lemma_len0_is_empty",
        "vstd::set_lib::lemma_is_singleton",
        "lemma_maximal_equivalent_greatest",
        "lemma_minimal_equivalent_least",
        "lemma_set_map_insert_commute",
        "lemma_map_union_commute",
        "lemma_any_map_preserved_pred",
        "lemma_filter_map_union",
        "lemma_map_finite",
        "flatten_insert_union_commute",
        "lemma_sets_eq_iff_injective_map_eq",
        "lemma_set_insert_finite_iff",
        "lemma_set_remove_finite_iff",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_len_union",
        "lemma_len_union_ind",
        "lemma_set_empty_equivalency_len",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len",
        "lemma_set_properties",
        "lemma_hashmap_deepview_values",
        "exchange_nondeterministic",
        "exchange_nondeterministic_with_shared",
        "map",
        "set"
      ],
      "vstd::set::insert": [],
      "vstd::set::remove": [],
      "union": [
        "lemma_union_dom",
        "axiom_set_union_finite",
        "lemma_map_union_commute",
        "lemma_filter_map_union",
        "flatten_insert_union_commute",
        "lemma_set_union_finite_iff",
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_len_union",
        "lemma_len_union_ind"
      ],
      "intersect": [
        "axiom_set_intersect_finite",
        "lemma_len_intersect",
        "lemma_len_subset",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len"
      ],
      "difference": [
        "axiom_set_difference_finite",
        "lemma_set_insert_diff_decreases",
        "lemma_set_subset_finite",
        "lemma_len_difference",
        "lemma_set_difference_len"
      ],
      "complement": [],
      "finite": [
        "seq_to_set_is_finite",
        "axiom_set_choose_len",
        "lemma_set_insert_finite_iff",
        "lemma_set_remove_finite_iff",
        "lemma_set_union_finite_iff",
        "lemma_set_properties"
      ],
      "vstd::set::len": [],
      "mk_map": [],
      "lemma_finite_set_induct": [
        "axiom_set_choose_len"
      ],
      "lemma_fold_insert": [],
      "lemma_fold_empty": [
        "axiom_set_empty_len"
      ],
      "axiom_set_empty": [],
      "axiom_set_new": [],
      "axiom_set_insert_same": [
        "axiom_set_remove_insert"
      ],
      "axiom_set_insert_different": [
        "axiom_set_remove_insert"
      ],
      "axiom_set_remove_same": [],
      "axiom_set_remove_insert": [],
      "axiom_set_remove_different": [
        "axiom_set_remove_insert"
      ],
      "axiom_set_union": [],
      "axiom_set_intersect": [],
      "axiom_set_difference": [],
      "axiom_set_complement": [],
      "axiom_set_ext_equal": [
        "axiom_set_remove_insert"
      ],
      "axiom_set_ext_equal_deep": [],
      "axiom_mk_map_domain": [],
      "axiom_mk_map_index": [],
      "axiom_set_empty_finite": [],
      "axiom_set_insert_finite": [
        "lemma_values_finite",
        "axiom_set_contains_len"
      ],
      "axiom_set_remove_finite": [
        "axiom_set_contains_len"
      ],
      "axiom_set_union_finite": [],
      "axiom_set_intersect_finite": [],
      "axiom_set_difference_finite": [],
      "axiom_set_choose_infinite": [],
      "axiom_set_empty_len": [],
      "axiom_set_insert_len": [
        "axiom_set_contains_len"
      ],
      "axiom_set_remove_len": [
        "lemma_set_union_finite_implies_sets_finite",
        "lemma_set_empty_equivalency_len"
      ],
      "axiom_set_contains_len": [],
      "axiom_set_choose_len": [],
      "find_unique_minimal": [
        "find_unique_minimal"
      ],
      "find_unique_minimal_ensures": [],
      "find_unique_maximal": [
        "find_unique_maximal"
      ],
      "find_unique_maximal_ensures": [],
      "lemma_len0_is_empty": [],
      "vstd::set_lib::lemma_singleton_size": [],
      "vstd::set_lib::lemma_is_singleton": [],
      "lemma_len_filter": [],
      "lemma_greatest_implies_maximal": [],
      "lemma_least_implies_minimal": [],
      "lemma_maximal_equivalent_greatest": [
        "lemma_maximal_is_unique"
      ],
      "lemma_minimal_equivalent_least": [
        "lemma_minimal_is_unique"
      ],
      "lemma_least_is_unique": [
        "lemma_minimal_is_unique"
      ],
      "lemma_greatest_is_unique": [
        "lemma_maximal_is_unique"
      ],
      "lemma_minimal_is_unique": [],
      "lemma_maximal_is_unique": [],
      "lemma_set_insert_diff_decreases": [],
      "lemma_subset_not_in_lt": [
        "lemma_set_insert_diff_decreases"
      ],
      "lemma_set_map_insert_commute": [],
      "lemma_map_union_commute": [],
      "lemma_any_map_preserved_pred": [],
      "lemma_filter_map_insert": [],
      "lemma_filter_map_union": [],
      "lemma_map_finite": [
        "lemma_map_finite"
      ],
      "lemma_set_all_subset": [],
      "lemma_filter_map_finite": [
        "lemma_filter_map_finite"
      ],
      "lemma_to_seq_to_set_id": [
        "lemma_to_seq_to_set_id"
      ],
      "flatten_insert_union_commute": [],
      "lemma_sets_eq_iff_injective_map_eq": [],
      "lemma_set_insert_finite_iff": [
        "lemma_set_union_finite_implies_sets_finite"
      ],
      "lemma_set_remove_finite_iff": [],
      "lemma_set_union_finite_iff": [],
      "lemma_set_union_finite_implies_sets_finite": [
        "lemma_set_union_finite_iff",
        "lemma_set_union_finite_implies_sets_finite"
      ],
      "lemma_len_union": [],
      "lemma_len_union_ind": [
        "lemma_len_union_ind"
      ],
      "lemma_len_intersect": [],
      "lemma_len_subset": [
        "lemma_subset_not_in_lt"
      ],
      "lemma_set_subset_finite": [],
      "lemma_len_difference": [],
      "lemma_int_range": [
        "lemma_int_range"
      ],
      "lemma_subset_equality": [
        "lemma_subset_equality"
      ],
      "lemma_map_size": [
        "lemma_map_size"
      ],
      "lemma_set_union_again1": [],
      "lemma_set_union_again2": [],
      "lemma_set_intersect_again1": [],
      "lemma_set_intersect_again2": [],
      "lemma_set_difference2": [],
      "lemma_set_disjoint": [],
      "lemma_set_empty_equivalency_len": [
        "lemma_set_disjoint_lens",
        "lemma_set_intersect_union_lens",
        "lemma_set_difference_len"
      ],
      "lemma_set_disjoint_lens": [
        "lemma_set_disjoint_lens"
      ],
      "lemma_set_intersect_union_lens": [
        "lemma_set_intersect_union_lens"
      ],
      "lemma_set_difference_len": [
        "lemma_set_difference_len"
      ],
      "lemma_set_properties": [],
      "axiom_is_empty": [],
      "axiom_is_empty_len0": [],
      "vstd::shared::view": [],
      "vstd::shared::new": [],
      "clone": [],
      "borrow": [
        "lemma_readers_match",
        "borrow"
      ],
      "addr": [
        "addr"
      ],
      "vstd::simple_pptr::mem_contents": [],
      "vstd::simple_pptr::is_nonnull": [],
      "vstd::simple_pptr::leak_contents": [],
      "vstd::simple_pptr::is_disjoint": [],
      "is_distinct": [],
      "slice_index_get": [],
      "spec_slice_len": [],
      "axiom_spec_len": [],
      "slice_to_vec": [],
      "slice_subrange": [],
      "spec_slice_get": [],
      "axiom_slice_get_usize": [],
      "axiom_slice_ext_equal": [],
      "u8_trailing_zeros": [
        "u8_trailing_zeros",
        "axiom_u8_trailing_zeros"
      ],
      "u8_leading_zeros": [
        "u8_leading_zeros",
        "axiom_u8_leading_zeros"
      ],
      "axiom_u8_trailing_zeros": [
        "axiom_u8_trailing_zeros",
        "axiom_u8_trailing_ones"
      ],
      "axiom_u8_trailing_ones": [],
      "axiom_u8_leading_zeros": [
        "axiom_u8_leading_zeros",
        "axiom_u8_leading_ones"
      ],
      "axiom_u8_leading_ones": [],
      "u16_trailing_zeros": [
        "u16_trailing_zeros",
        "axiom_u16_trailing_zeros"
      ],
      "u16_leading_zeros": [
        "u16_leading_zeros",
        "axiom_u16_leading_zeros"
      ],
      "axiom_u16_trailing_zeros": [
        "axiom_u16_trailing_zeros",
        "axiom_u16_trailing_ones"
      ],
      "axiom_u16_trailing_ones": [],
      "axiom_u16_leading_zeros": [
        "axiom_u16_leading_zeros",
        "axiom_u16_leading_ones"
      ],
      "axiom_u16_leading_ones": [],
      "u32_trailing_zeros": [
        "u32_trailing_zeros",
        "axiom_u32_trailing_zeros"
      ],
      "u32_leading_zeros": [
        "u32_leading_zeros",
        "axiom_u32_leading_zeros"
      ],
      "axiom_u32_trailing_zeros": [
        "axiom_u32_trailing_zeros",
        "axiom_u32_trailing_ones"
      ],
      "axiom_u32_trailing_ones": [],
      "axiom_u32_leading_zeros": [
        "axiom_u32_leading_zeros",
        "axiom_u32_leading_ones"
      ],
      "axiom_u32_leading_ones": [],
      "u64_trailing_zeros": [
        "u64_trailing_zeros",
        "axiom_u64_trailing_zeros"
      ],
      "axiom_u64_trailing_zeros": [
        "axiom_u64_trailing_zeros",
        "axiom_u64_trailing_ones"
      ],
      "axiom_u64_trailing_ones": [],
      "axiom_u64_leading_zeros": [
        "axiom_u64_leading_zeros",
        "axiom_u64_leading_ones"
      ],
      "axiom_u64_leading_ones": [],
      "eq_ensures": [],
      "ne_ensures": [],
      "partial_cmp_ensures": [],
      "lt_ensures": [],
      "le_ensures": [],
      "gt_ensures": [],
      "ge_ensures": [],
      "spec_from": [],
      "spec_from_blanket_identity": [],
      "obeys_key_model": [],
      "axiom_bool_obeys_hash_table_key_model": [],
      "axiom_u8_obeys_hash_table_key_model": [],
      "axiom_u16_obeys_hash_table_key_model": [],
      "axiom_u32_obeys_hash_table_key_model": [],
      "axiom_u64_obeys_hash_table_key_model": [],
      "axiom_u128_obeys_hash_table_key_model": [],
      "axiom_usize_obeys_hash_table_key_model": [],
      "axiom_i8_obeys_hash_table_key_model": [],
      "axiom_i16_obeys_hash_table_key_model": [],
      "axiom_i32_obeys_hash_table_key_model": [],
      "axiom_i164_obeys_hash_table_key_model": [],
      "axiom_i128_obeys_hash_table_key_model": [],
      "axiom_isize_obeys_hash_table_key_model": [],
      "axiom_box_bool_obeys_hash_table_key_model": [],
      "axiom_box_integer_type_obeys_hash_table_key_model": [],
      "builds_valid_hashers": [],
      "axiom_random_state_builds_valid_hashers": [],
      "spec_hash_map_iter": [
        "spec_hash_map_iter",
        "axiom_spec_hash_map_iter"
      ],
      "axiom_spec_hash_map_iter": [],
      "lemma_hashmap_deepview_dom": [],
      "lemma_hashmap_deepview_properties": [],
      "lemma_hashmap_deepview_values": [],
      "axiom_hashmap_deepview_borrow": [],
      "axiom_hashmap_view_finite_dom": [],
      "spec_hash_map_len": [],
      "axiom_spec_hash_map_len": [],
      "contains_borrowed_key": [],
      "axiom_contains_deref_key": [],
      "axiom_contains_box": [],
      "maps_borrowed_key_to_value": [],
      "axiom_maps_deref_key_to_value": [],
      "axiom_maps_box_key_to_value": [],
      "borrowed_key_removed": [],
      "axiom_deref_key_removed": [],
      "axiom_box_key_removed": [],
      "axiom_hashmap_decreases": [],
      "spec_hash_set_len": [],
      "axiom_spec_hash_set_len": [],
      "set_contains_borrowed_key": [],
      "axiom_set_contains_deref_key": [],
      "axiom_set_contains_box": [],
      "sets_borrowed_key_to_key": [],
      "axiom_set_deref_key_to_value": [],
      "axiom_set_box_key_to_value": [],
      "sets_differ_by_borrowed_key": [],
      "axiom_set_deref_key_removed": [],
      "axiom_set_box_key_removed": [],
      "axiom_hashset_decreases": [],
      "neg_ensures": [],
      "add_ensures": [],
      "sub_ensures": [],
      "mul_ensures": [],
      "div_ensures": [],
      "spec_range_next": [],
      "spec_slice_iter": [],
      "axiom_spec_slice_iter": [],
      "spec_vec_len": [],
      "vstd::std_specs::vec::axiom_spec_len": [],
      "vec_clone_deep_view_proof": [],
      "axiom_vec_index_decreases": [],
      "spec_into_iter": [],
      "axiom_spec_into_iter": [],
      "spec_vec_dequeue_len": [],
      "vstd::std_specs::vecdeque::axiom_spec_len": [],
      "axiom_vec_dequeue_index_decreases": [],
      "spec_iter": [],
      "axiom_spec_iter": [],
      "vstd::storage_protocol::value": [],
      "vstd::storage_protocol::loc": [],
      "vstd::storage_protocol::alloc": [],
      "vstd::storage_protocol::join": [],
      "vstd::storage_protocol::split": [],
      "vstd::storage_protocol::validate": [],
      "exchange": [
        "deposit",
        "withdraw",
        "vstd::storage_protocol::update"
      ],
      "deposit": [
        "put_resource"
      ],
      "withdraw": [
        "take_resource"
      ],
      "vstd::storage_protocol::update": [],
      "exchange_nondeterministic": [],
      "guard": [
        "vstd::tokens::frac::borrow"
      ],
      "vstd::storage_protocol::join_shared": [],
      "vstd::storage_protocol::weaken": [],
      "validate_with_shared": [],
      "exchange_with_shared": [],
      "exchange_nondeterministic_with_shared": [
        "exchange_with_shared"
      ],
      "str_slice_is_ascii": [],
      "to_string_from_display_ensures": [],
      "to_string_from_display_ensures_for_str": [],
      "axiom_str_literal_is_ascii": [],
      "axiom_str_literal_len": [],
      "axiom_str_literal_get_char": [],
      "string_is_ascii": [],
      "predicate": [
        "predicate"
      ],
      "vstd::thread::view": [],
      "agrees": [],
      "ghost_thread_id": [],
      "vstd::thread::id": [],
      "into": [],
      "vstd::thread::borrow": [],
      "send_into": [
        "vstd::thread::view",
        "vstd::thread::id",
        "into",
        "vstd::thread::borrow"
      ],
      "sync_borrow": [
        "send_into"
      ],
      "vstd::tokens::frac::id": [],
      "vstd::tokens::frac::view": [],
      "frac": [
        "update_with"
      ],
      "vstd::tokens::frac::new": [],
      "agree": [
        "agree_map"
      ],
      "take": [
        "tracked_pop",
        "lemma_seq_take_contains",
        "subrange_of_matching_take"
      ],
      "vstd::tokens::frac::split": [],
      "combine": [
        "vstd::tokens::frac::update",
        "update_with",
        "update_subrange_with",
        "vstd::tokens::seq::combine"
      ],
      "vstd::tokens::frac::update": [],
      "update_with": [],
      "bounded": [
        "take",
        "combine",
        "update_with"
      ],
      "dummy": [
        "take",
        "combine",
        "update_with",
        "vstd::tokens::map::take",
        "vstd::tokens::map::insert",
        "delete",
        "vstd::tokens::map::update",
        "vstd::tokens::seq::split",
        "vstd::tokens::seq::combine"
      ],
      "vstd::tokens::frac::agree": [],
      "resource": [
        "vstd::tokens::frac::borrow",
        "take_resource"
      ],
      "vstd::tokens::frac::frac": [],
      "vstd::tokens::frac::combine": [],
      "vstd::tokens::frac::bounded": [],
      "vstd::tokens::frac::borrow": [],
      "take_resource": [],
      "put_resource": [],
      "vstd::tokens::map::id": [],
      "vstd::tokens::map::view": [],
      "vstd::tokens::map::dummy": [],
      "vstd::tokens::map::take": [],
      "vstd::tokens::map::empty": [],
      "vstd::tokens::map::insert": [],
      "delete": [],
      "vstd::tokens::map::new": [],
      "vstd::tokens::map::agree": [],
      "vstd::tokens::map::combine": [],
      "disjoint": [
        "lemma_set_disjoint_lens",
        "take_resource",
        "put_resource",
        "vstd::tokens::seq::disjoint"
      ],
      "vstd::tokens::map::split": [],
      "vstd::tokens::map::update": [],
      "vstd::tokens::seq::id": [],
      "vstd::tokens::seq::view": [],
      "off": [
        "vstd::tokens::seq::agree",
        "update_subrange_with",
        "update_map",
        "vstd::tokens::seq::disjoint"
      ],
      "vstd::tokens::seq::new": [],
      "vstd::tokens::seq::dummy": [],
      "vstd::tokens::seq::agree": [],
      "update_subrange_with": [],
      "vstd::tokens::seq::off": [],
      "agree_map": [],
      "vstd::tokens::seq::update": [],
      "update_map": [
        "vstd::tokens::seq::update"
      ],
      "vstd::tokens::seq::split": [],
      "vstd::tokens::seq::combine": [],
      "vstd::tokens::seq::disjoint": [],
      "instance_id": [],
      "map": [
        "lemma_to_set_map_commutes",
        "lemma_set_map_insert_commute",
        "lemma_map_union_commute",
        "lemma_any_map_preserved_pred",
        "lemma_filter_map_union",
        "lemma_map_finite",
        "lemma_sets_eq_iff_injective_map_eq",
        "lemma_hashmap_deepview_dom",
        "lemma_hashmap_deepview_properties",
        "lemma_hashmap_deepview_values",
        "into_map"
      ],
      "vstd::tokens::empty": [],
      "vstd::tokens::insert": [],
      "vstd::tokens::remove": [],
      "into_map": [],
      "vstd::tokens::from_map": [],
      "vstd::tokens::instance_id": [],
      "set": [
        "vstd::tokens::from_map",
        "vstd::tokens::into_map"
      ],
      "vstd::tokens::into_map": [],
      "multiset": [
        "vstd::tokens::insert",
        "vstd::tokens::remove"
      ]
    }
  }
}
