"""
Structured Metadata for Repair Attempts

This module provides a global metadata store and typed dataclasses for tracking
repair attempts, replacing the previous ad-hoc dictionary approach.

Key Benefits:
- Type safety with dataclasses
- Centralized storage via MetadataStore
- Easy serialization to/from dict
- Clean querying and history access
"""

import re
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import TYPE_CHECKING, Any, Optional

from utils import ERROR_SUFFIX

# Avoid circular imports
if TYPE_CHECKING:
    from .shared_types import ActionResult, Observation, ReasoningResult

# Import utility functions (not types, so safe outside TYPE_CHECKING)
from .shared_types import generate_search_replace_diff


@dataclass
class CandidateMetadata:
    """
    Metadata for a single candidate solution.

    This is nested within RepairAttemptMetadata and represents one
    of potentially multiple repair candidates generated by an action.
    """

    # ===== IDENTITY =====
    candidate_index: int  # 0-indexed position in candidates list
    candidate_code: str
    original_code: str

    # ===== EVALUATION RESULTS =====
    accepted: bool = False
    reason: str = ""  # Combined evaluation/rejection reason (including safety info)

    # ===== VERIFICATION =====
    score: Any | None = None  # EvalScore object (or None if not evaluated)

    # ===== FILE REFERENCE =====
    candidate_file: Path | None = None

    # REMOVED FIELDS (now stored elsewhere or redundant):
    # - evaluation_reason + rejection_reason: combined into "reason"
    # - is_safe + safety_reason: included in "reason" text if needed
    # - is_best_candidate: use parent RepairAttemptMetadata.best_candidate_index
    # - failed_errors_after: get from score.verus_errors if needed

    def to_dict(self) -> dict[str, Any]:
        """
        Serialize to dictionary for storage and passing.

        Returns a JSON-serializable dict representation.
        """
        return {
            "candidate_index": self.candidate_index,
            "candidate_code": self.candidate_code,
            "original_code": self.original_code,
            "accepted": self.accepted,
            "reason": self.reason,
            "score": str(self.score) if self.score else None,
            "candidate_file": str(self.candidate_file) if self.candidate_file else None,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "CandidateMetadata":
        """
        Deserialize from dictionary.

        Provides backward compatibility with old field names.
        """
        # Create a copy to avoid modifying input
        data = data.copy()

        # Convert path strings back to Path objects
        if data.get("candidate_file"):
            data["candidate_file"] = Path(data["candidate_file"])

        # Backward compatibility: combine old fields into new "reason" field
        if "evaluation_reason" in data or "rejection_reason" in data:
            eval_reason = data.pop("evaluation_reason", "")
            reject_reason = data.pop("rejection_reason", "")
            data["reason"] = reject_reason if reject_reason else eval_reason

        # Remove old/deprecated fields
        data.pop("failed_errors_after", None)
        data.pop("failed_errors_after_count", None)
        data.pop("failed_errors_after_summary", None)
        data.pop("is_safe", None)
        data.pop("safety_reason", None)
        data.pop("is_best_candidate", None)

        return cls(**data)


@dataclass
class RepairAttemptMetadata:
    """
    Complete metadata for one repair attempt.

    A repair attempt represents one pass through the Observe-Reason-Act cycle
    and may generate multiple candidates.

    Usage:
        # Phase 1-2: Create with attempt-level info
        metadata = RepairAttemptMetadata(
            attempt_id=1,
            agent_name="AssertionErrorAgent",
            error_type="AssertFail",
            observation=obs.to_dict(),
            reasoning=reasoning.to_dict(),
            primary_action="instantiate_forall",
        )

        # Phase 3: Add candidates incrementally
        for i, cand_code in enumerate(candidates):
            candidate = CandidateMetadata(...)
            metadata.add_candidate(candidate)

        # Store in global registry
        GlobalConfig.get_metadata_store().add_attempt(metadata)
    """

    # ===== ATTEMPT IDENTITY =====
    attempt_id: int
    agent_name: str  # e.g., "AssertionErrorAgent", "PreconditionAgent"
    error_type: str  # e.g., "AssertFail", "PreconditionFail"

    # ===== THREE-PHASE RESULTS (Store objects directly, not dicts!) =====
    observation: Optional["Observation"] = None
    reasoning: Optional["ReasoningResult"] = None
    action_result: Optional["ActionResult"] = None  # Added for completeness

    # ===== CANDIDATES =====
    # This is the key field - contains all generated candidates
    candidates: list[CandidateMetadata] = field(default_factory=list)
    best_candidate_index: int | None = None  # Index of the best candidate

    # ===== TIMING =====
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

    # REMOVED FIELDS (now accessed through nested objects):
    # - primary_action: str (use reasoning.primary_action.value)
    # - secondary_actions: List[str] (use reasoning.secondary_actions)
    # - failed_errors_before: List[VerusError] (use observation.error or get from VEval)

    # ===== INCREMENTAL BUILDING =====

    def add_candidate(self, candidate: CandidateMetadata) -> None:
        """
        Add a candidate to this attempt.

        Candidates are added incrementally as they are evaluated.
        """
        self.candidates.append(candidate)

    # ===== COMPUTED PROPERTIES (for backward compatibility) =====

    @property
    def primary_action(self) -> str:
        """Get primary action from reasoning object"""
        return self.reasoning.primary_action.value if self.reasoning else ""

    @property
    def secondary_actions(self) -> list[str]:
        """Get secondary actions from reasoning object"""
        if not self.reasoning:
            return []
        return [a.value for a in self.reasoning.secondary_actions]

    @property
    def was_successful(self) -> bool:
        """Whether this attempt produced an accepted candidate"""
        return any(c.accepted for c in self.candidates)

    @property
    def accepted_candidates(self) -> list[CandidateMetadata]:
        """Get all accepted candidates"""
        return [c for c in self.candidates if c.accepted]

    @property
    def rejected_candidates(self) -> list[CandidateMetadata]:
        """Get all rejected candidates"""
        return [c for c in self.candidates if not c.accepted]

    @property
    def best_candidate(self) -> CandidateMetadata | None:
        """Get the best candidate if available"""
        if self.best_candidate_index is not None and 0 <= self.best_candidate_index < len(
            self.candidates
        ):
            return self.candidates[self.best_candidate_index]
        # Fallback: first accepted candidate
        accepted = self.accepted_candidates
        return accepted[0] if accepted else None

    # ===== SERIALIZATION =====

    def to_dict(self) -> dict[str, Any]:
        """
        Serialize to dictionary for:
        - Returning to repair_veval caller
        - Storing in action_history (backward compatibility)
        - JSON export for debugging

        Returns a JSON-serializable dict representation.
        """
        return {
            "attempt_id": self.attempt_id,
            "agent_name": self.agent_name,
            "error_type": self.error_type,
            # Recursively serialize nested objects
            "observation": self.observation.to_dict() if self.observation else None,
            "reasoning": self.reasoning.to_dict() if self.reasoning else None,
            "action": self.action_result.to_dict() if self.action_result else None,
            # Computed properties for backward compatibility
            "primary_action": self.primary_action,
            "secondary_actions": self.secondary_actions,
            "candidates": [c.to_dict() for c in self.candidates],
            "best_candidate_index": self.best_candidate_index,
            "timestamp": self.timestamp,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "RepairAttemptMetadata":
        """
        Deserialize from dictionary.

        Used for:
        - Reading history in reasoning phase
        - Reconstructing previous attempts
        - Loading from JSON
        """
        # Create a copy to avoid modifying input
        data = data.copy()

        # Convert candidate dicts to CandidateMetadata objects
        if "candidates" in data:
            data["candidates"] = [CandidateMetadata.from_dict(c) for c in data["candidates"]]

        # Remove serialization-only fields
        data.pop("failed_errors_before_count", None)
        data.pop("failed_errors_before_summary", None)

        # VerusError reconstruction not implemented
        data["failed_errors_before"] = []

        return cls(**data)

    # ===== CONVENIENCE PROPERTIES =====

    @property
    def total_candidates(self) -> int:
        """Total number of candidates generated"""
        return len(self.candidates)

    def get_summary(self) -> str:
        """Get a one-line summary of this attempt"""
        status = "SUCCESS" if self.was_successful else "FAILED"
        accepted_count = len(self.accepted_candidates)
        return (
            f"Attempt {self.attempt_id}: {self.primary_action} - "
            f"{status} ({accepted_count}/{self.total_candidates} accepted)"
        )


class MetadataStore:
    """
    Global store for all repair attempt metadata.

    This provides a centralized registry for tracking repair attempts,
    eliminating the need to pass metadata dicts back and forth.

    Benefits:
    - Single source of truth for all attempts
    - Easy querying and history access
    - Can persist to disk for debugging
    - No scattered state across agent instances

    Usage:
        # Get global instance
        store = GlobalConfig.get_metadata_store()

        # Add attempt
        metadata = RepairAttemptMetadata(...)
        store.add_attempt(metadata)

        # Query history
        recent = store.get_recent_attempts(n=5)
        successful = store.get_successful_attempts()

        # Export for debugging
        store.export_to_json(path)
    """

    def __init__(self):
        """Initialize empty metadata store"""
        self._attempts: dict[int, RepairAttemptMetadata] = {}
        self._creation_time = datetime.now().isoformat()

    def add_attempt(self, metadata: RepairAttemptMetadata) -> None:
        """
        Add a repair attempt to the store.

        Args:
            metadata: RepairAttemptMetadata to store
        """
        self._attempts[metadata.attempt_id] = metadata

    def get_attempt(self, attempt_id: int) -> RepairAttemptMetadata | None:
        """
        Get metadata for a specific attempt.

        Args:
            attempt_id: The attempt number to retrieve

        Returns:
            RepairAttemptMetadata if found, None otherwise
        """
        return self._attempts.get(attempt_id)

    def get_all_attempts(self) -> list[RepairAttemptMetadata]:
        """
        Get all repair attempts in chronological order.

        Returns:
            List of RepairAttemptMetadata sorted by attempt_id
        """
        return sorted(self._attempts.values(), key=lambda m: m.attempt_id)

    def get_recent_attempts(self, n: int = 5) -> list[RepairAttemptMetadata]:
        """
        Get the N most recent repair attempts.

        Useful for providing history context to the reasoning phase.

        Args:
            n: Number of recent attempts to return

        Returns:
            List of up to N most recent RepairAttemptMetadata
        """
        all_attempts = self.get_all_attempts()
        return all_attempts[-n:] if len(all_attempts) > n else all_attempts

    def get_successful_attempts(self) -> list[RepairAttemptMetadata]:
        """
        Get all attempts that produced at least one accepted candidate.

        Returns:
            List of successful RepairAttemptMetadata
        """
        return [m for m in self.get_all_attempts() if m.was_successful]

    def get_failed_attempts(self) -> list[RepairAttemptMetadata]:
        """
        Get all attempts that did not produce any accepted candidates.

        Returns:
            List of failed RepairAttemptMetadata
        """
        return [m for m in self.get_all_attempts() if not m.was_successful]

    def get_attempts_by_action(self, action_name: str) -> list[RepairAttemptMetadata]:
        """
        Get all attempts that used a specific action.

        Args:
            action_name: The action to filter by (e.g., "instantiate_forall")

        Returns:
            List of RepairAttemptMetadata that used this action
        """
        return [m for m in self.get_all_attempts() if m.primary_action == action_name]

    def clear(self) -> None:
        """
        Clear all metadata from the store.

        This should be called at the start of a new repair session.
        """
        self._attempts.clear()
        self._creation_time = datetime.now().isoformat()

    def get_statistics(self) -> dict[str, Any]:
        """
        Get summary statistics about all attempts.

        Returns:
            Dict with statistics like total attempts, success rate, etc.
        """
        all_attempts = self.get_all_attempts()
        successful = self.get_successful_attempts()

        if not all_attempts:
            return {
                "total_attempts": 0,
                "successful_attempts": 0,
                "failed_attempts": 0,
                "success_rate": 0.0,
            }

        # Count candidates
        total_candidates = sum(m.total_candidates for m in all_attempts)
        accepted_candidates = sum(len(m.accepted_candidates) for m in all_attempts)

        # Action usage
        action_counts: dict[str, int] = {}
        for m in all_attempts:
            action_counts[m.primary_action] = action_counts.get(m.primary_action, 0) + 1

        return {
            "total_attempts": len(all_attempts),
            "successful_attempts": len(successful),
            "failed_attempts": len(all_attempts) - len(successful),
            "success_rate": len(successful) / len(all_attempts),
            "total_candidates_generated": total_candidates,
            "total_candidates_accepted": accepted_candidates,
            "candidate_acceptance_rate": (
                accepted_candidates / total_candidates if total_candidates > 0 else 0.0
            ),
            "action_usage": action_counts,
            "creation_time": self._creation_time,
        }

    def export_to_json(self, file_path: Path) -> None:
        """
        Export all metadata to JSON file for debugging.

        Args:
            file_path: Path where JSON should be written
        """
        import json

        data = {
            "metadata": [m.to_dict() for m in self.get_all_attempts()],
            "statistics": self.get_statistics(),
        }

        with open(file_path, "w") as f:
            json.dump(data, f, indent=2)

    def import_from_json(self, file_path: Path) -> None:
        """
        Import metadata from JSON file.

        Args:
            file_path: Path to JSON file to import
        """
        import json

        with open(file_path) as f:
            data = json.load(f)

        # Clear existing data
        self.clear()

        # Import attempts
        for attempt_dict in data.get("metadata", []):
            metadata = RepairAttemptMetadata.from_dict(attempt_dict)
            self.add_attempt(metadata)

    def format_action_history(self, max_attempts: int = None) -> str:
        """
        Format action history for inclusion in LLM prompts.

        Args:
            max_attempts: Maximum number of attempts to include (None = all)

        Returns:
            Formatted markdown text describing previous repair attempts
        """
        repair_history = self.get_all_attempts()

        # Limit number of attempts if specified
        if max_attempts and len(repair_history) > max_attempts:
            repair_history = repair_history[-max_attempts:]

        if not repair_history:
            return "## Previous Repair Attempts\nNo previous repair attempts."

        history_text = "## Previous Repair Attempts\n"
        for attempt_meta in repair_history:
            acceptance_status = "âœ“ ACCEPTED" if attempt_meta.was_successful else "âœ— REJECTED"
            history_text += f"""
### Attempt {attempt_meta.attempt_id}: {attempt_meta.primary_action.upper()} - {acceptance_status}
"""

            # Get original code from observation
            original_code = attempt_meta.observation.code if attempt_meta.observation else ""
            original_code = original_code.replace(ERROR_SUFFIX, "")

            if not attempt_meta.was_successful:
                if attempt_meta.rejected_candidates:
                    history_text += "- **Detailed Changes**:\n"
                    for candidate in attempt_meta.rejected_candidates[
                        :2
                    ]:  # Limit to first 2 candidates
                        history_text += (
                            f"  - Candidate {candidate.candidate_index}: {candidate.reason}\n"
                        )

                        # Add syntax hints for compilation/syntax errors
                        if candidate.candidate_code and (
                            "syntax" in candidate.reason.lower()
                            or "compilation" in candidate.reason.lower()
                        ):
                            from .verus_syntax_patterns import get_syntax_hint

                            hint = get_syntax_hint(candidate.candidate_code)
                            if hint:
                                history_text += f"  ðŸ’¡ **Syntax Hint**: {hint}\n"

                        if original_code and candidate.candidate_code:
                            try:
                                # Filter out code containing SEARCH/REPLACE markers
                                if re.search(
                                    r"<{7,}\s*SEARCH|={7,}\s*$|>{7,}\s*REPLACE",
                                    candidate.candidate_code,
                                    re.MULTILINE,
                                ):
                                    history_text += (
                                        "  (Malformed diff - contains SEARCH/REPLACE markers)\n"
                                    )
                                else:
                                    diff = generate_search_replace_diff(
                                        original_code, candidate.candidate_code
                                    )
                                    history_text += "  ```diff\n"
                                    history_text += diff if diff else "  (No changes detected)\n"
                                    history_text += "  ```\n"
                            except Exception:
                                history_text += "  (Unable to generate diff)\n"
            else:
                best_candidate = attempt_meta.best_candidate
                if best_candidate:
                    history_text += "- **Accepted Change**:\n"
                    if original_code and best_candidate.candidate_code:
                        try:
                            # Filter out code containing SEARCH/REPLACE markers
                            if re.search(
                                r"<{7,}\s*SEARCH|={7,}\s*$|>{7,}\s*REPLACE",
                                best_candidate.candidate_code,
                                re.MULTILINE,
                            ):
                                history_text += (
                                    "  (Malformed diff - contains SEARCH/REPLACE markers)\n"
                                )
                            else:
                                diff = generate_search_replace_diff(
                                    original_code, best_candidate.candidate_code
                                )
                                history_text += "  ```diff\n"
                                history_text += diff if diff else "  (No changes detected)\n"
                                history_text += "  ```\n"
                        except Exception:
                            history_text += "  (Unable to generate diff)\n"
                    # Log the score for the accepted candidate
                    if best_candidate.score:
                        history_text += f"- **Score**: {best_candidate.score}\n"

        history_text += "\n**Important**: Analyze the previous attempts carefully before proposing a new repair. Avoid repeating failed approaches, especially those marked as UNSAFE and SYNTAX ERROR. Consider why each attempt failed and ensure your solution addresses those issues.\n"
        return history_text

    def __len__(self) -> int:
        """Return number of attempts in store"""
        return len(self._attempts)

    def __repr__(self) -> str:
        """String representation"""
        stats = self.get_statistics()
        return (
            f"MetadataStore("
            f"attempts={stats['total_attempts']}, "
            f"successful={stats['successful_attempts']}, "
            f"success_rate={stats['success_rate']:.1%})"
        )
