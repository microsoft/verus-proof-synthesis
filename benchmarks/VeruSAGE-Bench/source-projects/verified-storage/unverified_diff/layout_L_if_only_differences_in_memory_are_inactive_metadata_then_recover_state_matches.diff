--- benchmarks/verified-storage/unverified_nolemma/layout_L_if_only_differences_in_memory_are_inactive_metadata_then_recover_state_matches.rs

+++ benchmarks/verified-storage/unverified/layout_L_if_only_differences_in_memory_are_inactive_metadata_then_recover_state_matches.rs

@@ -85,6 +85,32 @@

         &&& u64::bytes_parseable(extract_bytes(mem, crc_pos as nat, u64::spec_size_of()))
         &&& crc == spec_crc_u64(metadata.spec_to_bytes())
     }
+}
+
+#[verifier::external_body]
+pub proof fn lemma_active_metadata_bytes_equal_implies_metadata_types_set(
+    mem1: Seq<u8>,
+    mem2: Seq<u8>,
+    cdb: bool,
+)
+    requires
+        ABSOLUTE_POS_OF_LOG_AREA <= mem1.len(),
+        ABSOLUTE_POS_OF_LOG_AREA <= mem2.len(),
+        active_metadata_bytes_are_equal(mem1, mem2),
+        ({
+            let cdb1 = deserialize_and_check_log_cdb(mem1);
+            let cdb2 = deserialize_and_check_log_cdb(mem2);
+            let log_metadata_pos = get_log_metadata_pos(cdb);
+            &&& cdb1 is Some
+            &&& cdb2 is Some
+            &&& cdb ==> cdb1.unwrap() && cdb2.unwrap()
+            &&& !cdb ==> !cdb1.unwrap() && !cdb2.unwrap()
+        }),
+        metadata_types_set(mem1),
+    ensures
+        metadata_types_set(mem2),
+{
+    unimplemented!()
 }
 
 pub const ABSOLUTE_POS_OF_GLOBAL_METADATA: u64 = 0;
@@ -384,6 +410,16 @@

     }
 }
 
+#[verifier::external_body]
+pub proof fn lemma_establish_subrange_equivalence(mem1: Seq<u8>, mem2: Seq<u8>)
+    ensures
+        forall|i: int, j: int|
+            mem1.subrange(i, j) =~= mem2.subrange(i, j) ==> #[trigger] mem1.subrange(i, j)
+                == #[trigger] mem2.subrange(i, j),
+{
+    unimplemented!()
+}
+
 pub struct AbstractLogState {
     pub head: int,
     pub log: Seq<u8>,
@@ -410,6 +446,38 @@

     }
 }
 
+
+
+pub trait PmCopy: PmSized + SpecPmSized + Sized + Copy {
+
+}
+
+pub trait PmCopyHelper: PmCopy {
+    spec fn spec_to_bytes(self) -> Seq<u8>;
+
+    spec fn spec_from_bytes(bytes: Seq<u8>) -> Self;
+
+    spec fn bytes_parseable(bytes: Seq<u8>) -> bool;
+
+    spec fn spec_crc(self) -> u64;
+}
+
+impl<T> PmCopyHelper for T where T: PmCopy {
+    closed spec fn spec_to_bytes(self) -> Seq<u8>;
+
+    closed spec fn spec_from_bytes(bytes: Seq<u8>) -> Self {
+        choose|x: T| x.spec_to_bytes() == bytes
+    }
+
+    open spec fn spec_crc(self) -> u64 {
+        spec_crc_u64(self.spec_to_bytes())
+    }
+
+    open spec fn bytes_parseable(bytes: Seq<u8>) -> bool {
+        Self::spec_from_bytes(bytes).spec_to_bytes() == bytes
+    }
+}
+
 #[verifier::external_body]
 pub proof fn axiom_bytes_len<S: PmCopy>(s: S)
     ensures
@@ -424,36 +492,6 @@

         s == #[trigger] S::spec_from_bytes(s.spec_to_bytes()),
 {
     unimplemented!()
-}
-
-pub trait PmCopy: PmSized + SpecPmSized + Sized + Copy {
-
-}
-
-pub trait PmCopyHelper: PmCopy {
-    spec fn spec_to_bytes(self) -> Seq<u8>;
-
-    spec fn spec_from_bytes(bytes: Seq<u8>) -> Self;
-
-    spec fn bytes_parseable(bytes: Seq<u8>) -> bool;
-
-    spec fn spec_crc(self) -> u64;
-}
-
-impl<T> PmCopyHelper for T where T: PmCopy {
-    closed spec fn spec_to_bytes(self) -> Seq<u8>;
-
-    closed spec fn spec_from_bytes(bytes: Seq<u8>) -> Self {
-        choose|x: T| x.spec_to_bytes() == bytes
-    }
-
-    open spec fn spec_crc(self) -> u64 {
-        spec_crc_u64(self.spec_to_bytes())
-    }
-
-    open spec fn bytes_parseable(bytes: Seq<u8>) -> bool {
-        Self::spec_from_bytes(bytes).spec_to_bytes() == bytes
-    }
 }
 
 impl PmCopy for u64 {