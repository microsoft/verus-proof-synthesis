--- benchmarks/verified-storage/unverified_nolemma/logimpl_advance_head.rs

+++ benchmarks/verified-storage/unverified/logimpl_advance_head.rs

@@ -160,6 +160,61 @@

         &&& u64::bytes_parseable(extract_bytes(mem, crc_pos as nat, u64::spec_size_of()))
         &&& crc == spec_crc_u64(metadata.spec_to_bytes())
     }
+}
+
+#[verifier::external_body]
+pub proof fn lemma_addresses_in_log_area_correspond_to_relative_log_positions(
+    pm_region_view: PersistentMemoryRegionView,
+    info: LogInfo,
+)
+    requires
+        pm_region_view.len() >= ABSOLUTE_POS_OF_LOG_AREA + info.log_area_len,
+        info.head_log_area_offset < info.log_area_len,
+        info.log_area_len > 0,
+    ensures
+        forall|addr: int|
+            #![trigger
+    pm_region_view.state[addr]]
+            ABSOLUTE_POS_OF_LOG_AREA <= addr < ABSOLUTE_POS_OF_LOG_AREA + info.log_area_len ==> {
+                let log_area_offset = addr - ABSOLUTE_POS_OF_LOG_AREA;
+                let pos_relative_to_head = if log_area_offset >= info.head_log_area_offset {
+                    log_area_offset - info.head_log_area_offset
+                } else {
+                    log_area_offset - info.head_log_area_offset + info.log_area_len
+                };
+                &&& 0 <= pos_relative_to_head < info.log_area_len
+                &&& addr == ABSOLUTE_POS_OF_LOG_AREA + relative_log_pos_to_log_area_offset(
+                    pos_relative_to_head,
+                    info.head_log_area_offset as int,
+                    info.log_area_len as int,
+                )
+            },
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_invariants_imply_crash_recover_forall(
+    pm_region_view: PersistentMemoryRegionView,
+    log_id: u128,
+    cdb: bool,
+    info: LogInfo,
+    state: AbstractLogState,
+)
+    requires
+        memory_matches_deserialized_cdb(pm_region_view, cdb),
+        metadata_consistent_with_info(pm_region_view, log_id, cdb, info),
+        info_consistent_with_log_area_in_region(pm_region_view, info, state),
+        metadata_types_set(pm_region_view.committed()),
+    ensures
+        forall|mem| #[trigger]
+            pm_region_view.can_crash_as(mem) ==> {
+                &&& recover_cdb(mem) == Some(cdb)
+                &&& recover_state(mem, log_id) == Some(state.drop_pending_appends())
+                &&& metadata_types_set(mem)
+            },
+{
+    unimplemented!()
 }
 
 pub const ABSOLUTE_POS_OF_GLOBAL_METADATA: u64 = 0;
@@ -571,6 +626,32 @@

             self.inv(wrpm_region, log_id),
             wrpm_region.constants() == old(wrpm_region).constants(),
             self.state == old(self).state,
+    {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_check_fast_way_to_compute_head_mod_log_area_len(
+        info: LogInfo,
+        state: AbstractLogState,
+        new_head: u128,
+    )
+        requires
+            info.head <= new_head,
+            new_head - info.head <= info.log_length as u128,
+            info.log_area_len >= MIN_LOG_AREA_SIZE,
+            info.log_length <= info.log_plus_pending_length <= info.log_area_len,
+            info.head_log_area_offset == info.head as int % info.log_area_len as int,
+        ensures
+            ({
+                let amount_of_advancement: u64 = (new_head - info.head) as u64;
+                new_head as int % info.log_area_len as int == if amount_of_advancement
+                    < info.log_area_len - info.head_log_area_offset {
+                    amount_of_advancement + info.head_log_area_offset
+                } else {
+                    amount_of_advancement - (info.log_area_len - info.head_log_area_offset)
+                }
+            }),
     {
         unimplemented!()
     }
@@ -693,6 +774,38 @@

     }
 }
 
+
+
+pub trait PmCopy: PmSized + SpecPmSized + Sized + Copy {
+
+}
+
+pub trait PmCopyHelper: PmCopy {
+    spec fn spec_to_bytes(self) -> Seq<u8>;
+
+    spec fn spec_from_bytes(bytes: Seq<u8>) -> Self;
+
+    spec fn bytes_parseable(bytes: Seq<u8>) -> bool;
+
+    spec fn spec_crc(self) -> u64;
+}
+
+impl<T> PmCopyHelper for T where T: PmCopy {
+    closed spec fn spec_to_bytes(self) -> Seq<u8>;
+
+    closed spec fn spec_from_bytes(bytes: Seq<u8>) -> Self {
+        choose|x: T| x.spec_to_bytes() == bytes
+    }
+
+    open spec fn spec_crc(self) -> u64 {
+        spec_crc_u64(self.spec_to_bytes())
+    }
+
+    open spec fn bytes_parseable(bytes: Seq<u8>) -> bool {
+        Self::spec_from_bytes(bytes).spec_to_bytes() == bytes
+    }
+}
+
 #[verifier::external_body]
 pub proof fn axiom_bytes_len<S: PmCopy>(s: S)
     ensures
@@ -707,36 +820,6 @@

         s == #[trigger] S::spec_from_bytes(s.spec_to_bytes()),
 {
     unimplemented!()
-}
-
-pub trait PmCopy: PmSized + SpecPmSized + Sized + Copy {
-
-}
-
-pub trait PmCopyHelper: PmCopy {
-    spec fn spec_to_bytes(self) -> Seq<u8>;
-
-    spec fn spec_from_bytes(bytes: Seq<u8>) -> Self;
-
-    spec fn bytes_parseable(bytes: Seq<u8>) -> bool;
-
-    spec fn spec_crc(self) -> u64;
-}
-
-impl<T> PmCopyHelper for T where T: PmCopy {
-    closed spec fn spec_to_bytes(self) -> Seq<u8>;
-
-    closed spec fn spec_from_bytes(bytes: Seq<u8>) -> Self {
-        choose|x: T| x.spec_to_bytes() == bytes
-    }
-
-    open spec fn spec_crc(self) -> u64 {
-        spec_crc_u64(self.spec_to_bytes())
-    }
-
-    open spec fn bytes_parseable(bytes: Seq<u8>) -> bool {
-        Self::spec_from_bytes(bytes).spec_to_bytes() == bytes
-    }
 }
 
 impl PmCopy for u64 {