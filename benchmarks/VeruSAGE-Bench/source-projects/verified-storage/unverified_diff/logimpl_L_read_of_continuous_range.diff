--- benchmarks/verified-storage/unverified_nolemma/logimpl_L_read_of_continuous_range.rs

+++ benchmarks/verified-storage/unverified/logimpl_L_read_of_continuous_range.rs

@@ -86,6 +86,37 @@

         info,
         state,
     )
+}
+
+#[verifier::external_body]
+pub proof fn lemma_addresses_in_log_area_correspond_to_relative_log_positions(
+    pm_region_view: PersistentMemoryRegionView,
+    info: LogInfo,
+)
+    requires
+        pm_region_view.len() >= ABSOLUTE_POS_OF_LOG_AREA + info.log_area_len,
+        info.head_log_area_offset < info.log_area_len,
+        info.log_area_len > 0,
+    ensures
+        forall|addr: int|
+            #![trigger
+    pm_region_view.state[addr]]
+            ABSOLUTE_POS_OF_LOG_AREA <= addr < ABSOLUTE_POS_OF_LOG_AREA + info.log_area_len ==> {
+                let log_area_offset = addr - ABSOLUTE_POS_OF_LOG_AREA;
+                let pos_relative_to_head = if log_area_offset >= info.head_log_area_offset {
+                    log_area_offset - info.head_log_area_offset
+                } else {
+                    log_area_offset - info.head_log_area_offset + info.log_area_len
+                };
+                &&& 0 <= pos_relative_to_head < info.log_area_len
+                &&& addr == ABSOLUTE_POS_OF_LOG_AREA + relative_log_pos_to_log_area_offset(
+                    pos_relative_to_head,
+                    info.head_log_area_offset as int,
+                    info.log_area_len as int,
+                )
+            },
+{
+    unimplemented!()
 }
 
 pub const ABSOLUTE_POS_OF_GLOBAL_METADATA: u64 = 0;
@@ -332,6 +363,33 @@

     }
 }
 
+
+
+pub trait PmCopy: PmSized + SpecPmSized + Sized + Copy {
+
+}
+
+pub trait PmCopyHelper: PmCopy {
+    spec fn spec_to_bytes(self) -> Seq<u8>;
+
+    spec fn spec_from_bytes(bytes: Seq<u8>) -> Self;
+
+    spec fn spec_crc(self) -> u64;
+}
+
+impl<T> PmCopyHelper for T where T: PmCopy {
+    closed spec fn spec_to_bytes(self) -> Seq<u8>;
+
+    #[verifier::external_body]
+    closed spec fn spec_from_bytes(bytes: Seq<u8>) -> Self {
+        unimplemented!()
+    }
+
+    open spec fn spec_crc(self) -> u64 {
+        spec_crc_u64(self.spec_to_bytes())
+    }
+}
+
 #[verifier::external_body]
 pub proof fn axiom_bytes_len<S: PmCopy>(s: S)
     ensures
@@ -346,31 +404,6 @@

         s == #[trigger] S::spec_from_bytes(s.spec_to_bytes()),
 {
     unimplemented!()
-}
-
-pub trait PmCopy: PmSized + SpecPmSized + Sized + Copy {
-
-}
-
-pub trait PmCopyHelper: PmCopy {
-    spec fn spec_to_bytes(self) -> Seq<u8>;
-
-    spec fn spec_from_bytes(bytes: Seq<u8>) -> Self;
-
-    spec fn spec_crc(self) -> u64;
-}
-
-impl<T> PmCopyHelper for T where T: PmCopy {
-    closed spec fn spec_to_bytes(self) -> Seq<u8>;
-
-    #[verifier::external_body]
-    closed spec fn spec_from_bytes(bytes: Seq<u8>) -> Self {
-        unimplemented!()
-    }
-
-    open spec fn spec_crc(self) -> u64 {
-        spec_crc_u64(self.spec_to_bytes())
-    }
 }
 
 impl PmCopy for u64 {