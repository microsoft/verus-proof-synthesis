--- benchmarks/verified-storage/unverified_nolemma/logimpl_tentatively_append_to_log.rs

+++ benchmarks/verified-storage/unverified/logimpl_tentatively_append_to_log.rs

@@ -3,6 +3,132 @@

 use vstd::prelude::*;
 use vstd::slice::*;
 verus! {
+
+#[verifier::external_body]
+pub proof fn lemma_tentatively_append(
+    pm_region_view: PersistentMemoryRegionView,
+    bytes_to_append: Seq<u8>,
+    prev_info: LogInfo,
+    prev_state: AbstractLogState,
+)
+    requires
+        pm_region_view.len() == prev_info.log_area_len,
+        info_consistent_with_log_area(pm_region_view, prev_info, prev_state),
+        ({
+            let log_area_len = prev_info.log_area_len;
+            let num_bytes = bytes_to_append.len();
+            let max_len_without_wrapping = log_area_len - relative_log_pos_to_log_area_offset(
+                prev_info.log_plus_pending_length as int,
+                prev_info.head_log_area_offset as int,
+                log_area_len as int,
+            );
+            &&& 0 < num_bytes <= max_len_without_wrapping
+            &&& prev_info.log_plus_pending_length + num_bytes <= log_area_len
+            &&& prev_info.head + prev_info.log_plus_pending_length + num_bytes <= u128::MAX
+        }),
+    ensures
+        ({
+            let log_area_len = prev_info.log_area_len;
+            let num_bytes = bytes_to_append.len();
+            let new_info = prev_info.tentatively_append(num_bytes as u64);
+            let new_state = prev_state.tentatively_append(bytes_to_append);
+            let write_addr = relative_log_pos_to_log_area_offset(
+                prev_info.log_plus_pending_length as int,
+                prev_info.head_log_area_offset as int,
+                log_area_len as int,
+            );
+            let pm_region_view2 = pm_region_view.write(write_addr, bytes_to_append);
+            &&& pm_region_view.no_outstanding_writes_in_range(write_addr, write_addr + num_bytes)
+            &&& forall|log_area_offset: int|
+                write_addr <= log_area_offset < write_addr + num_bytes
+                    ==> log_area_offset_unreachable_during_recovery(
+                    prev_info.head_log_area_offset as int,
+                    prev_info.log_area_len as int,
+                    prev_info.log_length as int,
+                    log_area_offset,
+                )
+            &&& info_consistent_with_log_area(pm_region_view2, new_info, new_state)
+        }),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_tentatively_append_wrapping(
+    pm_region_view: PersistentMemoryRegionView,
+    bytes_to_append: Seq<u8>,
+    prev_info: LogInfo,
+    prev_state: AbstractLogState,
+)
+    requires
+        pm_region_view.len() == prev_info.log_area_len,
+        info_consistent_with_log_area(pm_region_view, prev_info, prev_state),
+        ({
+            let log_area_len = prev_info.log_area_len;
+            let num_bytes = bytes_to_append.len();
+            let max_len_without_wrapping = log_area_len - relative_log_pos_to_log_area_offset(
+                prev_info.log_plus_pending_length as int,
+                prev_info.head_log_area_offset as int,
+                log_area_len as int,
+            );
+            &&& num_bytes > max_len_without_wrapping
+            &&& prev_info.head + prev_info.log_plus_pending_length + num_bytes <= u128::MAX
+            &&& num_bytes <= log_area_len - prev_info.log_plus_pending_length
+        }),
+    ensures
+        ({
+            let log_area_len = prev_info.log_area_len;
+            let max_len_without_wrapping = log_area_len - relative_log_pos_to_log_area_offset(
+                prev_info.log_plus_pending_length as int,
+                prev_info.head_log_area_offset as int,
+                log_area_len as int,
+            );
+            let new_info = prev_info.tentatively_append(bytes_to_append.len() as u64);
+            let new_state = prev_state.tentatively_append(bytes_to_append);
+            let bytes_to_append_part1 = bytes_to_append.subrange(
+                0,
+                max_len_without_wrapping as int,
+            );
+            let bytes_to_append_part2 = bytes_to_append.subrange(
+                max_len_without_wrapping as int,
+                bytes_to_append.len() as int,
+            );
+            let write_addr = relative_log_pos_to_log_area_offset(
+                prev_info.log_plus_pending_length as int,
+                prev_info.head_log_area_offset as int,
+                log_area_len as int,
+            );
+            let pm_region_view2 = pm_region_view.write(write_addr, bytes_to_append_part1);
+            let pm_region_view3 = pm_region_view2.write(0int, bytes_to_append_part2);
+            &&& pm_region_view.no_outstanding_writes_in_range(
+                write_addr,
+                write_addr + bytes_to_append_part1.len(),
+            )
+            &&& forall|log_area_offset: int|
+                write_addr <= log_area_offset < write_addr + bytes_to_append_part1.len()
+                    ==> log_area_offset_unreachable_during_recovery(
+                    prev_info.head_log_area_offset as int,
+                    prev_info.log_area_len as int,
+                    prev_info.log_length as int,
+                    log_area_offset,
+                )
+            &&& pm_region_view2.no_outstanding_writes_in_range(
+                0int,
+                bytes_to_append_part2.len() as int,
+            )
+            &&& forall|log_area_offset: int|
+                0 <= log_area_offset < bytes_to_append_part2.len()
+                    ==> log_area_offset_unreachable_during_recovery(
+                    prev_info.head_log_area_offset as int,
+                    prev_info.log_area_len as int,
+                    prev_info.log_length as int,
+                    log_area_offset,
+                )
+            &&& info_consistent_with_log_area(pm_region_view3, new_info, new_state)
+        }),
+{
+    unimplemented!()
+}
 
 pub open spec fn info_consistent_with_log_area(
     log_area_view: PersistentMemoryRegionView,