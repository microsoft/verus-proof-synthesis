--- benchmarks/verified-storage/unverified_nolemma/inv_L_active_metadata_set_after_crash.rs

+++ benchmarks/verified-storage/unverified/inv_L_active_metadata_set_after_crash.rs

@@ -241,6 +241,16 @@

     u64::spec_from_bytes(bytes)
 }
 
+#[verifier::external_body]
+pub proof fn lemma_establish_subrange_equivalence(mem1: Seq<u8>, mem2: Seq<u8>)
+    ensures
+        forall|i: int, j: int|
+            mem1.subrange(i, j) =~= mem2.subrange(i, j) ==> #[trigger] mem1.subrange(i, j)
+                == #[trigger] mem2.subrange(i, j),
+{
+    unimplemented!()
+}
+
 pub open spec fn nat_seq_max(seq: Seq<nat>) -> nat
     recommends
         0 < seq.len(),
@@ -260,6 +270,32 @@

     }
 }
 
+
+
+pub trait PmCopy: PmSized + SpecPmSized + Sized + Copy {
+
+}
+
+pub trait PmCopyHelper: PmCopy {
+    spec fn spec_to_bytes(self) -> Seq<u8>;
+
+    spec fn spec_from_bytes(bytes: Seq<u8>) -> Self;
+
+    spec fn bytes_parseable(bytes: Seq<u8>) -> bool;
+}
+
+impl<T> PmCopyHelper for T where T: PmCopy {
+    closed spec fn spec_to_bytes(self) -> Seq<u8>;
+
+    closed spec fn spec_from_bytes(bytes: Seq<u8>) -> Self {
+        choose|x: T| x.spec_to_bytes() == bytes
+    }
+
+    open spec fn bytes_parseable(bytes: Seq<u8>) -> bool {
+        Self::spec_from_bytes(bytes).spec_to_bytes() == bytes
+    }
+}
+
 #[verifier::external_body]
 pub proof fn axiom_bytes_len<S: PmCopy>(s: S)
     ensures
@@ -274,30 +310,6 @@

         s == #[trigger] S::spec_from_bytes(s.spec_to_bytes()),
 {
     unimplemented!()
-}
-
-pub trait PmCopy: PmSized + SpecPmSized + Sized + Copy {
-
-}
-
-pub trait PmCopyHelper: PmCopy {
-    spec fn spec_to_bytes(self) -> Seq<u8>;
-
-    spec fn spec_from_bytes(bytes: Seq<u8>) -> Self;
-
-    spec fn bytes_parseable(bytes: Seq<u8>) -> bool;
-}
-
-impl<T> PmCopyHelper for T where T: PmCopy {
-    closed spec fn spec_to_bytes(self) -> Seq<u8>;
-
-    closed spec fn spec_from_bytes(bytes: Seq<u8>) -> Self {
-        choose|x: T| x.spec_to_bytes() == bytes
-    }
-
-    open spec fn bytes_parseable(bytes: Seq<u8>) -> bool {
-        Self::spec_from_bytes(bytes).spec_to_bytes() == bytes
-    }
 }
 
 impl PmCopy for u64 {
@@ -422,6 +434,21 @@

     bytes.subrange(pos as int, (pos + len) as int)
 }
 
+#[verifier::external_body]
+pub proof fn lemma_wherever_no_outstanding_writes_persistent_memory_view_can_only_crash_as_committed(
+    pm_region_view: PersistentMemoryRegionView,
+)
+    ensures
+        forall|s, addr: int|
+            {
+                &&& pm_region_view.can_crash_as(s)
+                &&& 0 <= addr < s.len()
+                &&& pm_region_view.state[addr].outstanding_write.is_none()
+            } ==> #[trigger] s[addr] == pm_region_view.committed()[addr],
+{
+    unimplemented!()
+}
+
 #[verifier::external_trait_specification]
 pub trait ExPmSized: SpecPmSized {
     type ExternalTraitSpecificationFor: PmSized;