--- benchmarks/verified-ironkv/unverified_nolemma/marshal_ironsht_specific_v__lemma_is_marshalable_CKeyHashMap.rs

+++ benchmarks/verified-ironkv/unverified/marshal_ironsht_specific_v__lemma_is_marshalable_CKeyHashMap.rs

@@ -21,6 +21,22 @@

     }
 
     pub uninterp spec fn spec_from_vec(v: Vec<CKeyKV>) -> Self;
+
+    #[verifier::external_body]
+    pub proof fn lemma_to_vec(self)
+        ensures
+            Self::spec_from_vec(self.spec_to_vec()) == self,
+            self.spec_to_vec().len() == self@.dom().len(),
+            spec_sorted_keys(self.spec_to_vec()),
+            (forall|i: int|
+                #![trigger(self.spec_to_vec() [i])]
+                0 <= i < self.spec_to_vec().len() ==> {
+                    let (k, v) = self.spec_to_vec()[i]@;
+                    self@.contains_pair(k, v)
+                }),
+    {
+        unimplemented!()
+    }
 }
 
 pub struct CKeyKV {
@@ -46,6 +62,33 @@

 #[derive(Eq, PartialEq, Hash)]
 pub struct SHTKey {
     pub ukey: u64,
+}
+
+#[verifier::external_body]
+pub proof fn lemma_seq_fold_left_append_len_int<A, B>(
+    s: Seq<A>,
+    prefix: Seq<B>,
+    f: spec_fn(A) -> Seq<B>,
+)
+    ensures
+        s.fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)).len() as int == s.fold_left(
+            prefix.len() as int,
+            |i: int, a: A| i + f(a).len() as int,
+        ),
+    decreases s.len(),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_seq_fold_left_sum_le<A>(s: Seq<A>, init: int, high: int, f: spec_fn(A) -> int)
+    requires
+        forall|i: int| 0 <= i < s.len() ==> f(s[i]) <= high,
+    ensures
+        s.fold_left(init, |acc: int, x: A| acc + f(x)) <= init + s.len() * high,
+    decreases s.len(),
+{
+    unimplemented!()
 }
 
 pub trait Marshalable: Sized {
@@ -121,18 +164,19 @@

     }
 }
 
-macro_rules!
-    derive_marshalable_for_struct { { $(#[$attr : meta])* $pub : vis struct $newstruct :
-    ident $(< $($poly : ident : Marshalable),+ $(,)? >)? { $($fieldvis : vis $field :
-    ident : $fieldty : ty),+ $(,)? } } => { ::builtin_macros::verus! { impl $(< $($poly :
-    Marshalable),* >)? Marshalable for $newstruct $(< $($poly),* >)? { open spec fn
-    is_marshalable(& self) -> bool { $(&&& self.$field .is_marshalable())* &&& 0 $(+ self
-    .$field .ghost_serialize().len())* <= usize::MAX } open spec fn ghost_serialize(&
-    self) -> Seq < u8 > { Seq::empty() $(+ self.$field .ghost_serialize())* } } } } }
-
-macro_rules! marshalable_by_bijection { { [$type : ty] <-> [$marshalable : ty];
-    forward($self : ident) $forward : expr; backward($m : ident) $backward : expr; } => {
-    ::builtin_macros::verus! { impl $type { pub open spec fn
+macro_rules! derive_marshalable_for_struct { { $(#[$attr :
+    meta])* $pub : vis struct $newstruct : ident $(< $($poly : ident : Marshalable),+
+    $(,)? >)? { $($fieldvis : vis $field : ident : $fieldty : ty),+ $(,)? } } => {
+    ::builtin_macros::verus! { impl $(< $($poly : Marshalable),* >)? Marshalable for
+    $newstruct $(< $($poly),* >)? { open spec fn is_marshalable(& self) -> bool { $(&&&
+    self.$field .is_marshalable())* &&& 0 $(+ self.$field .ghost_serialize().len())* <=
+    usize::MAX } open spec fn ghost_serialize(& self) -> Seq < u8 > { Seq::empty() $(+
+    self.$field .ghost_serialize())* } } } } }
+
+macro_rules! marshalable_by_bijection { {
+    [$type : ty] <-> [$marshalable : ty]; forward($self : ident) $forward : expr;
+    backward($m : ident) $backward : expr; } => { ::builtin_macros::verus! { impl $type {
+    pub open spec fn
     forward_bijection_for_view_equality_do_not_use_for_anything_else($self : Self) ->
     $marshalable { $forward } } impl Marshalable for $type { open spec fn
     is_marshalable($self : & Self) -> bool { $forward .is_marshalable() } open spec fn