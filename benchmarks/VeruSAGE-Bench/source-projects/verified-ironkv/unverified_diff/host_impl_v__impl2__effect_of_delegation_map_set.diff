--- benchmarks/verified-ironkv/unverified_nolemma/host_impl_v__impl2__effect_of_delegation_map_set.rs

+++ benchmarks/verified-ironkv/unverified/host_impl_v__impl2__effect_of_delegation_map_set.rs

@@ -1,6 +1,33 @@

 use vstd::prelude::*;
+
 fn main() {}
+
 verus! {
+
+pub struct AbstractEndPoint {
+    pub id: Seq<u8>,
+}
+
+impl AbstractEndPoint {
+    pub open spec fn valid_physical_address(self) -> bool {
+        self.id.len() < 0x100000
+    }
+
+    pub open spec fn abstractable(self) -> bool {
+        self.valid_physical_address()
+    }
+}
+
+#[derive(PartialEq, Eq, Hash)]
+pub struct EndPoint {
+    pub id: Vec<u8>,
+}
+
+impl EndPoint {
+    pub open spec fn view(self) -> AbstractEndPoint {
+        AbstractEndPoint { id: self.id@ }
+    }
+}
 
 pub struct AbstractDelegationMap(pub Map<AbstractKey, AbstractEndPoint>);
 
@@ -30,30 +57,15 @@

     pub closed spec fn valid(self) -> bool {
         unimplemented!()
     }
-}
-
-pub struct AbstractEndPoint {
-    pub id: Seq<u8>,
-}
-
-impl AbstractEndPoint {
-    pub open spec fn valid_physical_address(self) -> bool {
-        self.id.len() < 0x100000
-    }
-
-    pub open spec fn abstractable(self) -> bool {
-        self.valid_physical_address()
-    }
-}
-
-#[derive(PartialEq, Eq, Hash)]
-pub struct EndPoint {
-    pub id: Vec<u8>,
-}
-
-impl EndPoint {
-    pub open spec fn view(self) -> AbstractEndPoint {
-        AbstractEndPoint { id: self.id@ }
+
+    #[verifier::external_body]
+    pub proof fn valid_implies_complete(&self)
+        requires
+            self.valid(),
+        ensures
+            self@.dom().is_full(),
+    {
+        unimplemented!()
     }
 }
 
@@ -66,9 +78,12 @@

 
 impl Ordering {
     pub open spec fn lt(self) -> bool {
-        matches!(self,
-    Ordering::Less)
-    }
+        matches!(self, Ordering::Less)
+    }
+}
+
+pub struct KeyIterator<K: KeyTrait + VerusClone> {
+    pub k: Option<K>,
 }
 
 pub trait VerusClone {
@@ -77,10 +92,6 @@

 
 pub trait KeyTrait: Sized {
     spec fn cmp_spec(self, other: Self) -> Ordering;
-}
-
-pub struct KeyIterator<K: KeyTrait + VerusClone> {
-    pub k: Option<K>,
 }
 
 impl<K: KeyTrait + VerusClone> KeyIterator<K> {
@@ -138,7 +149,6 @@

         self.k.as_ref().unwrap()
     }
 }
-
 
 pub struct KeyRange<K: KeyTrait + VerusClone> {
     pub lo: KeyIterator<K>,
@@ -194,6 +204,7 @@

     lows: StrictlyOrderedMap<K>,
     m: Ghost<Map<K, AbstractEndPoint>>,
 }
+
 
 proof fn effect_of_delegation_map_set(
     pre: DelegationMap<CKey>,