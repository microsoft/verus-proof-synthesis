--- benchmarks/verified-ironkv/unverified_nolemma/marshal_v__impl4__deserialize.rs

+++ benchmarks/verified-ironkv/unverified/marshal_v__impl4__deserialize.rs

@@ -2,6 +2,43 @@

 use vstd::prelude::*;
 fn main() {}
 verus! {
+
+#[verifier::external_body]
+pub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)
+    requires
+        0 <= i <= j <= k <= s.len(),
+    ensures
+        s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_seq_fold_left_sum_right<A>(s: Seq<A>, low: int, f: spec_fn(A) -> int)
+    requires
+        s.len() > 0,
+    ensures
+        s.subrange(0, s.len() - 1).fold_left(low, |b: int, a: A| b + f(a)) + f(s[s.len() - 1])
+            == s.fold_left(low, |b: int, a: A| b + f(a)),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_seq_fold_left_append_right<A, B>(
+    s: Seq<A>,
+    prefix: Seq<B>,
+    f: spec_fn(A) -> Seq<B>,
+)
+    requires
+        s.len() > 0,
+    ensures
+        s.subrange(0, s.len() - 1).fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)) + f(
+            s[s.len() - 1],
+        ) == s.fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)),
+{
+    unimplemented!()
+}
 
 pub trait Marshalable: Sized {
     spec fn is_marshalable(&self) -> bool;
@@ -154,7 +191,6 @@

             i = i + 1;
         }
         let ret = Some((res, end));
-        ret
     }
 }
 