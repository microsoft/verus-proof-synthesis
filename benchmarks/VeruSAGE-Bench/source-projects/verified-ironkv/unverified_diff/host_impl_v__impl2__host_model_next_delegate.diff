--- benchmarks/verified-ironkv/unverified_nolemma/host_impl_v__impl2__host_model_next_delegate.rs

+++ benchmarks/verified-ironkv/unverified/host_impl_v__impl2__host_model_next_delegate.rs

@@ -3,64 +3,6 @@

 use vstd::prelude::*;
 fn main() {}
 verus! {
-
-pub struct AbstractEndPoint {
-    pub id: Seq<u8>,
-}
-
-impl AbstractEndPoint {
-    pub open spec fn valid_physical_address(self) -> bool {
-        self.id.len() < 0x100000
-    }
-
-    pub open spec fn abstractable(self) -> bool {
-        self.valid_physical_address()
-    }
-}
-
-#[derive(PartialEq, Eq, Hash)]
-pub struct EndPoint {
-    pub id: Vec<u8>,
-}
-
-impl EndPoint {
-    pub open spec fn view(self) -> AbstractEndPoint {
-        AbstractEndPoint { id: self.id@ }
-    }
-
-    #[verifier(inline)]
-    pub open spec fn abstractable(self) -> bool {
-        self@.valid_physical_address()
-    }
-}
-
-
-pub struct AbstractParameters {
-    pub max_seqno: nat,
-    pub max_delegations: nat,
-}
-
-impl AbstractParameters {
-    pub open spec fn static_params() -> AbstractParameters {
-        AbstractParameters {
-            max_seqno: 0xffff_ffff_ffff_ffff as nat,
-            max_delegations: 0x7FFF_FFFF_FFFF_FFFF as nat,
-        }
-    }
-}
-
-pub enum AppRequest {
-    AppGetRequest { seqno: nat, key: AbstractKey },
-    AppSetRequest { seqno: nat, key: AbstractKey, ov: Option<AbstractValue> },
-}
-
-
-pub open spec fn optional_value_view(ov: Option::<Vec::<u8>>) -> Option::<Seq::<u8>> {
-    match ov {
-        Some(v) => Some(v@),
-        None => None,
-    }
-}
 
 #[allow(inconsistent_fields)]
 pub enum CMessage {
@@ -70,6 +12,13 @@

     Redirect { k: CKey, id: EndPoint },
     Shard { kr: KeyRange::<CKey>, recipient: EndPoint },
     Delegate { range: KeyRange::<CKey>, h: CKeyHashMap },
+}
+
+pub open spec fn optional_value_view(ov: Option::<Vec::<u8>>) -> Option::<Seq::<u8>> {
+    match ov {
+        Some(v) => Some(v@),
+        None => None,
+    }
 }
 
 impl CMessage {
@@ -173,7 +122,9 @@

     forall|i: int| 0 <= i && i < packets.len() ==> #[trigger] packets[i].abstractable()
 }
 
-pub open spec fn abstractify_outbound_packets_to_seq_of_lsht_packets(packets: Seq<CPacket>) -> Seq<LSHTPacket>
+pub open spec fn abstractify_outbound_packets_to_seq_of_lsht_packets(packets: Seq<CPacket>) -> Seq<
+    LSHTPacket,
+>
     recommends
         cpacket_seq_is_abstractable(packets),
 {
@@ -187,7 +138,6 @@

     cps.map_values(|cp: CPacket| cp@).to_set()
 }
 
-/*Marshalable Trait*/
 pub trait Marshalable: Sized {
     spec fn is_marshalable(&self) -> bool;
 
@@ -317,6 +267,35 @@

     is_marshalable($self : & Self) -> bool { $forward .is_marshalable() } open spec fn
     ghost_serialize($self : & Self) -> Seq < u8 > { $forward .ghost_serialize() } } } } }
 
+impl Ordering {
+    pub open spec fn lt(self) -> bool {
+        matches!(self, Ordering::Less)
+    }
+}
+
+impl<K: KeyTrait + VerusClone> KeyIterator<K> {
+    pub open spec fn is_end_spec(&self) -> bool {
+        self.k.is_None()
+    }
+
+    pub open spec fn get_spec(&self) -> &K
+        recommends
+            self.k.is_some(),
+    {
+        &self.k.get_Some_0()
+    }
+
+    #[verifier::external_body]
+    #[verifier(when_used_as_spec(get_spec))]
+    pub fn get(&self) -> (k: &K) {
+        unimplemented!()
+    }
+
+    pub open spec fn between(lhs: Self, ki: Self, rhs: Self) -> bool {
+        !ki.lt_spec(lhs) && ki.lt_spec(rhs)
+    }
+}
+
 #[verifier::reject_recursive_types(K)]
 pub struct DelegationMap<K: KeyTrait + VerusClone> {
     lows: StrictlyOrderedMap<K>,
@@ -331,6 +310,16 @@

 
     #[verifier::external_body]
     pub closed spec fn valid(self) -> bool {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    pub proof fn valid_implies_complete(&self)
+        requires
+            self.valid(),
+        ensures
+            self@.dom().is_full(),
+    {
         unimplemented!()
     }
 
@@ -406,6 +395,18 @@

     LPacket { dst: cp.dst@, src: cp.src@, msg: cp.msg@ }
 }
 
+pub struct HostState {
+    next_action_index: u64,
+    resend_count: u64,
+    constants: Constants,
+    delegation_map: DelegationMap<CKey>,
+    h: CKeyHashMap,
+    sd: CSingleDelivery,
+    received_packet: Option<CPacket>,
+    num_delegations: u64,
+    received_requests: Ghost<Seq<AppRequest>>,
+}
+
 #[verifier::ext_equal]
 pub struct CAckState {
     pub num_packets_acked: u64,
@@ -528,6 +529,39 @@

         &&& self.abstractable()
         &&& self.send_state.valid()
     }
+}
+
+pub struct AbstractEndPoint {
+    pub id: Seq<u8>,
+}
+
+impl AbstractEndPoint {
+    pub open spec fn valid_physical_address(self) -> bool {
+        self.id.len() < 0x100000
+    }
+
+    pub open spec fn abstractable(self) -> bool {
+        self.valid_physical_address()
+    }
+}
+
+pub struct AbstractParameters {
+    pub max_seqno: nat,
+    pub max_delegations: nat,
+}
+
+impl AbstractParameters {
+    pub open spec fn static_params() -> AbstractParameters {
+        AbstractParameters {
+            max_seqno: 0xffff_ffff_ffff_ffff as nat,
+            max_delegations: 0x7FFF_FFFF_FFFF_FFFF as nat,
+        }
+    }
+}
+
+pub enum AppRequest {
+    AppGetRequest { seqno: nat, key: AbstractKey },
+    AppSetRequest { seqno: nat, key: AbstractKey, ov: Option<AbstractValue> },
 }
 
 #[verifier::ext_equal]
@@ -727,8 +761,28 @@

     &&& post.received_requests == pre.received_requests
 }
 
+#[derive(PartialEq, Eq, Hash)]
+pub struct EndPoint {
+    pub id: Vec<u8>,
+}
+
+impl EndPoint {
+    pub open spec fn view(self) -> AbstractEndPoint {
+        AbstractEndPoint { id: self.id@ }
+    }
+
+    #[verifier(inline)]
+    pub open spec fn abstractable(self) -> bool {
+        self@.valid_physical_address()
+    }
+}
+
 pub open spec fn abstractify_end_points(end_points: Vec<EndPoint>) -> Seq<AbstractEndPoint> {
     end_points@.map(|i, end_point: EndPoint| end_point@)
+}
+
+pub trait KeyTrait: Sized {
+    spec fn cmp_spec(self, other: Self) -> Ordering;
 }
 
 #[derive(Structural, PartialEq, Eq)]
@@ -738,46 +792,9 @@

     Greater,
 }
 
-impl Ordering {
-    pub open spec fn lt(self) -> bool {
-        matches!(self, Ordering::Less)
-    }
-}
-
-pub trait VerusClone {
-}
-
-pub trait KeyTrait: Sized {
-    spec fn cmp_spec(self, other: Self) -> Ordering;
-}
-
 pub struct KeyIterator<K: KeyTrait + VerusClone> {
     pub k: Option<K>,
 }
-
-impl<K: KeyTrait + VerusClone> KeyIterator<K> {
-    pub open spec fn is_end_spec(&self) -> bool {
-        self.k.is_None()
-    }
-
-    pub open spec fn get_spec(&self) -> &K
-        recommends
-            self.k.is_some(),
-    {
-        &self.k.get_Some_0()
-    }
-
-    #[verifier::external_body]
-    #[verifier(when_used_as_spec(get_spec))]
-    pub fn get(&self) -> (k: &K) {
-        unimplemented!()
-    }
-
-    pub open spec fn between(lhs: Self, ki: Self, rhs: Self) -> bool {
-        !ki.lt_spec(lhs) && ki.lt_spec(rhs)
-    }
-}
-
 
 impl<K: KeyTrait + VerusClone> KeyIterator<K> {
     pub open spec fn new_spec(k: K) -> Self {
@@ -793,19 +810,6 @@

         !self.lt_spec(other)
     }
 }
-
-impl VerusClone for SHTKey {
-}
-
-pub type AbstractKey = SHTKey;
-
-pub type CKey = SHTKey;
-
-pub type Hashtable = Map<AbstractKey, AbstractValue>;
-
-pub type AbstractValue = Seq<u8>;
-
-type ID = EndPoint;
 
 pub struct KeyRange<K: KeyTrait + VerusClone> {
     pub lo: KeyIterator<K>,
@@ -942,6 +946,23 @@

     value.len() < max_val_len()
 }
 
+pub trait VerusClone {
+
+}
+
+impl VerusClone for SHTKey {
+
+}
+
+pub type AbstractKey = SHTKey;
+
+pub type CKey = SHTKey;
+
+pub type Hashtable = Map<AbstractKey, AbstractValue>;
+
+pub type AbstractValue = Seq<u8>;
+
+type ID = EndPoint;
 
 #[verifier::reject_recursive_types(K)]
 struct StrictlyOrderedMap<K: KeyTrait + VerusClone> {
@@ -1000,19 +1021,6 @@

 
 derive_marshalable_for_struct! { pub struct CKeyKV { pub k :
     CKey, pub v : Vec::< u8 >, } }
-
-pub struct HostState {
-    next_action_index: u64,
-    resend_count: u64,
-    constants: Constants,
-    delegation_map: DelegationMap<CKey>,
-    h: CKeyHashMap,
-    sd: CSingleDelivery,
-    received_packet: Option<CPacket>,
-    num_delegations: u64,
-    received_requests: Ghost<Seq<AppRequest>>,
-}
-
 
 impl HostState {
     pub closed spec fn view(self) -> AbstractHostState {
@@ -1146,6 +1154,59 @@

             abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets),
         )
         &&& self.resend_count < 100000000
+    }
+
+    #[verifier::external_body]
+    proof fn effect_of_delegation_map_set(
+        pre: DelegationMap<CKey>,
+        post: DelegationMap<CKey>,
+        lo: &KeyIterator<CKey>,
+        hi: &KeyIterator<CKey>,
+        dst: &EndPoint,
+    )
+        requires
+            pre.valid(),
+            post.valid(),
+            forall|ki: KeyIterator<CKey>| #[trigger]
+                KeyIterator::between(*lo, ki, *hi) ==> post@[*ki.get()] == dst@,
+            forall|ki: KeyIterator<CKey>|
+                !ki.is_end_spec() && !(#[trigger] KeyIterator::between(*lo, ki, *hi))
+                    ==> post@[*ki.get()] == pre@[*ki.get()],
+        ensures
+            AbstractDelegationMap(post@) == AbstractDelegationMap(pre@).update(
+                KeyRange::<AbstractKey> { lo: *lo, hi: *hi },
+                dst@,
+            ),
+    {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn effect_of_hashmap_bulk_update(
+        pre: CKeyHashMap,
+        post: CKeyHashMap,
+        kr: &KeyRange::<CKey>,
+        other: CKeyHashMap,
+    )
+        requires
+            forall|k| pre@.dom().contains(k) ==> #[trigger] valid_value(pre@[k]),
+            valid_hashtable(other@),
+            post@ == Map::<AbstractKey, Seq<u8>>::new(
+                |k: AbstractKey|
+                    (pre@.dom().contains(k) || other@.dom().contains(k)) && (kr.contains(k)
+                        ==> other@.dom().contains(k)),
+                |k: AbstractKey|
+                    if other@.dom().contains(k) {
+                        other@[k]
+                    } else {
+                        pre@[k]
+                    },
+            ),
+        ensures
+            post@ == bulk_update_hashtable(pre@, *kr, other@),
+            forall|k| post@.dom().contains(k) ==> #[trigger] valid_value(post@[k]),
+    {
+        unimplemented!()
     }
 
     fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)