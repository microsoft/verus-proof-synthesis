--- benchmarks/verified-ironkv/unverified_nolemma/marshal_v__impl4__lemma_serialization_is_not_a_prefix_of.rs

+++ benchmarks/verified-ironkv/unverified/marshal_v__impl4__lemma_serialization_is_not_a_prefix_of.rs

@@ -2,6 +2,62 @@

 use vstd::prelude::*;
 fn main() {}
 verus! {
+
+#[verifier::external_body]
+pub proof fn choose_smallest(low: int, high: int, p: spec_fn(int) -> bool) -> (res: int)
+    requires
+        exists|i: int| #![trigger(p(i))] low <= i < high && p(i),
+    ensures
+        low <= res < high,
+        p(res),
+        forall|i: int| #![trigger(p(i))] low <= i < res ==> !p(i),
+    decreases high - low,
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_fold_left_on_equiv_seqs<A, B>(
+    s1: Seq<A>,
+    s2: Seq<A>,
+    eq: spec_fn(A, A) -> bool,
+    init: B,
+    f: spec_fn(B, A) -> B,
+)
+    requires
+        s1.len() == s2.len(),
+        (forall|i: int| 0 <= i < s1.len() ==> eq(s1[i], s2[i])),
+        (forall|b: B, a1: A, a2: A| #[trigger] eq(a1, a2) ==> #[trigger] f(b, a1) == f(b, a2)),
+    ensures
+        s1.fold_left(init, f) == s2.fold_left(init, f),
+    decreases s1.len(),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_fold_left_append_merge<A, B>(s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> Seq<B>)
+    ensures
+        (s1 + s2).fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a)) == s1.fold_left(
+            Seq::empty(),
+            |acc: Seq<B>, a: A| acc + f(a),
+        ) + s2.fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a)),
+    decreases s1.len() + s2.len(),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)
+    requires
+        s1 != s2,
+        s1.len() == s2.len(),
+    ensures
+        0 <= i < s1.len(),
+        s1[i] != s2[i],
+{
+    unimplemented!()
+}
 
 pub trait Marshalable: Sized {
     spec fn is_marshalable(&self) -> bool;
@@ -55,6 +111,11 @@

         self@ === other@
     }
 
+    #[verifier::external_body]
+    proof fn lemma_view_equal_symmetric(&self, other: &Self) {
+        unimplemented!()
+    }
+
     open spec fn is_marshalable(&self) -> bool {
         true
     }
@@ -62,6 +123,16 @@

     open spec fn ghost_serialize(&self) -> Seq<u8> {
         spec_u64_to_le_bytes(*self)
     }
+
+    #[verifier::external_body]
+    proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_same_views_serialize_the_same(self: &Self, other: &Self) {
+        unimplemented!()
+    }
 }
 
 impl Marshalable for usize {
@@ -69,6 +140,11 @@

         self@ === other@
     }
 
+    #[verifier::external_body]
+    proof fn lemma_view_equal_symmetric(&self, other: &Self) {
+        unimplemented!()
+    }
+
     open spec fn is_marshalable(&self) -> bool {
         &&& *self as int <= u64::MAX
     }
@@ -76,11 +152,26 @@

     open spec fn ghost_serialize(&self) -> Seq<u8> {
         (*self as u64).ghost_serialize()
     }
+
+    #[verifier::external_body]
+    proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_same_views_serialize_the_same(self: &Self, other: &Self) {
+        unimplemented!()
+    }
 }
 
 impl Marshalable for Vec<u8> {
     open spec fn view_equal(&self, other: &Self) -> bool {
         self@ === other@
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_view_equal_symmetric(&self, other: &Self) {
+        unimplemented!()
     }
 
     open spec fn is_marshalable(&self) -> bool {
@@ -90,6 +181,16 @@

 
     open spec fn ghost_serialize(&self) -> Seq<u8> {
         (self@.len() as usize).ghost_serialize() + self@
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_same_views_serialize_the_same(self: &Self, other: &Self) {
+        unimplemented!()
     }
 }
 
@@ -99,6 +200,11 @@

         let o = other@;
         s.len() == o.len() && (forall|i: int|
             0 <= i < s.len() ==> #[trigger] s[i].view_equal(&o[i]))
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_view_equal_symmetric(&self, other: &Self) {
+        unimplemented!()
     }
 
     open spec fn is_marshalable(&self) -> bool {
@@ -117,6 +223,11 @@

         )
     }
 
+    #[verifier::external_body]
+    proof fn lemma_same_views_serialize_the_same(self: &Self, other: &Self) {
+        unimplemented!()
+    }
+
     proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
     }
 }