--- benchmarks/verified-ironkv/unverified_nolemma/net_sht_v__sht_demarshall_data_method.rs

+++ benchmarks/verified-ironkv/unverified/net_sht_v__sht_demarshall_data_method.rs

@@ -99,6 +99,11 @@

     open spec fn ghost_serialize(&self) -> Seq<u8> {
         spec_u64_to_le_bytes(*self)
     }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
+    }
 }
 
 impl Marshalable for usize {
@@ -112,6 +117,11 @@

 
     open spec fn ghost_serialize(&self) -> Seq<u8> {
         (*self as u64).ghost_serialize()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
     }
 }
 
@@ -127,6 +137,11 @@

 
     open spec fn ghost_serialize(&self) -> Seq<u8> {
         (self@.len() as usize).ghost_serialize() + self@
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
     }
 }
 
@@ -151,6 +166,11 @@

             None => seq![0],
             Some(x) => seq![1] + x.ghost_serialize(),
         }
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
     }
 }
 
@@ -177,6 +197,11 @@

             |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),
         )
     }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
+    }
 }
 
 impl<T: Marshalable, U: Marshalable> Marshalable for (T, U) {
@@ -193,31 +218,36 @@

     open spec fn ghost_serialize(&self) -> Seq<u8> {
         self.0.ghost_serialize() + self.1.ghost_serialize()
     }
-}
-
-macro_rules!
-    derive_marshalable_for_struct { { $(#[$attr : meta])* $pub : vis struct $newstruct :
-    ident $(< $($poly : ident : Marshalable),+ $(,)? >)? { $($fieldvis : vis $field :
-    ident : $fieldty : ty),+ $(,)? } } => { ::builtin_macros::verus! { impl $(< $($poly :
-    Marshalable),* >)? Marshalable for $newstruct $(< $($poly),* >)? { open spec fn
-    view_equal(& self, other : & Self) -> bool { $(&&& self.$field .view_equal(& other
-    .$field))* } open spec fn is_marshalable(& self) -> bool { $(&&& self.$field
-    .is_marshalable())* &&& 0 $(+ self.$field .ghost_serialize().len())* <= usize::MAX }
-    open spec fn ghost_serialize(& self) -> Seq < u8 > { Seq::empty() $(+ self.$field
-    .ghost_serialize())* } #[verifier::external_body] proof fn
-    lemma_serialize_injective(self : & Self, other : & Self) { unimplemented!() } } } } }
-
-macro_rules! derive_marshalable_for_enum { { $(#[$attr : meta])* $pub : vis enum
-    $newenum : ident $(< $($poly : ident : Marshalable),+ $(,)? >)? { $(#[tag = $tag :
-    literal] $variant : ident $({ $(#[o =$memother : ident] $member : ident : $memberty :
-    ty),* $(,)? })?),+ $(,)? } $([rlimit attr = $rlimitattr : meta])? } => {
-    ::builtin_macros::verus! { impl $(< $($poly : Marshalable),+ >)? Marshalable for
-    $newenum $(< $($poly),+ >)? { open spec fn view_equal(& self, other : & Self) -> bool
-    { &&& match (self, other) { $(($newenum ::$variant $({ $($member),* })?, $newenum
-    ::$variant $({ $($member : $memother),* })?) => { $($(&&& $member
-    .view_equal($memother))*)? &&& true }),+ _ => false, } } open spec fn
-    is_marshalable(& self) -> bool { &&& match self { $($newenum ::$variant $({
-    $($member),* })? => { $($(&&& $member .is_marshalable())*)? &&& 1 $($(+ $member
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
+    }
+}
+
+macro_rules! derive_marshalable_for_struct { {
+    $(#[$attr : meta])* $pub : vis struct $newstruct : ident $(< $($poly : ident :
+    Marshalable),+ $(,)? >)? { $($fieldvis : vis $field : ident : $fieldty : ty),+ $(,)?
+    } } => { ::builtin_macros::verus! { impl $(< $($poly : Marshalable),* >)? Marshalable
+    for $newstruct $(< $($poly),* >)? { open spec fn view_equal(& self, other : & Self)
+    -> bool { $(&&& self.$field .view_equal(& other.$field))* } open spec fn
+    is_marshalable(& self) -> bool { $(&&& self.$field .is_marshalable())* &&& 0 $(+ self
+    .$field .ghost_serialize().len())* <= usize::MAX } open spec fn ghost_serialize(&
+    self) -> Seq < u8 > { Seq::empty() $(+ self.$field .ghost_serialize())* }
+    #[verifier::external_body] proof fn lemma_serialize_injective(self : & Self, other :
+    & Self) { unimplemented!() } } } } }
+
+macro_rules! derive_marshalable_for_enum { {
+    $(#[$attr : meta])* $pub : vis enum $newenum : ident $(< $($poly : ident :
+    Marshalable),+ $(,)? >)? { $(#[tag = $tag : literal] $variant : ident $({ $(#[o
+    =$memother : ident] $member : ident : $memberty : ty),* $(,)? })?),+ $(,)? }
+    $([rlimit attr = $rlimitattr : meta])? } => { ::builtin_macros::verus! { impl $(<
+    $($poly : Marshalable),+ >)? Marshalable for $newenum $(< $($poly),+ >)? { open spec
+    fn view_equal(& self, other : & Self) -> bool { &&& match (self, other) { $(($newenum
+    ::$variant $({ $($member),* })?, $newenum ::$variant $({ $($member : $memother),*
+    })?) => { $($(&&& $member .view_equal($memother))*)? &&& true }),+ _ => false, } }
+    open spec fn is_marshalable(& self) -> bool { &&& match self { $($newenum ::$variant
+    $({ $($member),* })? => { $($(&&& $member .is_marshalable())*)? &&& 1 $($(+ $member
     .ghost_serialize().len())*)? <= usize::MAX }),+ } } open spec fn ghost_serialize(&
     self) -> Seq < u8 > { match self { $($newenum ::$variant $({ $($member),* })? => {
     seq![$tag] $($(+ $member .ghost_serialize())*)? }),* } } #[verifier::external_body]
@@ -346,6 +376,11 @@

     open spec fn ghost_serialize(&self) -> Seq<u8> {
         self.to_vec().ghost_serialize()
     }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
+    }
 }
 
 pub trait KeyTrait {
@@ -364,10 +399,10 @@

 
 }
 
-define_enum_and_derive_marshalable! { pub enum CSingleMessage { #[tag = 0]
-    Message { #[o = o0] seqno : u64, #[o = o1] dst : EndPoint, #[o = o2] m : CMessage },
-    #[tag = 1] Ack { #[o = o0] ack_seqno : u64 }, #[tag = 2] InvalidMessage, } [rlimit
-    attr = verifier::rlimit(25)] }
+define_enum_and_derive_marshalable! { pub enum CSingleMessage { #[tag = 0] Message {
+    #[o = o0] seqno : u64, #[o = o1] dst : EndPoint, #[o = o2] m : CMessage }, #[tag = 1]
+    Ack { #[o = o0] ack_seqno : u64 }, #[tag = 2] InvalidMessage, } [rlimit attr =
+    verifier::rlimit(25)] }
 
 pub type NetEvent = LIoOp<AbstractEndPoint, Seq<u8>>;
 
@@ -415,16 +450,15 @@

 
 pub type LSHTPacket = LPacket<AbstractEndPoint, SingleMessage<Message>>;
 
-marshalable_by_bijection! {
-    [EndPoint] <-> [Vec::< u8 >]; forward(self) self.id; backward(x) EndPoint { id : x };
-    }
-
-derive_marshalable_for_enum! { pub enum CMessage { #[tag = 0] GetRequest { #[o =
-    o0] k : CKey }, #[tag = 1] SetRequest { #[o = o0] k : CKey, #[o = o1] v : Option::<
-    Vec < u8 >> }, #[tag = 2] Reply { #[o = o0] k : CKey, #[o = o1] v : Option::< Vec::<
-    u8 >> }, #[tag = 3] Redirect { #[o = o0] k : CKey, #[o = o1] id : EndPoint }, #[tag =
-    4] Shard { #[o = o0] kr : KeyRange::< CKey >, #[o = o1] recipient : EndPoint }, #[tag
-    = 5] Delegate { #[o = o0] range : KeyRange::< CKey >, #[o = o1] h : CKeyHashMap }, }
+marshalable_by_bijection! { [EndPoint] <-> [Vec::< u8
+    >]; forward(self) self.id; backward(x) EndPoint { id : x }; }
+
+derive_marshalable_for_enum! { pub enum CMessage { #[tag = 0] GetRequest { #[o = o0]
+    k : CKey }, #[tag = 1] SetRequest { #[o = o0] k : CKey, #[o = o1] v : Option::< Vec <
+    u8 >> }, #[tag = 2] Reply { #[o = o0] k : CKey, #[o = o1] v : Option::< Vec::< u8 >>
+    }, #[tag = 3] Redirect { #[o = o0] k : CKey, #[o = o1] id : EndPoint }, #[tag = 4]
+    Shard { #[o = o0] kr : KeyRange::< CKey >, #[o = o1] recipient : EndPoint }, #[tag =
+    5] Delegate { #[o = o0] range : KeyRange::< CKey >, #[o = o1] h : CKeyHashMap }, }
     [rlimit attr = verifier::rlimit(20)] }
 
 marshalable_by_bijection! { [KeyRange::< CKey