--- benchmarks/verified-ironkv/unverified_nolemma/marshal_ironsht_specific_v__impl2__lemma_serialize_injective.rs

+++ benchmarks/verified-ironkv/unverified/marshal_ironsht_specific_v__impl2__lemma_serialize_injective.rs

@@ -92,6 +92,16 @@

     open spec fn ghost_serialize(&self) -> Seq<u8> {
         spec_u64_to_le_bytes(*self)
     }
+
+    #[verifier::external_body]
+    proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
+    }
 }
 
 impl Marshalable for usize {
@@ -105,6 +115,16 @@

 
     open spec fn ghost_serialize(&self) -> Seq<u8> {
         (*self as u64).ghost_serialize()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
     }
 }
 
@@ -120,6 +140,16 @@

 
     open spec fn ghost_serialize(&self) -> Seq<u8> {
         (self@.len() as usize).ghost_serialize() + self@
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
     }
 }
 
@@ -146,25 +176,33 @@

             |acc: Seq<u8>, x: T| acc + x.ghost_serialize(),
         )
     }
-}
-
-#[allow(unused_macros)] macro_rules!
-    derive_marshalable_for_struct { { $(#[$attr : meta])* $pub : vis struct $newstruct :
-    ident $(< $($poly : ident : Marshalable),+ $(,)? >)? { $($fieldvis : vis $field :
-    ident : $fieldty : ty),+ $(,)? } } => { ::builtin_macros::verus! { impl $(< $($poly :
-    Marshalable),* >)? Marshalable for $newstruct $(< $($poly),* >)? { open spec fn
-    view_equal(& self, other : & Self) -> bool { $(&&& self.$field .view_equal(& other
-    .$field))* } open spec fn is_marshalable(& self) -> bool { $(&&& self.$field
-    .is_marshalable())* &&& 0 $(+ self.$field .ghost_serialize().len())* <= usize::MAX }
-    open spec fn ghost_serialize(& self) -> Seq < u8 > { Seq::empty() $(+ self.$field
-    .ghost_serialize())* } #[verifier::external_body] proof fn
-    lemma_serialization_is_not_a_prefix_of(self : & Self, other : & Self) {
-    unimplemented!() } #[verifier::external_body] proof fn lemma_serialize_injective(self
-    : & Self, other : & Self) { unimplemented!() } } } } }
-
-macro_rules!
-    marshalable_by_bijection { { [$type : ty] <-> [$marshalable : ty]; forward($self :
-    ident) $forward : expr; backward($m : ident) $backward : expr; } => {
+
+    #[verifier::external_body]
+    proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
+        unimplemented!()
+    }
+
+    #[verifier::external_body]
+    proof fn lemma_serialize_injective(self: &Self, other: &Self) {
+        unimplemented!()
+    }
+}
+
+#[allow(unused_macros)] macro_rules! derive_marshalable_for_struct { { $(#[$attr :
+    meta])* $pub : vis struct $newstruct : ident $(< $($poly : ident : Marshalable),+
+    $(,)? >)? { $($fieldvis : vis $field : ident : $fieldty : ty),+ $(,)? } } => {
+    ::builtin_macros::verus! { impl $(< $($poly : Marshalable),* >)? Marshalable for
+    $newstruct $(< $($poly),* >)? { open spec fn view_equal(& self, other : & Self) ->
+    bool { $(&&& self.$field .view_equal(& other.$field))* } open spec fn
+    is_marshalable(& self) -> bool { $(&&& self.$field .is_marshalable())* &&& 0 $(+ self
+    .$field .ghost_serialize().len())* <= usize::MAX } open spec fn ghost_serialize(&
+    self) -> Seq < u8 > { Seq::empty() $(+ self.$field .ghost_serialize())* }
+    #[verifier::external_body] proof fn lemma_serialization_is_not_a_prefix_of(self : &
+    Self, other : & Self) { unimplemented!() } #[verifier::external_body] proof fn
+    lemma_serialize_injective(self : & Self, other : & Self) { unimplemented!() } } } } }
+
+macro_rules! marshalable_by_bijection { { [$type : ty] <-> [$marshalable : ty];
+    forward($self : ident) $forward : expr; backward($m : ident) $backward : expr; } => {
     ::builtin_macros::verus! { impl $type { pub open spec fn
     forward_bijection_for_view_equality_do_not_use_for_anything_else($self : Self) ->
     $marshalable { $forward } } impl Marshalable for $type { open spec fn view_equal(&
@@ -206,6 +244,11 @@

         self.to_vec().ghost_serialize()
     }
 
+    #[verifier::external_body]
+    proof fn lemma_serialization_is_not_a_prefix_of(&self, other: &Self) {
+        unimplemented!()
+    }
+
     proof fn lemma_serialize_injective(self: &Self, other: &Self) {
     }
 }