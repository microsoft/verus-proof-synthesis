--- benchmarks/verified-ironkv/unverified_nolemma/single_delivery_model_v__impl2__retransmit_un_acked_packets.rs

+++ benchmarks/verified-ironkv/unverified/single_delivery_model_v__impl2__retransmit_un_acked_packets.rs

@@ -366,7 +366,19 @@

 }
 
 impl SingleDelivery<Message> {
-
+    #[verifier::external_body]
+    pub proof fn lemma_un_acked_messages_for_dests_empty(
+        &self,
+        src: AbstractEndPoint,
+        dests: Set<AbstractEndPoint>,
+    )
+        requires
+            dests == Set::<AbstractEndPoint>::empty(),
+        ensures
+            self.un_acked_messages_for_dests(src, dests) == Set::<Packet>::empty(),
+    {
+        unimplemented!()
+    }
 }
 
 pub struct AbstractEndPoint {
@@ -572,6 +584,89 @@

 
 pub open spec fn flatten_sets<A>(sets: Set<Set<A>>) -> Set<A> {
     Set::new(|a: A| (exists|s: Set<A>| sets.contains(s) && s.contains(a)))
+}
+
+#[verifier::external_body]
+pub proof fn lemma_flatten_sets_union_auto<A>()
+    ensures
+        forall|sets1: Set<Set<A>>, sets2: Set<Set<A>>| #[trigger]
+            flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn set_map_union_auto<A, B>()
+    ensures
+        forall|s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B| #[trigger]
+            (s1 + s2).map(f) == s1.map(f) + s2.map(f),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn seq_map_values_concat_auto<A, B>()
+    ensures
+        forall|s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B| #[trigger]
+            (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_to_set_union_auto<A>()
+    ensures
+        forall|s: Seq<A>, t: Seq<A>| #[trigger] (s + t).to_set() == s.to_set() + t.to_set(),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn map_set_finite_auto<A, B>()
+    ensures
+        forall|s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()),
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_to_set_singleton_auto<A>()
+    ensures
+        forall|x: A| #[trigger] seq![x].to_set() == set![x],
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_map_values_singleton_auto<A, B>()
+    ensures
+        forall|x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)],
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_map_set_singleton_auto<A, B>()
+    ensures
+        forall|x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) == set![f(x)],
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn lemma_map_seq_singleton_auto<A, B>()
+    ensures
+        forall|x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)],
+{
+    unimplemented!()
+}
+
+#[verifier::external_body]
+pub proof fn flatten_sets_singleton_auto<A>()
+    ensures
+        forall|x: Set<A>| #[trigger] flatten_sets(set![x]) =~= x,
+{
+    unimplemented!()
 }
 
 #[verifier::opaque]