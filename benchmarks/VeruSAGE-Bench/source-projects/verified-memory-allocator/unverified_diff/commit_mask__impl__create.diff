--- benchmarks/verified-memory-allocator/unverified_nolemma/commit_mask__impl__create.rs

+++ benchmarks/verified-memory-allocator/unverified/commit_mask__impl__create.rs

@@ -33,6 +33,45 @@

     a & (1usize << b) == (1usize << b)
 }
 
+	#[verifier::external_body]
+proof fn lemma_bitmask_to_is_bit_set(n: usize, o: usize)
+    requires
+        n < 64,
+        o <= 64 - n,
+    ensures ({
+        let m = sub(1usize << n, 1) << o;
+        &&& forall|j: usize| j < o           ==> !is_bit_set(m, j)
+        &&& forall|j: usize| o <= j < o + n  ==> is_bit_set(m, j)
+        &&& forall|j: usize| o + n <= j < 64 ==> !is_bit_set(m, j)
+}),
+	{
+		unimplemented!()
+	}
+
+	#[verifier::external_body]
+proof fn lemma_obtain_bit_index_1(a: usize) -> (b: usize)
+    requires a != 0
+    ensures
+        b < 64,
+        is_bit_set(a, b)
+	{
+		unimplemented!()
+	}
+
+	#[verifier::external_body]
+proof fn lemma_is_bit_set()
+    ensures
+        forall|j: usize| j < 64 ==> !(#[trigger] is_bit_set(0, j)),
+        forall|j: usize| is_bit_set(!0usize, j),
+        forall|a: usize, b: usize, j: usize| #[trigger] is_bit_set(a | b, j)  <==> is_bit_set(a, j) || is_bit_set(b, j),
+        forall|a: usize, b: usize, j: usize| j < 64 ==> (#[trigger] is_bit_set(a & !b, j) <==> is_bit_set(a, j) && !is_bit_set(b, j)),
+        forall|a: usize, b: usize, j: usize| #[trigger] is_bit_set(a & b, j)  <==> is_bit_set(a, j) && is_bit_set(b, j),
+        // Implied by previous properties, possibly too aggressive trigger
+        forall|a: usize, b: usize, j: usize| j < 64 ==> (a & b == 0) ==> !(#[trigger] is_bit_set(a, j) && #[trigger] is_bit_set(b, j)),
+	{
+		unimplemented!()
+	}
+
 pub struct CommitMask {
     mask: [usize; 8],     // size = COMMIT_MASK_FIELD_COUNT
 }
@@ -44,6 +83,36 @@

                  && is_bit_set(self.mask[t.0], t.1)
         ).map(|t: (int, usize)| t.0 * 64 + t.1)
     }
+
+	#[verifier::external_body]
+    proof fn lemma_view(&self)
+        ensures
+        // forall|i: int| self@.contains(i) ==> i < 512,
+        // TODO: this isn't currently used but probably will need it (-> check later)
+        (forall|i: int| self@.contains(i) ==> {
+            let a = i / usize::BITS as int;
+            let b = (i % usize::BITS as int) as usize;
+            &&& a * 64 + b == i
+            &&& is_bit_set(self.mask[a], b)
+        }),
+        forall|a: int, b: usize| 0 <= a < 8 && b < 64 && is_bit_set(self.mask[a], b)
+            ==> #[trigger] self@.contains(a * 64 + b),
+	{
+		unimplemented!()
+	}
+
+	#[verifier::external_body]
+    proof fn lemma_change_one_entry(&self, other: &Self, i: int)
+        requires
+            0 <= i < 8,
+            self.mask[i] == 0,
+            forall|j: int| 0 <= j < i ==> other.mask[j] == self.mask[j],
+            forall|j: int| i < j < 8 ==> other.mask[j] == self.mask[j],
+        ensures
+            other@ == self@.union(Set::new(|b: usize| b < 64 && is_bit_set(other.mask[i], b)).map(|b: usize| 64 * i + b)),
+	{
+		unimplemented!()
+	}
 
     #[verifier::external_body]
     pub fn create_full(&mut self)