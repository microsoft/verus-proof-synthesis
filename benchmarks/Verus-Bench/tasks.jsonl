{"task_id": "cloverbench_all_digits_strong", "source": "CloverBench", "name": "all_digits_strong", "task": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nspec fn is_ascii_digit_spec(c: char) -> bool {\n    c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7'\n        || c == '8' || c == '9'\n}\n\nfn is_ascii_digit(c: char) -> (r: bool)\n    ensures\n        r == is_ascii_digit_spec(c),\n{\n    c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7'\n        || c == '8' || c == '9'\n}\n\nspec fn all_digits_spec(s: Seq<char>) -> bool {\n    forall|i: nat| #![auto] i < s.len() ==> is_ascii_digit_spec(s[i as int])\n}\n\nfn all_digits(s: String) -> (result: bool)\n    requires\n        s.is_ascii(),\n    ensures\n        all_digits_spec(s@) == result,\n{\n    let mut result = true;\n    let mut i = 0;\n    while i < s.as_str().unicode_len() {\n        if !is_ascii_digit(s.as_str().get_char(i)) {\n            return false;\n        }\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nspec fn is_ascii_digit_spec(c: char) -> bool {\n    c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7'\n        || c == '8' || c == '9'\n}\n\nfn is_ascii_digit(c: char) -> (r: bool)\n    ensures\n        r == is_ascii_digit_spec(c),\n{\n    c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7'\n        || c == '8' || c == '9'\n}\n\nspec fn all_digits_spec(s: Seq<char>) -> bool {\n    forall|i: nat| #![auto] i < s.len() ==> is_ascii_digit_spec(s[i as int])\n}\n\nfn all_digits(s: String) -> (result: bool)\n    requires\n        s.is_ascii(),\n    ensures\n        all_digits_spec(s@) == result,\n{\n    let mut result = true;\n    let mut i = 0;\n    while i < s.as_str().unicode_len()\n        invariant\n            all_digits_spec(s@.subrange(0, i as int)),\n    {\n        if !is_ascii_digit(s.as_str().get_char(i)) {\n            return false;\n        }\n    }\n    true\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/all_digits_strong.rs", "solution_path": "CloverBench/verified/all_digits_strong.rs"}
{"task_id": "cloverbench_array_append_strong", "source": "CloverBench", "name": "array_append_strong", "task": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn append(v: &Vec<u64>, elem: u64) -> (c: Vec<u64>)\n    requires\n        v.len() <= 100,\n    ensures\n        c@.len() == v@.len() + 1,\n        forall|i: int| (0 <= i && i < v.len()) ==> c[i] == v[i],\n        c@.last() == elem,\n{\n    let mut c = Vec::with_capacity(v.len() + 1);\n    let mut n: usize = 0;\n    let len: usize = v.len();\n    while n != len {\n        c.push(v[n]);\n        n = n + 1;\n    }\n    c.push(elem);\n    c\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn append(v: &Vec<u64>, elem: u64) -> (c: Vec<u64>)\n    requires\n        v.len() <= 100,\n    ensures\n        c@.len() == v@.len() + 1,\n        forall|i: int| (0 <= i && i < v.len()) ==> c[i] == v[i],\n        c@.last() == elem,\n{\n    let mut c = Vec::with_capacity(v.len() + 1);\n    let mut n: usize = 0;\n    let len: usize = v.len();\n    while n != len\n        invariant\n            n <= len,\n            n == c@.len(),\n            len == v@.len(),\n            forall|i: int| 0 <= i < n ==> c[i] == v[i],\n    {\n        c.push(v[n]);\n        n = n + 1;\n    }\n    c.push(elem);\n    c\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/array_append_strong.rs", "solution_path": "CloverBench/verified/array_append_strong.rs"}
{"task_id": "cloverbench_array_concat_strong", "source": "CloverBench", "name": "array_concat_strong", "task": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn concat(a: &Vec<u64>, b: &Vec<u64>) -> (c: Vec<u64>)\n    requires\n        a.len() <= 100 && b.len() <= 100,\n    ensures\n        c@.len() == a@.len() + b@.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> c[i] == a[i],\n        forall|i: int| (a.len() <= i && i < c.len()) ==> c[i] == b[i - a.len()],\n{\n    let mut c = Vec::with_capacity(a.len() + b.len());\n    let mut n: usize = 0;\n    let len: usize = a.len() + b.len();\n    while n != len {\n        c.push(\n            if 0 <= n && n < a.len() {\n                a[n]\n            } else {\n                b[n - a.len()]\n            },\n        );\n        n = n + 1;\n    }\n    c\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn concat(a: &Vec<u64>, b: &Vec<u64>) -> (c: Vec<u64>)\n    requires\n        a.len() <= 100 && b.len() <= 100,\n    ensures\n        c@.len() == a@.len() + b@.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> c[i] == a[i],\n        forall|i: int| (a.len() <= i && i < c.len()) ==> c[i] == b[i - a.len()],\n{\n    let mut c = Vec::with_capacity(a.len() + b.len());\n    let mut n: usize = 0;\n    let len: usize = a.len() + b.len();\n    while n != len\n        invariant\n            n <= len,\n            n == c@.len(),\n            len == a@.len() + b@.len(),\n            forall|i: int| (0 <= i && i < a.len() && i < n) ==> c[i] == a[i],\n            forall|i: int| (a.len() <= i && i < c.len() && i < n) ==> c[i] == b[i - a.len()],\n    {\n        c.push(\n            if 0 <= n && n < a.len() {\n                a[n]\n            } else {\n                b[n - a.len()]\n            },\n        );\n        n = n + 1;\n    }\n    c\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/array_concat_strong.rs", "solution_path": "CloverBench/verified/array_concat_strong.rs"}
{"task_id": "cloverbench_array_copy_strong", "source": "CloverBench", "name": "array_copy_strong", "task": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn copy(a: &Vec<u64>) -> (b: Vec<u64>)\n    requires\n        a.len() <= 100,\n    ensures\n        b@.len() == a@.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> b[i] == a[i],\n{\n    let mut b = Vec::with_capacity(a.len());\n    let mut n: usize = 0;\n    let len: usize = a.len();\n    while n != len {\n        b.push(a[n]);\n        n = n + 1;\n    }\n    b\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn copy(a: &Vec<u64>) -> (b: Vec<u64>)\n    requires\n        a.len() <= 100,\n    ensures\n        b@.len() == a@.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> b[i] == a[i],\n{\n    let mut b = Vec::with_capacity(a.len());\n    let mut n: usize = 0;\n    let len: usize = a.len();\n    while n != len\n        invariant\n            n <= len,\n            n == b@.len(),\n            len == a@.len(),\n            forall|i: int| (0 <= i && i < n) ==> b[i] == a[i],\n    {\n        b.push(a[n]);\n        n = n + 1;\n    }\n    b\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/array_copy_strong.rs", "solution_path": "CloverBench/verified/array_copy_strong.rs"}
{"task_id": "cloverbench_array_product_strong", "source": "CloverBench", "name": "array_product_strong", "task": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn product(a: &Vec<u32>, b: &Vec<u32>) -> (c: Vec<u32>)\n    requires\n        a.len() <= 100 && a.len() == b.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> (a[i] * b[i] < 1000),\n    ensures\n        c@.len() == a@.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> c[i] == #[trigger] a[i] * #[trigger] b[i],\n{\n    let mut c = Vec::with_capacity(a.len());\n    let mut n: usize = 0;\n    let len: usize = a.len();\n    while n != len {\n        let product: u32 = a[n] * b[n];\n        c.push(product);\n        n = n + 1;\n    }\n    c\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn product(a: &Vec<u32>, b: &Vec<u32>) -> (c: Vec<u32>)\n    requires\n        a.len() <= 100 && a.len() == b.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> (a[i] * b[i] < 1000),\n    ensures\n        c@.len() == a@.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> c[i] == #[trigger] a[i] * #[trigger] b[i],\n{\n    let mut c = Vec::with_capacity(a.len());\n    let mut n: usize = 0;\n    let len: usize = a.len();\n    while n != len\n        invariant\n            n <= len,\n            n == c@.len(),\n            len == a@.len(),\n            a.len() <= 100 && a.len() == b.len(),\n            forall|i: int| (0 <= i && i < a.len()) ==> (a[i] * b[i] < 1000),\n            forall|i: int| (0 <= i && i < n) ==> c[i] == #[trigger] a[i] * #[trigger] b[i],\n    {\n        let product: u32 = a[n] * b[n];\n        c.push(product);\n        n = n + 1;\n    }\n    c\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/array_product_strong.rs", "solution_path": "CloverBench/verified/array_product_strong.rs"}
{"task_id": "cloverbench_array_sum_strong", "source": "CloverBench", "name": "array_sum_strong", "task": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn sum(a: &Vec<u32>, b: &Vec<u32>) -> (c: Vec<u32>)\n    requires\n        a.len() <= 100 && a.len() == b.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> (a[i] + b[i] < 1000),\n    ensures\n        c@.len() == a@.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> c[i] == #[trigger] a[i] + #[trigger] b[i],\n{\n    let mut c = Vec::with_capacity(a.len());\n    let mut n: usize = 0;\n    let len: usize = a.len();\n    while n != len {\n        let sum: u32 = a[n] + b[n];\n        c.push(sum);\n        n = n + 1;\n    }\n    c\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn sum(a: &Vec<u32>, b: &Vec<u32>) -> (c: Vec<u32>)\n    requires\n        a.len() <= 100 && a.len() == b.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> (a[i] + b[i] < 1000),\n    ensures\n        c@.len() == a@.len(),\n        forall|i: int| (0 <= i && i < a.len()) ==> c[i] == #[trigger] a[i] + #[trigger] b[i],\n{\n    let mut c = Vec::with_capacity(a.len());\n    let mut n: usize = 0;\n    let len: usize = a.len();\n    while n != len\n        invariant\n            n <= len,\n            n == c@.len(),\n            len == a@.len(),\n            a.len() <= 100 && a.len() == b.len(),\n            forall|i: int| (0 <= i && i < a.len()) ==> (a[i] + b[i] < 1000),\n            forall|i: int| (0 <= i && i < n) ==> c[i] == #[trigger] a[i] + #[trigger] b[i],\n    {\n        let sum: u32 = a[n] + b[n];\n        c.push(sum);\n        n = n + 1;\n    }\n    c\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/array_sum_strong.rs", "solution_path": "CloverBench/verified/array_sum_strong.rs"}
{"task_id": "cloverbench_binary_search", "source": "CloverBench", "name": "binary_search", "task": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2 {\n        let ghost d = i2 - i1;\n\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n    {\n        let ghost d = i2 - i1;\n\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n        assert(i2 - i1 < d);\n    }\n    i1\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/binary_search.rs", "solution_path": "CloverBench/verified/binary_search.rs"}
{"task_id": "cloverbench_cal_div", "source": "CloverBench", "name": "cal_div", "task": "use vstd::prelude::*;\n\nverus! {\n\nfn cal_div() -> (r: (u32, u32))\n    ensures\n        r.0 == 27,\n        r.1 == 2,\n{\n    let mut x: u32 = 0;\n    let mut y: u32 = 191;\n    while 7 <= y\n    {\n        x = x + 1;\n        y = 191 - 7 * x;\n    }\n    (x, y)\n}\n\n} // verus!\nfn main() {}\n", "ground_truth": "use vstd::prelude::*;\n\nverus! {\n\nfn cal_div() -> (r: (u32, u32))\n    ensures\n        r.0 == 27,\n        r.1 == 2,\n{\n    let mut x: u32 = 0;\n    let mut y: u32 = 191;\n    while 7 <= y\n        invariant\n            0 <= y,\n            7u32 * x + y == 191u32,\n    {\n        x = x + 1;\n        y = 191 - 7 * x;\n    }\n    (x, y)\n}\n\n} // verus!\nfn main() {}\n", "task_path": "CloverBench/unverified/cal_div.rs", "solution_path": "CloverBench/verified/cal_div.rs"}
{"task_id": "cloverbench_is_prime", "source": "CloverBench", "name": "is_prime", "task": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate {\n        if candidate % factor == 0 {\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor <= candidate,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            assert(!is_prime(candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/is_prime.rs", "solution_path": "CloverBench/verified/is_prime.rs"}
{"task_id": "cloverbench_linear_search2", "source": "CloverBench", "name": "linear_search2", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\npub fn linear_search(a: &Vec<i32>, e: i32) -> (n: usize)\n    requires\n        exists|i: int| (0 <= i < a.len() as int) && a[i] == e,\n    ensures\n        0 <= n < a.len(),\n        a[n as int] == e,\n        forall|k: int| (0 <= k < n as int) ==> a[k] != e,\n{\n    let mut n: usize = 0;\n    while n != a.len() {\n        if a[n] == e {\n            return n;\n        }\n        n = n + 1;\n    }\n    n\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\npub fn linear_search(a: &Vec<i32>, e: i32) -> (n: usize)\n    requires\n        exists|i: int| (0 <= i < a.len() as int) && a[i] == e,\n    ensures\n        0 <= n < a.len(),\n        a[n as int] == e,\n        forall|k: int| (0 <= k < n as int) ==> a[k] != e,\n{\n    let mut n: usize = 0;\n    while n != a.len()\n        invariant\n            n <= a.len(),\n            forall|i: int| (0 <= i < n as int) ==> e != a[i],\n    {\n        if a[n] == e {\n            return n;\n        }\n        n = n + 1;\n    }\n    n\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/linear_search2.rs", "solution_path": "CloverBench/verified/linear_search2.rs"}
{"task_id": "cloverbench_two_sum", "source": "CloverBench", "name": "two_sum", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn two_sum(nums: &Vec<u32>, target: u32) -> (r: (usize, usize))\n    requires\n        nums.len() > 1,\n        forall|ii: int, jj: int|\n            ((0 <= ii && ii < nums.len() && ii < jj && jj < nums.len())) ==> nums[ii] + nums[jj]\n                < 256,\n        exists|i: int, j: int| (0 <= i && i < j && j < nums.len()) && nums[i] + nums[j] == target,\n    ensures\n        (0 <= r.0 && r.0 < r.1 && r.1 < nums.len()) && nums[r.0 as int] + nums[r.1 as int]\n            == target,\n        forall|ii: int, jj: int|\n            ((0 <= ii && ii < r.0 && ii < jj && jj < nums.len()) || (ii == r.0 && ii < jj && jj\n                < r.1)) ==> nums[ii] + nums[jj] != target,\n{\n    let n = nums.len();\n    let mut i = 0;\n    let mut j = 1;\n\n    while i < n - 1 {\n        j = i + 1;\n        while j < n {\n            if nums[i] + nums[j] == target {\n                return (i, j);\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    (i, j)\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn two_sum(nums: &Vec<u32>, target: u32) -> (r: (usize, usize))\n    requires\n        nums.len() > 1,\n        forall|ii: int, jj: int|\n            ((0 <= ii && ii < nums.len() && ii < jj && jj < nums.len())) ==> nums[ii] + nums[jj]\n                < 256,\n        exists|i: int, j: int| (0 <= i && i < j && j < nums.len()) && nums[i] + nums[j] == target,\n    ensures\n        (0 <= r.0 && r.0 < r.1 && r.1 < nums.len()) && nums[r.0 as int] + nums[r.1 as int]\n            == target,\n        forall|ii: int, jj: int|\n            ((0 <= ii && ii < r.0 && ii < jj && jj < nums.len()) || (ii == r.0 && ii < jj && jj\n                < r.1)) ==> nums[ii] + nums[jj] != target,\n{\n    let n = nums.len();\n    let mut i = 0;\n    let mut j = 1;\n\n    while i < n - 1\n        invariant\n            n == nums@.len(),\n            0 <= i && i < j && j <= n,\n            forall|ii: int, jj: int|\n                ((0 <= ii && ii < nums.len() && ii < jj && jj < nums.len())) ==> nums[ii] + nums[jj]\n                    < 256,\n            forall|ii: int, jj: int|\n                (0 <= ii && ii < i && ii < jj && jj < n) ==> nums[ii] + nums[jj] != target,\n    {\n        j = i + 1;\n        while j < n\n            invariant\n                n == nums@.len(),\n                0 <= i && i < j && j <= n,\n                forall|ii: int, jj: int|\n                    ((0 <= ii && ii < nums.len() && ii < jj && jj < nums.len())) ==> nums[ii]\n                        + nums[jj] < 256,\n                forall|ii: int, jj: int|\n                    (0 <= ii && ii < i && ii < jj && jj < n) ==> nums[ii] + nums[jj] != target,\n                forall|jj: int| (i < jj && jj < j) ==> nums[i as int] + nums[jj] != target,\n        {\n            if nums[i] + nums[j] == target {\n                return (i, j);\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    (i, j)\n}\n\n} // verus!\n", "task_path": "CloverBench/unverified/two_sum.rs", "solution_path": "CloverBench/verified/two_sum.rs"}
{"task_id": "mbpp_task_id_105", "source": "MBPP", "name": "task_id_105", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn count_boolean(seq: Seq<bool>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_boolean(seq.drop_last()) + if (seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_true(arr: &Vec<bool>) -> (count: u64)\n    ensures\n        0 <= count <= arr.len(),\n        count_boolean(arr@) == count,\n{\n    let mut index = 0;\n    let mut counter = 0;\n\n    while index < arr.len() {\n        if (arr[index]) {\n            counter += 1;\n        }\n        index += 1;\n    }\n    counter\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to count true booleans in the given boolean list.\n\n    assert_eq!(count_true(&vec![true, false, true]), 2);\n    assert_eq!(count_true(&vec![false, false]), 0);\n    assert_eq!(count_true(&vec![true, true, true]), 3);\n}\n\nverus! {\n\nspec fn count_boolean(seq: Seq<bool>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_boolean(seq.drop_last()) + if (seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_true(arr: &Vec<bool>) -> (count: u64)\n    ensures\n        0 <= count <= arr.len(),\n        count_boolean(arr@) == count,\n{\n    let mut index = 0;\n    let mut counter = 0;\n\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            0 <= counter <= index,\n            count_boolean(arr@.subrange(0, index as int)) == counter,\n    {\n        if (arr[index]) {\n            counter += 1;\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    counter\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_105.rs", "solution_path": "MBPP/verified/task_id_105.rs"}
{"task_id": "mbpp_task_id_113", "source": "MBPP", "name": "task_id_113", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn is_digit_spec(c: u8) -> bool {\n    c >= 48 && c <= 57\n}\n\nfn is_digit(c: u8) -> (res: bool)\n    ensures\n        res == is_digit_spec(c),\n{\n    c >= 48 && c <= 57\n}\n\nfn is_integer(text: &[u8]) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < text.len() ==> (#[trigger] is_digit_spec(text[i]))),\n{\n    let mut index = 0;\n    while index < text.len() {\n        if (!is_digit(text[index])) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check if a string represents an integer or not.\n\n    assert!(!is_integer(b\"python\"));\n    assert!(is_integer(b\"1\"));\n    assert!(is_integer(b\"123\"));\n}\n\nverus! {\n\nspec fn is_digit_sepc(c: u8) -> bool {\n    c >= 48 && c <= 57\n}\n\nfn is_digit(c: u8) -> (res: bool)\n    ensures\n        res == is_digit_sepc(c),\n{\n    c >= 48 && c <= 57\n}\n\nfn is_integer(text: &[u8]) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < text.len() ==> (#[trigger] is_digit_sepc(text[i]))),\n{\n    let mut index = 0;\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            forall|i: int| 0 <= i < index ==> (#[trigger] is_digit_sepc(text[i])),\n    {\n        if (!is_digit(text[index])) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_113.rs", "solution_path": "MBPP/verified/task_id_113.rs"}
{"task_id": "mbpp_task_id_133", "source": "MBPP", "name": "task_id_133", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn sum_negative_to(seq: Seq<i64>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        sum_negative_to(seq.drop_last()) + if (seq.last() < 0) {\n            seq.last() as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn sum_negatives(arr: &Vec<i64>) -> (sum_neg: i128)\n    ensures\n        sum_negative_to(arr@) == sum_neg,\n{\n    let mut index = 0;\n    let mut sum_neg = 0i128;\n\n    while index < arr.len() {\n        if (arr[index] < 0) {\n            sum_neg = sum_neg + (arr[index] as i128);\n        }\n        index += 1;\n\n    }\n    sum_neg\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    //Write a function in Rust to calculate the sum of the negative numbers of a given list of numbers.\n\n    assert_eq!(sum_negatives(&vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), -32);\n    assert_eq!(sum_negatives(&vec![10, 15, -14, 13, -18, 12, -20]), -52);\n    assert_eq!(\n        sum_negatives(&vec![19, -65, 57, 39, 152, -639, 121, 44, 90, -190]),\n        -894\n    );\n}\n\nverus! {\n\nspec fn sum_negative_to(seq: Seq<i64>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        sum_negative_to(seq.drop_last()) + if (seq.last() < 0) {\n            seq.last() as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn sum_negatives(arr: &Vec<i64>) -> (sum_neg: i128)\n    ensures\n        sum_negative_to(arr@) == sum_neg,\n{\n    let mut index = 0;\n    let mut sum_neg = 0i128;\n\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|j: int|\n                0 <= j <= index ==> (i64::MIN * index <= (sum_negative_to(\n                    #[trigger] arr@.subrange(0, j),\n                )) <= 0),\n            sum_negative_to(arr@.subrange(0, index as int)) == sum_neg,\n    {\n        if (arr[index] < 0) {\n            sum_neg = sum_neg + (arr[index] as i128);\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    sum_neg\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_133.rs", "solution_path": "MBPP/verified/task_id_133.rs"}
{"task_id": "mbpp_task_id_142", "source": "MBPP", "name": "task_id_142", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn count_identical(s1: Seq<i32>, s2: Seq<i32>, s3: Seq<i32>) -> int\n    decreases s1.len(), s2.len(), s3.len(),\n{\n    if s1.len() == 0 || s2.len() == 0 || s3.len() == 0 {\n        0\n    } else {\n        count_identical(s1.drop_last(), s2.drop_last(), s3.drop_last()) + if (s1.last() == s2.last()\n            && s2.last() == s3.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_identical_position(arr1: &Vec<i32>, arr2: &Vec<i32>, arr3: &Vec<i32>) -> (count: usize)\n    requires\n        arr1.len() == arr2.len() && arr2.len() == arr3.len(),\n    ensures\n        0 <= count <= arr1.len(),\n        count_identical(arr1@, arr2@, arr3@) == count,\n{\n    let mut count = 0;\n    let mut index = 0;\n    while index < arr1.len() {\n        if arr1[index] == arr2[index] && arr2[index] == arr3[index] {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to count number items that are identical in the same position of three given lists.\n\n    assert_eq!(\n        count_identical_position(\n            &vec![1, 2, 3, 4, 5, 6, 7, 8],\n            &vec![2, 2, 3, 1, 2, 6, 7, 9],\n            &vec![2, 1, 3, 1, 2, 6, 7, 9]\n        ),\n        3\n    );\n    assert_eq!(\n        count_identical_position(\n            &vec![1, 2, 3, 4, 5, 6, 7, 8],\n            &vec![2, 2, 3, 1, 2, 6, 7, 8],\n            &vec![2, 1, 3, 1, 2, 6, 7, 8]\n        ),\n        4\n    );\n    assert_eq!(\n        count_identical_position(\n            &vec![1, 2, 3, 4, 2, 6, 7, 8],\n            &vec![2, 2, 3, 1, 2, 6, 7, 8],\n            &vec![2, 1, 3, 1, 2, 6, 7, 8]\n        ),\n        5\n    );\n}\n\nverus! {\n\nspec fn count_identical(s1: Seq<i32>, s2: Seq<i32>, s3: Seq<i32>) -> int\n    decreases s1.len(), s2.len(), s3.len(),\n{\n    if s1.len() == 0 || s2.len() == 0 || s3.len() == 0 {\n        0\n    } else {\n        count_identical(s1.drop_last(), s2.drop_last(), s3.drop_last()) + if (s1.last() == s2.last()\n            && s2.last() == s3.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_identical_position(arr1: &Vec<i32>, arr2: &Vec<i32>, arr3: &Vec<i32>) -> (count: usize)\n    requires\n        arr1.len() == arr2.len() && arr2.len() == arr3.len(),\n    ensures\n        0 <= count <= arr1.len(),\n        count_identical(arr1@, arr2@, arr3@) == count,\n{\n    let mut count = 0;\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            0 <= index <= arr1.len(),\n            0 <= count <= index,\n            arr1.len() == arr2.len() && arr2.len() == arr3.len(),\n            count_identical(\n                arr1@.subrange(0, index as int),\n                arr2@.subrange(0, index as int),\n                arr3@.subrange(0, index as int),\n            ) == count,\n    {\n        if arr1[index] == arr2[index] && arr2[index] == arr3[index] {\n            count += 1;\n        }\n        index += 1;\n        assert(arr1@.subrange(0, index - 1 as int) == arr1@.subrange(0, index as int).drop_last());\n        assert(arr2@.subrange(0, index - 1 as int) == arr2@.subrange(0, index as int).drop_last());\n        assert(arr3@.subrange(0, index - 1 as int) == arr3@.subrange(0, index as int).drop_last());\n    }\n    assert(arr1@ == arr1@.subrange(0, index as int));\n    assert(arr2@ == arr2@.subrange(0, index as int));\n    assert(arr3@ == arr3@.subrange(0, index as int));\n    count\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_142.rs", "solution_path": "MBPP/verified/task_id_142.rs"}
{"task_id": "mbpp_task_id_145", "source": "MBPP", "name": "task_id_145", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn max_difference(arr: &Vec<i32>) -> (diff: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() ==> arr[i] - arr[j] <= diff,\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n\n    let mut index = 1;\n    while index < arr.len() {\n        if (arr[index] < min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n    }\n    max_val - min_val\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the maximum difference between any two elements in a given array.\n\n    assert_eq!(max_difference(&vec![2, 1, 5, 3]), 4);\n    assert_eq!(max_difference(&vec![9, 3, 2, 5, 1]), 8);\n    assert_eq!(max_difference(&vec![3, 2, 1]), 2);\n}\n\nverus! {\n\nfn max_difference(arr: &Vec<i32>) -> (diff: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() ==> arr[i] - arr[j] <= diff,\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n\n    let mut index = 1;\n    while index < arr.len()\n        invariant\n            i32::MIN / 2 < min_val < i32::MAX / 2,\n            i32::MIN / 2 < max_val < i32::MAX / 2,\n            min_val <= max_val,\n            forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n            forall|k: int| 0 <= k < index ==> min_val <= arr[k] && arr[k] <= max_val,\n    {\n        if (arr[index] < min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n    }\n    max_val - min_val\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_145.rs", "solution_path": "MBPP/verified/task_id_145.rs"}
{"task_id": "mbpp_task_id_161", "source": "MBPP", "name": "task_id_161", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains(str: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result <==> (exists|i: int| 0 <= i < str.len() && (str[i] == key)),\n{\n    let mut i = 0;\n    while i < str.len() {\n        if (str[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn remove_elements(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && !arr2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int|\n            0 <= i < arr1.len() ==> (arr2@.contains(#[trigger] arr1[i]) || result@.contains(\n                #[trigger] arr1[i],\n            )),\n{\n    let mut output_str = Vec::new();\n    let mut index: usize = 0;\n\n    while index < arr1.len() {\n        if (!contains(arr2, arr1[index])) {\n            output_str.push(arr1[index]);\n        }\n        index += 1;\n    }\n    output_str\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to remove all elements from a given list present in another list.\n\n    assert_eq!(\n        remove_elements(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], &vec![2, 4, 6, 8]),\n        [1, 3, 5, 7, 9, 10]\n    );\n    assert_eq!(\n        remove_elements(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], &vec![1, 3, 5, 7]),\n        [2, 4, 6, 8, 9, 10]\n    );\n    assert_eq!(\n        remove_elements(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], &vec![5, 7]),\n        [1, 2, 3, 4, 6, 8, 9, 10]\n    );\n}\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(str: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result <==> (exists|i: int| 0 <= i < str.len() && (str[i] == key)),\n{\n    let mut i = 0;\n    while i < str.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (str[m] != key),\n    {\n        if (str[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn remove_elements(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && !arr2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int|\n            0 <= i < arr1.len() ==> (arr2@.contains(#[trigger] arr1[i]) || result@.contains(\n                #[trigger] arr1[i],\n            )),\n{\n    let mut output_str = Vec::new();\n    let mut index: usize = 0;\n    let ghost mut output_len: int = 0;\n\n    while index < arr1.len()\n        invariant\n            forall|k: int|\n                0 <= k < output_str.len() ==> (arr1@.contains(#[trigger] output_str[k])\n                    && !arr2@.contains(#[trigger] output_str[k])),\n            forall|k: int|\n                0 <= k < index ==> (arr2@.contains(#[trigger] arr1[k]) || output_str@.contains(\n                    #[trigger] arr1[k],\n                )),\n    {\n        if (!contains(arr2, arr1[index])) {\n            proof {\n                lemma_vec_push(output_str@, arr1[index as int], output_str.len());\n                output_len = output_len + 1;\n            }\n            output_str.push(arr1[index]);\n        }\n        index += 1;\n    }\n    output_str\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_161.rs", "solution_path": "MBPP/verified/task_id_161.rs"}
{"task_id": "mbpp_task_id_170", "source": "MBPP", "name": "task_id_170", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn sum_to(arr: Seq<i64>) -> int\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        sum_to(arr.drop_last()) + arr.last()\n    }\n}\n\nfn sum_range_list(arr: &Vec<i64>, start: usize, end: usize) -> (sum: i128)\n    requires\n        0 <= start <= end,\n        start <= end < arr.len(),\n    ensures\n        sum_to(arr@.subrange(start as int, end + 1 as int)) == sum,\n{\n    let mut index = start;\n    let mut sum = 0i128;\n    let _end = end + 1;\n\n    while index < _end {\n        sum = sum + arr[index] as i128;\n        index += 1;\n    }\n    sum\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the sum of numbers in a list within a range specified by two indices.\n\n    assert_eq!(\n        sum_range_list(&vec![2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10),\n        29\n    );\n    assert_eq!(\n        sum_range_list(&vec![2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 5, 7),\n        16\n    );\n    assert_eq!(\n        sum_range_list(&vec![2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 7, 10),\n        38\n    );\n}\n\nverus! {\n\nspec fn sum_to(arr: Seq<i64>) -> int\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        sum_to(arr.drop_last()) + arr.last()\n    }\n}\n\nfn sum_range_list(arr: &Vec<i64>, start: usize, end: usize) -> (sum: i128)\n    requires\n        0 <= start <= end,\n        start <= end < arr.len(),\n    ensures\n        sum_to(arr@.subrange(start as int, end + 1 as int)) == sum,\n{\n    let mut index = start;\n    let mut sum = 0i128;\n    let _end = end + 1;\n\n    while index < _end\n        invariant\n            start <= _end <= arr.len(),\n            start <= index <= _end,\n            sum == sum_to(arr@.subrange(start as int, index as int)),\n            forall|j: int|\n                start <= j <= index ==> (i64::MIN * index <= (sum_to(\n                    #[trigger] arr@.subrange(start as int, j),\n                )) <= i64::MAX * index),\n    {\n        assert(arr@.subrange(start as int, index as int) =~= arr@.subrange(\n            start as int,\n            (index + 1) as int,\n        ).drop_last());\n        sum = sum + arr[index] as i128;\n        index += 1;\n    }\n    sum\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_170.rs", "solution_path": "MBPP/verified/task_id_170.rs"}
{"task_id": "mbpp_task_id_18", "source": "MBPP", "name": "task_id_18", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains(str: &[u8], key: u8) -> (result: bool)\n    ensures\n        result <==> (exists|i: int| 0 <= i < str.len() && (str[i] == key)),\n{\n    let mut i = 0;\n    while i < str.len() {\n        if (str[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn remove_chars(str1: &[u8], str2: &[u8]) -> (result: Vec<u8>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (str1@.contains(#[trigger] result[i]) && !str2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int|\n            0 <= i < str1.len() ==> (str2@.contains(#[trigger] str1[i]) || result@.contains(\n                #[trigger] str1[i],\n            )),\n{\n    let mut output_str = Vec::new();\n    let mut index: usize = 0;\n\n    while index < str1.len() {\n        if (!contains(str2, str1[index])) {\n            output_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    output_str\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to remove characters from the first string which are present in the second string.\n\n    assert_eq!(remove_chars((b\"probasscurve\"), (b\"pros\")), b\"bacuve\");\n    assert_eq!(remove_chars((b\"digitalindia\"), (b\"talent\")), b\"digiidi\");\n    assert_eq!(remove_chars((b\"exoticmiles\"), (b\"toxic\")), b\"emles\");\n}\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(str: &[u8], key: u8) -> (result: bool)\n    ensures\n        result <==> (exists|i: int| 0 <= i < str.len() && (str[i] == key)),\n{\n    let mut i = 0;\n    while i < str.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (str[m] != key),\n    {\n        if (str[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn remove_chars(str1: &[u8], str2: &[u8]) -> (result: Vec<u8>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (str1@.contains(#[trigger] result[i]) && !str2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int|\n            0 <= i < str1.len() ==> (str2@.contains(#[trigger] str1[i]) || result@.contains(\n                #[trigger] str1[i],\n            )),\n{\n    let mut output_str = Vec::new();\n    let mut index: usize = 0;\n    let ghost mut output_len: int = 0;\n\n    while index < str1.len()\n        invariant\n            forall|k: int|\n                0 <= k < output_str.len() ==> (str1@.contains(#[trigger] output_str[k])\n                    && !str2@.contains(#[trigger] output_str[k])),\n            forall|k: int|\n                0 <= k < index ==> (str2@.contains(#[trigger] str1[k]) || output_str@.contains(\n                    #[trigger] str1[k],\n                )),\n    {\n        if (!contains(str2, str1[index])) {\n            proof {\n                lemma_vec_push(output_str@, str1[index as int], output_str.len());\n                output_len = output_len + 1;\n            }\n            output_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    output_str\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_18.rs", "solution_path": "MBPP/verified/task_id_18.rs"}
{"task_id": "mbpp_task_id_2", "source": "MBPP", "name": "task_id_2", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len() {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn shared_elements(list1: &Vec<i32>, list2: &Vec<i32>) -> (shared: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < shared.len() ==> (list1@.contains(#[trigger] shared[i]) && list2@.contains(\n                #[trigger] shared[i],\n            )),\n        forall|i: int, j: int| 0 <= i < j < shared.len() ==> shared[i] != shared[j],\n{\n    let mut shared = Vec::new();\n    let mut index = 0;\n    while index < list1.len() {\n        if (contains(list2, list1[index]) && !contains(&shared, list1[index])) {\n            shared.push(list1[index]);\n        }\n        index += 1\n    }\n    shared\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    //Write a function in Rust to find the shared elements from the given two lists.\n\n    assert_eq!(\n        shared_elements(&vec![3, 4, 5, 6], &vec![5, 7, 4, 10]),\n        [4, 5]\n    );\n    assert_eq!(\n        shared_elements(&vec![1, 2, 3, 4], &vec![5, 4, 3, 7]),\n        [3, 4]\n    );\n    assert_eq!(\n        shared_elements(&vec![11, 12, 14, 13], &vec![17, 15, 14, 13]),\n        [14, 13]\n    );\n}\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn shared_elements(list1: &Vec<i32>, list2: &Vec<i32>) -> (shared: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < shared.len() ==> (list1@.contains(#[trigger] shared[i]) && list2@.contains(\n                #[trigger] shared[i],\n            )),\n        forall|i: int, j: int| 0 <= i < j < shared.len() ==> shared[i] != shared[j],\n{\n    let mut shared = Vec::new();\n    let ghost mut shared_arr_len: int = 0;\n\n    let mut index = 0;\n    while index < list1.len()\n        invariant\n            forall|i: int|\n                0 <= i < shared.len() ==> (list1@.contains(#[trigger] shared[i]) && list2@.contains(\n                    #[trigger] shared[i],\n                )),\n            forall|m: int, n: int| 0 <= m < n < shared.len() ==> shared[m] != shared[n],\n    {\n        if (contains(list2, list1[index]) && !contains(&shared, list1[index])) {\n            shared.push(list1[index]);\n            proof {\n                shared_arr_len = shared_arr_len + 1;\n            }\n        }\n        index += 1\n    }\n    shared\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_2.rs", "solution_path": "MBPP/verified/task_id_2.rs"}
{"task_id": "mbpp_task_id_230", "source": "MBPP", "name": "task_id_230", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn replace_blanks_with_chars(str1: &[u8], ch: u8) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if str1[i] == 32 {\n                ch\n            } else {\n                str1[i]\n            }),\n{\n    let mut out_str: Vec<u8> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len() {\n        if str1[index] == 32 {\n            out_str.push(ch);\n        } else {\n            out_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    out_str\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\n    assert_eq!(\n        replace_blanks_with_chars(b\"hello people\", b'@'),\n        b\"hello@people\"\n    );\n    assert_eq!(\n        replace_blanks_with_chars(b\"python program language\", b'$'),\n        b\"python$program$language\"\n    );\n    assert_eq!(\n        replace_blanks_with_chars(b\"blank space\", b'-'),\n        b\"blank-space\"\n    );\n}\n\nverus! {\n\nfn replace_blanks_with_chars(str1: &[u8], ch: u8) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if str1[i] == 32 {\n                ch\n            } else {\n                str1[i]\n            }),\n{\n    let mut out_str: Vec<u8> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            out_str@.len() == index,\n            forall|k: int|\n                0 <= k < index ==> out_str[k] == (if str1[k] == 32 {  // 32 is ASCII Space as u8\n                    ch\n                } else {\n                    str1[k]\n                }),\n    {\n        if (str1[index] == 32) {  // 32 is ASCII Space as u8\n            out_str.push(ch);\n        } else {\n            out_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    out_str\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_230.rs", "solution_path": "MBPP/verified/task_id_230.rs"}
{"task_id": "mbpp_task_id_240", "source": "MBPP", "name": "task_id_240", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn replace_last_element(first: &Vec<i32>, second: &Vec<i32>) -> (replaced_list: Vec<i32>)\n    requires\n        first.len() > 0,\n    ensures\n        replaced_list@ == first@.subrange(0, first.len() - 1).add(second@),\n{\n    let mut replaced_list = Vec::new();\n    let first_end = first.len() - 1;\n    let mut index = 0;\n\n    while index < first_end {\n        replaced_list.push(first[index]);\n        index += 1;\n    }\n    index = 0;\n    while index < second.len() {\n        replaced_list.push(second[index]);\n        index += 1;\n    }\n    replaced_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust that takes in two lists and replaces the last element of the first list with the elements of the second list.\n\n    assert_eq!(\n        replace_last_element(&vec![1, 3, 5, 7, 9, 10], &vec![2, 4, 6, 8]),\n        [1, 3, 5, 7, 9, 2, 4, 6, 8]\n    );\n    assert_eq!(\n        replace_last_element(&vec![1, 2, 3, 4, 5], &vec![5, 6, 7, 8]),\n        [1, 2, 3, 4, 5, 6, 7, 8]\n    );\n    assert_eq!(\n        replace_last_element(&vec![1, 2, 4, 6, 8], &vec![3, 5, 7, 9]),\n        [1, 2, 4, 6, 3, 5, 7, 9]\n    );\n}\n\nverus! {\n\nfn replace_last_element(first: &Vec<i32>, second: &Vec<i32>) -> (replaced_list: Vec<i32>)\n    requires\n        first.len() > 0,\n    ensures\n        replaced_list@ == first@.subrange(0, first.len() - 1).add(second@),\n{\n    let mut replaced_list = Vec::new();\n    let first_end = first.len() - 1;\n    let mut index = 0;\n\n    while index < first_end\n        invariant\n            first_end == first.len() - 1,\n            0 <= index <= first_end,\n            replaced_list@ =~= first@.subrange(0, index as int),\n    {\n        replaced_list.push(first[index]);\n        index += 1;\n    }\n    index = 0;\n    while index < second.len()\n        invariant\n            0 <= index <= second.len(),\n            replaced_list@ =~= first@.subrange(0, first.len() - 1).add(\n                second@.subrange(0, index as int),\n            ),\n    {\n        replaced_list.push(second[index]);\n        index += 1;\n    }\n    assert(replaced_list@ =~= first@.subrange(0, first.len() - 1).add(second@));\n    replaced_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_240.rs", "solution_path": "MBPP/verified/task_id_240.rs"}
{"task_id": "mbpp_task_id_249", "source": "MBPP", "name": "task_id_249", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len() {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn intersection(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && arr2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],\n{\n    let mut output_arr = Vec::new();\n    let mut index = 0;\n    while index < arr1.len() {\n        if (contains(arr2, arr1[index]) && !contains(&output_arr, arr1[index])) {\n            output_arr.push(arr1[index]);\n        }\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    //Write a function in Rust to find the intersection of two integers arrays.\n\n    assert_eq!(\n        intersection(&vec![1, 2, 3, 5, 7, 8, 9, 10], &vec![1, 2, 4, 8, 9]),\n        [1, 2, 8, 9]\n    );\n    assert_eq!(\n        intersection(&vec![1, 2, 3, 5, 7, 8, 9, 10], &vec![3, 5, 7, 9]),\n        [3, 5, 7, 9]\n    );\n    assert_eq!(\n        intersection(&vec![1, 2, 3, 5, 7, 8, 9, 10], &vec![10, 20, 30, 40]),\n        [10]\n    );\n}\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn intersection(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && arr2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],\n{\n    let mut output_arr = Vec::new();\n    let ghost mut out_arr_len: int = 0;\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            forall|i: int|\n                0 <= i < output_arr.len() ==> (arr1@.contains(#[trigger] output_arr[i])\n                    && arr2@.contains(#[trigger] output_arr[i])),\n            forall|m: int, n: int| 0 <= m < n < output_arr.len() ==> output_arr[m] != output_arr[n],\n    {\n        if (contains(arr2, arr1[index]) && !contains(&output_arr, arr1[index])) {\n            output_arr.push(arr1[index]);\n            proof {\n                out_arr_len = out_arr_len + 1;\n            }\n        }\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_249.rs", "solution_path": "MBPP/verified/task_id_249.rs"}
{"task_id": "mbpp_task_id_251", "source": "MBPP", "name": "task_id_251", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn insert_before_each(arr: &Vec<i32>, elem: i32) -> (result: Vec<i32>)\n    ensures\n        result@.len() == (2 * arr.len()),\n        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k] == elem,\n        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k + 1] == arr[k],\n{\n    let mut result: Vec<i32> = Vec::new();\n    let mut index = 0;\n\n    while index < arr.len() {\n        result.push(elem);\n        result.push(arr[index]);\n        index += 1;\n    }\n    result\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\n    // ***chagne the MBPP test input from string to integer\n    assert_eq!(\n        insert_before_each(&vec![10, 4, 6, 9], 1),\n        [1, 10, 1, 4, 1, 6, 1, 9]\n    );\n    assert_eq!(\n        insert_before_each(&vec![1, 1, 1, 1], 0),\n        [0, 1, 0, 1, 0, 1, 0, 1]\n    );\n    assert_eq!(\n        insert_before_each(&vec![-3, -2, -1, 1, 2, 3], 0),\n        [0, -3, 0, -2, 0, -1, 0, 1, 0, 2, 0, 3]\n    );\n}\n\nverus! {\n\nfn insert_before_each(arr: &Vec<i32>, elem: i32) -> (result: Vec<i32>)\n    ensures\n        result@.len() == (2 * arr.len()),\n        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k] == elem,\n        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k + 1] == arr[k],\n{\n    let mut result: Vec<i32> = Vec::new();\n    let mut index = 0;\n\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            result@.len() == index * 2,\n            forall|k: int| 0 <= k < index ==> #[trigger] result[2 * k] == elem,\n            forall|k: int| 0 <= k < index ==> #[trigger] result[2 * k + 1] == arr[k],\n    {\n        result.push(elem);\n        result.push(arr[index]);\n        index += 1;\n    }\n    result\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_251.rs", "solution_path": "MBPP/verified/task_id_251.rs"}
{"task_id": "mbpp_task_id_261", "source": "MBPP", "name": "task_id_261", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn element_wise_division(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|m: int|\n            0 <= m < arr1.len() ==> (u32::MIN <= #[trigger] arr1[m] / #[trigger] arr2[m]\n                <= u32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n\n    while index < arr1.len() {\n        output_arr.push((arr1[index] / arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    //Write a function in Rust that takes in two sequences and performs mathematical division operation element-wise across the given sequences.\n\n    assert_eq!(\n        element_wise_division(&vec![10, 4, 6, 9], &vec![5, 2, 3, 3]),\n        [2, 2, 2, 3]\n    );\n    assert_eq!(\n        element_wise_division(&vec![12, 6, 8, 16], &vec![6, 3, 4, 4]),\n        [2, 2, 2, 4]\n    );\n    assert_eq!(\n        element_wise_division(&vec![20, 14, 36, 18], &vec![5, 7, 6, 9]),\n        [4, 2, 6, 2]\n    );\n}\n\nverus! {\n\nfn element_wise_division(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|m: int|\n            0 <= m < arr1.len() ==> (u32::MIN <= #[trigger] arr1[m] / #[trigger] arr2[m]\n                <= u32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n\n    let mut index = 0;\n\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n            forall|m: int|\n                0 <= m < arr1.len() ==> (u32::MIN <= #[trigger] arr1[m] / #[trigger] arr2[m]\n                    <= u32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] / arr2[k]),\n    {\n        output_arr.push((arr1[index] / arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_261.rs", "solution_path": "MBPP/verified/task_id_261.rs"}
{"task_id": "mbpp_task_id_262", "source": "MBPP", "name": "task_id_262", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nfn split_array(list: &Vec<i32>, l: usize) -> (new_list: (Vec<i32>, Vec<i32>))\n    requires\n        list@.len() > 0,\n        0 < l < list@.len(),\n    ensures\n        new_list.0@ == list@.subrange(0, l as int),\n        new_list.1@ == list@.subrange(l as int, list.len() as int),\n{\n    let mut part1: Vec<i32> = Vec::new();\n    let mut index = 0;\n    while index < l {\n        part1.push(list[index]);\n        index += 1;\n    }\n    let mut part2: Vec<i32> = Vec::new();\n    index = l;\n    while index < list.len() {\n        part2.push(list[index]);\n        index += 1;\n    }\n    (part1, part2)\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\nfn main() {\n    /*Write a function in Rust that takes in a list and an integer L and splits the given list into two parts\n    where the length of the first part of the list is L, and returns the resulting lists in a tuple*/\n\n    assert_eq!(\n        split_array(&vec![1, 1, 2, 3, 4, 4, 5, 1], 3),\n        (vec![1, 1, 2], vec![3, 4, 4, 5, 1])\n    );\n    assert_eq!(\n        split_array(&vec![1, 1, 2, 3, 4, 4, 5, 1], 4),\n        (vec![1, 1, 2, 3], vec![4, 4, 5, 1])\n    );\n    assert_eq!(\n        split_array(&vec![1, 1, 2, 3, 4, 4, 5, 1], 2),\n        (vec![1, 1], vec![2, 3, 4, 4, 5, 1])\n    );\n}\n\nverus! {\n\nfn split_array(list: &Vec<i32>, l: usize) -> (new_list: (Vec<i32>, Vec<i32>))\n    requires\n        list@.len() > 0,\n        0 < l < list@.len(),\n    ensures\n        new_list.0@ == list@.subrange(0, l as int),\n        new_list.1@ == list@.subrange(l as int, list.len() as int),\n{\n    let mut part1: Vec<i32> = Vec::new();\n    let mut index = 0;\n    while index < l\n        invariant\n            0 < l < list@.len(),\n            0 <= index <= l,\n            part1@ =~= list@.subrange(0, index as int),\n    {\n        part1.push(list[index]);\n        index += 1;\n    }\n    let mut part2: Vec<i32> = Vec::new();\n    index = l;\n    while index < list.len()\n        invariant\n            l <= index <= list.len(),\n            part2@ =~= list@.subrange(l as int, index as int),\n    {\n        part2.push(list[index]);\n        index += 1;\n    }\n\n    (part1, part2)\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_262.rs", "solution_path": "MBPP/verified/task_id_262.rs"}
{"task_id": "mbpp_task_id_273", "source": "MBPP", "name": "task_id_273", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len() {\n        output_arr.push((arr1[index] - arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust that takes in two sequences and subtracts the elements of the first sequence by the elements of the second sequence with the same index.\n\n    assert_eq!(\n        element_wise_subtract(&vec![10, 4, 5], &vec![2, 5, 18]),\n        [8, -1, -13]\n    );\n    assert_eq!(\n        element_wise_subtract(&vec![11, 2, 3], &vec![24, 45, 16]),\n        [-13, -43, -13]\n    );\n    assert_eq!(\n        element_wise_subtract(&vec![7, 18, 9], &vec![10, 11, 12]),\n        [-3, 7, -3]\n    );\n}\n\nverus! {\n\nfn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] - arr2[k]),\n    {\n        output_arr.push((arr1[index] - arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_273.rs", "solution_path": "MBPP/verified/task_id_273.rs"}
{"task_id": "mbpp_task_id_282", "source": "MBPP", "name": "task_id_282", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len() {\n        output_arr.push((arr1[index] - arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to subtract two lists element-wise.\n\n    assert_eq!(\n        element_wise_subtract(&vec![1, 2, 3], &vec![4, 5, 6]),\n        [-3, -3, -3]\n    );\n    assert_eq!(element_wise_subtract(&vec![1, 2], &vec![3, 4]), [-2, -2]);\n    assert_eq!(\n        element_wise_subtract(&vec![90, 120], &vec![50, 70]),\n        [40, 50]\n    );\n}\n\nverus! {\n\nfn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] - arr2[k]),\n    {\n        output_arr.push((arr1[index] - arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_282.rs", "solution_path": "MBPP/verified/task_id_282.rs"}
{"task_id": "mbpp_task_id_284", "source": "MBPP", "name": "task_id_284", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn all_elements_equals(arr: &Vec<i32>, element: i32) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < arr.len() ==> (arr[i] == element)),\n{\n    let mut index = 0;\n    while index < arr.len() {\n        if arr[index] != element {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust that takes in an array and element and checks whether all items in the array are equal to the given element.\n\n    assert!(!all_elements_equals(&vec![1, 3, 5, 7, 9, 2, 4, 6, 8], 3));\n    assert!(all_elements_equals(&vec![1, 1, 1, 1, 1, 1, 1], 1));\n    assert!(!all_elements_equals(&vec![5, 6, 7, 4, 8], 6));\n}\n\nverus! {\n\nfn all_elements_equals(arr: &Vec<i32>, element: i32) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < arr.len() ==> (arr[i] == element)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|k: int| 0 <= k < index ==> (arr[k] == element),\n    {\n        if arr[index] != element {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_284.rs", "solution_path": "MBPP/verified/task_id_284.rs"}
{"task_id": "mbpp_task_id_290", "source": "MBPP", "name": "task_id_290", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn max_length_list(seq: &Vec<Vec<i32>>) -> (max_list: &Vec<i32>)\n    requires\n        seq.len() > 0,\n    ensures\n        forall|k: int| 0 <= k < seq.len() ==> max_list.len() >= #[trigger] (seq[k]).len(),\n        exists|k: int| 0 <= k < seq.len() && max_list@ =~= #[trigger] (seq[k]@),\n{\n    let mut max_list = &seq[0];\n    let mut index = 1;\n\n    while index < seq.len() {\n        if ((seq[index]).len() > max_list.len()) {\n            max_list = &seq[index];\n        }\n        index += 1;\n    }\n    max_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the list of maximum length in a list of lists\n\n    assert_eq!(\n        max_length_list(\n            &(vec![\n                vec![0],\n                vec![1, 3],\n                vec![5, 7],\n                vec![9, 11],\n                vec![13, 15, 17]\n            ])\n        ),\n        &vec![13, 15, 17]\n    );\n    assert_eq!(\n        max_length_list(&(vec![vec![1], vec![5, 7], vec![10, 12, 14, 15]])),\n        &vec![10, 12, 14, 15]\n    );\n    assert_eq!(\n        max_length_list(&(vec![vec![5], vec![15, 20, 25]])),\n        &vec![15, 20, 25]\n    );\n}\n\nverus! {\n\nfn max_length_list(seq: &Vec<Vec<i32>>) -> (max_list: &Vec<i32>)\n    requires\n        seq.len() > 0,\n    ensures\n        forall|k: int| 0 <= k < seq.len() ==> max_list.len() >= #[trigger] (seq[k]).len(),\n        exists|k: int| 0 <= k < seq.len() && max_list@ =~= #[trigger] (seq[k]@),\n{\n    let mut max_list = &seq[0];\n    assert(max_list@ =~= seq[0]@);\n    let mut index = 1;\n\n    while index < seq.len()\n        invariant\n            0 <= index <= seq.len(),\n            forall|k: int| 0 <= k < index ==> max_list.len() >= #[trigger] (seq[k]).len(),\n            exists|k: int| 0 <= k < index && max_list@ =~= #[trigger] (seq[k]@),\n    {\n        if ((seq[index]).len() > max_list.len()) {\n            max_list = &seq[index];\n        }\n        index += 1;\n    }\n    max_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_290.rs", "solution_path": "MBPP/verified/task_id_290.rs"}
{"task_id": "mbpp_task_id_3", "source": "MBPP", "name": "task_id_3", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\nfn is_non_prime(n: u64) -> (result: bool)\n    requires\n        n >= 2,\n    ensures\n        result == (exists|k: int| 2 <= k < n && is_divisible(n as int, k)),\n{\n    if n <= 1 {\n        return true;\n    }\n    let mut index = 2;\n    while index < n {\n        if ((n % index) == 0) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // verus does not support mod(%) operation on signed integers\n    // so input should be unsigned integers\n\n    //Write a function in Rust to identify non-prime numbers.\n    assert!(is_non_prime(0));\n    assert!(is_non_prime(1));\n    assert!(!is_non_prime(2));\n    assert!(is_non_prime(10));\n    assert!(is_non_prime(35));\n    assert!(!is_non_prime(37));\n}\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\nfn is_non_prime(n: u64) -> (result: bool)\n    requires\n        n >= 2,\n    ensures\n        result == (exists|k: int| 2 <= k < n && is_divisible(n as int, k)),\n{\n    if n <= 1 {\n        return true;\n    }\n    let mut index = 2;\n    while index < n\n        invariant\n            2 <= index,\n            forall|k: int| 2 <= k < index ==> !is_divisible(n as int, k),\n    {\n        if ((n % index) == 0) {\n            assert(is_divisible(n as int, index as int));\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_3.rs", "solution_path": "MBPP/verified/task_id_3.rs"}
{"task_id": "mbpp_task_id_307", "source": "MBPP", "name": "task_id_307", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn list_deep_clone(arr: &Vec<u64>) -> (copied: Vec<u64>)\n    ensures\n        arr@.len() == copied@.len(),\n        forall|i: int| (0 <= i < arr.len()) ==> arr[i] == copied[i],\n{\n    let mut copied_array = Vec::with_capacity(arr.len());\n    let mut index = 0;\n    while index < arr.len() {\n        copied_array.push(arr[index]);\n        index += 1;\n    }\n    copied_array\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to get a deep clone of a list.\n\n    assert_eq!(list_deep_clone(&vec![5, 2, 3, 3]), [5, 2, 3, 3]);\n    assert_eq!(list_deep_clone(&vec![3, 4, 7, 2, 6, 9]), [3, 4, 7, 2, 6, 9]);\n    assert_eq!(\n        list_deep_clone(&vec![6, 8, 3, 5, 7, 3, 5, 87]),\n        [6, 8, 3, 5, 7, 3, 5, 87]\n    );\n}\n\nverus! {\n\nfn list_deep_clone(arr: &Vec<u64>) -> (copied: Vec<u64>)\n    ensures\n        arr@.len() == copied@.len(),\n        forall|i: int| (0 <= i < arr.len()) ==> arr[i] == copied[i],\n{\n    let mut copied_array = Vec::with_capacity(arr.len());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            copied_array.len() == index,\n            forall|i: int| (0 <= i < index) ==> arr[i] == copied_array[i],\n    {\n        copied_array.push(arr[index]);\n        index += 1;\n    }\n    copied_array\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_307.rs", "solution_path": "MBPP/verified/task_id_307.rs"}
{"task_id": "mbpp_task_id_399", "source": "MBPP", "name": "task_id_399", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn bit_wise_xor(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> result[i] == #[trigger] arr1[i] ^ #[trigger] arr2[i],\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len() {\n        output_arr.push((arr1[index] ^ arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to perform the mathematical bitwise xor operation across the given two sequences.\n\n    assert_eq!(\n        bit_wise_xor(&vec![10, 4, 6, 9], &vec![5, 2, 3, 3]),\n        [15, 6, 5, 10]\n    );\n    assert_eq!(\n        bit_wise_xor(&vec![11, 5, 7, 10], &vec![6, 3, 4, 4]),\n        [13, 6, 3, 14]\n    );\n    assert_eq!(\n        bit_wise_xor(&vec![12, 6, 8, 11], &vec![7, 4, 5, 6]),\n        [11, 2, 13, 13]\n    );\n}\n\nverus! {\n\nfn bit_wise_xor(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> result[i] == #[trigger] arr1[i] ^ #[trigger] arr2[i],\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|k: int|\n                0 <= k < index ==> output_arr[k] == #[trigger] arr1[k] ^ #[trigger] arr2[k],\n    {\n        output_arr.push((arr1[index] ^ arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_399.rs", "solution_path": "MBPP/verified/task_id_399.rs"}
{"task_id": "mbpp_task_id_412", "source": "MBPP", "name": "task_id_412", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn remove_odds(arr: &Vec<u32>) -> (even_list: Vec<u32>)\n    ensures\n        even_list@ == arr@.filter(|x: u32| x % 2 == 0),\n{\n    let mut even_list: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] % 2 == 0) {\n            even_list.push(arr[index]);\n        }\n        index += 1;\n    }\n    even_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to remove odd numbers from a given list.\n\n    assert_eq!(remove_odds(&vec![1, 2, 3]), [2]);\n    assert_eq!(remove_odds(&vec![2, 4, 6]), [2, 4, 6]);\n    assert_eq!(remove_odds(&vec![10, 20, 3]), [10, 20]);\n}\n\nverus! {\n\nfn remove_odds(arr: &Vec<u32>) -> (even_list: Vec<u32>)\n    ensures\n        even_list@ == arr@.filter(|x: u32| x % 2 == 0),\n{\n    let mut even_list: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: u32| x % 2 == 0) == Seq::<u32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            even_list@ == arr@.take(index as int).filter(|x: u32| x % 2 == 0),\n    {\n        if (arr[index] % 2 == 0) {\n            even_list.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    even_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_412.rs", "solution_path": "MBPP/verified/task_id_412.rs"}
{"task_id": "mbpp_task_id_414", "source": "MBPP", "name": "task_id_414", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len() {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn any_value_exists(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)\n    ensures\n        result == exists|k: int| 0 <= k < arr1.len() && arr2@.contains(#[trigger] arr1[k]),\n{\n    let mut index = 0;\n    while index < arr1.len() {\n        if (contains(arr2, arr1[index])) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether any value in a sequence exists in a sequence or not.\n\n    assert!(!any_value_exists(&vec![1, 2, 3, 4, 5], &vec![6, 7, 8, 9]));\n    assert!(!any_value_exists(&vec![1, 2, 3], &vec![4, 5, 6]));\n    assert!(any_value_exists(&vec![1, 4, 5], &vec![1, 4, 5]));\n}\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            0 <= i <= arr.len(),\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn any_value_exists(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)\n    ensures\n        result == exists|k: int| 0 <= k < arr1.len() && arr2@.contains(#[trigger] arr1[k]),\n{\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            0 <= index <= arr1.len(),\n            forall|k: int| 0 <= k < index ==> !arr2@.contains(#[trigger] arr1[k]),\n    {\n        if (contains(arr2, arr1[index])) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_414.rs", "solution_path": "MBPP/verified/task_id_414.rs"}
{"task_id": "mbpp_task_id_424", "source": "MBPP", "name": "task_id_424", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn extract_rear_chars(s: &Vec<Vec<u8>>) -> (result: Vec<u8>)\n    requires\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i].len() > 0,\n    ensures\n        s.len() == result.len(),\n        forall|i: int| 0 <= i < s.len() ==> result[i] == #[trigger] s[i][s[i].len() - 1],\n{\n    let mut rear_chars: Vec<u8> = Vec::with_capacity(s.len());\n    let mut index = 0;\n    while index < s.len() {\n        let seq = &s[index];\n        rear_chars.push(seq[seq.len() - 1]);\n        index += 1;\n    }\n    rear_chars\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to extract only the rear index character of each string in the given sequence of strings.\n\n    assert_eq!(\n        extract_rear_chars(&vec![\n            \"Mers\".as_bytes().to_vec(),\n            \"for\".as_bytes().to_vec(),\n            \"Vers\".as_bytes().to_vec()\n        ]),\n        \"srs\".as_bytes().to_vec()\n    );\n    assert_eq!(\n        extract_rear_chars(&vec![\n            \"Avenge\".as_bytes().to_vec(),\n            \"for\".as_bytes().to_vec(),\n            \"People\".as_bytes().to_vec()\n        ]),\n        \"ere\".as_bytes().to_vec()\n    );\n    assert_eq!(\n        extract_rear_chars(&vec![\n            \"Gotta\".as_bytes().to_vec(),\n            \"get\".as_bytes().to_vec(),\n            \"go\".as_bytes().to_vec()\n        ]),\n        \"ato\".as_bytes().to_vec()\n    );\n}\n\nverus! {\n\nfn extract_rear_chars(s: &Vec<Vec<u8>>) -> (result: Vec<u8>)\n    requires\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i].len() > 0,\n    ensures\n        s.len() == result.len(),\n        forall|i: int| 0 <= i < s.len() ==> result[i] == #[trigger] s[i][s[i].len() - 1],\n{\n    let mut rear_chars: Vec<u8> = Vec::with_capacity(s.len());\n    let mut index = 0;\n    while index < s.len()\n        invariant\n            0 <= index <= s.len(),\n            rear_chars.len() == index,\n            forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i].len() > 0,\n            forall|k: int| 0 <= k < index ==> rear_chars[k] == #[trigger] s[k][s[k].len() - 1],\n    {\n        let seq = &s[index];\n        rear_chars.push(seq[seq.len() - 1]);\n        index += 1;\n    }\n    rear_chars\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_424.rs", "solution_path": "MBPP/verified/task_id_424.rs"}
{"task_id": "mbpp_task_id_426", "source": "MBPP", "name": "task_id_426", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn filter_odd_numbers(arr: &Vec<u32>) -> (odd_list: Vec<u32>)\n    ensures\n        odd_list@ == arr@.filter(|x: u32| x % 2 != 0),\n{\n    let mut odd_list: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] % 2 != 0) {\n            odd_list.push(arr[index]);\n        }\n        index += 1;\n    }\n    odd_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to filter odd numbers.\n\n    assert_eq!(\n        filter_odd_numbers(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n        [1, 3, 5, 7, 9]\n    );\n    assert_eq!(\n        filter_odd_numbers(&vec![10, 20, 45, 67, 84, 93]),\n        [45, 67, 93]\n    );\n    assert_eq!(filter_odd_numbers(&vec![5, 7, 9, 8, 6, 4, 3]), [5, 7, 9, 3]);\n}\n\nverus! {\n\nfn filter_odd_numbers(arr: &Vec<u32>) -> (odd_list: Vec<u32>)\n    ensures\n        odd_list@ == arr@.filter(|x: u32| x % 2 != 0),\n{\n    let mut odd_list: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: u32| x % 2 != 0) == Seq::<u32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            odd_list@ == arr@.take(index as int).filter(|x: u32| x % 2 != 0),\n    {\n        if (arr[index] % 2 != 0) {\n            odd_list.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    odd_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_426.rs", "solution_path": "MBPP/verified/task_id_426.rs"}
{"task_id": "mbpp_task_id_431", "source": "MBPP", "name": "task_id_431", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn has_common_element(list1: &Vec<i32>, list2: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (exists|i: int, j: int|\n            0 <= i < list1.len() && 0 <= j < list2.len() && (list1[i] == list2[j])),\n{\n    let mut i = 0;\n    while i < list1.len() {\n        let mut j = 0;\n        while j < list2.len() {\n            if list1[i] == list2[j] {\n                return true;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    false\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust that takes two lists and returns true if they have at least one common element.\n\n    assert!(has_common_element(\n        &vec![1, 2, 3, 4, 5],\n        &vec![5, 6, 7, 8, 9]\n    ));\n    assert!(!has_common_element(&vec![1, 2, 3, 4, 5], &vec![6, 7, 8, 9]));\n    assert!(has_common_element(&vec![1, 0, 1, 0], &vec![2, 0, 1]));\n}\n\nverus! {\n\nfn has_common_element(list1: &Vec<i32>, list2: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (exists|i: int, j: int|\n            0 <= i < list1.len() && 0 <= j < list2.len() && (list1[i] == list2[j])),\n{\n    let mut i = 0;\n    while i < list1.len()\n        invariant\n            0 <= i <= list1.len(),\n            forall|k: int, j: int| 0 <= k < i && 0 <= j < list2.len() ==> (list1[k] != list2[j]),\n    {\n        let mut j = 0;\n        while j < list2.len()\n            invariant\n                0 <= i < list1.len(),\n                0 <= j <= list2.len(),\n                forall|k: int| 0 <= k < j ==> (list1[i as int] != list2[k]),\n        {\n            if list1[i] == list2[j] {\n                return true;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    false\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_431.rs", "solution_path": "MBPP/verified/task_id_431.rs"}
{"task_id": "mbpp_task_id_433", "source": "MBPP", "name": "task_id_433", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn is_greater(arr: &Vec<i32>, number: i32) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < arr.len() ==> number > arr[i]),\n{\n    let mut i = 0;\n    while i < arr.len() {\n        if number <= arr[i] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether the given integer is greater than the elements of the given integer array.\n\n    assert!(!is_greater(&vec![1, 2, 3, 4, 5], 4));\n    assert!(is_greater(&vec![2, 3, 4, 5, 6], 8));\n    assert!(is_greater(&vec![9, 7, 4, 8, 6, 1], 11));\n}\n\nverus! {\n\nfn is_greater(arr: &Vec<i32>, number: i32) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < arr.len() ==> number > arr[i]),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            0 <= i <= arr.len(),\n            forall|k: int| 0 <= k < i ==> number > arr[k],\n    {\n        if number <= arr[i] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_433.rs", "solution_path": "MBPP/verified/task_id_433.rs"}
{"task_id": "mbpp_task_id_436", "source": "MBPP", "name": "task_id_436", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn find_negative_numbers(arr: &Vec<i32>) -> (negative_list: Vec<i32>)\n    ensures\n        negative_list@ == arr@.filter(|x: i32| x < 0),\n{\n    let mut negative_list: Vec<i32> = Vec::new();\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] < 0) {\n            negative_list.push(arr[index]);\n        }\n        index += 1;\n    }\n    negative_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to return the negative numbers in a list.\n\n    assert_eq!(find_negative_numbers(&vec![-1, 4, 5, -6]), [-1, -6]);\n    assert_eq!(find_negative_numbers(&vec![-1, -2, 3, 4]), [-1, -2]);\n    assert_eq!(find_negative_numbers(&vec![-7, -6, 8, 9]), [-7, -6]);\n}\n\nverus! {\n\nfn find_negative_numbers(arr: &Vec<i32>) -> (negative_list: Vec<i32>)\n    ensures\n        negative_list@ == arr@.filter(|x: i32| x < 0),\n{\n    let mut negative_list: Vec<i32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: i32| x < 0) == Seq::<i32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            negative_list@ == arr@.take(index as int).filter(|x: i32| x < 0),\n    {\n        if (arr[index] < 0) {\n            negative_list.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    negative_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_436.rs", "solution_path": "MBPP/verified/task_id_436.rs"}
{"task_id": "mbpp_task_id_445", "source": "MBPP", "name": "task_id_445", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn element_wise_multiplication(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] * arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] * arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len() {\n        output_arr.push((arr1[index] * arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to perform index wise multiplication of elements in the given two sequences.\n\n    assert_eq!(\n        element_wise_multiplication(\n            &vec![1, 3, 4, 5, 2, 9, 1, 10],\n            &vec![6, 7, 3, 9, 1, 1, 7, 3]\n        ),\n        [6, 21, 12, 45, 2, 9, 7, 30]\n    );\n    assert_eq!(\n        element_wise_multiplication(\n            &vec![2, 4, 5, 6, 3, 10, 2, 11],\n            &vec![7, 8, 4, 10, 2, 2, 8, 4]\n        ),\n        [14, 32, 20, 60, 6, 20, 16, 44]\n    );\n    assert_eq!(\n        element_wise_multiplication(\n            &vec![3, 5, 6, 7, 4, 11, 3, 12],\n            &vec![8, 9, 5, 11, 3, 3, 9, 5]\n        ),\n        [24, 45, 30, 77, 12, 33, 27, 60]\n    );\n}\n\nverus! {\n\nfn element_wise_multiplication(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] * arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] * arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] * arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] * arr2[k]),\n    {\n        output_arr.push((arr1[index] * arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_445.rs", "solution_path": "MBPP/verified/task_id_445.rs"}
{"task_id": "mbpp_task_id_447", "source": "MBPP", "name": "task_id_447", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn cube_element(nums: &Vec<i32>) -> (cubed: Vec<i32>)\n    requires\n        forall|k: int|\n            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                <= i32::MAX),\n        forall|k: int|\n            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                * #[trigger] nums[k] <= i32::MAX),\n    ensures\n        forall|i: int|\n            0 <= i < nums.len() ==> cubed[i] == #[trigger] nums[i] * #[trigger] nums[i]\n                * #[trigger] nums[i],\n{\n    let mut cubed_array: Vec<i32> = Vec::new();\n    let mut i = 0;\n    while i < nums.len() {\n        cubed_array.push(nums[i] * nums[i] * nums[i]);\n        i += 1;\n    }\n    cubed_array\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find cubes of individual elements in a list.\n\n    assert_eq!(\n        cube_element(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n        [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n    );\n    assert_eq!(cube_element(&vec![10, 20, 30]), [1000, 8000, 27000]);\n    assert_eq!(cube_element(&vec![12, 15]), [1728, 3375]);\n}\n\nverus! {\n\nfn cube_element(nums: &Vec<i32>) -> (cubed: Vec<i32>)\n    requires\n        forall|k: int|\n            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                <= i32::MAX),\n        forall|k: int|\n            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                * #[trigger] nums[k] <= i32::MAX),\n    ensures\n        forall|i: int|\n            0 <= i < nums.len() ==> cubed[i] == #[trigger] nums[i] * #[trigger] nums[i]\n                * #[trigger] nums[i],\n{\n    let mut cubed_array: Vec<i32> = Vec::new();\n    let mut i = 0;\n    while i < nums.len()\n        invariant\n            cubed_array@.len() == i,\n            forall|k: int|\n                0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                    <= i32::MAX),\n            forall|k: int|\n                0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                    * #[trigger] nums[k] <= i32::MAX),\n            forall|k: int|\n                0 <= k < i ==> (#[trigger] cubed_array[k] == nums[k] * nums[k] * nums[k]),\n    {\n        cubed_array.push(nums[i] * nums[i] * nums[i]);\n        i += 1;\n    }\n    cubed_array\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_447.rs", "solution_path": "MBPP/verified/task_id_447.rs"}
{"task_id": "mbpp_task_id_454", "source": "MBPP", "name": "task_id_454", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains_z(text: &[u8]) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < text.len() && (text[i] == 90 || text[i] == 122)),\n{\n    let mut index = 0;\n    while index < text.len() {\n        if text[index] == 90 || text[index] == 122 {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust that matches a word containing 'z'.\n\n    assert!(contains_z(b\"pythonz.\"));\n    assert!(contains_z(b\"xyz.\"));\n    assert!(!contains_z(b\"  lang  .\"));\n}\n\nverus! {\n\nfn contains_z(text: &[u8]) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < text.len() && (text[i] == 90 || text[i] == 122)),\n{\n    let mut index = 0;\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            forall|k: int| 0 <= k < index ==> (text[k] != 90 && text[k] != 122),\n    {\n        if text[index] == 90 || text[index] == 122 {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_454.rs", "solution_path": "MBPP/verified/task_id_454.rs"}
{"task_id": "mbpp_task_id_457", "source": "MBPP", "name": "task_id_457", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn min_sublist(seq: &Vec<Vec<i32>>) -> (min_list: &Vec<i32>)\n    requires\n        seq.len() > 0,\n    ensures\n        forall|k: int| 0 <= k < seq.len() ==> min_list.len() <= #[trigger] (seq[k]).len(),\n        exists|k: int| 0 <= k < seq.len() && min_list@ =~= #[trigger] (seq[k]@),\n{\n    let mut min_list = &seq[0];\n    let mut index = 1;\n\n    while index < seq.len() {\n        if ((seq[index]).len() < min_list.len()) {\n            min_list = &seq[index];\n        }\n        index += 1;\n    }\n    min_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a python function to find the sublist having minimum length.\n\n    assert_eq!(\n        min_sublist(&(vec![vec![1], vec![1, 2], vec![1, 2, 3]])),\n        &vec![1]\n    );\n    assert_eq!(\n        min_sublist(&(vec![vec![1, 1], vec![1, 1, 1], vec![1, 2, 7, 8]])),\n        &vec![1, 1]\n    );\n    assert_eq!(\n        min_sublist(&(vec![vec![1, 2, 3], vec![3, 4], vec![11, 12, 14]])),\n        &vec![3, 4]\n    );\n}\n\nverus! {\n\nfn min_sublist(seq: &Vec<Vec<i32>>) -> (min_list: &Vec<i32>)\n    requires\n        seq.len() > 0,\n    ensures\n        forall|k: int| 0 <= k < seq.len() ==> min_list.len() <= #[trigger] (seq[k]).len(),\n        exists|k: int| 0 <= k < seq.len() && min_list@ =~= #[trigger] (seq[k]@),\n{\n    let mut min_list = &seq[0];\n    assert(min_list@ =~= seq[0]@);\n    let mut index = 1;\n\n    while index < seq.len()\n        invariant\n            0 <= index <= seq.len(),\n            forall|k: int| 0 <= k < index ==> min_list.len() <= #[trigger] (seq[k]).len(),\n            exists|k: int| 0 <= k < index && min_list@ =~= #[trigger] (seq[k]@),\n    {\n        if ((seq[index]).len() < min_list.len()) {\n            min_list = &seq[index];\n        }\n        index += 1;\n    }\n    min_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_457.rs", "solution_path": "MBPP/verified/task_id_457.rs"}
{"task_id": "mbpp_task_id_460", "source": "MBPP", "name": "task_id_460", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn get_first_elements(arr: &Vec<Vec<i32>>) -> (result: Vec<i32>)\n    requires\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() > 0,\n    ensures\n        arr.len() == result.len(),\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] result[i] == #[trigger] arr[i][0],\n{\n    let mut first_elem_arr: Vec<i32> = Vec::new();\n    let mut index = 0;\n    while index < arr.len() {\n        let seq = &arr[index];\n        first_elem_arr.push(seq[0]);\n        index += 1;\n    }\n    first_elem_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to get the first element of each sublist.\n\n    assert_eq!(\n        get_first_elements(&vec![vec![1, 2], vec![3, 4, 5], vec![6, 7, 8, 9]]),\n        [1, 3, 6]\n    );\n    assert_eq!(get_first_elements(&vec![vec![1, 2, 3], vec![4, 5]]), [1, 4]);\n    assert_eq!(get_first_elements(&vec![vec![9, 8, 1], vec![1, 2]]), [9, 1]);\n}\n\nverus! {\n\nfn get_first_elements(arr: &Vec<Vec<i32>>) -> (result: Vec<i32>)\n    requires\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() > 0,\n    ensures\n        arr.len() == result.len(),\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] result[i] == #[trigger] arr[i][0],\n{\n    let mut first_elem_arr: Vec<i32> = Vec::new();\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            first_elem_arr.len() == index,\n            forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() > 0,\n            forall|k: int| 0 <= k < index ==> #[trigger] first_elem_arr[k] == #[trigger] arr[k][0],\n    {\n        let seq = &arr[index];\n        assert(seq.len() > 0);\n        first_elem_arr.push(seq[0]);\n        index += 1;\n    }\n    first_elem_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_460.rs", "solution_path": "MBPP/verified/task_id_460.rs"}
{"task_id": "mbpp_task_id_461", "source": "MBPP", "name": "task_id_461", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn is_lower_case(c: u8) -> bool {\n    c >= 97 && c <= 122\n}\n\nspec fn is_upper_case(c: u8) -> bool {\n    c >= 65 && c <= 90\n}\n\nspec fn count_uppercase_recursively(seq: Seq<u8>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_uppercase_recursively(seq.drop_last()) + if is_upper_case(seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_uppercase(text: &[u8]) -> (count: u64)\n    ensures\n        0 <= count <= text.len(),\n        count_uppercase_recursively(text@) == count,\n{\n    let mut index = 0;\n    let mut count = 0;\n\n    while index < text.len() {\n        if (text[index] >= 65 && text[index] <= 90) {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to count the upper case characters in a given string.\n\n    assert_eq!(count_uppercase(b\"PYthon\"), 2);\n    assert_eq!(count_uppercase(b\"BigData\"), 2);\n    assert_eq!(count_uppercase(b\"program\"), 0);\n}\n\nverus! {\n\nspec fn is_lower_case(c: u8) -> bool {\n    c >= 97 && c <= 122\n}\n\nspec fn is_upper_case(c: u8) -> bool {\n    c >= 65 && c <= 90\n}\n\nspec fn count_uppercase_recursively(seq: Seq<u8>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_uppercase_recursively(seq.drop_last()) + if is_upper_case(seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_uppercase(text: &[u8]) -> (count: u64)\n    ensures\n        0 <= count <= text.len(),\n        count_uppercase_recursively(text@) == count,\n{\n    let mut index = 0;\n    let mut count = 0;\n\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            0 <= count <= index,\n            count_uppercase_recursively(text@.subrange(0, index as int)) == count,\n    {\n        if (text[index] >= 65 && text[index] <= 90) {\n            count += 1;\n        }\n        index += 1;\n        assert(text@.subrange(0, index - 1 as int) == text@.subrange(0, index as int).drop_last());\n\n    }\n    assert(text@ == text@.subrange(0, index as int));\n    count\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_461.rs", "solution_path": "MBPP/verified/task_id_461.rs"}
{"task_id": "mbpp_task_id_472", "source": "MBPP", "name": "task_id_472", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains_consecutive_numbers(arr: &Vec<i32>) -> (is_consecutive: bool)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> (0 <= #[trigger] arr[i] + 1 < i32::MAX),\n    ensures\n        is_consecutive == (forall|i: int, j: int|\n            0 <= i < j < arr.len() && j == i + 1 ==> (arr[i] + 1 == arr[j])),\n{\n    let mut index = 0;\n    while (index < arr.len() - 1) {\n        if (arr[index] + 1 != arr[index + 1]) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether the given list contains consecutive numbers or not.\n\n    assert!(contains_consecutive_numbers(&vec![1, 2, 3, 4, 5]));\n    assert!(!contains_consecutive_numbers(&vec![1, 2, 3, 5, 6]));\n    assert!(!contains_consecutive_numbers(&vec![1, 2, 1]));\n}\n\nverus! {\n\nfn contains_consecutive_numbers(arr: &Vec<i32>) -> (is_consecutive: bool)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> (0 <= #[trigger] arr[i] + 1 < i32::MAX),\n    ensures\n        is_consecutive == (forall|i: int, j: int|\n            0 <= i < j < arr.len() && j == i + 1 ==> (arr[i] + 1 == arr[j])),\n{\n    let mut index = 0;\n    while (index < arr.len() - 1)\n        invariant\n            0 <= index <= arr.len() - 1,\n            forall|k: int| 0 <= k < arr.len() ==> (0 <= #[trigger] arr[k] + 1 < i32::MAX),\n            forall|k: int, l: int| (0 <= k < l <= index && l == k + 1) ==> (arr[k] + 1 == arr[l]),\n    {\n        if (arr[index] + 1 != arr[index + 1]) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_472.rs", "solution_path": "MBPP/verified/task_id_472.rs"}
{"task_id": "mbpp_task_id_474", "source": "MBPP", "name": "task_id_474", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn replace_chars(str1: &[u8], old_char: u8, new_char: u8) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if str1[i] == old_char {\n                new_char\n            } else {\n                str1[i]\n            }),\n{\n    let mut result_str = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len() {\n        if str1[index] == old_char {\n            result_str.push(new_char);\n        } else {\n            result_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    result_str\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust  to replace characters in a string.\n\n    assert_eq!(replace_chars(b\"polygon\", b'y', b'l'), b\"pollgon\");\n    assert_eq!(replace_chars(b\"character\", b'c', b'a'), b\"aharaater\");\n    assert_eq!(replace_chars(b\"python\", b'l', b'a'), b\"python\");\n}\n\nverus! {\n\nfn replace_chars(str1: &[u8], old_char: u8, new_char: u8) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if str1[i] == old_char {\n                new_char\n            } else {\n                str1[i]\n            }),\n{\n    let mut result_str = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1@.len(),\n            result_str@.len() == index,\n            forall|k: int|\n                0 <= k < index ==> result_str[k] == (if str1[k] == old_char {\n                    new_char\n                } else {\n                    str1[k]\n                }),\n    {\n        if str1[index] == old_char {\n            result_str.push(new_char);\n        } else {\n            result_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    result_str\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_474.rs", "solution_path": "MBPP/verified/task_id_474.rs"}
{"task_id": "mbpp_task_id_476", "source": "MBPP", "name": "task_id_476", "task": "#![verifier::loop_isolation(false)]\nuse vstd::math::*;\nuse vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn max_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        max(seq.last() as int, max_rcur(seq.drop_last()))\n    }\n}\n\nspec fn min_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        min(seq.last() as int, min_rcur(seq.drop_last()))\n    }\n}\n\nfn sum_min_max(arr: &Vec<i32>) -> (sum: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        sum == max_rcur(arr@) + min_rcur(arr@),\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let mut index = 1;\n\n    while index < arr.len() {\n        if (arr[index] <= min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n    }\n    max_val + min_val\n}\n\n} // verus!\n", "ground_truth": "#![verifier::loop_isolation(false)]\nuse vstd::math::*;\nuse vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the sum of the largest and smallest value in a given array.\n\n    assert_eq!(sum_min_max(&vec![1, 2, 3]), 4);\n    assert_eq!(sum_min_max(&vec![-1, 2, 3, 4]), 3);\n    assert_eq!(sum_min_max(&vec![2, 3, 6]), 8);\n}\n\nverus! {\n\nspec fn max_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        max(seq.last() as int, max_rcur(seq.drop_last()))\n    }\n}\n\nspec fn min_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        min(seq.last() as int, min_rcur(seq.drop_last()))\n    }\n}\n\nfn sum_min_max(arr: &Vec<i32>) -> (sum: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        sum == max_rcur(arr@) + min_rcur(arr@),\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let mut index = 1;\n\n    while index < arr.len()\n        invariant\n            1 <= index <= arr.len(),\n            i32::MIN / 2 < min_val < i32::MAX / 2,\n            i32::MIN / 2 < max_val < i32::MAX / 2,\n            max_val == max_rcur(arr@.subrange(0, index as int)),\n            min_val == min_rcur(arr@.subrange(0, index as int)),\n    {\n        if (arr[index] <= min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    max_val + min_val\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_476.rs", "solution_path": "MBPP/verified/task_id_476.rs"}
{"task_id": "mbpp_task_id_477", "source": "MBPP", "name": "task_id_477", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn is_upper_case(c: u8) -> bool {\n    c >= 65 && c <= 90\n}\n\nspec fn shift32_spec(c: u8) -> u8 {\n    (c + 32) as u8\n}\n\nfn to_lowercase(str1: &[u8]) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if is_upper_case(#[trigger] str1[i]) {\n                shift32_spec(str1[i])\n            } else {\n                str1[i]\n            }),\n{\n    let mut lower_case: Vec<u8> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len() {\n        if (str1[index] >= 65 && str1[index] <= 90) {\n            lower_case.push((str1[index] + 32) as u8);\n\n        } else {\n            lower_case.push(str1[index]);\n        }\n        index += 1;\n    }\n    lower_case\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to convert the given string to lower case.\n\n    assert_eq!(to_lowercase(b\"InValid\"), b\"invalid\");\n    assert_eq!(to_lowercase(b\"TruE\"), b\"true\");\n    assert_eq!(to_lowercase(b\"SenTenCE\"), b\"sentence\");\n}\n\nverus! {\n\nspec fn is_upper_case(c: u8) -> bool {\n    c >= 65 && c <= 90\n}\n\nspec fn shift32_spec(c: u8) -> u8 {\n    (c + 32) as u8\n}\n\nfn to_lowercase(str1: &[u8]) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if is_upper_case(#[trigger] str1[i]) {\n                shift32_spec(str1[i])\n            } else {\n                str1[i]\n            }),\n{\n    let mut lower_case: Vec<u8> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            lower_case.len() == index,\n            forall|i: int|\n                0 <= i < index ==> lower_case[i] == (if is_upper_case(#[trigger] str1[i]) {\n                    shift32_spec(str1[i])\n                } else {\n                    str1[i]\n                }),\n    {\n        if (str1[index] >= 65 && str1[index] <= 90) {\n            lower_case.push((str1[index] + 32) as u8);\n\n        } else {\n            lower_case.push(str1[index]);\n        }\n        assert(lower_case[index as int] == (if is_upper_case(str1[index as int]) {\n            shift32_spec(str1[index as int])\n        } else {\n            str1[index as int]\n        }));\n        index += 1;\n    }\n    assert(forall|i: int|\n        0 <= i < str1.len() ==> lower_case[i] == (if is_upper_case(#[trigger] str1[i]) {\n            shift32_spec(str1[i])\n        } else {\n            str1[i]\n        }));\n    lower_case\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_477.rs", "solution_path": "MBPP/verified/task_id_477.rs"}
{"task_id": "mbpp_task_id_554", "source": "MBPP", "name": "task_id_554", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn find_odd_numbers(arr: &Vec<u32>) -> (odd_numbers: Vec<u32>)\n    ensures\n        odd_numbers@ == arr@.filter(|x: u32| x % 2 != 0),\n{\n    let mut odd_numbers: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] % 2 != 0) {\n            odd_numbers.push(arr[index]);\n        }\n        index += 1;\n    }\n    odd_numbers\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust which takes a list of integers and only returns the odd ones.\n\n    assert_eq!(find_odd_numbers(&vec![1, 2, 3, 4, 5, 6]), [1, 3, 5]);\n    assert_eq!(find_odd_numbers(&vec![10, 11, 12, 13]), [11, 13]);\n    assert_eq!(find_odd_numbers(&vec![7, 8, 9, 1]), [7, 9, 1]);\n}\n\nverus! {\n\nfn find_odd_numbers(arr: &Vec<u32>) -> (odd_numbers: Vec<u32>)\n    ensures\n        odd_numbers@ == arr@.filter(|x: u32| x % 2 != 0),\n{\n    let mut odd_numbers: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: u32| x % 2 != 0) == Seq::<u32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            odd_numbers@ == arr@.take(index as int).filter(|x: u32| x % 2 != 0),\n    {\n        if (arr[index] % 2 != 0) {\n            odd_numbers.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    odd_numbers\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_554.rs", "solution_path": "MBPP/verified/task_id_554.rs"}
{"task_id": "mbpp_task_id_557", "source": "MBPP", "name": "task_id_557", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nspec fn is_upper_case(c: u8) -> bool {\n    c >= 65 && c <= 90\n}\n\nspec fn shift32_spec(c: u8) -> u8 {\n    (c + 32) as u8\n}\n\nspec fn is_lower_case(c: u8) -> bool {\n    c >= 97 && c <= 122\n}\n\nspec fn shift_minus_32_spec(c: u8) -> u8 {\n    (c - 32) as u8\n}\n\nspec fn to_toggle_case_spec(s: u8) -> u8 {\n    if is_lower_case(s) {\n        shift_minus_32_spec(s)\n    } else if is_upper_case(s) {\n        shift32_spec(s)\n    } else {\n        s\n    }\n}\n\nfn to_toggle_case(str1: &[u8]) -> (toggle_case: Vec<u8>)\n    ensures\n        str1@.len() == toggle_case@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]),\n{\n    let mut toggle_case = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len() {\n        if (str1[index] >= 97 && str1[index] <= 122) {\n            toggle_case.push((str1[index] - 32) as u8);\n        } else if (str1[index] >= 65 && str1[index] <= 90) {\n            toggle_case.push((str1[index] + 32) as u8);\n        } else {\n            toggle_case.push(str1[index]);\n        }\n        index += 1;\n\n    }\n    toggle_case\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\nfn main() {\n    // Write a function in Rust to toggle the case of all characters in a string.\n\n    assert_eq!(to_toggle_case(b\"Python\"), b\"pYTHON\");\n    assert_eq!(to_toggle_case(b\"Pangram\"), b\"pANGRAM\");\n    assert_eq!(to_toggle_case(b\"LIttLE\"), b\"liTTle\");\n}\n\nverus! {\n\nspec fn is_upper_case(c: u8) -> bool {\n    c >= 65 && c <= 90\n}\n\nspec fn shift32_spec(c: u8) -> u8 {\n    (c + 32) as u8\n}\n\nspec fn is_lower_case(c: u8) -> bool {\n    c >= 97 && c <= 122\n}\n\nspec fn shift_minus_32_spec(c: u8) -> u8 {\n    (c - 32) as u8\n}\n\nspec fn to_toggle_case_spec(s: u8) -> u8 {\n    if is_lower_case(s) {\n        shift_minus_32_spec(s)\n    } else if is_upper_case(s) {\n        shift32_spec(s)\n    } else {\n        s\n    }\n}\n\nfn to_toggle_case(str1: &[u8]) -> (toggle_case: Vec<u8>)\n    ensures\n        str1@.len() == toggle_case@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]),\n{\n    let mut toggle_case = Vec::with_capacity(str1.len());\n\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            toggle_case.len() == index,\n            forall|i: int|\n                0 <= i < index ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]),\n    {\n        if (str1[index] >= 97 && str1[index] <= 122) {\n            toggle_case.push((str1[index] - 32) as u8);\n        } else if (str1[index] >= 65 && str1[index] <= 90) {\n            toggle_case.push((str1[index] + 32) as u8);\n        } else {\n            toggle_case.push(str1[index]);\n        }\n        index += 1;\n\n    }\n    assert(forall|i: int|\n        0 <= i < str1.len() ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]));\n    toggle_case\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_557.rs", "solution_path": "MBPP/verified/task_id_557.rs"}
{"task_id": "mbpp_task_id_567", "source": "MBPP", "name": "task_id_567", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn is_sorted(arr: &Vec<i32>) -> (is_sorted: bool)\n    requires\n        arr.len() > 0,\n    ensures\n        is_sorted == (forall|i: int, j: int| 0 <= i < j < arr.len() ==> (arr[i] <= arr[j])),\n{\n    let mut index = 0;\n    while index < arr.len() - 1 {\n        if arr[index] > arr[index + 1] {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether a specified list is sorted or not.\n\n    assert!(is_sorted(&vec![1, 2, 4, 6, 8, 10, 12, 14, 16, 17]));\n    assert!(!is_sorted(&vec![1, 2, 4, 6, 8, 10, 12, 14, 20, 17]));\n    assert!(!is_sorted(&vec![1, 2, 4, 6, 8, 10, 15, 14, 20]));\n}\n\nverus! {\n\nfn is_sorted(arr: &Vec<i32>) -> (is_sorted: bool)\n    requires\n        arr.len() > 0,\n    ensures\n        is_sorted == (forall|i: int, j: int| 0 <= i < j < arr.len() ==> (arr[i] <= arr[j])),\n{\n    let mut index = 0;\n    while index < arr.len() - 1\n        invariant\n            0 <= index <= arr.len() - 1,\n            forall|k: int, l: int| 0 <= k < l <= index ==> arr[k] <= arr[l],\n    {\n        if arr[index] > arr[index + 1] {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_567.rs", "solution_path": "MBPP/verified/task_id_567.rs"}
{"task_id": "mbpp_task_id_572", "source": "MBPP", "name": "task_id_572", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\npub open spec fn count_frequency_rcr(seq: Seq<i32>, key: i32) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_frequency(arr: &Vec<i32>, key: i32) -> (frequency: usize)\n    ensures\n        count_frequency_rcr(arr@, key) == frequency,\n{\n    let mut index = 0;\n    let mut counter = 0;\n    while index < arr.len() {\n        if (arr[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n    }\n    counter\n}\n\nfn remove_duplicates(arr: &Vec<i32>) -> (unique_arr: Vec<i32>)\n    ensures\n        unique_arr@ == arr@.filter(|x: i32| count_frequency_rcr(arr@, x) == 1),\n{\n    let mut unique_arr: Vec<i32> = Vec::new();\n    let input_len = arr.len();\n    let mut index = 0;\n    while index < arr.len() {\n        if count_frequency(&arr, arr[index]) == 1 {\n            unique_arr.push(arr[index]);\n        }\n        index += 1;\n    }\n    unique_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to remove duplicate numbers from a given list.\n\n    assert_eq!(remove_duplicates(&vec![1, 2, 3, 2, 3, 4, 5]), [1, 4, 5]);\n    assert_eq!(remove_duplicates(&vec![1, 2, 3, 2, 4, 5]), [1, 3, 4, 5]);\n    assert_eq!(remove_duplicates(&vec![1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n}\n\nverus! {\n\npub open spec fn count_frequency_rcr(seq: Seq<i32>, key: i32) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_frequency(arr: &Vec<i32>, key: i32) -> (frequency: usize)\n    ensures\n        count_frequency_rcr(arr@, key) == frequency,\n{\n    let mut index = 0;\n    let mut counter = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            0 <= counter <= index,\n            count_frequency_rcr(arr@.subrange(0, index as int), key) == counter,\n    {\n        if (arr[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    counter\n}\n\nfn remove_duplicates(arr: &Vec<i32>) -> (unique_arr: Vec<i32>)\n    ensures\n        unique_arr@ == arr@.filter(|x: i32| count_frequency_rcr(arr@, x) == 1),\n{\n    let mut unique_arr: Vec<i32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: i32| count_frequency_rcr(arr@, x) == 1) == Seq::<\n        i32,\n    >::empty());\n\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            unique_arr@ == arr@.take(index as int).filter(\n                |x: i32| count_frequency_rcr(arr@, x) == 1,\n            ),\n    {\n        if count_frequency(&arr, arr[index]) == 1 {\n            unique_arr.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    unique_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_572.rs", "solution_path": "MBPP/verified/task_id_572.rs"}
{"task_id": "mbpp_task_id_576", "source": "MBPP", "name": "task_id_576", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn sub_array_at_index(main: &Vec<i32>, sub: &Vec<i32>, idx: usize) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n        0 <= idx <= (main.len() - sub.len()),\n    ensures\n        result == (main@.subrange(idx as int, (idx + sub@.len())) =~= sub@),\n{\n    let mut i = 0;\n    while i < sub.len() {\n        if (main[idx + i] != sub[i]) {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn is_sub_array(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n    ensures\n        result == (exists|k: int, l: int|\n            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(\n                k,\n                l,\n            ))) =~= sub@),\n{\n    if sub.len() > main.len() {\n        return false;\n    }\n    let mut index = 0;\n    while index <= (main.len() - sub.len()) {\n        if (sub_array_at_index(&main, &sub, index)) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether a list is sublist of another or not.\n\n    assert!(!is_sub_array(&vec![1, 4, 3, 5], &vec![1, 2]));\n    assert!(is_sub_array(&vec![1, 2, 1], &vec![1, 2, 1]));\n    assert!(!is_sub_array(&vec![1, 0, 2, 2], &vec![2, 2, 0]));\n    assert!(is_sub_array(&vec![1, 0, 2, 2], &vec![2, 2]));\n    assert!(is_sub_array(&vec![1, 0, 2, 2], &vec![1, 0]));\n\n    assert_eq!(\n        sub_array_at_index(&vec![1, 0, 2, 2], &vec![1, 0, 2, 2], 0),\n        true\n    );\n    assert_eq!(\n        sub_array_at_index(&vec![1, 0, 2, 2], &vec![1, 0, 2, 2], 1),\n        false\n    );\n}\n\nverus! {\n\nfn sub_array_at_index(main: &Vec<i32>, sub: &Vec<i32>, idx: usize) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n        0 <= idx <= (main.len() - sub.len()),\n    ensures\n        result == (main@.subrange(idx as int, (idx + sub@.len())) =~= sub@),\n{\n    let mut i = 0;\n    while i < sub.len()\n        invariant\n            0 <= idx <= (main.len() - sub.len()),\n            0 <= i <= sub.len(),\n            0 <= idx + i <= main.len(),\n            forall|k: int| 0 <= k < i ==> main[idx + k] == sub[k],\n            forall|k: int|\n                0 <= k < i ==> (main@.subrange(idx as int, (idx + k)) =~= sub@.subrange(0, k)),\n    {\n        if (main[idx + i] != sub[i]) {\n            assert(exists|k: int| 0 <= k < i ==> main[idx + k] != sub[k]);\n            assert(main@.subrange(idx as int, (idx + sub@.len())) != sub@);\n            return false;\n\n        }\n        i += 1;\n    }\n    assert(main@.subrange(idx as int, (idx + sub@.len())) == sub@);\n    true\n}\n\nfn is_sub_array(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n    ensures\n        result == (exists|k: int, l: int|\n            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(\n                k,\n                l,\n            ))) =~= sub@),\n{\n    if sub.len() > main.len() {\n        return false;\n    }\n    let mut index = 0;\n    while index <= (main.len() - sub.len())\n        invariant\n            sub.len() <= main.len(),\n            0 <= index <= (main.len() - sub.len()) + 1,\n            forall|k: int, l: int|\n                (0 <= k < index) && l == k + sub.len() ==> (#[trigger] (main@.subrange(k, l))\n                    != sub@),\n    {\n        if (sub_array_at_index(&main, &sub, index)) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_576.rs", "solution_path": "MBPP/verified/task_id_576.rs"}
{"task_id": "mbpp_task_id_578", "source": "MBPP", "name": "task_id_578", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn interleave(s1: &Vec<i32>, s2: &Vec<i32>, s3: &Vec<i32>) -> (res: Vec<i32>)\n    requires\n        s1@.len() == s2@.len() && s2@.len() == s3@.len(),\n        0 <= (s1@.len() * 3) <= i32::MAX,\n    ensures\n        res@.len() == s1@.len() * 3,\n        forall|i: int|\n            0 <= i < s1@.len() ==> (res[3 * i] == s1[i] && res[3 * i + 1] == s2[i] && res[3 * i + 2]\n                == s3[i]),\n{\n    let new_seq_len = s1.len() * 3;\n    let mut output_seq = Vec::with_capacity(new_seq_len);\n    let mut index = 0;\n\n    while index < s1.len() {\n        output_seq.push(s1[index]);\n        output_seq.push(s2[index]);\n        output_seq.push(s3[index]);\n        index += 1;\n    }\n    output_seq\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    //Write a function in Rust to interleave 3 lists of the same length into a single flat list.\n\n    assert_eq!(\n        interleave(\n            &vec![1, 2, 3, 4, 5, 6, 7],\n            &vec![10, 20, 30, 40, 50, 60, 70],\n            &vec![100, 200, 300, 400, 500, 600, 700]\n        ),\n        [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n    );\n    assert_eq!(\n        interleave(&vec![10, 20], &vec![15, 2], &vec![5, 10]),\n        [10, 15, 5, 20, 2, 10]\n    );\n    assert_eq!(\n        interleave(&vec![11, 44], &vec![10, 15], &vec![20, 5]),\n        [11, 10, 20, 44, 15, 5]\n    );\n}\n\nverus! {\n\nfn interleave(s1: &Vec<i32>, s2: &Vec<i32>, s3: &Vec<i32>) -> (res: Vec<i32>)\n    requires\n        s1@.len() == s2@.len() && s2@.len() == s3@.len(),\n        0 <= (s1@.len() * 3) <= i32::MAX,\n    ensures\n        res@.len() == s1@.len() * 3,\n        forall|i: int|\n            0 <= i < s1@.len() ==> (res[3 * i] == s1[i] && res[3 * i + 1] == s2[i] && res[3 * i + 2]\n                == s3[i]),\n{\n    let new_seq_len = s1.len() * 3;\n    let mut output_seq = Vec::with_capacity(new_seq_len);\n    let mut index = 0;\n\n    while index < s1.len()\n        invariant\n            0 <= index <= s1.len(),\n            output_seq@.len() == 3 * index,\n            s1@.len() == s2@.len() && s2@.len() == s3@.len(),\n            forall|k: int|\n                0 <= k < index ==> (output_seq[3 * k] == s1[k] && output_seq[3 * k + 1] == s2[k]\n                    && output_seq[3 * k + 2] == s3[k]),\n    {\n        output_seq.push(s1[index]);\n        output_seq.push(s2[index]);\n        output_seq.push(s3[index]);\n        index += 1;\n    }\n    output_seq\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_578.rs", "solution_path": "MBPP/verified/task_id_578.rs"}
{"task_id": "mbpp_task_id_579", "source": "MBPP", "name": "task_id_579", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] == key) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn find_dissimilar(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                arr1[i],\n            )),\n        forall|i: int|\n            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                arr2[i],\n            )),\n        forall|i: int, j: int|\n            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],\n{\n    let mut result = Vec::new();\n    let mut index = 0;\n    while index < arr1.len() {\n        if (!contains(arr2, arr1[index]) && !contains(&result, arr1[index])) {\n            result.push(arr1[index]);\n\n        }\n        index += 1;\n    }\n    let mut index = 0;\n    while index < arr2.len() {\n        if (!contains(arr1, arr2[index]) && !contains(&result, arr2[index])) {\n            result.push(arr2[index]);\n        }\n        index += 1;\n    }\n    result\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to get the difference between two lists.\n\n    assert_eq!(\n        find_dissimilar(&vec![3, 4, 5, 6], &vec![5, 7, 4, 10]),\n        [3, 6, 7, 10]\n    );\n    assert_eq!(\n        find_dissimilar(&vec![1, 2, 3, 4], &vec![7, 2, 3, 9]),\n        [1, 4, 7, 9]\n    );\n    assert_eq!(\n        find_dissimilar(&vec![21, 11, 25, 26], &vec![26, 34, 21, 36]),\n        [11, 25, 34, 36]\n    );\n}\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            forall|m: int| 0 <= m < index ==> (arr[m] != key),\n    {\n        if (arr[index] == key) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn find_dissimilar(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                arr1[i],\n            )),\n        forall|i: int|\n            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                arr2[i],\n            )),\n        forall|i: int, j: int|\n            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],\n{\n    let mut result = Vec::new();\n    let ghost mut output_len: int = 0;\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            forall|i: int|\n                0 <= i < index ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                    arr1[i],\n                )),\n            forall|m: int, n: int|\n                0 <= m < n < result.len() ==> #[trigger] result[m] != #[trigger] result[n],\n    {\n        if (!contains(arr2, arr1[index]) && !contains(&result, arr1[index])) {\n            proof {\n                lemma_vec_push(result@, arr1[index as int], result.len());\n                output_len = output_len + 1;\n            }\n            result.push(arr1[index]);\n\n        }\n        index += 1;\n    }\n    let mut index = 0;\n    while index < arr2.len()\n        invariant\n            forall|i: int|\n                0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                    arr1[i],\n                )),\n            forall|i: int|\n                0 <= i < index ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                    arr2[i],\n                )),\n            forall|m: int, n: int|\n                0 <= m < n < result.len() ==> #[trigger] result[m] != #[trigger] result[n],\n    {\n        if (!contains(arr1, arr2[index]) && !contains(&result, arr2[index])) {\n            proof {\n                lemma_vec_push(result@, arr2[index as int], result.len());\n                output_len = output_len + 1;\n            }\n            result.push(arr2[index]);\n        }\n        index += 1;\n    }\n    assert(forall|i: int|\n        0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n            arr1[i],\n        )));\n    assert(forall|i: int|\n        0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n            arr2[i],\n        )));\n    assert(forall|i: int, j: int|\n        0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j]);\n\n    result\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_579.rs", "solution_path": "MBPP/verified/task_id_579.rs"}
{"task_id": "mbpp_task_id_586", "source": "MBPP", "name": "task_id_586", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nfn split_and_append(list: &Vec<i32>, n: usize) -> (new_list: Vec<i32>)\n    requires\n        list@.len() > 0,\n        0 < n < list@.len(),\n    ensures\n        new_list@ == list@.subrange(n as int, list@.len() as int).add(list@.subrange(0, n as int)),\n{\n    let mut new_list = Vec::new();\n    let mut index = n;\n    while index < list.len() {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    let mut index = 0;\n    while index < n {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    new_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\nfn main() {\n    //Write a function in Rust to split a list at the nth eelment and add the first part to the end.\n\n    assert_eq!(\n        split_and_append(&vec![12, 10, 5, 6, 52, 36], 2),\n        [5, 6, 52, 36, 12, 10]\n    );\n    assert_eq!(split_and_append(&vec![1, 2, 3, 4], 1), [2, 3, 4, 1]);\n    assert_eq!(\n        split_and_append(&vec![0, 1, 2, 3, 4, 5, 6, 7], 3),\n        [3, 4, 5, 6, 7, 0, 1, 2]\n    );\n}\n\nverus! {\n\nfn split_and_append(list: &Vec<i32>, n: usize) -> (new_list: Vec<i32>)\n    requires\n        list@.len() > 0,\n        0 < n < list@.len(),\n    ensures\n        new_list@ == list@.subrange(n as int, list@.len() as int).add(list@.subrange(0, n as int)),\n{\n    let mut new_list = Vec::new();\n    let mut index = n;\n    while index < list.len()\n        invariant\n            n <= index <= list.len(),\n            list@.subrange(n as int, index as int) =~= new_list@,\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    let mut index = 0;\n    while index < n\n        invariant\n            0 < n < list@.len(),\n            0 <= index <= n,\n            new_list@ =~= list@.subrange(n as int, list@.len() as int).add(\n                list@.subrange(0, index as int),\n            ),\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    new_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_586.rs", "solution_path": "MBPP/verified/task_id_586.rs"}
{"task_id": "mbpp_task_id_588", "source": "MBPP", "name": "task_id_588", "task": "#![verifier::loop_isolation(false)]\nuse vstd::math::*;\nuse vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn max_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        max(seq.last() as int, max_rcur(seq.drop_last()))\n    }\n}\n\nspec fn min_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        min(seq.last() as int, min_rcur(seq.drop_last()))\n    }\n}\n\nfn difference_max_min(arr: &Vec<i32>) -> (diff: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        diff == max_rcur(arr@) - min_rcur(arr@),\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let mut index = 1;\n\n    while index < arr.len() {\n        if (arr[index] <= min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n    }\n    max_val - min_val\n}\n\n} // verus!\n", "ground_truth": "#![verifier::loop_isolation(false)]\nuse vstd::math::*;\nuse vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the difference between largest and smallest value in a given list.\n\n    assert_eq!(difference_max_min(&vec![1, 2, 3, 4]), 3);\n    assert_eq!(difference_max_min(&vec![4, 5, 12]), 8);\n    assert_eq!(difference_max_min(&vec![9, 2, 3]), 7);\n}\n\nverus! {\n\nspec fn max_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        max(seq.last() as int, max_rcur(seq.drop_last()))\n    }\n}\n\nspec fn min_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        min(seq.last() as int, min_rcur(seq.drop_last()))\n    }\n}\n\nfn difference_max_min(arr: &Vec<i32>) -> (diff: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        diff == max_rcur(arr@) - min_rcur(arr@),\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let mut index = 1;\n\n    while index < arr.len()\n        invariant\n            1 <= index <= arr.len(),\n            i32::MIN / 2 < min_val < i32::MAX / 2,\n            i32::MIN / 2 < max_val < i32::MAX / 2,\n            max_val == max_rcur(arr@.subrange(0, index as int)),\n            min_val == min_rcur(arr@.subrange(0, index as int)),\n    {\n        if (arr[index] <= min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    max_val - min_val\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_588.rs", "solution_path": "MBPP/verified/task_id_588.rs"}
{"task_id": "mbpp_task_id_602", "source": "MBPP", "name": "task_id_602", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\npub open spec fn count_frequency_rcr(seq: Seq<u8>, key: u8) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_frequency(arr: &[u8], key: u8) -> (frequency: usize)\n    ensures\n        count_frequency_rcr(arr@, key) == frequency,\n{\n    let mut index = 0;\n    let mut counter = 0;\n    while index < arr.len() {\n        if (arr[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n    }\n    counter\n}\n\nfn first_repeated_char(str1: &[u8]) -> (repeated_char: Option<(usize, u8)>)\n    ensures\n        if let Some((idx, rp_char)) = repeated_char {\n            &&& str1@.take(idx as int) =~= str1@.take(idx as int).filter(\n                |x: u8| count_frequency_rcr(str1@, x) <= 1,\n            )\n            &&& count_frequency_rcr(str1@, rp_char) > 1\n        } else {\n            forall|k: int|\n                0 <= k < str1.len() ==> count_frequency_rcr(str1@, #[trigger] str1[k]) <= 1\n        },\n{\n    let mut index = 0;\n    while index < str1.len() {\n        if count_frequency(&str1, str1[index]) > 1 {\n            return Some((index, str1[index]));\n        }\n        index += 1;\n    }\n    None\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the first repeated character in a given string.\n\n    assert_eq!(first_repeated_char(b\"abcabc\"), Some((0, b'a')));\n    assert_eq!(first_repeated_char(b\"abc\"), None);\n    assert_eq!(first_repeated_char(b\"123123\"), Some((0, b'1')));\n}\n\nverus! {\n\npub open spec fn count_frequency_rcr(seq: Seq<u8>, key: u8) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_frequency(arr: &[u8], key: u8) -> (frequency: usize)\n    ensures\n        count_frequency_rcr(arr@, key) == frequency,\n{\n    let mut index = 0;\n    let mut counter = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            0 <= counter <= index,\n            count_frequency_rcr(arr@.subrange(0, index as int), key) == counter,\n    {\n        if (arr[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    counter\n}\n\nfn first_repeated_char(str1: &[u8]) -> (repeated_char: Option<(usize, u8)>)\n    ensures\n        if let Some((idx, rp_char)) = repeated_char {\n            &&& str1@.take(idx as int) =~= str1@.take(idx as int).filter(\n                |x: u8| count_frequency_rcr(str1@, x) <= 1,\n            )\n            &&& count_frequency_rcr(str1@, rp_char) > 1\n        } else {\n            forall|k: int|\n                0 <= k < str1.len() ==> count_frequency_rcr(str1@, #[trigger] str1[k]) <= 1\n        },\n{\n    let input_len = str1.len();\n    assert(str1@.take(0int).filter(|x: u8| count_frequency_rcr(str1@, x) > 1) == Seq::<\n        u8,\n    >::empty());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            str1@.take(index as int) =~= str1@.take(index as int).filter(\n                |x: u8| count_frequency_rcr(str1@, x) <= 1,\n            ),\n    {\n        if count_frequency(&str1, str1[index]) > 1 {\n            return Some((index, str1[index]));\n        }\n        assert(str1@.take((index + 1) as int).drop_last() == str1@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(str1@ =~= str1@.take(input_len as int));\n    assert(forall|k: int|\n        0 <= k < str1.len() ==> count_frequency_rcr(str1@, #[trigger] str1[k]) <= 1);\n    None\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_602.rs", "solution_path": "MBPP/verified/task_id_602.rs"}
{"task_id": "mbpp_task_id_605", "source": "MBPP", "name": "task_id_605", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\nfn prime_num(n: u64) -> (result: bool)\n    requires\n        n >= 2,\n    ensures\n        result == (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k)),\n{\n    if n <= 1 {\n        return false;\n    }\n    let mut index = 2;\n    while index < n {\n        if ((n % index) == 0) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // verus does not support mod(%) operation on signed integers\n    // so input should be unsigned integers\n\n    // Write a function in Rust to check if the given integer is a prime number.\n\n    assert!(!prime_num(0));\n    assert!(!prime_num(1));\n    assert!(prime_num(13));\n    assert!(prime_num(7));\n    assert!(!prime_num(1010));\n}\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\nfn prime_num(n: u64) -> (result: bool)\n    requires\n        n >= 2,\n    ensures\n        result == (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k)),\n{\n    if n <= 1 {\n        return false;\n    }\n    let mut index = 2;\n    while index < n\n        invariant\n            2 <= index <= n,\n            forall|k: int| 2 <= k < index ==> !is_divisible(n as int, k),\n    {\n        if ((n % index) == 0) {\n            assert(is_divisible(n as int, index as int));\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_605.rs", "solution_path": "MBPP/verified/task_id_605.rs"}
{"task_id": "mbpp_task_id_610", "source": "MBPP", "name": "task_id_610", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nfn remove_kth_element(list: &Vec<i32>, k: usize) -> (new_list: Vec<i32>)\n    requires\n        list.len() > 0,\n        0 < k < list@.len(),\n    ensures\n        new_list@ == list@.subrange(0, k - 1 as int).add(\n            list@.subrange(k as int, list.len() as int),\n        ),\n{\n    let mut new_list = Vec::new();\n    let mut index = 0;\n    while index < (k - 1) {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    let mut index = k;\n    while index < list.len() {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    new_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\nfn main() {\n    //Write a function in Rust which takes a list and returns a list with the same elements, but the k'th element removed.\n\n    assert_eq!(\n        remove_kth_element(&vec![1, 1, 2, 3, 4, 4, 5, 1], 3),\n        [1, 1, 3, 4, 4, 5, 1]\n    );\n    assert_eq!(\n        remove_kth_element(&vec![0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4], 4),\n        [0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]\n    );\n    assert_eq!(\n        remove_kth_element(&vec![10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10], 5),\n        [10, 10, 15, 19, 18, 17, 26, 26, 17, 18, 10]\n    );\n}\n\nverus! {\n\nfn remove_kth_element(list: &Vec<i32>, k: usize) -> (new_list: Vec<i32>)\n    requires\n        list.len() > 0,\n        0 < k < list@.len(),\n    ensures\n        new_list@ == list@.subrange(0, k - 1 as int).add(\n            list@.subrange(k as int, list.len() as int),\n        ),\n{\n    let mut new_list = Vec::new();\n    let mut index = 0;\n    while index < (k - 1)\n        invariant\n            0 <= index <= k - 1,\n            0 < k < list@.len(),\n            new_list@ =~= list@.subrange(0, index as int),\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    let mut index = k;\n    while index < list.len()\n        invariant\n            k <= index <= list.len(),\n            new_list@ =~= list@.subrange(0 as int, k - 1 as int).add(\n                list@.subrange(k as int, index as int),\n            ),\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    assert(new_list@ == list@.subrange(0, k - 1 as int).add(\n        list@.subrange(k as int, list.len() as int),\n    ));\n    new_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_610.rs", "solution_path": "MBPP/verified/task_id_610.rs"}
{"task_id": "mbpp_task_id_616", "source": "MBPP", "name": "task_id_616", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn element_wise_module(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] % arr2[i]) <= i32::MAX),\n    ensures\n        result@.len() == arr1@.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] % arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len() {\n        output_arr.push((arr1[index] % arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust which takes two integer arrays of the same length and performs the element wise modulo.\n\n    assert_eq!(\n        element_wise_module(&vec![10, 4, 5, 6], &vec![5, 6, 7, 5]),\n        [0, 4, 5, 1]\n    );\n    assert_eq!(\n        element_wise_module(&vec![11, 5, 6, 7], &vec![6, 7, 8, 6]),\n        [5, 5, 6, 1]\n    );\n    assert_eq!(\n        element_wise_module(&vec![12, 6, 7, 8], &vec![7, 8, 9, 7]),\n        [5, 6, 7, 1]\n    );\n}\n\nverus! {\n\nfn element_wise_module(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] % arr2[i]) <= i32::MAX),\n    ensures\n        result@.len() == arr1@.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] % arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] % arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] % arr2[k]),\n    {\n        output_arr.push((arr1[index] % arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_616.rs", "solution_path": "MBPP/verified/task_id_616.rs"}
{"task_id": "mbpp_task_id_618", "source": "MBPP", "name": "task_id_618", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn element_wise_divide(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] / arr2[i]) <= i32::MAX),\n    ensures\n        result@.len() == arr1@.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len() {\n        output_arr.push((arr1[index] / arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to divide two lists element wise.\n\n    assert_eq!(\n        element_wise_divide(&vec![4, 5, 6], &vec![1, 2, 3]),\n        [4, 2, 2]\n    );\n    assert_eq!(element_wise_divide(&vec![3, 4], &vec![3, 2]), [1, 2]);\n    assert_eq!(element_wise_divide(&vec![90, 120], &vec![30, 20]), [3, 6]);\n}\n\nverus! {\n\nfn element_wise_divide(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] / arr2[i]) <= i32::MAX),\n    ensures\n        result@.len() == arr1@.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] / arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] / arr2[k]),\n    {\n        output_arr.push((arr1[index] / arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_618.rs", "solution_path": "MBPP/verified/task_id_618.rs"}
{"task_id": "mbpp_task_id_62", "source": "MBPP", "name": "task_id_62", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn smallest_num(nums: &Vec<i32>) -> (min: i32)\n    requires\n        nums.len() > 0,\n    ensures\n        forall|i: int| 0 <= i < nums.len() ==> min <= nums[i],\n        exists|i: int| 0 <= i < nums.len() && min == nums[i],\n{\n    let mut min = nums[0];\n    let mut index = 1;\n\n    while index < nums.len() {\n        if nums[index] < min {\n            min = nums[index];\n        }\n        index += 1;\n    }\n    min\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find smallest number in a list.\n\n    assert_eq!(smallest_num(&vec![10, 20, 1, 45, 99]), 1);\n    assert_eq!(smallest_num(&vec![1, 2, 3]), 1);\n    assert_eq!(smallest_num(&vec![45, 46, 50, 60]), 45);\n}\n\nverus! {\n\nfn smallest_num(nums: &Vec<i32>) -> (min: i32)\n    requires\n        nums.len() > 0,\n    ensures\n        forall|i: int| 0 <= i < nums.len() ==> min <= nums[i],\n        exists|i: int| 0 <= i < nums.len() && min == nums[i],\n{\n    let mut min = nums[0];\n    let mut index = 1;\n\n    while index < nums.len()\n        invariant\n            0 <= index <= nums.len(),\n            forall|k: int| 0 <= k < index ==> min <= nums[k],\n            exists|k: int| 0 <= k < index && min == nums[k],\n    {\n        if nums[index] < min {\n            min = nums[index];\n        }\n        index += 1;\n    }\n    min\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_62.rs", "solution_path": "MBPP/verified/task_id_62.rs"}
{"task_id": "mbpp_task_id_624", "source": "MBPP", "name": "task_id_624", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn is_lower_case(c: u8) -> bool {\n    c >= 97 && c <= 122\n}\n\nspec fn shift_minus_32_spec(c: u8) -> u8 {\n    (c - 32) as u8\n}\n\nfn to_uppercase(str1: &[u8]) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> (result[i] == (if is_lower_case(#[trigger] str1[i]) {\n                shift_minus_32_spec(str1[i])\n            } else {\n                str1[i]\n            })),\n{\n    let mut upper_case: Vec<u8> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len() {\n        if (str1[index] >= 97 && str1[index] <= 122) {\n            upper_case.push((str1[index] - 32) as u8);\n        } else {\n            upper_case.push(str1[index]);\n        }\n        index += 1;\n    }\n    upper_case\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to convert a given string to uppercase.\n\n    assert_eq!(to_uppercase(b\"person\"), b\"PERSON\");\n    assert_eq!(to_uppercase(b\"final\"), b\"FINAL\");\n    assert_eq!(to_uppercase(b\"Valid\"), b\"VALID\");\n}\n\nverus! {\n\nspec fn is_lower_case(c: u8) -> bool {\n    c >= 97 && c <= 122\n}\n\nspec fn shift_minus_32_spec(c: u8) -> u8 {\n    (c - 32) as u8\n}\n\nfn to_uppercase(str1: &[u8]) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> (result[i] == (if is_lower_case(#[trigger] str1[i]) {\n                shift_minus_32_spec(str1[i])\n            } else {\n                str1[i]\n            })),\n{\n    let mut upper_case: Vec<u8> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            upper_case.len() == index,\n            forall|i: int|\n                0 <= i < index ==> (upper_case[i] == (if is_lower_case(#[trigger] str1[i]) {\n                    shift_minus_32_spec(str1[i])\n                } else {\n                    str1[i]\n                })),\n    {\n        if (str1[index] >= 97 && str1[index] <= 122) {\n            upper_case.push((str1[index] - 32) as u8);\n        } else {\n            upper_case.push(str1[index]);\n        }\n        assert(upper_case[index as int] == (if is_lower_case(str1[index as int]) {\n            shift_minus_32_spec(str1[index as int])\n        } else {\n            str1[index as int]\n        }));\n        index += 1;\n    }\n    assert(forall|i: int|\n        0 <= i < str1.len() ==> upper_case[i] == (if is_lower_case(#[trigger] str1[i]) {\n            shift_minus_32_spec(str1[i])\n        } else {\n            str1[i]\n        }));\n    upper_case\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_624.rs", "solution_path": "MBPP/verified/task_id_624.rs"}
{"task_id": "mbpp_task_id_629", "source": "MBPP", "name": "task_id_629", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn find_even_numbers(arr: &Vec<u32>) -> (even_numbers: Vec<u32>)\n    ensures\n        even_numbers@ == arr@.filter(|x: u32| x % 2 == 0),\n{\n    let mut even_numbers: Vec<u32> = Vec::new();\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] % 2 == 0) {\n            even_numbers.push(arr[index]);\n        }\n        index += 1;\n    }\n    even_numbers\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find even numbers from a list of numbers.\n\n    assert_eq!(find_even_numbers(&vec![1, 2, 3, 4, 5]), [2, 4]);\n    assert_eq!(find_even_numbers(&vec![4, 5, 6, 7, 8, 0, 1]), [4, 6, 8, 0]);\n    assert_eq!(find_even_numbers(&vec![8, 12, 15, 19]), [8, 12]);\n}\n\nverus! {\n\nfn find_even_numbers(arr: &Vec<u32>) -> (even_numbers: Vec<u32>)\n    ensures\n        even_numbers@ == arr@.filter(|x: u32| x % 2 == 0),\n{\n    let mut even_numbers: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: u32| x % 2 == 0) == Seq::<u32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            even_numbers@ == arr@.take(index as int).filter(|x: u32| x % 2 == 0),\n    {\n        if (arr[index] % 2 == 0) {\n            even_numbers.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    even_numbers\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_629.rs", "solution_path": "MBPP/verified/task_id_629.rs"}
{"task_id": "mbpp_task_id_644", "source": "MBPP", "name": "task_id_644", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nfn reverse_to_k(list: &Vec<i32>, n: usize) -> (reversed_list: Vec<i32>)\n    requires\n        list@.len() > 0,\n        0 < n < list@.len(),\n    ensures\n        reversed_list@ == list@.subrange(0, n as int).reverse().add(\n            list@.subrange(n as int, list.len() as int),\n        ),\n{\n    let mut reversed_list = Vec::new();\n    let mut index = 0;\n    while index < n {\n        reversed_list.push(list[n - 1 - index]);\n        index += 1;\n    }\n    index = n;\n    while index < list.len() {\n        reversed_list.push(list[index]);\n        index += 1;\n    }\n    reversed_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\nfn main() {\n    //Write a function in Rust to reverse an array upto a given position.\n\n    assert_eq!(reverse_to_k(&vec![1, 2, 3, 4, 5, 6], 4), [4, 3, 2, 1, 5, 6]);\n    assert_eq!(reverse_to_k(&vec![4, 5, 6, 7], 2), [5, 4, 6, 7]);\n    assert_eq!(reverse_to_k(&vec![9, 8, 7, 6, 5], 3), [7, 8, 9, 6, 5]);\n}\n\nverus! {\n\nfn reverse_to_k(list: &Vec<i32>, n: usize) -> (reversed_list: Vec<i32>)\n    requires\n        list@.len() > 0,\n        0 < n < list@.len(),\n    ensures\n        reversed_list@ == list@.subrange(0, n as int).reverse().add(\n            list@.subrange(n as int, list.len() as int),\n        ),\n{\n    let mut reversed_list = Vec::new();\n    let mut index = 0;\n    while index < n\n        invariant\n            0 < n < list@.len(),\n            0 <= index <= n,\n            reversed_list.len() == index,\n            forall|k: int| 0 <= k < index ==> reversed_list[k] == list[n - 1 - k],\n    {\n        reversed_list.push(list[n - 1 - index]);\n        index += 1;\n    }\n    index = n;\n    while index < list.len()\n        invariant\n            n <= index <= list.len(),\n            reversed_list@ =~= list@.subrange(0, n as int).reverse().add(\n                list@.subrange(n as int, index as int),\n            ),\n    {\n        reversed_list.push(list[index]);\n        index += 1;\n    }\n    reversed_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_644.rs", "solution_path": "MBPP/verified/task_id_644.rs"}
{"task_id": "mbpp_task_id_69", "source": "MBPP", "name": "task_id_69", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn is_sub_list_at_index(main: &Vec<i32>, sub: &Vec<i32>, idx: usize) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n        0 <= idx <= (main.len() - sub.len()),\n    ensures\n        result == (main@.subrange(idx as int, (idx + sub@.len())) =~= sub@),\n{\n    let mut i = 0;\n    while i < sub.len() {\n        if (main[idx + i] != sub[i]) {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn is_sub_list(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n    ensures\n        result == (exists|k: int, l: int|\n            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(\n                k,\n                l,\n            ))) =~= sub@),\n{\n    if sub.len() > main.len() {\n        return false;\n    }\n    let mut index = 0;\n    while index <= (main.len() - sub.len()) {\n        if (is_sub_list_at_index(&main, &sub, index)) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether a list contains the given sublist or not.\n\n    assert!(!is_sub_list(&vec![2, 4, 3, 5, 7], &vec![3, 7]));\n    assert!(is_sub_list(&vec![2, 4, 3, 5, 7], &vec![4, 3]));\n    assert!(!is_sub_list(&vec![2, 4, 3, 5, 7], &vec![1, 6]));\n}\n\nverus! {\n\nfn is_sub_list_at_index(main: &Vec<i32>, sub: &Vec<i32>, idx: usize) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n        0 <= idx <= (main.len() - sub.len()),\n    ensures\n        result == (main@.subrange(idx as int, (idx + sub@.len())) =~= sub@),\n{\n    let mut i = 0;\n    while i < sub.len()\n        invariant\n            0 <= idx <= (main.len() - sub.len()),\n            0 <= i <= sub.len(),\n            0 <= idx + i <= main.len(),\n            forall|k: int| 0 <= k < i ==> main[idx + k] == sub[k],\n            forall|k: int|\n                0 <= k < i ==> (main@.subrange(idx as int, (idx + k)) =~= sub@.subrange(0, k)),\n    {\n        if (main[idx + i] != sub[i]) {\n            assert(exists|k: int| 0 <= k < i ==> main[idx + k] != sub[k]);\n            assert(main@.subrange(idx as int, (idx + sub@.len())) != sub@);\n            return false;\n        }\n        i += 1;\n    }\n    assert(main@.subrange(idx as int, (idx + sub@.len())) == sub@);\n    true\n}\n\nfn is_sub_list(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n    ensures\n        result == (exists|k: int, l: int|\n            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(\n                k,\n                l,\n            ))) =~= sub@),\n{\n    if sub.len() > main.len() {\n        return false;\n    }\n    let mut index = 0;\n    while index <= (main.len() - sub.len())\n        invariant\n            sub.len() <= main.len(),\n            0 <= index <= (main.len() - sub.len()) + 1,\n            forall|k: int, l: int|\n                (0 <= k < index) && l == k + sub.len() ==> (#[trigger] (main@.subrange(k, l))\n                    != sub@),\n    {\n        if (is_sub_list_at_index(&main, &sub, index)) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_69.rs", "solution_path": "MBPP/verified/task_id_69.rs"}
{"task_id": "mbpp_task_id_70", "source": "MBPP", "name": "task_id_70", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn all_sequence_equal_length(seq: &Vec<Vec<i32>>) -> (result: bool)\n    requires\n        seq.len() > 0,\n    ensures\n        result == (forall|i: int, j: int|\n            (0 <= i < seq.len() && 0 <= j < seq.len()) ==> (#[trigger] seq[i].len()\n                == #[trigger] seq[j].len())),\n{\n    let mut index = 1;\n    while index < seq.len() {\n        if ((&seq[index]).len() != (&seq[0]).len()) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find whether all the given list of sequences have equal length or not.\n\n    assert!(all_sequence_equal_length(\n        &(vec![vec![11, 22, 33], vec![44, 55, 66]])\n    ));\n    assert!(!all_sequence_equal_length(\n        &(vec![vec![1, 2, 3], vec![4, 5, 6, 7]])\n    ));\n    assert!(all_sequence_equal_length(&(vec![vec![1, 2], vec![3, 4]])));\n}\n\nverus! {\n\nfn all_sequence_equal_length(seq: &Vec<Vec<i32>>) -> (result: bool)\n    requires\n        seq.len() > 0,\n    ensures\n        result == (forall|i: int, j: int|\n            (0 <= i < seq.len() && 0 <= j < seq.len()) ==> (#[trigger] seq[i].len()\n                == #[trigger] seq[j].len())),\n{\n    let mut index = 1;\n    while index < seq.len()\n        invariant\n            1 <= index <= seq.len(),\n            forall|k: int| 0 <= k < index ==> (#[trigger] seq[k].len() == (&seq[0]).len()),\n    {\n        if ((&seq[index]).len() != (&seq[0]).len()) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_70.rs", "solution_path": "MBPP/verified/task_id_70.rs"}
{"task_id": "mbpp_task_id_728", "source": "MBPP", "name": "task_id_728", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn add_list(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] + arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] + arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len() {\n        output_arr.push((arr1[index] + arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n\n    assert_eq!(add_list(&vec![10, 20, 30], &vec![15, 25, 35]), [25, 45, 65]);\n    assert_eq!(add_list(&vec![1, 2, 3], &vec![5, 6, 7]), [6, 8, 10]);\n    assert_eq!(\n        add_list(&vec![15, 20, 30], &vec![15, 45, 75]),\n        [30, 65, 105]\n    );\n}\n\nverus! {\n\nfn add_list(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] + arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] + arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] + arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] + arr2[k]),\n    {\n        output_arr.push((arr1[index] + arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_728.rs", "solution_path": "MBPP/verified/task_id_728.rs"}
{"task_id": "mbpp_task_id_732", "source": "MBPP", "name": "task_id_732", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn is_space_comma_dot_spec(c: u8) -> bool {\n    (c == 32) || (c == 44) || (c == 46)\n}\n\nfn replace_with_colon(str1: &[u8]) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|k: int|\n            0 <= k < result.len() ==> #[trigger] result[k] == (if is_space_comma_dot_spec(str1[k]) {\n                58\n            } else {\n                str1[k]\n            }),\n{\n    let mut result: Vec<u8> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len() {\n        if ((str1[index] == 32) || (str1[index] == 44) || (str1[index] == 46)) {\n            result.push(58);\n        } else {\n            result.push(str1[index]);\n        }\n        index += 1;\n    }\n    result\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to replace all occurrences of spaces, commas or dots with a colon.\n\n    assert_eq!(\n        replace_with_colon(b\"Python language, Programming language.\"),\n        b\"Python:language::Programming:language:\"\n    );\n    assert_eq!(replace_with_colon(b\"a b c,d e f\"), b\"a:b:c:d:e:f\");\n    assert_eq!(\n        replace_with_colon(b\"ram reshma,ram rahim\"),\n        b\"ram:reshma:ram:rahim\"\n    );\n}\n\nverus! {\n\n// ASCII --> space=32, comma=44 , dot=46 , colon=58\nspec fn is_space_comma_dot_spec(c: u8) -> bool {\n    (c == 32) || (c == 44) || (c == 46)\n}\n\nfn replace_with_colon(str1: &[u8]) -> (result: Vec<u8>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|k: int|\n            0 <= k < result.len() ==> #[trigger] result[k] == (if is_space_comma_dot_spec(str1[k]) {\n                58  //ASCII -> colon=58\n\n            } else {\n                str1[k]\n            }),\n{\n    let mut result: Vec<u8> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            result@.len() == index,\n            forall|k: int|\n                0 <= k < index ==> #[trigger] result[k] == (if is_space_comma_dot_spec(str1[k]) {\n                    58  //ASCII -> colon=58\n\n                } else {\n                    str1[k]\n                }),\n    {\n        if ((str1[index] == 32) || (str1[index] == 44) || (str1[index] == 46)) {\n            result.push(58);  //ASCII -> colon=58\n        } else {\n            result.push(str1[index]);\n        }\n        index += 1;\n    }\n    result\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_732.rs", "solution_path": "MBPP/verified/task_id_732.rs"}
{"task_id": "mbpp_task_id_733", "source": "MBPP", "name": "task_id_733", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn find_first_occurrence(arr: &Vec<i32>, target: i32) -> (index: Option<usize>)\n    requires\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],\n    ensures\n        if let Some(idx) = index {\n            &&& 0 <= idx < arr.len()\n            &&& forall|k: int| 0 <= k < idx ==> arr[k] != target\n            &&& arr[idx as int] == target\n        } else {\n            forall|k: int| 0 <= k < arr.len() ==> arr[k] != target\n        },\n{\n    let mut index = 0;\n    while index < arr.len() {\n        if arr[index] == target {\n            return Some(index);\n        }\n        index += 1;\n    }\n    None\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the index of the first occurrence of a given number in a sorted array.\n\n    assert_eq!(\n        find_first_occurrence(&vec![2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5),\n        Some(1)\n    );\n    assert_eq!(\n        find_first_occurrence(&vec![2, 3, 5, 5, 6, 6, 8, 9, 9, 9], 5),\n        Some(2)\n    );\n    assert_eq!(\n        find_first_occurrence(&vec![2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 6),\n        Some(4)\n    );\n    assert_eq!(\n        find_first_occurrence(&vec![2, 4, 1, 5, 6, 6, 8, 9, 9, 9], 10),\n        None\n    );\n}\n\nverus! {\n\nfn find_first_occurrence(arr: &Vec<i32>, target: i32) -> (index: Option<usize>)\n    requires\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],\n    ensures\n        if let Some(idx) = index {\n            &&& 0 <= idx < arr.len()\n            &&& forall|k: int| 0 <= k < idx ==> arr[k] != target\n            &&& arr[idx as int] == target\n        } else {\n            forall|k: int| 0 <= k < arr.len() ==> arr[k] != target\n        },\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            forall|k: int| 0 <= k < index ==> arr[k] != target,\n    {\n        if arr[index] == target {\n            return Some(index);\n        }\n        index += 1;\n    }\n    None\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_733.rs", "solution_path": "MBPP/verified/task_id_733.rs"}
{"task_id": "mbpp_task_id_741", "source": "MBPP", "name": "task_id_741", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn all_characters_same(char_arr: &[u8]) -> (result: bool)\n    ensures\n        result == (forall|i: int|\n            1 <= i < char_arr@.len() ==> char_arr[0] == #[trigger] char_arr[i]),\n{\n    if char_arr.len() <= 1 {\n        return true;\n    }\n    let mut index = 1;\n    while index < char_arr.len() {\n        if char_arr[0] != char_arr[index] {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether all the characters are same or not.\n\n    assert!(!all_characters_same(b\"python\"));\n    assert!(all_characters_same(b\"aaa\"));\n    assert!(!all_characters_same(b\"data\"));\n}\n\nverus! {\n\nfn all_characters_same(char_arr: &[u8]) -> (result: bool)\n    ensures\n        result == (forall|i: int|\n            1 <= i < char_arr@.len() ==> char_arr[0] == #[trigger] char_arr[i]),\n{\n    if char_arr.len() <= 1 {\n        return true;\n    }\n    let mut index = 1;\n    while index < char_arr.len()\n        invariant\n            1 <= index <= char_arr.len(),\n            forall|k: int| 0 <= k < index ==> char_arr[0] == #[trigger] char_arr[k],\n    {\n        if char_arr[0] != char_arr[index] {\n            assert(exists|i: int|\n                1 <= i < char_arr@.len() && char_arr[0] != #[trigger] char_arr[i]);\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_741.rs", "solution_path": "MBPP/verified/task_id_741.rs"}
{"task_id": "mbpp_task_id_743", "source": "MBPP", "name": "task_id_743", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nspec fn rotation_split(len: usize, n: usize) -> int {\n    len - (n % len)\n}\n\nfn rotate_right(list: &Vec<u32>, n: usize) -> (new_list: Vec<u32>)\n    requires\n        list.len() > 0,\n    ensures\n        new_list.len() == list.len(),\n        new_list@ == list@.subrange(rotation_split(list.len(), n) as int, list@.len() as int).add(\n            list@.subrange(0, rotation_split(list.len(), n) as int),\n        ),\n{\n    let rotation = n % list.len();\n    let split_index = list.len() - rotation;\n    let mut new_list = Vec::with_capacity(list.len());\n    let mut index = split_index;\n\n    while index < list.len() {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    index = 0;\n    while index < split_index {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    new_list\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\nfn main() {\n    //Write a method in Rust to rotate a given list by specified N number of items to the right direction.\n\n    assert_eq!(\n        rotate_right(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3),\n        [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n    );\n    assert_eq!(\n        rotate_right(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2),\n        [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n    );\n    assert_eq!(\n        rotate_right(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5),\n        [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]\n    );\n}\n\nverus! {\n\nspec fn rotation_split(len: usize, n: usize) -> int {\n    len - (n % len)\n}\n\nfn rotate_right(list: &Vec<u32>, n: usize) -> (new_list: Vec<u32>)\n    requires\n        list.len() > 0,\n    ensures\n        new_list.len() == list.len(),\n        new_list@ == list@.subrange(rotation_split(list.len(), n) as int, list@.len() as int).add(\n            list@.subrange(0, rotation_split(list.len(), n) as int),\n        ),\n{\n    let rotation = n % list.len();\n    let split_index = list.len() - rotation;\n\n    let mut new_list = Vec::with_capacity(list.len());\n\n    let mut index = split_index;\n\n    while index < list.len()\n        invariant\n            split_index <= index <= list.len(),\n            list@.subrange(split_index as int, index as int) =~= new_list@,\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    index = 0;\n    while index < split_index\n        invariant\n            0 <= split_index <= list@.len(),\n            0 <= index <= split_index,\n            new_list@ =~= list@.subrange(split_index as int, list@.len() as int).add(\n                list@.subrange(0, index as int),\n            ),\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    assert(new_list@ =~= list@.subrange(split_index as int, list@.len() as int).add(\n        list@.subrange(0, split_index as int),\n    ));\n    new_list\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_743.rs", "solution_path": "MBPP/verified/task_id_743.rs"}
{"task_id": "mbpp_task_id_755", "source": "MBPP", "name": "task_id_755", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nspec fn min_spec(seq: Seq<i32>) -> int\n    recommends\n        0 < seq.len(),\n    decreases seq.len(),\n{\n    if seq.len() == 1 {\n        seq[0] as int\n    } else if seq.len() == 0 {\n        0\n    } else {\n        let later_min = min_spec(seq.drop_first());\n        if seq[0] <= later_min {\n            seq[0] as int\n        } else {\n            later_min as int\n        }\n    }\n}\n\nfn second_smallest(numbers: &Vec<i32>) -> (indices: (usize, usize))\n    requires\n        numbers.len() >= 2,\n    ensures\n        forall|k: int|\n            0 <= k < numbers.len() && k != indices.0 && numbers[indices.0 as int] == min_spec(\n                numbers@,\n            ) ==> (#[trigger] numbers[k] >= numbers[indices.1 as int]),\n        exists|k: int|\n            0 <= k < numbers.len() && k != indices.0 && (#[trigger] numbers[k]\n                == numbers[indices.1 as int]),\n{\n    let mut min_index: usize = 0;\n    let mut second_min_index: usize = 1;\n\n    if numbers[1] < numbers[0] {\n        min_index = 1;\n        second_min_index = 0;\n    }\n    let mut index = 2;\n    while index < numbers.len() {\n        if numbers[index] < numbers[min_index] {\n            second_min_index = min_index;\n            min_index = index;\n        } else if numbers[index] < numbers[second_min_index] {\n            second_min_index = index;\n        }\n        index += 1;\n    }\n    (min_index, second_min_index)\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\nfn main() {\n    // Write a function to find the second smallest number in a list.\n    // change the signatue to return -> (min_index, second_min_index)\n    assert_eq!(second_smallest(&vec![1, 2, -8, -2, 0, -2]), (2, 3));\n    assert_eq!(second_smallest(&vec![2, 2, 1]), (2, 0));\n    assert_eq!(second_smallest(&vec![-2, -3, -2]), (1, 0));\n    assert_eq!(second_smallest(&vec![-2, -2, -2]), (0, 1));\n}\n\nverus! {\n\nspec fn min_spec(seq: Seq<i32>) -> int\n    recommends\n        0 < seq.len(),\n    decreases seq.len(),\n{\n    if seq.len() == 1 {\n        seq[0] as int\n    } else if seq.len() == 0 {\n        0\n    } else {\n        let later_min = min_spec(seq.drop_first());\n        if seq[0] <= later_min {\n            seq[0] as int\n        } else {\n            later_min as int\n        }\n    }\n}\n\n// change the signatue to return -> (min_index, second_min_index)\nfn second_smallest(numbers: &Vec<i32>) -> (indices: (\n    usize,\n    usize,\n))  //(min_index, second_min_index)\n    requires\n        numbers.len()\n            >= 2,  // There must be at least 2 different values, a minimum and another one\n\n    ensures\n        forall|k: int|\n            0 <= k < numbers.len() && k != indices.0 && numbers[indices.0 as int] == min_spec(\n                numbers@,\n            ) ==> (#[trigger] numbers[k] >= numbers[indices.1 as int]),\n        exists|k: int|\n            0 <= k < numbers.len() && k != indices.0 && (#[trigger] numbers[k]\n                == numbers[indices.1 as int]),\n{\n    let mut min_index: usize = 0;\n    let mut second_min_index: usize = 1;\n\n    if numbers[1] < numbers[0] {\n        min_index = 1;\n        second_min_index = 0;\n    }\n    let mut index = 2;\n    while index < numbers.len()\n        invariant\n            0 <= index <= numbers.len(),\n            0 <= min_index < index,\n            0 <= second_min_index < index,\n            min_index != second_min_index,\n            forall|k: int| 0 <= k < index ==> numbers[k] >= numbers[min_index as int],\n            forall|k: int|\n                0 <= k < index && k != min_index ==> numbers[k] >= numbers[second_min_index as int],\n    {\n        if numbers[index] < numbers[min_index] {\n            second_min_index = min_index;\n            min_index = index;\n        } else if numbers[index] < numbers[second_min_index] {\n            second_min_index = index;\n        }\n        index += 1;\n        assert(forall|k: int|\n            0 <= k < index && k != min_index ==> numbers[k] >= numbers[second_min_index as int]);\n    }\n    assert(forall|k: int|\n        0 <= k < index && k != min_index ==> numbers[k] >= numbers[second_min_index as int]);\n    assert(forall|k: int|\n        0 <= k < numbers.len() && k != min_index && numbers[min_index as int] == min_spec(numbers@)\n            ==> (numbers[k] >= numbers[second_min_index as int]));\n    (min_index, second_min_index)\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_755.rs", "solution_path": "MBPP/verified/task_id_755.rs"}
{"task_id": "mbpp_task_id_760", "source": "MBPP", "name": "task_id_760", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn has_only_one_distinct_element(arr: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 1 <= i < arr@.len() ==> arr[0] == #[trigger] arr[i]),\n{\n    if arr.len() <= 1 {\n        return true;\n    }\n    let mut index = 1;\n    while index < arr.len() {\n        if arr[0] != arr[index] {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether a list of numbers contains only one distinct element or not.\n\n    assert!(has_only_one_distinct_element(&vec![1, 1, 1]));\n    assert!(!has_only_one_distinct_element(&vec![1, 2, 1, 2]));\n    assert!(!has_only_one_distinct_element(&vec![1, 2, 3, 4, 5]));\n}\n\nverus! {\n\nfn has_only_one_distinct_element(arr: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 1 <= i < arr@.len() ==> arr[0] == #[trigger] arr[i]),\n{\n    if arr.len() <= 1 {\n        return true;\n    }\n    let mut index = 1;\n    while index < arr.len()\n        invariant\n            1 <= index <= arr.len(),\n            forall|k: int| 0 <= k < index ==> arr[0] == #[trigger] arr[k],\n    {\n        if arr[0] != arr[index] {\n            assert(exists|i: int| 1 <= i < arr@.len() && arr[0] != #[trigger] arr[i]);\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_760.rs", "solution_path": "MBPP/verified/task_id_760.rs"}
{"task_id": "mbpp_task_id_764", "source": "MBPP", "name": "task_id_764", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn is_digit(c: u8) -> bool {\n    (c >= 48 && c <= 57)\n}\n\nspec fn count_digits_recursively(seq: Seq<u8>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_digits_recursively(seq.drop_last()) + if is_digit(seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_digits(text: &[u8]) -> (count: usize)\n    ensures\n        0 <= count <= text.len(),\n        count_digits_recursively(text@) == count,\n{\n    let mut count = 0;\n    let mut index = 0;\n\n    while index < text.len() {\n        if (text[index] >= 48 && text[index] <= 57) {\n            count += 1;\n        }\n        index += 1;\n    }\n    count\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to count number of digits in a given string.\n\n    assert_eq!(count_digits(b\"program2bedone\"), 1);\n    assert_eq!(count_digits(b\"3wonders\"), 1);\n    assert_eq!(count_digits(b\"123\"), 3);\n    assert_eq!(count_digits(b\"3wond-1ers2\"), 3);\n}\n\nverus! {\n\nspec fn is_digit(c: u8) -> bool {\n    (c >= 48 && c <= 57)\n}\n\nspec fn count_digits_recursively(seq: Seq<u8>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_digits_recursively(seq.drop_last()) + if is_digit(seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_digits(text: &[u8]) -> (count: usize)\n    ensures\n        0 <= count <= text.len(),\n        count_digits_recursively(text@) == count,\n{\n    let mut count = 0;\n    let mut index = 0;\n\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            0 <= count <= index,\n            count == count_digits_recursively(text@.subrange(0, index as int)),\n    {\n        if (text[index] >= 48 && text[index] <= 57) {\n            count += 1;\n        }\n        index += 1;\n        assert(text@.subrange(0, index - 1 as int) == text@.subrange(0, index as int).drop_last());\n    }\n    assert(text@ == text@.subrange(0, index as int));\n    count\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_764.rs", "solution_path": "MBPP/verified/task_id_764.rs"}
{"task_id": "mbpp_task_id_769", "source": "MBPP", "name": "task_id_769", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] == key) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn difference(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                arr1[i],\n            )),\n        forall|i: int|\n            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                arr2[i],\n            )),\n        forall|i: int, j: int|\n            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],\n{\n    let mut result = Vec::new();\n\n    let mut index = 0;\n    while index < arr1.len() {\n        if (!contains(arr2, arr1[index]) && !contains(&result, arr1[index])) {\n            result.push(arr1[index]);\n        }\n        index += 1;\n    }\n    index = 0;\n    while index < arr2.len() {\n        if (!contains(arr1, arr2[index]) && !contains(&result, arr2[index])) {\n            result.push(arr2[index]);\n        }\n        index += 1;\n    }\n    result\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to get the difference between two lists.\n\n    assert_eq!(\n        difference(&vec![10, 15, 20, 25, 30, 35, 40], &vec![25, 40, 35]),\n        [10, 15, 20, 30]\n    );\n    assert_eq!(\n        difference(&vec![1, 2, 3, 4, 5], &vec![6, 7, 1]),\n        [2, 3, 4, 5, 6, 7]\n    );\n    assert_eq!(difference(&vec![1, 2, 3], &vec![6, 7, 1]), [2, 3, 6, 7]);\n}\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            forall|m: int| 0 <= m < index ==> (arr[m] != key),\n    {\n        if (arr[index] == key) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn difference(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                arr1[i],\n            )),\n        forall|i: int|\n            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                arr2[i],\n            )),\n        forall|i: int, j: int|\n            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],\n{\n    let mut result = Vec::new();\n    let ghost mut output_len: int = 0;\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            forall|i: int|\n                0 <= i < index ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                    arr1[i],\n                )),\n            forall|m: int, n: int|\n                0 <= m < n < result.len() ==> #[trigger] result[m] != #[trigger] result[n],\n    {\n        if (!contains(arr2, arr1[index]) && !contains(&result, arr1[index])) {\n            proof {\n                lemma_vec_push(result@, arr1[index as int], result.len());\n                output_len = output_len + 1;\n            }\n            result.push(arr1[index]);\n        }\n        index += 1;\n    }\n    index = 0;\n    while index < arr2.len()\n        invariant\n            forall|i: int|\n                0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                    arr1[i],\n                )),\n            forall|i: int|\n                0 <= i < index ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                    arr2[i],\n                )),\n            forall|m: int, n: int|\n                0 <= m < n < result.len() ==> #[trigger] result[m] != #[trigger] result[n],\n    {\n        if (!contains(arr1, arr2[index]) && !contains(&result, arr2[index])) {\n            proof {\n                lemma_vec_push(result@, arr2[index as int], result.len());\n                output_len = output_len + 1;\n            }\n            result.push(arr2[index]);\n        }\n        index += 1;\n    }\n    assert(forall|i: int|\n        0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n            arr1[i],\n        )));\n    assert(forall|i: int|\n        0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n            arr2[i],\n        )));\n    assert(forall|i: int, j: int|\n        0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j]);\n    result\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_769.rs", "solution_path": "MBPP/verified/task_id_769.rs"}
{"task_id": "mbpp_task_id_775", "source": "MBPP", "name": "task_id_775", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn is_odd_at_odd_index(arr: &Vec<usize>) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),\n{\n    let mut index = 0;\n    while index < arr.len() {\n        if ((index % 2) != (arr[index] % 2)) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether every odd index contains odd numbers of a given list.\n\n    assert!(is_odd_at_odd_index(&vec![2, 1, 4, 3, 6, 7, 6, 3]));\n    assert!(is_odd_at_odd_index(&vec![4, 1, 2]));\n    assert!(!is_odd_at_odd_index(&vec![1, 2, 3]));\n}\n\nverus! {\n\nfn is_odd_at_odd_index(arr: &Vec<usize>) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|i: int| 0 <= i < index ==> ((i % 2) == (arr[i] % 2)),\n    {\n        if ((index % 2) != (arr[index] % 2)) {\n            assert(((index as int) % 2) != (arr[index as int] % 2));\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_775.rs", "solution_path": "MBPP/verified/task_id_775.rs"}
{"task_id": "mbpp_task_id_790", "source": "MBPP", "name": "task_id_790", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn is_even_at_even_index(arr: &Vec<usize>) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),\n{\n    let mut index = 0;\n    while index < arr.len() {\n        if ((index % 2) != (arr[index] % 2)) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check whether every even index contains even numbers of a given list.\n\n    assert!(!is_even_at_even_index(&vec![3, 2, 1]));\n    assert!(!is_even_at_even_index(&vec![1, 2, 3]));\n    assert!(is_even_at_even_index(&vec![2, 1, 4]));\n}\n\nverus! {\n\nfn is_even_at_even_index(arr: &Vec<usize>) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|i: int| 0 <= i < index ==> ((i % 2) == (arr[i] % 2)),\n    {\n        if ((index % 2) != (arr[index] % 2)) {\n            assert(((index as int) % 2) != (arr[index as int] % 2));\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_790.rs", "solution_path": "MBPP/verified/task_id_790.rs"}
{"task_id": "mbpp_task_id_798", "source": "MBPP", "name": "task_id_798", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn sum_to(arr: Seq<i64>) -> int\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        sum_to(arr.drop_last()) + arr.last()\n    }\n}\n\nfn sum(arr: &Vec<i64>) -> (sum: i128)\n    ensures\n        sum_to(arr@) == sum,\n{\n    let mut index = 0;\n    let mut sum = 0i128;\n\n    while index < arr.len() {\n        sum = sum + arr[index] as i128;\n        index += 1;\n    }\n    sum\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the sum of an array.\n\n    assert_eq!(sum(&vec![1, 2, 3]), 6);\n    assert_eq!(sum(&vec![15, 12, 13, 10]), 50);\n    assert_eq!(sum(&vec![0, 1, 2]), 3);\n}\n\nverus! {\n\nspec fn sum_to(arr: Seq<i64>) -> int\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        sum_to(arr.drop_last()) + arr.last()\n    }\n}\n\nfn sum(arr: &Vec<i64>) -> (sum: i128)\n    ensures\n        sum_to(arr@) == sum,\n{\n    let mut index = 0;\n    let mut sum = 0i128;\n\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            sum == sum_to(arr@.subrange(0, index as int)),\n            forall|j: int|\n                0 <= j <= index ==> (i64::MIN * index <= (sum_to(#[trigger] arr@.subrange(0, j)))\n                    <= i64::MAX * index),\n    {\n        assert(arr@.subrange(0, index as int) =~= arr@.subrange(0, (index + 1) as int).drop_last());\n        sum = sum + arr[index] as i128;\n        index += 1;\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    sum\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_798.rs", "solution_path": "MBPP/verified/task_id_798.rs"}
{"task_id": "mbpp_task_id_8", "source": "MBPP", "name": "task_id_8", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn square_nums(nums: &Vec<i32>) -> (squared: Vec<i32>)\n    requires\n        forall|k: int|\n            0 <= k < nums.len() ==> (0 <= #[trigger] nums[k] * #[trigger] nums[k] < i32::MAX),\n    ensures\n        nums.len() == squared.len(),\n        forall|k: int| 0 <= k < nums.len() ==> (#[trigger] squared[k] == nums[k] * nums[k]),\n{\n    let mut result: Vec<i32> = Vec::new();\n    let mut index = 0;\n\n    while index < nums.len() {\n        result.push(nums[index] * nums[index]);\n        index += 1;\n    }\n    result\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    //Write a function in Rust to find squares of individual elements in a list.\n\n    assert_eq!(\n        square_nums(&vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),\n        [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    );\n    assert_eq!(square_nums(&vec![10, 20, 30]), [100, 400, 900]);\n    assert_eq!(square_nums(&vec![12, 15]), [144, 225]);\n}\n\nverus! {\n\nfn square_nums(nums: &Vec<i32>) -> (squared: Vec<i32>)\n    requires\n        forall|k: int|\n            0 <= k < nums.len() ==> (0 <= #[trigger] nums[k] * #[trigger] nums[k] < i32::MAX),\n    ensures\n        nums.len() == squared.len(),\n        forall|k: int| 0 <= k < nums.len() ==> (#[trigger] squared[k] == nums[k] * nums[k]),\n{\n    let mut result: Vec<i32> = Vec::new();\n    let mut index = 0;\n\n    while index < nums.len()\n        invariant\n            0 <= index <= nums.len(),\n            result@.len() == index,\n            forall|k: int|\n                0 <= k < nums.len() ==> (0 <= #[trigger] nums[k] * #[trigger] nums[k] < i32::MAX),\n            forall|k: int| 0 <= k < index ==> (#[trigger] result[k] == nums[k] * nums[k]),\n    {\n        result.push(nums[index] * nums[index]);\n        index += 1\n    }\n    result\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_8.rs", "solution_path": "MBPP/verified/task_id_8.rs"}
{"task_id": "mbpp_task_id_804", "source": "MBPP", "name": "task_id_804", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nspec fn is_even(n: u32) -> bool {\n    (n % 2) == 0\n}\n\nfn is_product_even(arr: &Vec<u32>) -> (result: bool)\n    ensures\n        result <==> (exists|k: int| 0 <= k < arr.len() && is_even(#[trigger] arr[k])),\n{\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] % 2 == 0) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\nfn main() {\n    // Write a function in Rust to check whether the product of numbers in a list is even or not.\n    assert!(is_product_even(&vec![1, 2, 3]));\n    assert!(is_product_even(&vec![1, 2, 1, 4]));\n    assert!(!is_product_even(&vec![1, 1]));\n}\n\nverus! {\n\nspec fn is_even(n: u32) -> bool {\n    (n % 2) == 0\n}\n\nfn is_product_even(arr: &Vec<u32>) -> (result: bool)\n    ensures\n        result <==> (exists|k: int| 0 <= k < arr.len() && is_even(#[trigger] arr[k])),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|k: int| 0 <= k < index ==> !(is_even(#[trigger] arr[k])),\n    {\n        if (arr[index] % 2 == 0) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_804.rs", "solution_path": "MBPP/verified/task_id_804.rs"}
{"task_id": "mbpp_task_id_807", "source": "MBPP", "name": "task_id_807", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn find_first_odd(arr: &Vec<u32>) -> (index: Option<usize>)\n    ensures\n        if let Some(idx) = index {\n            &&& arr@.take(idx as int) == arr@.take(idx as int).filter(|x: u32| x % 2 == 0)\n            &&& arr[idx as int] % 2 != 0\n        } else {\n            forall|k: int| 0 <= k < arr.len() ==> (arr[k] % 2 == 0)\n        },\n{\n    let input_len = arr.len();\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] % 2 != 0) {\n            return Some(index);\n        }\n        index += 1;\n    }\n    None\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the first odd number in a given list of numbers.\n\n    assert_eq!(find_first_odd(&vec![]), None);\n    assert_eq!(find_first_odd(&vec![2, 4, 6, 8]), None);\n    assert_eq!(find_first_odd(&vec![1, 3, 5]), Some(0));\n    assert_eq!(find_first_odd(&vec![8, 9, 1]), Some(1));\n    assert_eq!(find_first_odd(&vec![2, 4, 1, 3]), Some(2));\n}\n\nverus! {\n\nfn find_first_odd(arr: &Vec<u32>) -> (index: Option<usize>)\n    ensures\n        if let Some(idx) = index {\n            &&& arr@.take(idx as int) == arr@.take(idx as int).filter(|x: u32| x % 2 == 0)\n            &&& arr[idx as int] % 2 != 0\n        } else {\n            forall|k: int| 0 <= k < arr.len() ==> (arr[k] % 2 == 0)\n        },\n{\n    let input_len = arr.len();\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            arr@.take(index as int) =~= arr@.take(index as int).filter(|x: u32| x % 2 == 0),\n    {\n        if (arr[index] % 2 != 0) {\n            return Some(index);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    None\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_807.rs", "solution_path": "MBPP/verified/task_id_807.rs"}
{"task_id": "mbpp_task_id_808", "source": "MBPP", "name": "task_id_808", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn contains_k(arr: &Vec<i32>, k: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == k)),\n{\n    let mut index = 0;\n    while index < arr.len() {\n        if (arr[index] == k) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check if the given sequence contain the k or not.\n\n    assert!(contains_k(&vec![10, 4, 5, 6, 8], 6));\n    assert!(!contains_k(&vec![1, 2, 3, 4, 5, 6], 7));\n    assert!(contains_k(&vec![7, 8, 9, 44, 11, 12], 11));\n}\n\nverus! {\n\nfn contains_k(arr: &Vec<i32>, k: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == k)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|m: int| 0 <= m < index ==> (arr[m] != k),\n    {\n        if (arr[index] == k) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_808.rs", "solution_path": "MBPP/verified/task_id_808.rs"}
{"task_id": "mbpp_task_id_809", "source": "MBPP", "name": "task_id_809", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn is_smaller(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)\n    requires\n        arr1.len() == arr2.len(),\n    ensures\n        result == (forall|i: int| 0 <= i < arr1.len() ==> arr1[i] > arr2[i]),\n{\n    let mut index = 0;\n    while index < arr1.len() {\n        if arr1[index] <= arr2[index] {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to check if each element of second sequence is smaller than its corresponding element in the first sequence.\n\n    assert!(!is_smaller(&vec![1, 2, 3], &vec![2, 3, 4]));\n    assert!(is_smaller(&vec![4, 5, 6], &vec![3, 4, 5]));\n    assert!(is_smaller(&vec![11, 12, 13], &vec![10, 11, 12]));\n}\n\nverus! {\n\nfn is_smaller(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)\n    requires\n        arr1.len() == arr2.len(),\n    ensures\n        result == (forall|i: int| 0 <= i < arr1.len() ==> arr1[i] > arr2[i]),\n{\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            0 <= index <= arr1.len(),\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            forall|k: int| 0 <= k < index ==> arr1[k] > arr2[k],\n    {\n        if arr1[index] <= arr2[index] {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_809.rs", "solution_path": "MBPP/verified/task_id_809.rs"}
{"task_id": "mbpp_task_id_94", "source": "MBPP", "name": "task_id_94", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn min_second_value_first(arr: &Vec<Vec<i32>>) -> (first_of_min_second: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() >= 2,\n    ensures\n        exists|i: int|\n            0 <= i < arr.len() && first_of_min_second == #[trigger] arr[i][0] && (forall|j: int|\n                0 <= j < arr.len() ==> (arr[i][1] <= #[trigger] arr[j][1])),\n{\n    let mut min_second_index = 0;\n    let mut index = 0;\n\n    while index < arr.len() {\n        if arr[index][1] < arr[min_second_index][1] {\n            min_second_index = index;\n        }\n        index += 1;\n    }\n    arr[min_second_index][0]\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    //Given a list of sequences, write a function in Rust that returns the first value of the sequence with the smallest second value.\n\n    assert_eq!(\n        min_second_value_first(&(vec![vec![1, 3], vec![5, 7], vec![9, 11], vec![13, 15]])),\n        1\n    );\n    assert_eq!(\n        min_second_value_first(&(vec![vec![1, 4], vec![5, 1], vec![9, 11], vec![13, 15]])),\n        5\n    );\n    assert_eq!(\n        min_second_value_first(&(vec![vec![1, 3], vec![5, 7], vec![9, -1], vec![13, 15]])),\n        9\n    );\n}\n\nverus! {\n\nfn min_second_value_first(arr: &Vec<Vec<i32>>) -> (first_of_min_second: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() >= 2,\n    ensures\n        exists|i: int|\n            0 <= i < arr.len() && first_of_min_second == #[trigger] arr[i][0] && (forall|j: int|\n                0 <= j < arr.len() ==> (arr[i][1] <= #[trigger] arr[j][1])),\n{\n    let mut min_second_index = 0;\n    let mut index = 0;\n\n    while index < arr.len()\n        invariant\n            0 <= min_second_index < arr.len(),\n            forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() >= 2,\n            forall|k: int|\n                0 <= k < index ==> (arr[min_second_index as int][1] <= #[trigger] arr[k][1]),\n    {\n        assert(arr[index as int].len() > 0);\n        assert(arr[min_second_index as int].len() > 0);\n\n        if arr[index][1] < arr[min_second_index][1] {\n            min_second_index = index;\n        }\n        index += 1;\n    }\n    assert(arr[min_second_index as int].len() > 0);\n    arr[min_second_index][0]\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_94.rs", "solution_path": "MBPP/verified/task_id_94.rs"}
{"task_id": "mbpp_task_id_95", "source": "MBPP", "name": "task_id_95", "task": "use vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nfn smallest_list_length(list: &Vec<Vec<i32>>) -> (min: usize)\n    requires\n        list.len() > 0,\n    ensures\n        min >= 0,\n        forall|i: int| 0 <= i < list.len() ==> min <= #[trigger] list[i].len(),\n        exists|i: int| 0 <= i < list.len() && min == #[trigger] list[i].len(),\n{\n    let mut min = list[0].len();\n    let mut index = 1;\n    while index < list.len() {\n        if (&list[index]).len() < min {\n            min = (&list[index]).len();\n        }\n        index += 1;\n    }\n    min\n}\n\n} // verus!\n", "ground_truth": "use vstd::prelude::*;\n\nfn main() {\n    // Write a function in Rust to find the length of the smallest list in a list of lists.\n\n    assert_eq!(smallest_list_length(&(vec![vec![1], vec![1, 2]])), 1);\n    assert_eq!(\n        smallest_list_length(&(vec![vec![1, 2], vec![1, 2, 3], vec![1, 2, 3, 4]])),\n        2\n    );\n    assert_eq!(\n        smallest_list_length(&(vec![vec![3, 3, 3], vec![4, 4, 4, 4]])),\n        3\n    );\n}\n\nverus! {\n\nfn smallest_list_length(list: &Vec<Vec<i32>>) -> (min: usize)\n    requires\n        list.len() > 0,\n    ensures\n        min >= 0,\n        forall|i: int| 0 <= i < list.len() ==> min <= #[trigger] list[i].len(),\n        exists|i: int| 0 <= i < list.len() && min == #[trigger] list[i].len(),\n{\n    let mut min = list[0].len();\n\n    let mut index = 1;\n    while index < list.len()\n        invariant\n            0 <= index <= list.len(),\n            forall|k: int| 0 <= k < index ==> min <= #[trigger] list[k].len(),\n            exists|k: int| 0 <= k < index && min == #[trigger] list[k].len(),\n    {\n        if (&list[index]).len() < min {\n            min = (&list[index]).len();\n        }\n        index += 1;\n    }\n    min\n}\n\n} // verus!\n", "task_path": "MBPP/unverified/task_id_95.rs", "solution_path": "MBPP/verified/task_id_95.rs"}
{"task_id": "diffy_brs1", "source": "Diffy", "name": "brs1", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\tensures\n\t\tsum[0] <= N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (i % 1 == 0) {\n\t\t\ta.set(i, 1);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n    requires\n        N > 0,\n        old(a).len() == N,\n        old(sum).len() == 1,\n    ensures\n        sum[0] <= N,\n{\n    let mut i: usize = 0;\n    while (i < N as usize)\n        invariant\n            a.len() == N,\n            forall |k:int| 0 <= k < i ==> a[k] == 1,\n    {\n        if (i % 1 == 0) {\n            a.set(i, 1);\n        } else {\n            a.set(i, 0);\n        }\n        i = i + 1;\n    }\n\n    i = 0;\n    while (i < N as usize)\n        invariant\n            i <= N as usize,\n            sum.len() == 1,\n            a.len() == N,\n            i > 0 ==> sum[0] <= i,\n            forall |k:int| 0 <= k < N ==> a[k] == 1,\n    {\n        if (i == 0) {\n            sum.set(0, 0);\n        } else {\n            sum.set(0, sum[0] + a[i]);\n        }\n        i = i + 1;\n    }\n}\n}\n", "task_path": "Diffy/unverified/brs1.rs", "solution_path": "Diffy/verified/brs1.rs"}
{"task_id": "diffy_brs2", "source": "Diffy", "name": "brs2", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 2 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (i % 2 == 0) {\n\t\t\ta.set(i, 2);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 2 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 2 || a[k] == 0,\n\t\t\ta.len() == N,\n\t{\n\t\tif (i % 2 == 0) {\n\t\t\ta.set(i, 2);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 2 || a[k] == 0,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\ti > 0 ==> sum[0] <= 2 * i,\n\t\t\tN < 1000,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tlet temp = sum[0];\n\t\t\tsum.set(0, temp + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/brs2.rs", "solution_path": "Diffy/verified/brs2.rs"}
{"task_id": "diffy_brs3", "source": "Diffy", "name": "brs3", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 3 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (i % 3 == 0) {\n\t\t\ta.set(i, 3);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 3 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k: int| 0<= k < i ==> a[k] == 3 || a[k] == 0,\n\t\t\ta.len() == N,\n\t{\n\t\tif (i % 3 == 0) {\n\t\t\ta.set(i, 3);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k: int| 0<= k < N ==> a[k] == 3 || a[k] == 0,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\ti>0 ==> sum[0] <= 3 * i,\n\t\t\tN < 1000,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/brs3.rs", "solution_path": "Diffy/verified/brs3.rs"}
{"task_id": "diffy_brs4", "source": "Diffy", "name": "brs4", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 4 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (i % 4 == 0) {\n\t\t\ta.set(i, 4);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 4 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 4 || a[k] == 0,\n\t\t\ta.len() == N,\n\t{\n\t\tif (i % 4 == 0) {\n\t\t\ta.set(i, 4);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 4 || a[k] == 0,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\ti > 0 ==> sum[0] <= 4 * i,\n\t\t\tN < 1000,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/brs4.rs", "solution_path": "Diffy/verified/brs4.rs"}
{"task_id": "diffy_brs5", "source": "Diffy", "name": "brs5", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 5 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (i % 5 == 0) {\n\t\t\ta.set(i, 5);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 5 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 5 || a[k] == 0,\n\t\t\ta.len() == N,\n\t{\n\t\tif (i % 5 == 0) {\n\t\t\ta.set(i, 5);\n\t\t} else {\n\t\t\ta.set(i, 0);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 5 || a[k] == 0,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\ti>0 ==> sum[0] <= 5 * i,\n\t\t\tN < 1000,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/brs5.rs", "solution_path": "Diffy/verified/brs5.rs"}
{"task_id": "diffy_conda", "source": "Diffy", "name": "conda", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 1);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 2,\n\t\t\tforall |k:int| i<= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 1);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 2,\n\t\t\tsum[0] == 2 * i,\n\t\t\tsum.len() == 1,\n\t\t\ta.len() == N,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/conda.rs", "solution_path": "Diffy/verified/conda.rs"}
{"task_id": "diffy_condg", "source": "Diffy", "name": "condg", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == 0,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (sum[0] == N) {\n\t\t\ta.set(i, a[i] - 1);\n\t\t} else {\n\t\t\ta.set(i, a[i] + 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == 0,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant \n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == i,\n\t\t\tsum.len() == 1,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 0,\n\t\t\tforall |k:int| i <= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == N,\n\t{\n\t\tif (sum[0] == N) {\n\t\t\ta.set(i, a[i] - 1);\n\t\t} else {\n\t\t\ta.set(i, a[i] + 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/condg.rs", "solution_path": "Diffy/verified/condg.rs"}
{"task_id": "diffy_condm", "source": "Diffy", "name": "condm", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, N: u32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] % 2 == N % 2,\n{\n\tlet mut i: usize = 0;\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 0);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (N % 2 == 0) {\n\t\t\ta.set(i, a[i] + 2);\n\t\t} else {\n\t\t\ta.set(i, a[i] + 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, N: u32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] % 2 == N % 2,\n{\n\tlet mut i: usize = 0;\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 0,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 0);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] % 2 == N % 2,\n\t\t\tforall |k:int| i <= k < N ==> a[k] == 0,\n\t\t\ta.len() == N,\n\t{\n\t\tif (N % 2 == 0) {\n\t\t\ta.set(i, a[i] + 2);\n\t\t} else {\n\t\t\ta.set(i, a[i] + 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/condm.rs", "solution_path": "Diffy/verified/condm.rs"}
{"task_id": "diffy_condn", "source": "Diffy", "name": "condn", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, N: i32, m: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] <= N,\n{\n\tlet mut i: usize = 0;\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, m);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] < N) {\n\t\t\ta.set(i, a[i]);\n\t\t} else {\n\t\t\ta.set(i, N);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, N: i32, m: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] <= N,\n{\n\tlet mut i: usize = 0;\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, m);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] <= N,\n\t\t\ta.len() == N,\n\t{\n\t\tif (a[i] < N) {\n\t\t\ta.set(i, a[i]);\n\t\t} else {\n\t\t\ta.set(i, N);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/condn.rs", "solution_path": "Diffy/verified/condn.rs"}
{"task_id": "diffy_ms1", "source": "Diffy", "name": "ms1", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<usize>, sum: &mut Vec<usize>, N: usize) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\tensures\n\t\tsum[0] == 0,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, i % 1 );\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<usize>, sum: &mut Vec<usize>, N: usize) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\tensures\n\t\tsum[0] == 0,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k: int| 0<= k < i ==> a[k] == 0,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, i % 1 );\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k: int| 0<= k < N ==> a[k] == 0,\n\t\t\ta.len() == N,\n\t\t\ti > 0 ==> sum[0] == 0,\n\t\t\tsum.len() == 1,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}\n", "task_path": "Diffy/unverified/ms1.rs", "solution_path": "Diffy/verified/ms1.rs"}
{"task_id": "diffy_ms2", "source": "Diffy", "name": "ms2", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<usize>, sum: &mut Vec<usize>, N: usize) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\tensures\n\t\tsum[0] <= N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, i % 2 );\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<usize>, sum: &mut Vec<usize>, N: usize) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\tensures\n\t\tsum[0] <= N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 0 || a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, i % 2 );\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 0 || a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\ti>0 ==> sum[0] <= i,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}\n", "task_path": "Diffy/unverified/ms2.rs", "solution_path": "Diffy/verified/ms2.rs"}
{"task_id": "diffy_ms3", "source": "Diffy", "name": "ms3", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 2 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, (i % 3) as i32);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 2 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 0 || a[k] == 1 || a[k] == 2,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, (i % 3) as i32);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 0 || a[k] == 1 || a[k] == 2,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\ti > 0 ==> sum[0] <= 2 * i,\n\t\t\tN < 1000,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/ms3.rs", "solution_path": "Diffy/verified/ms3.rs"}
{"task_id": "diffy_ms4", "source": "Diffy", "name": "ms4", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 3 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, (i % 4) as i32);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 3 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == k % 4,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, (i % 4) as i32);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\ti>0 ==> sum[0] <= 3 * i,\n\t\t\tsum.len() == 1,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == k % 4,\n\t\t\ta.len() == N,\n\t\t\tN < 1000,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/ms4.rs", "solution_path": "Diffy/verified/ms4.rs"}
{"task_id": "diffy_ms5", "source": "Diffy", "name": "ms5", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 4 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, (i % 5) as i32);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) \n\trequires \n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN > 0,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 4 * N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == k % 5,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, (i % 5) as i32);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\t\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == k % 5,\n\t\t\ta.len() == N,\n\t\t\ti > 0 ==> sum[0] <= 4 * i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tif (i == 0) {\n\t\t\tsum.set(0, 0);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/ms5.rs", "solution_path": "Diffy/verified/ms5.rs"}
{"task_id": "diffy_res1", "source": "Diffy", "name": "res1", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 2 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\n\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n        N < 1000,\n\tensures\n\t\tsum[0] <= 2 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 1,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tb.len() == N,\n\t\t\tforall |k:int| 0 <= k < i ==> b[k] == 1,\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == i,\n            a.len() == N,\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == 1,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tsum.len() == 1,\n            b.len() == N,\n\t\t\tsum[0] == N + i,\n            N < 1000,\n\t\t\tforall |k:int| 0 <= k < N ==> b[k] == 1,\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n}\n}\n\n\n\n\n", "task_path": "Diffy/unverified/res1.rs", "solution_path": "Diffy/verified/res1.rs"}
{"task_id": "diffy_res1o", "source": "Diffy", "name": "res1o", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 1,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N as usize,\n\t\t\tsum.len() == 1,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == i, // Corrected invariant\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == 1,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tb.len() == N,\n\t\t\tforall |k:int| 0 <= k < i ==> b[k] == 1,\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N as usize,\n\t\t\tsum.len() == 1,\n\t\t\tb.len() == N,\n\t\t\tsum[0] == N + i,\n\t\t\tforall |k:int| 0 <= k < N ==> b[k] == 1,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/res1o.rs", "solution_path": "Diffy/verified/res1o.rs"}
{"task_id": "diffy_res2", "source": "Diffy", "name": "res2", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, c: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(c).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 3 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tc.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + c[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, c: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(c).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 3 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 1,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N, \n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == i,\n\t\t\ta.len() == N,\n\t\t\tforall |j: int| 0 <= j < N ==> a[j] == 1,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tb.len() == N,\n\t\t\tforall |j: int| 0 <= j < i ==> b[j] == 1,\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N, \n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == i + N,\n\t\t\tb.len() == N,\n\t\t\tforall |j: int| 0 <= j < N ==> b[j] == 1,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> c[j] == 1,\n\t\t\tc.len() == N,\n\t{\n\t\tc.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N, \n\t\t\tsum[0] == i + 2 * N,\n\t\t\tc.len() == N,\n\t\t\tforall |j: int| 0 <= j < N ==> c[j] == 1,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + c[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/res2.rs", "solution_path": "Diffy/verified/res2.rs"}
{"task_id": "diffy_res2o", "source": "Diffy", "name": "res2o", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, c: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(c).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 3 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tc.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + c[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, c: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(c).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] <= 3 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> b[j] == 1,\n\t\t\tb.len() == N,\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> c[j] == 1,\n\t\t\tc.len() == N,\n\t{\n\t\tc.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == i,\n\t\t\tforall |j: int| 0<= j < N ==> a[j] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == i + N,\n\t\t\tforall |j: int| 0<= j < N ==> b[j] == 1,\n\t\t\tb.len() == N,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == i + 2 * N,\n\t\t\tforall |j: int| 0<= j < N ==> c[j] == 1,\n\t\t\tc.len() == N,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + c[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/res2o.rs", "solution_path": "Diffy/verified/res2o.rs"}
{"task_id": "diffy_s12if", "source": "Diffy", "name": "s12if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 1);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 2) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 1,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 2,\n\t\t\tforall |k:int| i<= k < N ==> a[k] == 1,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 1);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 2,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == 2 * i,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 2) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s12if.rs", "solution_path": "Diffy/verified/s12if.rs"}
{"task_id": "diffy_s1if", "source": "Diffy", "name": "s1if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\tensures\n\t\tsum[0] == N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\tensures\n\t\tsum[0] == N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == i,\n\t\t\tsum.len() == 1,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s1if.rs", "solution_path": "Diffy/verified/s1if.rs"}
{"task_id": "diffy_s1lif", "source": "Diffy", "name": "s1lif", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 1);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 1,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 2,\n\t\t\tforall |j: int| i<= j < N ==> a[j] == 1,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 1);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\ta.len() == N,\n\t\t\tforall |j: int| 0<= j < N ==> a[j] == 2,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == 2 * i,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s1lif.rs", "solution_path": "Diffy/verified/s1lif.rs"}
{"task_id": "diffy_s22if", "source": "Diffy", "name": "s22if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 3 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 2);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 3) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 3 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 1,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 3,\n\t\t\tforall |k:int| i<= k < N ==> a[k] == 1,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 2);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 3,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == 3 * i,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 3) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s22if.rs", "solution_path": "Diffy/verified/s22if.rs"}
{"task_id": "diffy_s2if", "source": "Diffy", "name": "s2if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 2);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 2) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 2 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 2,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 2);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 2,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == 2 * i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 2) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s2if.rs", "solution_path": "Diffy/verified/s2if.rs"}
{"task_id": "diffy_s2lif", "source": "Diffy", "name": "s2lif", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 3 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 2);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 3 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 3,\n\t\t\tforall |j: int| i <= j < N ==> a[j] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 2);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |j: int| 0<= j < N ==> a[j] == 3,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == 3 * i,\n\t\t\tN <= 1000,\n\t\t\ta.len() == N,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s2lif.rs", "solution_path": "Diffy/verified/s2lif.rs"}
{"task_id": "diffy_s32if", "source": "Diffy", "name": "s32if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 4 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 3);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 4) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 4 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\tforall |k:int| 0<=k <i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\tforall |k:int| 0<=k <i ==> a[k] == 4,\n\t\t\tforall |k:int| i<=k <N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 3);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<=k <N ==> a[k] == 4,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == 4 * i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 4) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s32if.rs", "solution_path": "Diffy/verified/s32if.rs"}
{"task_id": "diffy_s3if", "source": "Diffy", "name": "s3if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 3 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 3);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 3) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 3 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 3,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 3);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 3,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == 3 * i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 3) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s3if.rs", "solution_path": "Diffy/verified/s3if.rs"}
{"task_id": "diffy_s3lif", "source": "Diffy", "name": "s3lif", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 4 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 3);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 4 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 4,\n\t\t\tforall |j: int| i <= j < N ==> a[j] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 3);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |j: int| 0<= j < N ==> a[j] == 4,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == 4 * i,\n\t\t\tN <= 1000,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s3lif.rs", "solution_path": "Diffy/verified/s3lif.rs"}
{"task_id": "diffy_s42if", "source": "Diffy", "name": "s42if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 5 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 4);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 5)\n\t\t{\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 5 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 5,\n\t\t\tforall |k:int| i<= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 4);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 5,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == 5 * i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 5)\n\t\t{\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s42if.rs", "solution_path": "Diffy/verified/s42if.rs"}
{"task_id": "diffy_s4if", "source": "Diffy", "name": "s4if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 4 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 4);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 4) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 4 * N,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 4,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 4);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 4,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == 4 * i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 4) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s4if.rs", "solution_path": "Diffy/verified/s4if.rs"}
{"task_id": "diffy_s4lif", "source": "Diffy", "name": "s4lif", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 5 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 4);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 5 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 1,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ta.len() == N,\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 5,\n\t\t\tforall |j: int| i <= j < N ==> a[j] == 1,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 4);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\tforall |j: int| 0<= j < N ==> a[j] == 5,\n\t\t\tsum[0] == 5 * i,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s4lif.rs", "solution_path": "Diffy/verified/s4lif.rs"}
{"task_id": "diffy_s52if", "source": "Diffy", "name": "s52if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 6 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 5);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t{\n\t\tif (a[i] == 6)\n\t\t{\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 6 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 6,\n\t\t\tforall |k:int| i <= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 5);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == 6,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == 6 * i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 6)\n\t\t{\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s52if.rs", "solution_path": "Diffy/verified/s52if.rs"}
{"task_id": "diffy_s5if", "source": "Diffy", "name": "s5if", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 5 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 5);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 5) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 5 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0<= k < i ==> a[k] == 5,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 5);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0<= k < N ==> a[k] == 5,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == 5 * i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tif (a[i] == 5) {\n\t\t\tsum.set(0, sum[0] + a[i]);\n\t\t} else {\n\t\t\tsum.set(0, sum[0] * a[i]);\n\t\t}\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s5if.rs", "solution_path": "Diffy/verified/s5if.rs"}
{"task_id": "diffy_s5lif", "source": "Diffy", "name": "s5lif", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 6 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 5);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tsum[0] == 6 * N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |j: int| 0<= j < i ==> a[j] == 6,\n\t\t\tforall |j: int| i <= j < N ==> a[j] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\tif (a[i] == 1) {\n\t\t\ta.set(i, a[i] + 5);\n\t\t} else {\n\t\t\ta.set(i, a[i] - 1);\n\t\t}\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |j: int| 0<= j < N ==> a[j] == 6,\n\t\t\tsum[0] == 6 * i,\n\t\t\tsum.len() == 1,\n\t\t\ta.len() == N,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/s5lif.rs", "solution_path": "Diffy/verified/s5lif.rs"}
{"task_id": "diffy_sina1", "source": "Diffy", "name": "sina1", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, sum[0]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == N,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == i,\n\t{\n\t\tsum.set(0, sum[0] + 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == sum[0],\n\t\t\tsum.len() == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, sum[0]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/sina1.rs", "solution_path": "Diffy/verified/sina1.rs"}
{"task_id": "diffy_sina2", "source": "Diffy", "name": "sina2", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == N + 1,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, a[i] + sum[0]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == N + 1,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == 1,\n\t\t\tsum[0] == i,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tsum[0] == N,\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == N + 1,\n\t\t\tforall |k:int| i <= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\ta.set(i, a[i] + sum[0]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/sina2.rs", "solution_path": "Diffy/verified/sina2.rs"}
{"task_id": "diffy_sina3", "source": "Diffy", "name": "sina3", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == N + 1,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, b[i] + sum[0]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == N + 1,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> b[k] == 1,\n\t\t\tb.len() == N,\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tsum.len() == 1,\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == i,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < N ==> b[k] == 1,\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == N + 1,\n\t\t\ta.len() == N,\n\t\t\tb.len() == N,\n\t\t\tsum.len() == 1,\n\t\t\tsum[0] == N,\n\t\t\tN < 1000,\n\t{\n\t\ta.set(i, b[i] + sum[0]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/sina3.rs", "solution_path": "Diffy/verified/sina3.rs"}
{"task_id": "diffy_sina4", "source": "Diffy", "name": "sina4", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> b[k] == N + 2,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, a[i] + sum[0]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tb.set(i, a[i] + 1);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> b[k] == N + 2,\n{\n\tsum.set(0, 0);\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == i,\n\t\t\tsum.len() == 1,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tsum[0] == N,\n\t\t\tsum.len() == 1,\n\t\t\tforall |k:int| i <= k < N ==> a[k] == 1,\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == N + 1,\n\t\t\ta.len() == N,\n\t\t\tN < 1000,\n\t{\n\t\ta.set(i, a[i] + sum[0]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == N + 1,\n\t\t\ta.len() == N,\n\t\t\tforall |k:int| 0 <= k < i ==> b[k] == N + 2,\n\t\t\tb.len() == N,\n\t\t\tN < 1000,\n\t{\n\t\tb.set(i, a[i] + 1);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/sina4.rs", "solution_path": "Diffy/verified/sina4.rs"}
{"task_id": "diffy_sina5", "source": "Diffy", "name": "sina5", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == 2 * N + 1,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t{\n\t\ta.set(i, a[i] + sum[0]);\n\t\ti = i + 1;\n\t}\n}\n}", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)\n\trequires\n\t\tN > 0,\n\t\told(a).len() == N,\n\t\told(b).len() == N,\n\t\told(sum).len() == 1,\n\t\tN < 1000,\n\tensures\n\t\tforall |k:int| 0 <= k < N ==> a[k] == 2 * N + 1,\n{\n\tlet mut i: usize = 0;\n\tsum.set(0, 0);\n\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t{\n\t\ta.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> b[k] == 1,\n\t\t\tb.len() == N,\n\t{\n\t\tb.set(i, 1);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tsum.len() == 1,\n\t\t\tforall |k:int| 0 <= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == i,\n\t{\n\t\tsum.set(0, sum[0] + a[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\ti <= N,\n\t\t\tforall |k:int| 0 <= k < N ==> b[k] == 1,\n\t\t\tb.len() == N,\n\t\t\tsum[0] == N + i,\n\t\t\tsum.len() == 1,\n\t\t\tN < 1000,\n\t{\n\t\tsum.set(0, sum[0] + b[i]);\n\t\ti = i + 1;\n\t}\n\n\ti = 0;\n\twhile (i < N as usize)\n\t\tinvariant\n\t\t\tforall |k:int| 0 <= k < i ==> a[k] == 2 * N + 1,\n\t\t\tforall |k:int| i <= k < N ==> a[k] == 1,\n\t\t\ta.len() == N,\n\t\t\tsum[0] == 2 * N,\n\t\t\tsum.len() == 1,\n\t{\n\t\ta.set(i, a[i] + sum[0]);\n\t\ti = i + 1;\n\t}\n}\n}", "task_path": "Diffy/unverified/sina5.rs", "solution_path": "Diffy/verified/sina5.rs"}
{"task_id": "misc_arg_free", "source": "Misc", "name": "arg_free", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn choose_odd()\n{\n    let mut idx: u64 = 0;\n    let mut res: u64 = 5;\n    while (idx < 10)\n    {\n        res = res + 1;\n        idx = idx + 1;\n    }\n    idx = 0;\n    while (idx < 10)\n    {\n        res = res + 1;\n        idx = idx + 1;\n    }\n    assert(res == 25);\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn choose_odd()\n{\n    let mut idx: u64 = 0;\n    let mut res: u64 = 5;\n    \n    let ghost gap = res-idx;\n    \n    while (idx < 10)\n    invariant\n        idx<=10,\n        gap<100,\n        gap==res-idx,\n    {\n        res = res + 1;\n        idx = idx + 1;\n    }\n    idx = 0;\n    \n    let ghost gap = res - idx;\n   \n    while (idx < 10)\n    invariant\n        idx<=10,\n        gap<100,\n        gap==res-idx,\n    {\n        \n        res = res + 1;\n        idx = idx + 1;\n        \n    }\n    assert(res == 25);\n}\n}\n", "task_path": "Misc/unverified/arg_free.rs", "solution_path": "Misc/verified/arg_free.rs"}
{"task_id": "misc_basic_nonlinear", "source": "Misc", "name": "basic_nonlinear", "task": "//from Verus tutorial\n\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\n     \nproof fn bound_check(x: u32, y: u32)\n    requires\n        x <= 0xffff,\n        y <= 0xffff,\n    ensures\n        x*y <= 0x100000000,\n{\n\n}\n}\n", "ground_truth": "//from Verus tutorial\n\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\n     \nproof fn bound_check(x: u32, y: u32)\n    requires\n        x <= 0xffff,\n        y <= 0xffff,\n    ensures\n        x*y <= 0x100000000,\n{\n    assert(x * y <= 0x100000000) by(nonlinear_arith)\n        requires\n            x <= 0xffff,\n            y <= 0xffff,\n    {\n        \n    }\n}\n}\n", "task_path": "Misc/unverified/basic_nonlinear.rs", "solution_path": "Misc/verified/basic_nonlinear.rs"}
{"task_id": "misc_binary_search", "source": "Misc", "name": "binary_search", "task": "//This example is from Verus tutorial, Chpt 7.5\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i:int, j:int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i:int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n}\n", "ground_truth": "//This example is from Verus tutorial, Chpt 7.5\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i:int, j:int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i:int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n}\n", "task_path": "Misc/unverified/binary_search.rs", "solution_path": "Misc/verified/binary_search.rs"}
{"task_id": "misc_bubble", "source": "Misc", "name": "bubble", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n \n \n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n \n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n        {\n            let mut j = i;\n            while j != 0\n            {\n                if nums[j - 1] > nums[j] {\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n            }\n        }\n    }\n}\n", "ground_truth": null, "task_path": "Misc/unverified/bubble.rs", "solution_path": null}
{"task_id": "misc_cell_2_sum", "source": "Misc", "name": "cell_2_sum", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<u32>, N: u32) -> (sum: u32)\n    requires \n        old(a).len() == N,\n        N <= 0x7FFF_FFFF,\n    ensures\n        sum <= 2 * N,\n{\n    let mut i: usize = 0;\n    while (i < N as usize)\n    {\n\tif a[i] > 2 \n        {\n\t    a.set(i, 2);\n\t} \n\ti = i + 1;\n    }\n\n    i = 0;\n    let mut sum: u32 = 0;\n\t\n    while (i < N as usize)\n    {\n        sum = sum + a[i];\n\ti = i + 1;\n    }\n\n    sum\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\n\npub fn myfun(a: &mut Vec<u32>, N: u32) -> (sum: u32)\n\trequires \n\t\told(a).len() == N,\n\t\tN <= 0x7FFF_FFFF,\n\tensures\n\t    sum <= 2*N,\n{\n\tlet mut i: usize = 0;\n\twhile (i < N as usize)\n\tinvariant \n\t    a.len()==N,\n\t    forall|j:int| 0<=j<i ==> a[j]<=2,\n\t{\n\t\tif (a[i] > 2) {\n\t\t\ta.set(i, 2);\n\t\t} \n\t\ti = i + 1;\n\t}\n\n\n\ti = 0;\n    let mut sum: u32 = 0;\n\t\n\twhile (i < N as usize)\n\tinvariant\n\t    i<=N,\n\t    N <= 0x7FFF_FFFF,\n\t    a.len()==N,\n\t    forall|j:int| 0<=j<N ==> a[j]<=2,\n\t    sum<=2 * i,\n\t{\n        sum = sum + a[i];\n\t\ti = i + 1;\n\t}\n\n    sum\n\n}\n}\n", "task_path": "Misc/unverified/cell_2_sum.rs", "solution_path": "Misc/verified/cell_2_sum.rs"}
{"task_id": "misc_choose_odd", "source": "Misc", "name": "choose_odd", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn choose_odd(v: &Vec<u64>) -> (odd_index: usize)\n    requires    \n        exists |q:int| 0 <= q < v.len() && v[q] % 2 == 1\n    ensures\n        odd_index < v.len()\n{\n    let mut j: usize = 0;\n    while (j < v.len())\n    {\n        if v[j] % 2 == 1 {\n            return j;\n        }\n        j = j + 1;\n    }\n    j\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn choose_odd(v: &Vec<u64>) -> (odd_index: usize)\n    requires    \n        exists |q:int| 0 <= q < v.len() && v[q] % 2 == 1\n    ensures\n        odd_index < v.len()\n{\n    let mut j: usize = 0;\n    \n    while (j < v.len())\n    invariant \n        forall |q:int| 0<=q<j ==> #[trigger] v[q]%2!=1,\n    {\n        if (v[j] % 2 == 1) {\n            return j;\n        }\n        j = j + 1;\n        \n    }\n    j\n}\n}\n", "task_path": "Misc/unverified/choose_odd.rs", "solution_path": "Misc/verified/choose_odd.rs"}
{"task_id": "misc_conditional_average", "source": "Misc", "name": "conditional_average", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn conditional_average(vals_1: &Vec<u64>, vals_2: &Vec<u64>, conds_1: &Vec<bool>, conds_2: &Vec<bool>, avgs: &mut Vec<u64>) \n    requires \n        vals_1.len() == vals_2.len(),\n        vals_1.len() == conds_1.len(),\n        vals_1.len() == conds_2.len(),\n        forall |idx:int| 0 <= idx < vals_1.len() ==> conds_1[idx] || conds_2[idx],\n        forall |idx:int| 0 <= idx < vals_1.len() ==> vals_1[idx] < 1000,\n        forall |idx:int| 0 <= idx < vals_2.len() ==> vals_2[idx] < 1000,\n    ensures\n        avgs.len() == vals_1.len(),\n        forall |idx:int| 0 <= idx < vals_1.len() ==> (\n            (conds_1[idx] && conds_2[idx] ==> avgs[idx] == (vals_1[idx] + vals_2[idx]) / 2) &&\n            (conds_1[idx] && !conds_2[idx] ==> avgs[idx] == vals_1[idx]) &&\n            (!conds_1[idx] && conds_2[idx] ==> avgs[idx] == vals_2[idx])\n        )\n{\n    let mut k: usize = 0;\n    let common_len = vals_1.len();\n    avgs.clear();\n    while (k < common_len)\n    {\n        let mut new_avg: u64 = 0;\n        if (conds_1[k]) {\n            if (conds_2[k]) {\n                new_avg = (vals_1[k] + vals_2[k]) / 2;\n            }\n            else {\n                new_avg = vals_1[k];\n            }\n        }\n        else {\n            new_avg = vals_2[k];\n        }\n        avgs.push(new_avg);\n        k = k + 1;\n    }\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn conditional_average(vals_1: &Vec<u64>, vals_2: &Vec<u64>, conds_1: &Vec<bool>, conds_2: &Vec<bool>, avgs: &mut Vec<u64>) \n    requires \n        vals_1.len() == vals_2.len(),\n        vals_1.len() == conds_1.len(),\n        vals_1.len() == conds_2.len(),\n        forall |idx:int| 0 <= idx < vals_1.len() ==> conds_1[idx] || conds_2[idx],\n        forall |idx:int| 0 <= idx < vals_1.len() ==> vals_1[idx] < 1000,\n        forall |idx:int| 0 <= idx < vals_2.len() ==> vals_2[idx] < 1000,\n    ensures\n        avgs.len() == vals_1.len(),\n        forall |idx:int| 0 <= idx < vals_1.len() ==> (\n            (conds_1[idx] && conds_2[idx] ==> avgs[idx] == (vals_1[idx] + vals_2[idx]) / 2) &&\n            (conds_1[idx] && !conds_2[idx] ==> avgs[idx] == vals_1[idx]) &&\n            (!conds_1[idx] && conds_2[idx] ==> avgs[idx] == vals_2[idx])\n        )\n{\n    let mut k: usize = 0;\n    let common_len = vals_1.len();\n    avgs.clear();\n    while (k < common_len)\n    invariant \n        k<=common_len,\n        avgs.len()==k,\n        vals_1.len()==common_len,\n        vals_2.len()==common_len,\n        conds_1.len()==common_len,\n        conds_2.len()==common_len,\n        forall |idx:int| 0 <= idx < vals_1.len() ==> vals_1[idx] < 1000,\n        forall |idx:int| 0 <= idx < vals_2.len() ==> vals_2[idx] < 1000,\n        forall |i:int| 0<=i<k ==> (\n            (conds_1[i] && conds_2[i] ==> avgs[i] == (vals_1[i] + vals_2[i]) / 2) &&\n            (conds_1[i] && !conds_2[i] ==> avgs[i] == vals_1[i]) &&\n            (!conds_1[i] && conds_2[i] ==> avgs[i] == vals_2[i])\n        ),\n    {\n        let mut new_avg: u64 = 0;\n        if (conds_1[k]) {\n            if (conds_2[k]) {\n                new_avg = (vals_1[k] + vals_2[k]) / 2;\n            }\n            else {\n                new_avg = vals_1[k];\n            }\n        }\n        else {\n            new_avg = vals_2[k];\n        }\n        avgs.push(new_avg);\n        k = k + 1;\n    }\n}\n}\n", "task_path": "Misc/unverified/conditional_average.rs", "solution_path": "Misc/verified/conditional_average.rs"}
{"task_id": "misc_deduplicate", "source": "Misc", "name": "deduplicate", "task": "#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len()\n{\n    if seq.len() == 0 {\n        Set::empty()\n    } else {\n        seq_to_set_rec(seq.drop_last()).insert(seq.last())\n    }\n}\n\n\nfn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)\nensures\n    res@.no_duplicates(),\n    nums@.to_set().ext_equal(res@.to_set())\n{\n    let mut res = Vec::new();\n    let mut i = 0;\n    while i < nums.len()\n    {\n        let mut found = false;\n        let mut j = 0;\n\n        while j < res.len()\n        {\n            if nums[i] == res[j] {\n                found = true;\n                break;\n            }\n            j += 1;\n        }\n        \n        if !found {\n            res.push(nums[i]);\n        }\n        i += 1;\n    }\n    res\n}\n}\n", "ground_truth": "#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len()\n{\n    if seq.len() == 0 {\n        Set::empty()\n    } else {\n        seq_to_set_rec(seq.drop_last()).insert(seq.last())\n    }\n}\n\n/// helper function showing that the resulting set contains all elements of the sequence\nproof fn seq_to_set_rec_contains<A>(seq: Seq<A>)\n    ensures forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a)\n    decreases seq.len()\n{\n    if seq.len() > 0 {\n        assert(forall |a| #[trigger] seq.drop_last().contains(a) <==> seq_to_set_rec(seq.drop_last()).contains(a)) by {\n            seq_to_set_rec_contains(seq.drop_last());\n        }\n\n        assert(seq =~= (seq.drop_last().push(seq.last())));\n        assert forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a) by {\n            if !seq.drop_last().contains(a) {\n                if a == seq.last() {\n                    assert(seq.contains(a));\n                    assert(seq_to_set_rec(seq).contains(a));\n                } else {\n                    assert(!seq_to_set_rec(seq).contains(a));\n                }\n            }\n        }\n    }\n}\n\n/// helper function showing that the recursive definition matches the set comprehension one\nproof fn seq_to_set_equal_rec<A>(seq: Seq<A>)\n    ensures seq.to_set() == seq_to_set_rec(seq)\n{\n    assert(forall |n| #[trigger] seq.contains(n) <==> seq_to_set_rec(seq).contains(n)) by {\n        seq_to_set_rec_contains(seq);\n    }\n    assert(forall |n| #[trigger] seq.contains(n) <==> seq.to_set().contains(n));\n    assert(seq.to_set() =~= seq_to_set_rec(seq));\n}\n\nproof fn lemma_seq_push_to_set_insert<T>(s: Seq<T>, val: T)\nensures\n    s.push(val).to_set() === s.to_set().insert(val),\n{\n    seq_to_set_equal_rec(s.push(val));\n    assert(s =~= s.push(val).drop_last());\n    seq_to_set_equal_rec(s);\n    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val)));\n    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val).drop_last()).insert(val));\n}\n\nfn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)\nensures\n    res@.no_duplicates(),\n    nums@.to_set() =~= (res@.to_set())\n{\n    let mut res = Vec::new();\n    let mut i = 0;\n    while i < nums.len()\n    invariant\n        0 <= i <= nums@.len(),\n        nums@.subrange(0, i  as int).to_set() =~= (res@.to_set()),\n        res@.no_duplicates(),\n    decreases nums.len() - i\n    {\n        let mut found = false;\n        let mut j = 0;\n\n        while j < res.len()\n        invariant_except_break\n            !found\n        invariant\n            0 <= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set() =~= (res@.to_set()),\n            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n        ensures\n            0<= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set() =~= (res@.to_set()),\n            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),\n            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n            !found ==> j == res@.len()\n        decreases res.len() - j\n        {\n            if nums[i] == res[j] {\n                found = true;\n                break;\n            }\n            j += 1;\n        }\n        proof {\n            let val = nums@[i as int];\n            assert(nums@.subrange(0, i as int + 1) =~= (nums@.subrange(0, i as int).push(val)));\n            lemma_seq_push_to_set_insert(nums@.subrange(0, i as int), val);\n            lemma_seq_push_to_set_insert(res@, val);\n            assert(nums@.subrange(0, i as int + 1).to_set() =~= (res@.to_set().insert(val)));\n            if found {\n                assert(res@.contains(val));\n                assert(res@.to_set().contains(val));\n                assert(res@.to_set() =~= (res@.to_set().insert(val)));\n                assert(nums@.subrange(0, i as int + 1).to_set() =~= (res@.to_set()));\n            }\n\n        }\n        if !found {\n            res.push(nums[i]);\n        }\n        i += 1;\n    }\n    proof {\n        assert(nums@.subrange(0, i  as int) =~= (nums@));\n    }\n    res\n}\n}\n", "task_path": "Misc/unverified/deduplicate.rs", "solution_path": "Misc/verified/deduplicate.rs"}
{"task_id": "misc_fib", "source": "Misc", "name": "fib", "task": "#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nspec fn fibo(n: int) -> nat\n    decreases n\n{\n    if n <= 0 { 0 } else if n == 1 { 1 }\n    else { fibo(n - 2) + fibo(n - 1) }\n}\n\nspec fn fibo_fits_i32(n: int) -> bool {\n    fibo(n) < 0x8000_0000\n}\n\nfn fibonacci(n: usize) -> (ret: Vec<i32>)\nrequires\n    fibo_fits_i32(n as int),\n    n >= 2,\nensures\n    forall |i: int| 2 <= i < n ==> #[trigger] ret@[i] ==  fibo(i), \n    ret@.len() == n,\n{\n    let mut fib = Vec::new();\n    fib.push(0);\n    fib.push(1);\n    let mut i = 2;\n\n    while i < n\n    {\n\n        let next_fib = fib[i - 1] + fib[i - 2];\n\n        fib.push(next_fib);\n        \n        i += 1;\n    }\n\n    fib\n}\n}\n", "ground_truth": "#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nspec fn fibo(n: int) -> nat\n    decreases n\n{\n    if n <= 0 { 0 } else if n == 1 { 1 }\n    else { fibo(n - 2) + fibo(n - 1) }\n}\n\nspec fn fibo_fits_i32(n: int) -> bool {\n    fibo(n) < 0x8000_0000\n}\n\nproof fn fibo_is_monotonic(i: int, j: int)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i\n{\n    if i <= 0 {\n    }\n    else if  i < j {\n        fibo_is_monotonic(i, j-1);\n        assert(fibo(j) == fibo(j-1)+fibo(j-2));\n    }\n}\n\nfn fibonacci(n: usize) -> (ret: Vec<i32>)\nrequires\n    fibo_fits_i32(n as int),\n    n >= 2,\nensures\n    forall |i: int| 2 <= i < n ==> #[trigger] ret@[i] ==  fibo(i), \n    ret@.len() == n,\n{\n    let mut fib = Vec::new();\n    fib.push(0);\n    fib.push(1);\n    let mut i = 2;\n    \n\n    while i < n\n        invariant\n            forall |k: int| 0 <= k < i ==> #[trigger] fib@[k] == fibo(k),\n            fibo_fits_i32(n as int),\n            2 <= i,\n            fib@.len() == i, \n            i <= n,\n    {\n        proof{\n            fibo_is_monotonic(i as int, n as int);\n        }\n        let next_fib = fib[i - 1] + fib[i - 2];\n\n        fib.push(next_fib);\n        \n        i += 1;\n    }\n\n    fib\n}\n}\n", "task_path": "Misc/unverified/fib.rs", "solution_path": "Misc/verified/fib.rs"}
{"task_id": "misc_filter", "source": "Misc", "name": "filter", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\npub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)\nrequires \n    old(y).len() == 0,\nensures \n    y@ == x@.filter(|k:u64| k%3 == 0),\n{\n    let mut i: usize = 0;\n    let xlen = x.len();\n    \n    while (i < xlen) \n    { \n        if (x[i] % 3 == 0) {\n            y.push(x[i]);            \n        }\n        i = i + 1;\n    }\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\npub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)\nrequires \n    old(y).len() == 0,\nensures \n    y@ == x@.filter(|k:u64| k%3 == 0),\n{\n    let mut i: usize = 0;\n    let xlen = x.len();\n    \n    assert(y@ == x@.take(0).filter(|k:u64| k%3 ==0)); //added in response to not-satisfied before loop error\n    while (i < xlen) \n        invariant \n            0 <= i <= xlen,\n            x@.len() == xlen,  // always specify the length of vectors used in the loop\n            y@ == x@.take(i as int).filter(|k:u64| k%3 == 0),//routine for filter\n    { \n        if (x[i] % 3 == 0) {\n            y.push(x[i]);\n            \n        }\n        assert(x@.take((i + 1) as int).drop_last() == x@.take(i as int));//routine for take, filter\n        reveal(Seq::filter);//routine for filter\n        i = i + 1;\n    }\n    assert(x@ == x@.take(x.len() as int)); //routine for take\n}\n}\n", "task_path": "Misc/unverified/filter.rs", "solution_path": "Misc/verified/filter.rs"}
{"task_id": "misc_filter_weak", "source": "Misc", "name": "filter_weak", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\n\n\npub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)\nrequires \n    old(y).len() == 0,\nensures \n    forall |k:int| 0 <= k < y.len() ==> y[k] % 3 == 0 && x@.contains(y@[k]),\n{\n    let mut i: usize = 0;\n    let xlen = x.len();\n    \n    while (i < xlen)  \n    { \n        if (x[i] % 3 == 0) {\n            y.push(x[i]);\n        }\n        i = i + 1;\n    }\n }\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\n\n\npub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)\nrequires \n    old(y).len() == 0,\nensures \n    forall |k:int| 0 <= k < y.len() ==> y[k] % 3 == 0 && x@.contains(y@[k]),\n{\n    let mut i: usize = 0;\n    let xlen = x.len();\n    \n    while (i < xlen) \n        invariant \n            x@.len() == xlen,  // always specify the length of vectors used in the loop\n            forall |k:int| 0 <= k < y.len() ==> y[k] % 3 == 0 && x@.contains(y@[k]),\n    { \n        if (x[i] % 3 == 0) {\n            y.push(x[i]);\n        }\n        i = i + 1;\n    }\n }\n}\n", "task_path": "Misc/unverified/filter_weak.rs", "solution_path": "Misc/verified/filter_weak.rs"}
{"task_id": "misc_findmax", "source": "Misc", "name": "findmax", "task": "#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nfn find_max(nums: Vec<i32>) -> (ret:i32)\nrequires\n    nums.len() > 0,\nensures\n    forall |i: int| 0 <= i < nums@.len() ==> nums@[i] <= ret,\n    exists |i: int| 0 <= i < nums@.len() ==> nums@[i] == ret,\n{\n    let mut max = nums[0];\n    let mut i = 1;\n    while i < nums.len()\n    {\n        if nums[i] > max {\n            max = nums[i];\n        }\n        i += 1;\n    }\n    max\n}\n}\n", "ground_truth": "#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nfn find_max(nums: Vec<i32>) -> (ret:i32)\nrequires\n    nums.len() > 0,\nensures\n    forall |i: int| 0 <= i < nums@.len() ==> nums@[i] <= ret,\n    exists |i: int| 0 <= i < nums@.len() ==> nums@[i] == ret,\n{\n    let mut max = nums[0];\n    let mut i = 1;\n    while i < nums.len()\n    invariant\n        forall |k: int| 0 <= k < i ==> nums@[k] <= max,\n        exists |k: int| 0 <= k < i && nums@[k] == max,\n    {\n        if nums[i] > max {\n            max = nums[i];\n        }\n        i += 1;\n    }\n    max\n}\n}\n", "task_path": "Misc/unverified/findmax.rs", "solution_path": "Misc/verified/findmax.rs"}
{"task_id": "misc_havoc_inline_post", "source": "Misc", "name": "havoc_inline_post", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn havoc_inline_post(v: &mut Vec<u32>, a: u32, b: bool)\n    requires \n        forall |k:int| 0 <= k < old(v).len() ==> old(v)[k] > 0,\n        a > 0,\n        b == false,\n{  \n    // Variables a and v are havocked. Their values are randomly reset, but their new values follow the following assumptions.\n    assume(10 < a < 20);\n    assume(forall |k:int| 0 <= k < v.len() ==> v[k] == 1);\n\n    let c: bool = !b;\n    let mut idx: usize = v.len();\n    while (idx > 0)\n    {\n        idx = idx - 1;\n        v.set(idx, v[idx] + a);\n    }\n    \n    proof {  // inline postcondition\n        assert(20 < 2*a < 40);\n        assert(forall |k:int| 0 <= k < v.len() ==> v[k] == 1 + a);\n        assert(c == true);\n    }\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn havoc_inline_post(v: &mut Vec<u32>, a: u32, b: bool)\n    requires \n        forall |k:int| 0 <= k < old(v).len() ==> old(v)[k] > 0,\n        a > 0,\n        b == false,\n{  \n    // Variables a and v are havocked. Their values are randomly reset, but their new values follow the following assumptions.\n    assume(10 < a < 20);\n    assume(forall |k:int| 0 <= k < v.len() ==> v[k] == 1);\n\n    let c: bool = !b;\n    let mut idx: usize = v.len();\n    while (idx > 0)\n        invariant\n            0 <= idx <= v.len(),\n            forall |k:int| idx <= k < v.len() ==> v[k] == 1 + a,\n            forall |k:int| 0 <= k < idx ==> v[k] == 1,\n            10 < a < 20,\n    {\n        idx = idx - 1;\n        v.set(idx, v[idx] + a);\n    }\n    \n    proof {  // inline postcondition\n        assert(20 < 2*a < 40);\n        assert(forall |k:int| 0 <= k < v.len() ==> v[k] == 1 + a);\n        assert(c == true);\n    }\n}\n}\n", "task_path": "Misc/unverified/havoc_inline_post.rs", "solution_path": "Misc/verified/havoc_inline_post.rs"}
{"task_id": "misc_len_intersect", "source": "Misc", "name": "len_intersect", "task": "//an example from Verus tutorial. VERY difficult.\n\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\n     \npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n\n}\n}\n", "ground_truth": "//This is an example taken from Verus tutorial\n\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\n     \npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        \n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n       \n    }\n}\n}\n", "task_path": "Misc/unverified/len_intersect.rs", "solution_path": "Misc/verified/len_intersect.rs"}
{"task_id": "misc_linearsearch", "source": "Misc", "name": "linearsearch", "task": "#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nfn main() {}\n\nverus! {\nfn linear_search(nums: Vec<i32>, target: i32) -> (ret: i32)\nrequires\n    nums@.len() < 0x8000_0000,\nensures\n    ret < nums@.len(),\n    ret >=0 ==> nums@[ret as int] == target,\n    ret >=0 ==> forall |i: int| 0 <= i < ret as int ==> #[trigger]nums@[i]!= target,\n    ret < 0 ==> forall |i: int| 0 <= i < nums@.len() as int ==> #[trigger]nums@[i] != target,\n{\n    let mut i = 0;\n    while i < nums.len()\n    {\n        if nums[i] == target {\n            break;\n        }\n        i = i + 1;\n    }\n    if i == nums.len() {\n        -1\n    } else {\n        i as i32\n    }\n}\n}\n", "ground_truth": "#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nfn main() {}\n\nverus! {\nfn linear_search(nums: Vec<i32>, target: i32) -> (ret: i32)\nrequires\n    nums@.len() < 0x8000_0000,\nensures\n    ret < nums@.len(),\n    ret >=0 ==> nums@[ret as int] == target,\n    ret >=0 ==> forall |i: int| 0 <= i < ret as int ==> #[trigger]nums@[i]!= target,\n    ret < 0 ==> forall |i: int| 0 <= i < nums@.len() as int ==> #[trigger]nums@[i] != target,\n{\n    let mut i = 0;\n    while i < nums.len()\n    invariant\n        forall |k: int| 0 <= k < i ==> #[trigger]nums[k]@!= target,\n        0 <= i <= nums@.len(),\n    ensures\n        0 <= i < nums@.len() ==> (#[trigger]nums@[i as int]) == target,\n    {\n        if nums[i] == target {\n            break;\n        }\n        i = i + 1;\n    }\n    if i == nums.len() {\n        -1\n    } else {\n        i as i32\n    }\n}\n}\n", "task_path": "Misc/unverified/linearsearch.rs", "solution_path": "Misc/verified/linearsearch.rs"}
{"task_id": "misc_map", "source": "Misc", "name": "map", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun2(x: &mut Vec<i32>) \nrequires \n    forall |k:int| 0 <= k < old(x).len() ==> old(x)[k] <= 0x7FFF_FFFB,\nensures \n    x@.len() == old(x)@.len(),\n    forall |k:int| 0 <= k < x.len() ==> #[trigger] x@[k] == old(x)@[k] + 4,\n{\n    let mut i: usize = 0;\n    let xlen: usize = x.len();\n    while (i < xlen) \n    { \n        x.set(i, x[i] + 4);  \n        i = i + 1;\n    }  \n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn myfun2(x: &mut Vec<i32>) \nrequires \n    forall |k:int| 0 <= k < old(x).len() ==> old(x)[k] <= 0x7FFF_FFFB,\nensures \n    x@.len() == old(x)@.len(),\n    forall |k:int| 0 <= k < x.len() ==> #[trigger] x@[k] == old(x)@[k] + 4,\n{\n    let mut i: usize = 0;\n    let xlen: usize = x.len();\n    while (i < xlen) \n        invariant \n            xlen == x.len(),  // always specify the length of vectors used in the loop\n            forall |k:int| 0 <= k < i ==> #[trigger] x[k] == old(x)[k] + 4,\n            forall |k:int| i <= k < xlen ==> x[k] == old(x)[k],\n            forall |k:int| 0 <= k < xlen ==> old(x)[k] <= 0x7FFF_FFFB,\n    { \n        x.set(i, x[i] + 4);  \n        i = i + 1;\n    }  \n}\n}\n", "task_path": "Misc/unverified/map.rs", "solution_path": "Misc/verified/map.rs"}
{"task_id": "misc_max_index", "source": "Misc", "name": "max_index", "task": "use vstd::prelude::*;\nfn main() {}\nverus! {\n\npub fn myfun1(x: &Vec<i32>) -> (max_index: usize)\n    requires\n        x.len() >= 1,\n    ensures\n        forall|k: int| 0 <= k < x.len() ==> x[max_index as int] >= x[k],\n        max_index < x.len(),\n{\n    let mut max_index = 0;\n    let mut i: usize = 1;\n    while (i < x.len()) {\n        if x[i] > x[max_index] {\n            max_index = i;\n        }\n        i = i + 1;\n    }\n    max_index\n}\n\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus! {\n\npub fn myfun1(x: &Vec<i32>) -> (max_index: usize)\n    requires\n        x.len() >= 1,\n    ensures\n        forall|k: int| 0 <= k < x.len() ==> x[max_index as int] >= x[k],\n        max_index < x.len(),\n{\n    let mut max_index = 0;\n    let mut i: usize = 1;\n    while (i < x.len())\n        invariant\n            i <= x.len(),\n            max_index < x.len(),\n            forall|k: int| 0 <= k < i ==> x[max_index as int] >= x[k],\n    {\n        if x[i] > x[max_index] {\n            max_index = i;\n        }\n        i = i + 1;\n    }\n\n    max_index\n}\n\n} // verus!\n", "task_path": "Misc/unverified/max_index.rs", "solution_path": "Misc/verified/max_index.rs"}
{"task_id": "misc_remove_all_greater", "source": "Misc", "name": "remove_all_greater", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn remove_all_greater(v: Vec<i32>, e: i32) -> (result: Vec<i32>)\n    requires \n        forall |k1:int,k2:int| 0 <= k1 < k2 < v.len() ==> v[k1] != v[k2]\n    ensures\n        forall |k:int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),\n        forall |k:int| 0 <= k < v.len() && v[k] <= e ==> result@.contains(v[k]),\n{  \n    let mut i: usize = 0;\n    let vlen = v.len();\n    let mut result: Vec<i32> = vec![];\n    while (i < v.len()) \n    {  \n        if (v[i] <= e) { \n            result.push(v[i]); \n        }\n        i = i + 1;\n    }  \n    result\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn remove_all_greater(v: Vec<i32>, e: i32) -> (result: Vec<i32>)\n    requires \n        forall |k1:int,k2:int| 0 <= k1 < k2 < v.len() ==> v[k1] != v[k2]\n    ensures\n        forall |k:int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),\n        forall |k:int| 0 <= k < v.len() && v[k] <= e ==> result@.contains(v[k]),\n{  \n    let mut i: usize = 0;\n    let vlen = v.len();\n    let mut result: Vec<i32> = vec![];\n    while (i < v.len()) \n        invariant \n            forall |k:int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),\n            forall |k:int| 0 <= k < i && v[k] <= e ==> result@.contains(v[k]),\n    {  \n        if (v[i] <= e) {\n            let ghost old_result = result;\n            result.push(v[i]);\n            assert(forall |k:int| 0<= k < old_result.len() ==> old_result[k] == result[k]);\n            assert(result[result.len() - 1] == v[i as int]);\n        }\n        i = i + 1;\n    }  \n    result\n}\n}\n", "task_path": "Misc/unverified/remove_all_greater.rs", "solution_path": "Misc/verified/remove_all_greater.rs"}
{"task_id": "misc_reverse", "source": "Misc", "name": "reverse", "task": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn reverse(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let mut n: usize = 0;\n    while n < length / 2\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\n\nverus!{\nfn reverse(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let mut n: usize = 0;\n    while n < length / 2\n        invariant\n            0 <= n <= length / 2,\n            v.len() == old(v).len(),\n            v.len() == length,\n            forall|i: int| 0 <= i < n ==> v[i] == old(v)[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v[length - i - 1] == old(v)[i],\n            forall|i: int| n <= i < length - n ==> v[i] == old(v)[i],\n        decreases length / 2 - n\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n}\n", "task_path": "Misc/unverified/reverse.rs", "solution_path": "Misc/verified/reverse.rs"}
{"task_id": "misc_simple_nested", "source": "Misc", "name": "simple_nested", "task": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn simple_nested(a: &mut Vec<i32>, b: &Vec<i32>, N: i32) -> (sum: i32)\n    requires \n        forall |k:int| k <= #[trigger] b[k] <= k + 1,\n        old(a).len() == N,\n        b.len() == N,\n        N <= 0x3FFF_FFFF,\n    ensures\n        N <= sum <= 2*N\n{  \n    let mut i: usize = 0;\n    let mut sum: i32 = 0;\n    while (i < N as usize) \n    {  \n        a.set(i, b[i] + 1);\n        let mut j: usize = 0;\n        while (j < i)\n        {\n            a.set(i, a[i] - 1);\n            j = j + 1;\n        }\n        sum = sum + a[i];\n        i = i + 1;\n    }  \n    sum\n}\n}\n", "ground_truth": "use vstd::prelude::*;\nfn main() {}\nverus!{\npub fn simple_nested(a: &mut Vec<i32>, b: &Vec<i32>, N: i32) -> (sum: i32)\n    requires \n        forall |k:int| k <= #[trigger] b[k] <= k + 1,\n        old(a).len() == N,\n        b.len() == N,\n        N <= 0x3FFF_FFFF,\n    ensures\n        N <= sum <= 2*N\n{  \n    let mut i: usize = 0;\n    let mut sum: i32 = 0;\n    while (i < N as usize) \n        invariant \n            0 <= i <= N,\n            N <= 0x3FFF_FFFF,\n            a.len() == N,  // always specify the length of vectors used in the loop\n            b.len() == N,  // always specify the length of vectors used in the loop\n            forall |k:int| k <= #[trigger] b[k] <= k + 1,\n            i <= sum <= 2*i,\n    {  \n        a.set(i, b[i] + 1);\n        let mut j: usize = 0;\n        while (j < i)\n            invariant \n                0 <= i < N,\n                0 <= j <= i,\n                a.len() == N,  // always specify the length of vectors used in the loop\n                i + 1 - j <= a[i as int] <= i + 2 - j,\n        {\n            a.set(i, a[i] - 1);\n            j = j + 1;\n        }\n        sum = sum + a[i];\n        i = i + 1;\n    }  \n    sum\n}\n}\n", "task_path": "Misc/unverified/simple_nested.rs", "solution_path": "Misc/verified/simple_nested.rs"}
{"task_id": "misc_sum", "source": "Misc", "name": "sum", "task": "#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn arith_sum_int(i: nat) -> nat\n    decreases i\n{\n    if i == 0 { 0 } else { i + arith_sum_int( (i - 1) as nat) }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        arith_sum_int(n as nat) < 10000,\n    ensures\n        arith_sum_int(n as nat) == sum,\n{\n    let mut i: u64 = 0;\n    let mut sum: u64 = 0;\n    while i < n\n    {\n        i = i + 1;\n        sum = sum + i;\n    }\n    sum\n}\n\n\n} // verus!\n", "ground_truth": "#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nfn main() {}\n\nverus! {\n\nspec fn arith_sum_int(i: nat) -> nat\n    decreases i\n{\n    if i == 0 { 0 } else { i + arith_sum_int( (i - 1) as nat) }\n}\n\nproof fn lemma_arith_sum_monotonic(i: nat, j:nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as nat) <= arith_sum_int(j as nat),\n    decreases j\n{\n    if i<j {\n        lemma_arith_sum_monotonic(i, (j-1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        arith_sum_int(n as nat) < 10000,\n    ensures\n        arith_sum_int(n as nat) == sum,\n{\n    let mut i: u64 = 0;\n    let mut sum: u64 = 0;\n    while i < n\n        invariant \n            i <= n,\n            sum == arith_sum_int(i as nat),\n            arith_sum_int(n as nat) < 10000,\n    {\n        i = i + 1;\n\n        assert( sum + i <= arith_sum_int(n as nat)) by {\n            lemma_arith_sum_monotonic(i as nat, n as nat);\n        }\n        sum = sum + i;\n    }\n    sum\n}\n\n\n} // verus!\n", "task_path": "Misc/unverified/sum.rs", "solution_path": "Misc/verified/sum.rs"}
{"task_id": "misc_tail_triangle", "source": "Misc", "name": "tail_triangle", "task": "//This is an example from Verus tutorial Chpt 4.2\n//This is a rather complicated example\n\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\n     \nspec fn triangle(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        n + triangle((n - 1) as nat)\n    }\n}\n\nfn tail_triangle(n: u32, idx: u32, sum: &mut u32)\n    requires\n        idx <= n,\n        *old(sum) == triangle(idx as nat),\n        triangle(n as nat) < 0x1_0000_0000,\n    ensures\n        *sum == triangle(n as nat),\n{\n    if idx < n {\n        let idx = idx + 1;\n        *sum = *sum + idx;\n        tail_triangle(n, idx, sum);\n    }\n}\n}\n", "ground_truth": "//This is an example from Verus tutorial Chpt 4.2\n//This is a rather complicated example: a inductive proof function is introduced to help prove that *sum_idx will not overflow\n\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\n     \nspec fn triangle(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        n + triangle((n - 1) as nat)\n    }\n}\n\nproof fn triangle_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        triangle(i) <= triangle(j),\n    decreases j\n{\n    if i < j {\n        triangle_is_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn tail_triangle(n: u32, idx: u32, sum: &mut u32)\n    requires\n        idx <= n,\n        *old(sum) == triangle(idx as nat),\n        triangle(n as nat) < 0x1_0000_0000,\n    ensures\n        *sum == triangle(n as nat),\n{\n    if idx < n {\n        let idx = idx + 1;\n         assert(*sum + idx < 0x1_0000_0000) by {\n            triangle_is_monotonic(idx as nat, n as nat);\n        }\n        *sum = *sum + idx;\n        tail_triangle(n, idx, sum);\n    }\n}\n}\n", "task_path": "Misc/unverified/tail_triangle.rs", "solution_path": "Misc/verified/tail_triangle.rs"}
{"task_id": "misc_trigger", "source": "Misc", "name": "trigger", "task": "#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nfn main() {}\n\nverus!{\nspec fn f(seq: Seq<u64>, i: int) -> bool {\n    seq[i] == i + 2\n}\n\nfn get_element_check_property(arr: Vec<u64>, i: usize) -> (ret: u64)\n    requires\n        arr.len() > 0,\n        0 < i < arr@.len(),\n        forall |i: int| f(arr@, i),\n    ensures\n        ret == i + 2,\n        ret == arr@[i as int],\n{\n    arr[i]\n}\n}\n", "ground_truth": "#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nfn main() {}\n\nverus!{\nspec fn f(seq: Seq<u64>, i: int) -> bool {\n    seq[i] == i + 2\n}\n\nfn get_element_check_property(arr: Vec<u64>, i: usize) -> (ret: u64)\n    requires\n        arr.len() > 0,\n        0 < i < arr@.len(),\n        forall |i: int| f(arr@, i),\n    ensures\n        ret == i + 2,\n        ret == arr@[i as int],\n{\n    proof {\n        assert(f(arr@, i as int));\n    }\n    arr[i]\n}\n}", "task_path": "Misc/unverified/trigger.rs", "solution_path": "Misc/verified/trigger.rs"}
